# Comparing `tmp/fitsio-1.1.9.tar.gz` & `tmp/fitsio-1.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "fitsio-1.1.9.tar", last modified: Fri May 26 13:06:55 2023, max compression
+gzip compressed data, was "fitsio-1.2.0.tar", last modified: Wed Aug  2 15:35:20 2023, max compression
```

## Comparing `fitsio-1.1.9.tar` & `fitsio-1.2.0.tar`

### file list

```diff
@@ -1,228 +1,228 @@
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.380537 fitsio-1.1.9/
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.292539 fitsio-1.1.9/.github/
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.296539 fitsio-1.1.9/.github/workflows/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2162 2023-05-24 20:40:55.000000 fitsio-1.1.9/.github/workflows/tests.yml
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1306 2021-03-26 15:14:38.000000 fitsio-1.1.9/.gitignore
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2350 2021-03-26 15:14:38.000000 fitsio-1.1.9/.travis.yml
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    26374 2023-05-26 13:05:13.000000 fitsio-1.1.9/CHANGES.md
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    18011 2021-03-26 15:14:38.000000 fitsio-1.1.9/LICENSE.txt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      131 2021-03-26 15:14:38.000000 fitsio-1.1.9/MANIFEST.in
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    15431 2023-05-26 13:06:55.380537 fitsio-1.1.9/PKG-INFO
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    14850 2023-05-26 13:05:13.000000 fitsio-1.1.9/README.md
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.340538 fitsio-1.1.9/cfitsio3490/
--rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)     6405 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/CMakeLists.txt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3209 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/FindPthreads.cmake
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1410 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/License.txt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6236 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/Makefile.in
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4528 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/README
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2493 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/README.MacOS
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6134 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/README.win
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3534 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/README_OLD.win
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    53229 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/buffers.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   263595 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cfileio.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      342 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cfitsio.pc.cmake
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      300 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cfitsio.pc.in
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.340538 fitsio-1.1.9/cfitsio3490/cfitsio.xcodeproj/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3233 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cfitsio.xcodeproj/project.pbxproj
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    23366 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cfitsio_mac.sit.hqx
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   135706 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cfortran.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    17601 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/checksum.c
--rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)    44283 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/config.guess
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    23466 2021-09-07 13:51:31.000000 fitsio-1.1.9/cfitsio3490/config.log
--rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)    36136 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/config.sub
--rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)   219087 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/configure
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    20705 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/configure.in
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    21858 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cookbook.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    30203 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/cookbook.f
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.360538 fitsio-1.1.9/cfitsio3490/docs/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)  1074054 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/cfitsio.pdf
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)  1412279 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/cfitsio.ps
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   507182 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/cfitsio.tex
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    11521 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/cfitsio.toc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    95483 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/cfortran.doc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   213622 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/changes.txt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   326397 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/fitsio.doc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   697014 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/fitsio.pdf
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   958163 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/fitsio.ps
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   346564 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/fitsio.tex
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8707 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/fitsio.toc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   588666 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/fpackguide.pdf
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   232878 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/quick.pdf
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   312357 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/quick.ps
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   101448 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/quick.tex
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1795 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/docs/quick.toc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    28508 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/drvrfile.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13960 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/drvrgsiftp.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      787 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/drvrgsiftp.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    39553 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/drvrmem.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   125780 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/drvrnet.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    38489 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/drvrsmem.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6536 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/drvrsmem.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   101807 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/editcol.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    32727 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/edithdu.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    16188 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/eval.l
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   177512 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/eval.y
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4254 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/eval_defs.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    98802 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/eval_f.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    69666 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/eval_l.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3564 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/eval_tab.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   275403 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/eval_y.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      853 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/f77.inc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    10430 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/f77_wrap.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12779 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/f77_wrap1.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    32385 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/f77_wrap2.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    33790 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/f77_wrap3.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    19467 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/f77_wrap4.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    47082 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fits_hcompress.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    63312 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fits_hdecompress.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2642 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fitscopy.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   318473 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fitscore.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   119295 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fitsio.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    63131 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fitsio2.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    16825 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fpack.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7155 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fpack.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    78403 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/fpackutil.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4664 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/funpack.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    41542 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcol.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    78585 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcolb.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    68830 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcold.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    68940 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcole.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    74885 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcoli.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   148225 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcolj.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    74751 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcolk.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    23298 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcoll.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    33907 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcols.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    77347 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcolsb.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    75282 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcolui.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   148281 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcoluj.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    75493 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getcoluk.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   125729 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/getkey.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   185566 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/group.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2097 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/group.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    46325 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/grparser.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5725 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/grparser.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    86820 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/histo.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   380829 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/imcompress.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     9368 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/imcopy.c
--rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)    14799 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/install-sh
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    57777 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iraffits.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5253 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_a.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6874 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_a.f
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   129600 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_a.fit
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3702 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_b.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5679 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_b.f
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   408960 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_b.fit
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6007 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_c.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    10525 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_c.f
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    92160 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_c.fit
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3076 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_image.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3319 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/iter_var.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    21784 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/longnam.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12754 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/makefile.bc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    18040 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/makefile.vcc
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2307 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/makepc.bat
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    67233 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/modkey.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7067 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/pliocomp.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    67801 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcol.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    37199 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcolb.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    38722 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcold.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    39292 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcole.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35439 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcoli.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    71429 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcolj.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    36390 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcolk.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13933 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcoll.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    10944 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcols.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35466 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcolsb.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    21555 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcolu.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    34837 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcolui.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    69378 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcoluj.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35653 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putcoluk.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   115057 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/putkey.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   118985 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/quantize.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    55811 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/region.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2157 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/region.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35605 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/ricecomp.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3581 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/sample.tpl
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8973 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/scalnull.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13925 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/simplerng.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1078 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/simplerng.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2564 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/smem.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    15459 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/speed.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7703 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/swapproc.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    80140 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/testf77.f
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    33427 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/testf77.out
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    66240 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/testf77.std
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    85934 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/testprog.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    32223 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/testprog.out
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    69120 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/testprog.std
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      396 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/testprog.tpt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3782 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/vmsieee.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35267 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/wcssub.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    16769 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/wcsutil.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4257 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/winDumpExts.mak
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13037 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/windumpexts.c
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.368538 fitsio-1.1.9/cfitsio3490/zlib/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5031 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/adler32.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13664 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/crc32.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    30568 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/crc32.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    67975 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/deflate.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12655 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/deflate.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    22622 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/infback.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13439 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/inffast.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      427 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/inffast.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6343 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/inffixed.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    52623 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/inflate.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6399 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/inflate.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13769 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/inftrees.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2928 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/inftrees.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    45225 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/trees.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8472 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/trees.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1977 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/uncompr.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    18946 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/zcompress.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13353 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/zconf.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    79564 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/zlib.h
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    16425 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/zuncompress.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7296 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/zutil.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7136 2021-03-26 15:14:38.000000 fitsio-1.1.9/cfitsio3490/zlib/zutil.h
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.372537 fitsio-1.1.9/fitsio/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      657 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/__init__.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   143281 2023-05-26 13:05:13.000000 fitsio-1.1.9/fitsio/fitsio_pywrap.c
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    64242 2022-09-26 18:00:17.000000 fitsio-1.1.9/fitsio/fitslib.py
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.372537 fitsio-1.1.9/fitsio/hdu/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      231 2021-03-26 15:14:38.000000 fitsio-1.1.9/fitsio/hdu/__init__.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12577 2022-01-04 20:03:22.000000 fitsio-1.1.9/fitsio/hdu/base.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13716 2021-03-26 15:14:38.000000 fitsio-1.1.9/fitsio/hdu/image.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    89144 2023-05-26 13:05:13.000000 fitsio-1.1.9/fitsio/hdu/table.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    22366 2022-06-23 13:51:45.000000 fitsio-1.1.9/fitsio/header.py
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.372537 fitsio-1.1.9/fitsio/test_images/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8640 2021-03-26 15:14:38.000000 fitsio-1.1.9/fitsio/test_images/test_gzip_compressed_image.fits.fz
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.376537 fitsio-1.1.9/fitsio/tests/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        0 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/__init__.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6155 2023-05-25 01:08:32.000000 fitsio-1.1.9/fitsio/tests/checks.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    11820 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/makedata.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    18789 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/test_header.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7248 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/test_header_junk.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8768 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/test_image.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4220 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/test_image_compression.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3638 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/test_lib.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    42339 2023-05-26 13:05:13.000000 fitsio-1.1.9/fitsio/tests/test_table.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1234 2023-05-24 20:40:55.000000 fitsio-1.1.9/fitsio/tests/test_warnings.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3453 2023-05-23 19:28:37.000000 fitsio-1.1.9/fitsio/util.py
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.372537 fitsio-1.1.9/fitsio.egg-info/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    15431 2023-05-26 13:06:55.000000 fitsio-1.1.9/fitsio.egg-info/PKG-INFO
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5101 2023-05-26 13:06:55.000000 fitsio-1.1.9/fitsio.egg-info/SOURCES.txt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        1 2023-05-26 13:06:55.000000 fitsio-1.1.9/fitsio.egg-info/dependency_links.txt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        6 2023-05-26 13:06:55.000000 fitsio-1.1.9/fitsio.egg-info/requires.txt
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        7 2023-05-26 13:06:55.000000 fitsio-1.1.9/fitsio.egg-info/top_level.txt
-drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-05-26 13:06:55.376537 fitsio-1.1.9/patches/
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      893 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/README.md
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      984 2023-05-24 20:40:55.000000 fitsio-1.1.9/patches/build_cfitsio_patches.py
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1013 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/build_cfitsio_patches.py~
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1196 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/configure.in.patch
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1559 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/configure.patch
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      360 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/drvrnet.c.patch
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      636 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/fitscore.c.patch
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      423 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/fitsio.h.patch
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      602 2021-03-26 15:14:38.000000 fitsio-1.1.9/patches/putcols.c.patch
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)       38 2023-05-26 13:06:55.380537 fitsio-1.1.9/setup.cfg
--rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     9873 2023-05-24 20:40:55.000000 fitsio-1.1.9/setup.py
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.905727 fitsio-1.2.0/
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.817729 fitsio-1.2.0/.github/
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.821729 fitsio-1.2.0/.github/workflows/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3064 2023-08-01 12:32:21.000000 fitsio-1.2.0/.github/workflows/tests.yml
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1410 2023-08-02 14:43:50.000000 fitsio-1.2.0/.gitignore
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2350 2021-03-26 15:14:38.000000 fitsio-1.2.0/.travis.yml
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    26964 2023-08-02 14:43:50.000000 fitsio-1.2.0/CHANGES.md
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    18011 2021-03-26 15:14:38.000000 fitsio-1.2.0/LICENSE.txt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      133 2023-08-01 12:32:21.000000 fitsio-1.2.0/MANIFEST.in
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    15431 2023-08-02 15:35:20.905727 fitsio-1.2.0/PKG-INFO
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    14850 2023-05-26 13:05:13.000000 fitsio-1.2.0/README.md
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.869727 fitsio-1.2.0/cfitsio-4.2.0/
+-rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)    11847 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/CMakeLists.txt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1410 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/License.txt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6064 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/Makefile.in
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4528 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/README
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2493 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/README.MacOS
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8454 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/README.win
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3534 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/README_OLD.win
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    53229 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/buffers.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   264972 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfileio.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      695 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfitsio-config-version.cmake.in
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1343 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfitsio-config.cmake.in
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      368 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfitsio.pc.cmake
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      328 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfitsio.pc.in
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.869727 fitsio-1.2.0/cfitsio-4.2.0/cfitsio.xcodeproj/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3233 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfitsio.xcodeproj/project.pbxproj
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    23366 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfitsio_mac.sit.hqx
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   137148 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cfortran.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    17601 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/checksum.c
+-rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)    49446 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/config.guess
+-rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)    34412 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/config.sub
+-rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)   228228 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/configure
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    21985 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/configure.in
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    21858 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cookbook.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    30206 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/cookbook.f
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.889727 fitsio-1.2.0/cfitsio-4.2.0/docs/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   920327 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/cfitsio.pdf
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)  1119059 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/cfitsio.ps
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   520278 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/cfitsio.tex
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     9656 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/cfitsio.toc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    95483 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/cfortran.doc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   218393 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/changes.txt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   326397 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.doc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   649089 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.pdf
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   848387 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.ps
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   354671 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.tex
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7342 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.toc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   140520 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/fpackguide.pdf
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   232878 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/quick.pdf
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   312357 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/quick.ps
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   101448 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/quick.tex
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1795 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/docs/quick.toc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    28508 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/drvrfile.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13960 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/drvrgsiftp.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      787 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/drvrgsiftp.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    40411 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/drvrmem.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   128157 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/drvrnet.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    38489 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/drvrsmem.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6536 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/drvrsmem.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   111642 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/editcol.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    32727 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/edithdu.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    17107 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/eval.l
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   202712 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/eval.y
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6017 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/eval_defs.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   104305 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/eval_f.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    85412 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/eval_l.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4952 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/eval_tab.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   304540 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/eval_y.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      853 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/f77.inc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    10513 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/f77_wrap.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12827 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/f77_wrap1.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    34143 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/f77_wrap2.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    33790 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/f77_wrap3.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    19467 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/f77_wrap4.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    47082 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fits_hcompress.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    63312 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fits_hdecompress.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2642 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fitscopy.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   322209 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fitscore.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   119972 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fitsio.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    65483 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fitsio2.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    16825 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fpack.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7155 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fpack.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    78403 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/fpackutil.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4664 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/funpack.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    45690 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcol.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    78338 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcolb.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    68830 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcold.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    68940 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcole.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    74885 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcoli.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   148225 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcolj.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    74751 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcolk.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    23298 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcoll.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    33907 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcols.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    77347 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcolsb.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    75282 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcolui.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   148281 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcoluj.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    75493 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getcoluk.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   125760 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/getkey.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   185566 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/group.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2097 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/group.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    46325 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/grparser.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5725 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/grparser.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   114162 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/histo.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   381387 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/imcompress.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     9368 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/imcopy.c
+-rwxrwxr-x   0 esheldon  (1000) esheldon  (1000)    14799 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/install-sh
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    57777 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iraffits.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5253 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_a.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6874 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_a.f
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   129600 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_a.fit
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3702 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_b.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5679 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_b.f
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   408960 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_b.fit
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6007 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_c.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    10525 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_c.f
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    92160 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_c.fit
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3076 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_image.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3319 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/iter_var.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    21894 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/longnam.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12754 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/makefile.bc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    18040 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/makefile.vcc
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2307 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/makepc.bat
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    67233 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/modkey.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7067 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/pliocomp.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    74414 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcol.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    37536 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcolb.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    38722 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcold.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    39292 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcole.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35439 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcoli.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    71429 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcolj.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    36390 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcolk.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13933 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcoll.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    10944 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcols.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35466 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcolsb.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    21555 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcolu.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    34837 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcolui.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    69378 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcoluj.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35653 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putcoluk.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   117321 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/putkey.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   118985 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/quantize.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    57375 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/region.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2157 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/region.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35605 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/ricecomp.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3581 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/sample.tpl
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8973 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/scalnull.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13925 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/simplerng.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1078 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/simplerng.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2564 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/smem.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    15459 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/speed.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7703 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/swapproc.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    80140 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/testf77.f
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    33427 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/testf77.out
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    66240 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/testf77.std
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    85934 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/testprog.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    32223 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/testprog.out
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    69120 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/testprog.std
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      396 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/testprog.tpt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3782 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/vmsieee.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    35267 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/wcssub.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    16769 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/wcsutil.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4257 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/winDumpExts.mak
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13037 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/windumpexts.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    19217 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/zcompress.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    16425 2023-08-01 12:32:21.000000 fitsio-1.2.0/cfitsio-4.2.0/zuncompress.c
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.893727 fitsio-1.2.0/fitsio/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      657 2023-08-01 12:36:00.000000 fitsio-1.2.0/fitsio/__init__.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)   143442 2023-08-02 14:43:50.000000 fitsio-1.2.0/fitsio/fitsio_pywrap.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    64242 2022-09-26 18:00:17.000000 fitsio-1.2.0/fitsio/fitslib.py
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.893727 fitsio-1.2.0/fitsio/hdu/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      231 2021-03-26 15:14:38.000000 fitsio-1.2.0/fitsio/hdu/__init__.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12577 2022-01-04 20:03:22.000000 fitsio-1.2.0/fitsio/hdu/base.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13716 2021-03-26 15:14:38.000000 fitsio-1.2.0/fitsio/hdu/image.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    89220 2023-06-27 15:20:30.000000 fitsio-1.2.0/fitsio/hdu/table.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    22366 2022-06-23 13:51:45.000000 fitsio-1.2.0/fitsio/header.py
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.893727 fitsio-1.2.0/fitsio/test_images/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8640 2021-03-26 15:14:38.000000 fitsio-1.2.0/fitsio/test_images/test_gzip_compressed_image.fits.fz
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.897727 fitsio-1.2.0/fitsio/tests/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        0 2023-05-24 20:40:55.000000 fitsio-1.2.0/fitsio/tests/__init__.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6155 2023-05-25 01:08:32.000000 fitsio-1.2.0/fitsio/tests/checks.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    11831 2023-06-27 15:20:30.000000 fitsio-1.2.0/fitsio/tests/makedata.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    18789 2023-05-24 20:40:55.000000 fitsio-1.2.0/fitsio/tests/test_header.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7248 2023-05-24 20:40:55.000000 fitsio-1.2.0/fitsio/tests/test_header_junk.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8768 2023-05-24 20:40:55.000000 fitsio-1.2.0/fitsio/tests/test_image.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     4220 2023-05-24 20:40:55.000000 fitsio-1.2.0/fitsio/tests/test_image_compression.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3638 2023-05-24 20:40:55.000000 fitsio-1.2.0/fitsio/tests/test_lib.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    42339 2023-05-26 13:05:13.000000 fitsio-1.2.0/fitsio/tests/test_table.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1234 2023-05-24 20:40:55.000000 fitsio-1.2.0/fitsio/tests/test_warnings.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     3453 2023-05-23 19:28:37.000000 fitsio-1.2.0/fitsio/util.py
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.893727 fitsio-1.2.0/fitsio.egg-info/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    15431 2023-08-02 15:35:20.000000 fitsio-1.2.0/fitsio.egg-info/PKG-INFO
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5181 2023-08-02 15:35:20.000000 fitsio-1.2.0/fitsio.egg-info/SOURCES.txt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        1 2023-08-02 15:35:20.000000 fitsio-1.2.0/fitsio.egg-info/dependency_links.txt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        6 2023-08-02 15:35:20.000000 fitsio-1.2.0/fitsio.egg-info/requires.txt
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)        7 2023-08-02 15:35:20.000000 fitsio-1.2.0/fitsio.egg-info/top_level.txt
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.897727 fitsio-1.2.0/patches/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      537 2023-08-01 12:32:21.000000 fitsio-1.2.0/patches/Makefile.in.patch
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      893 2021-03-26 15:14:38.000000 fitsio-1.2.0/patches/README.md
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1002 2023-08-01 12:32:21.000000 fitsio-1.2.0/patches/build_cfitsio_patches.py
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1013 2021-03-26 15:14:38.000000 fitsio-1.2.0/patches/build_cfitsio_patches.py~
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      890 2023-08-01 12:32:21.000000 fitsio-1.2.0/patches/configure.in.patch
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1461 2023-08-01 12:32:21.000000 fitsio-1.2.0/patches/configure.patch
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      645 2023-08-01 12:32:21.000000 fitsio-1.2.0/patches/fitscore.c.patch
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      526 2023-08-01 12:32:21.000000 fitsio-1.2.0/patches/fitsio.h.patch
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      591 2023-08-01 12:32:21.000000 fitsio-1.2.0/patches/putcols.c.patch
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)       38 2023-08-02 15:35:20.905727 fitsio-1.2.0/setup.cfg
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    11225 2023-08-02 14:43:50.000000 fitsio-1.2.0/setup.py
+drwxrwxr-x   0 esheldon  (1000) esheldon  (1000)        0 2023-08-02 15:35:20.905727 fitsio-1.2.0/zlib/
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     5031 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/adler32.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13664 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/crc32.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    30568 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/crc32.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    67975 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/deflate.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    12655 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/deflate.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    22622 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/infback.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13439 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/inffast.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)      427 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/inffast.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6343 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/inffixed.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    52623 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/inflate.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     6399 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/inflate.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13769 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/inftrees.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     2928 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/inftrees.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    45225 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/trees.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     8472 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/trees.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     1977 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/uncompr.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    13353 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/zconf.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)    79564 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/zlib.h
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7296 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/zutil.c
+-rw-rw-r--   0 esheldon  (1000) esheldon  (1000)     7136 2023-08-01 12:32:21.000000 fitsio-1.2.0/zlib/zutil.h
```

### Comparing `fitsio-1.1.9/.github/workflows/tests.yml` & `fitsio-1.2.0/.github/workflows/tests.yml`

 * *Files 11% similar despite different names*

```diff
@@ -2,14 +2,17 @@
 
 on:
   push:
     branches:
       - master
   pull_request: null
 
+env:
+  PY_COLORS: "1"
+
 jobs:
   tests:
     name: tests
     strategy:
       fail-fast: false
       matrix:
         os: [macos-latest, ubuntu-latest]
@@ -27,14 +30,15 @@
     steps:
       - name: cancel previous runs
         uses: styfle/cancel-workflow-action@0.6.0
         with:
           access_token: ${{ github.token }}
 
       - uses: actions/checkout@v2
+
       - uses: conda-incubator/setup-miniconda@v2
         with:
           python-version: ${{ matrix.pyver }}
           channels: conda-forge,defaults
           channel-priority: strict
           show-channel-urls: true
           miniforge-version: latest
@@ -48,30 +52,51 @@
           if [ "${{ matrix.pyver }}" == "3.8" ] || [ "${{ matrix.pyver }}" == "3.9" ] || [ "${{ matrix.pyver }}" == "3.10" ]; then
             mamba install importlib_resources
           fi
 
       - name: build external cfitsio
         shell: bash -l {0}
         run: |
-          wget https://heasarc.gsfc.nasa.gov/FTP/software/fitsio/c/cfitsio-3.49.tar.gz
-          tar -xzvf cfitsio-3.49.tar.gz
-          cd cfitsio-3.49
+          mkdir cfitsio-external-build
+          cd cfitsio-external-build
+          wget https://heasarc.gsfc.nasa.gov/FTP/software/fitsio/c/cfitsio-4.2.0.tar.gz
+          tar -xzvf cfitsio-4.2.0.tar.gz
+          cd cfitsio-4.2.0
           ./configure --disable-shared --prefix=$HOME/cfitsio-static-install
           make install -j 4
           cd ..
+          cd ..
 
-      - name: test bundled build
+      - name: test non-bundled build
         shell: bash -l {0}
         run: |
-          pip install -e . 
+          pip install -vv -e . \
+            --global-option="build_ext" \
+            --global-option="--use-system-fitsio" \
+            --global-option="--system-fitsio-includedir=$HOME/cfitsio-static-install/include" \
+            --global-option="--system-fitsio-libdir=$HOME/cfitsio-static-install/lib"
           SKIP_BZIP_TEST=true pytest -vv fitsio
 
-      - name: test non-bundled build
+      - name: test non-bundled build w/ env vars
+        shell: bash -l {0}
+        run: |
+          rm -rf build*
+          find . -name "*.so" -type f -delete
+          export FITSIO_USE_SYSTEM_FITSIO=1
+          export FITSIO_SYSTEM_FITSIO_INCLUDEDIR=$HOME/cfitsio-static-install/include
+          export FITSIO_SYSTEM_FITSIO_LIBDIR=$HOME/cfitsio-static-install/lib
+          pip install -vv -e .
+          SKIP_BZIP_TEST=true pytest -vv fitsio
+
+      - name: test bundled build
         shell: bash -l {0}
         run: |
-          pip install -e . --global-option="build_ext" --global-option "--use-system-fitsio"
+          rm -rf build*
+          rm -rf $HOME/cfitsio-static-install
+          find . -name "*.so" -type f -delete
+          pip install -vv -e .
           SKIP_BZIP_TEST=true pytest -vv fitsio
 
       - name: flake8
         shell: bash -l {0}
         run: |
           flake8 fitsio
```

### Comparing `fitsio-1.1.9/.gitignore` & `fitsio-1.2.0/.gitignore`

 * *Files 14% similar despite different names*

```diff
@@ -108,7 +108,15 @@
 # mypy
 .mypy_cache/
 .dmypy.json
 dmypy.json
 
 # Pyre type checker
 .pyre/
+
+# vscode
+.vscode/
+
+# stuff for cfitsio
+cfitsio-*/cfitsio.pc
+cfitsio-*/config.status
+cfitsio-*/Makefile
```

### Comparing `fitsio-1.1.9/.travis.yml` & `fitsio-1.2.0/.travis.yml`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/CHANGES.md` & `fitsio-1.2.0/CHANGES.md`

 * *Files 1% similar despite different names*

```diff
@@ -1,7 +1,33 @@
+version 1.2.0
+--------------
+
+Changes
+
+    - move to cfitsio 4
+
+Bug Fixes
+
+    - Fixed issue where the patched C fitsio headers were not
+      first in the include path.
+    - Added extra header guards and headers to help with compilation issues.
+    - Fixed builds of the bundled cfitsio code to hide symbols and directly
+      include the *.o files when linking.
+
+version 1.1.10
+--------------
+
+Changes
+
+Bug Fixes
+
+    - Fix errors on 32 bit builds where default numpy integer
+      types were 32 rather than 64 bit assumed by the C code.
+    - Fix checks for rows being sent to C codes
+
 version 1.1.9
 -------------
 
 Changes
 
     - Row subsets of table data are returned in the order sent by the user
       rather than sorted and unique.  E.g. rows = [2, 2, 1] will return
```

### Comparing `fitsio-1.1.9/LICENSE.txt` & `fitsio-1.2.0/LICENSE.txt`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/PKG-INFO` & `fitsio-1.2.0/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: fitsio
-Version: 1.1.9
+Version: 1.2.0
 Summary: A full featured python library to read from and write to FITS files.
 Home-page: https://github.com/esheldon/fitsio
 Author: Erin Scott Sheldon
 Author-email: erin.sheldon@gmail.com
 License: GPL
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: License :: OSI Approved :: GNU General Public License (GPL)
```

### Comparing `fitsio-1.1.9/README.md` & `fitsio-1.2.0/README.md`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/License.txt` & `fitsio-1.2.0/cfitsio-4.2.0/License.txt`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/Makefile.in` & `fitsio-1.2.0/cfitsio-4.2.0/Makefile.in`

 * *Files 6% similar despite different names*

```diff
@@ -17,16 +17,17 @@
 # testprog targets. See also changes and comments in configure.in
 
 
 # Default library name:
 PACKAGE		= cfitsio
 
 # CFITSIO version numbers:
-CFITSIO_MAJOR	= @CFITSIO_MAJOR@
+CFITSIO_MAJOR   = @CFITSIO_MAJOR@
 CFITSIO_MINOR	= @CFITSIO_MINOR@
+CFITSIO_MICRO   = @CFITSIO_MICRO@
 CFITSIO_SONAME	= @CFITSIO_SONAME@
 
 prefix		= @prefix@
 exec_prefix	= @exec_prefix@
 CFITSIO_BIN	= ${DESTDIR}@bindir@
 CFITSIO_LIB	= ${DESTDIR}@libdir@
 CFITSIO_INCLUDE	= ${DESTDIR}@includedir@
@@ -64,17 +65,15 @@
 		modkey.c putcol.c putcolb.c putcold.c putcole.c putcoli.c \
 		putcolj.c putcolk.c putcoluk.c putcoll.c putcols.c putcolsb.c \
 		putcolu.c putcolui.c putcoluj.c putkey.c region.c scalnull.c \
 		swapproc.c wcssub.c wcsutil.c imcompress.c quantize.c ricecomp.c \
 		pliocomp.c fits_hcompress.c fits_hdecompress.c \
 		simplerng.c @GSIFTP_SRC@
 
-ZLIB_SOURCES =	zlib/adler32.c zlib/crc32.c zlib/deflate.c zlib/infback.c \
-		zlib/inffast.c zlib/inflate.c zlib/inftrees.c zlib/trees.c \
-		zlib/uncompr.c zlib/zcompress.c zlib/zuncompress.c zlib/zutil.c
+ZLIB_SOURCES =	zcompress.c zuncompress.c
 
 SOURCES = ${CORE_SOURCES} ${ZLIB_SOURCES} @F77_WRAPPERS@
 
 OBJECTS = 	${SOURCES:.c=.o}
 
 CORE_OBJECTS = 	${CORE_SOURCES:.c=.o} ${ZLIB_SOURCES:.c=.o}
 
@@ -109,14 +108,16 @@
 			ln -sf ${CFITSIO_SHLIB_SONAME} $@; \
 		fi
 
 install:	lib${PACKAGE}.a ${INSTALL_DIRS}
 		@for lib in lib${PACKAGE}.a lib${PACKAGE}${SHLIB_SUFFIX} \
 				${CFITSIO_SHLIB} ${CFITSIO_SHLIB_SONAME}; do \
 		    if [ -f $$lib ]; then \
+			echo "/bin/rm -f ${CFITSIO_LIB}/$$lib"; \
+			/bin/rm -f ${CFITSIO_LIB}/$$lib; \
 			echo "/bin/cp -a $$lib ${CFITSIO_LIB}"; \
 			/bin/cp -a $$lib ${CFITSIO_LIB}; \
 		    fi; \
 		done
 		/bin/cp fitsio.h fitsio2.h longnam.h drvrsmem.h ${CFITSIO_INCLUDE}
 		/bin/cp cfitsio.pc ${CFITSIO_LIB}/pkgconfig
 		@for task in ${FPACK_UTILS} ${UTILS}; do \
@@ -160,27 +161,25 @@
 
 imcopy:		imcopy.o lib${PACKAGE}.a ${OBJECTS}
 		${CC} ${LDFLAGS_BIN} ${DEFS} -o $@ ${@}.o -L. -l${PACKAGE} -lm ${LIBS}
 
 cookbook:	cookbook.o lib${PACKAGE}.a ${OBJECTS}
 		${CC} ${LDFLAGS_BIN} ${DEFS} -o $@ ${@}.o -L. -l${PACKAGE} -lm ${LIBS}
 
+testf77:	testf77.o lib${PACKAGE}.a ${OBJECTS}
+		${FC} ${LDFLAGS_BIN} -o $@ ${@}.o -L. -l${PACKAGE} -lm ${LIBS}
+
+# Tested with bison 3.8 and flex 2.6.4
 eval:		# Rebuild eval_* files from flex/bison source
-		${FLEX} -t eval.l > eval_l.c1
-		# Note workaround for yyfree=fffree conflict
-		/bin/sed -e 's/yy/ff/g' -e 's/YY/FF/g' eval_l.c1 -e 's/fffree/yyfffree/g' > eval_l.c
-		/bin/rm -f eval_l.c1
-		${BISON} -d -v -y eval.y
-		/bin/sed -e 's/yy/ff/g' -e 's/YY/FF/g' y.tab.c > eval_y.c
-		/bin/sed -e 's/yy/ff/g' -e 's/YY/FF/g' y.tab.h > eval_tab.h
-		/bin/rm -f y.tab.c y.tab.h
+		${FLEX} -o eval_l.c eval.l 
+		${BISON} -o eval_y.c --header=eval_tab.h eval.y
 
 clean:
 	-	/bin/rm -rf *.o zlib/*.o *.dSYM lib${PACKAGE}* y.output so_locations \
-		${UTILS} ${FPACK_UTILS} testprog.fit
+		${UTILS} ${FPACK_UTILS} testprog.fit testf77
 
 distclean:	clean
 	-	/bin/rm -f Makefile cfitsio.pc config.log config.status configure.lineno
 
 # Make target which outputs the list of the .o contained in the cfitsio lib
 # usefull to build a single big shared library containing Tcl/Tk and other
 # extensions.  used for the Tcl Plugin.
```

### Comparing `fitsio-1.1.9/cfitsio3490/README` & `fitsio-1.2.0/cfitsio-4.2.0/README`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/README.MacOS` & `fitsio-1.2.0/cfitsio-4.2.0/README.MacOS`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/README_OLD.win` & `fitsio-1.2.0/cfitsio-4.2.0/README_OLD.win`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/buffers.c` & `fitsio-1.2.0/cfitsio-4.2.0/buffers.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/cfileio.c` & `fitsio-1.2.0/cfitsio-4.2.0/cfileio.c`

 * *Files 0% similar despite different names*

```diff
@@ -1302,31 +1302,36 @@
 
     /* ------------------------------------------------------------------- */
     /* make an image histogram by binning columns, if specified in the URL */
     /* ------------------------------------------------------------------- */
  
     if (*binspec)
     {
+       char **exprs = 0;
        if (*histfilename  && !(*pixfilter) )
            strcpy(outfile, histfilename); /* the original outfile name */
        else
            strcpy(outfile, "mem://_3");  /* create histogram in memory */
                                          /* if not already copied the file */ 
 
        /* parse the binning specifier into individual parameters */
-       ffbins(binspec, &imagetype, &haxis, colname, 
-                          minin, maxin, binsizein, 
-                          minname, maxname, binname,
-                          &weight, wtcol, &recip, status);
-
+       ffbinse(binspec, &imagetype, &haxis, colname, 
+	       minin, maxin, binsizein, 
+	       minname, maxname, binname,
+	       &weight, wtcol, &recip, &(exprs), status);
+       
        /* Create the histogram primary array and open it as the current fptr */
        /* This will close the table that was used to create the histogram. */
-       ffhist2(fptr, outfile, imagetype, haxis, colname, minin, maxin,
-              binsizein, minname, maxname, binname,
-              weight, wtcol, recip, rowselect, status);
+       ffhist2e(fptr, outfile, imagetype, haxis, 
+		colname, exprs, minin, maxin, binsizein, 
+		minname, maxname, binname,
+		weight, wtcol, (exprs?exprs[4]:0),
+		recip, rowselect, status);
+
+       if (exprs) free(exprs);
 
        if (rowselect)
           free(rowselect);
 
        if (*status > 0)
        {
       ffpmsg("on-the-fly histogramming of input table failed (ffopen)");
@@ -1732,14 +1737,46 @@
            return(0); 
         } else {  /* skip over any other character */
            tstr++;
         }
     }
     return(1);  /* opps, didn't find the closing character */
 }
+
+/*--------------------------------------------------------------------------*/
+char *fits_find_match_delim(char *string, char delim)
+/*
+  Find matching delimiter, respecting quoting and (potentially nested) parentheses
+  
+  char *string - null-terminated string to be searched for delimiter
+  char delim - single delimiter to search for (one of '")]} )
+
+  returns: pointer to character after delimiter, or 0 if not found
+*/
+{
+  char *tstr = string;
+  int retval = 0;
+
+  if (!string) return 0;
+  switch (delim) {
+  case '\'': retval = find_quote(&tstr); break;
+  case '"':  retval = find_doublequote(&tstr); break;
+  case '}':  retval = find_curlybracket(&tstr); break;
+  case ']':  retval = find_bracket(&tstr); break;
+  case ')':  retval = find_paren(&tstr); break;
+  default: return 0; /* Invalid delimeter, return failure */
+  }
+
+  /* Delimeter not found, return failure */
+  if (retval) return 0;
+
+  /* Delimeter was found, return next position */
+  return (tstr);
+}
+
 /*--------------------------------------------------------------------------*/
 static int find_doublequote(char **string)
 
 /*  
     look for the closing double quote character in the input string
 */
 {
@@ -2077,17 +2114,19 @@
 
 	    /* Case Ib. delete column names with wildcard or not
 	            -COLNAME  - deleted exact column
 		    -COLNAM*  - delete first column that matches pattern
 	       Note no leading '#'
 	    */
 	    } else if (clause1[0] && clause1[0] != '#' &&
-		ffgcno(*fptr, CASEINSEN, clause1, &colnum, status) <= 0)
+		       ((ffgcno(*fptr, CASEINSEN, clause1, &colnum, status) <= 0) ||
+			*status == COL_NOT_UNIQUE))
             {
                 /* a column with this name exists, so try to delete it */
+	        *status = 0; /* Clear potential status=COL_NOT_UNIQUE */
                 if (ffdcol(*fptr, colnum, status) > 0)
                 {
                     ffpmsg("failed to delete column in input file:");
                     ffpmsg(clause);
                     if( colindex ) free( colindex );
                     if( file_expr ) free( file_expr );
 		    if( clause ) free(clause);
@@ -2297,15 +2336,15 @@
             {
               /* ------------------------------------ */
               /* case 1 - simply the name of a column */
               /* ------------------------------------ */
 
               /* look for matching column */
               ffgcno(*fptr, CASEINSEN, colname, &testnum, status);
-
+	      
               while (*status == COL_NOT_UNIQUE) 
               {
                  /* the column name contained wild cards, and it */
                  /* matches more than one column in the table. */
 		 
 		 colnum = testnum;
 
@@ -6115,19 +6154,20 @@
         {
 	    if (strlen(ptr1 +1) > FLEN_FILENAME - 1)
 	    {
                     free(infile);
                     return(*status = URL_PARSE_ERROR);
             }
 
-            strcpy(binspec, ptr1 + 1);       
-            ptr2 = strchr(binspec, ']');
+            strcpy(binspec, ptr1 + 1);
+	    ptr2 = fits_find_match_delim(binspec, ']');
 
             if (ptr2)      /* terminate the binning filter */
             {
+	        --ptr2;    /* points beyond delimeter, so rewind by 1 */
                 *ptr2 = '\0';
 
                 if ( *(--ptr2) == ' ')  /* delete trailing spaces */
                     *ptr2 = '\0';
             }
             else
             {
@@ -6135,17 +6175,24 @@
                 ffpmsg(rowfilter);
                 free(infile);
                 return(*status = URL_PARSE_ERROR);  /* error, no closing ] */
             }
         }
 
         /* delete the binning spec from the row filter string */
-        ptr2 = strchr(ptr1, ']');
-        strcpy(tmpstr, ptr2+1);  /* copy any chars after the binspec */
-        strcpy(ptr1, tmpstr);    /* overwrite binspec */
+	ptr2 = fits_find_match_delim(ptr1+1, ']');
+	if (ptr2) {
+	  strcpy(tmpstr, ptr2);    /* copy any chars after the binspec */
+	  strcpy(ptr1, tmpstr);    /* overwrite binspec */
+	} else {
+	  ffpmsg("input file URL is missing closing bracket ']'");
+	  ffpmsg(rowfilter);
+	  free(infile);
+	  return(*status = URL_PARSE_ERROR);  /* error, no closing ] */
+	}
     }
 
     /* --------------------------------------------------------- */
     /* does the filter contain a column selection specification? */
     /* --------------------------------------------------------- */
 
     ptr1 = strstr(rowfilter, "[col ");
@@ -7067,15 +7114,15 @@
 
         ptr2++;  /* skip over the '(' delimiter */
         while (*ptr2 == ' ')  /* skip over any leading blanks */
             ptr2++;
 
 
         ptr1 = strchr(ptr2, ')');
-        if (!ptr2)
+        if (!ptr1)
         {
             ffpmsg("illegal specification of image in table cell in input URL:");
             ffpmsg(" missing closing ')' character in row expression");
             ffpmsg(extspec);
             return(*status = URL_PARSE_ERROR);
         }
```

### Comparing `fitsio-1.1.9/cfitsio3490/cfitsio.xcodeproj/project.pbxproj` & `fitsio-1.2.0/cfitsio-4.2.0/cfitsio.xcodeproj/project.pbxproj`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/cfitsio_mac.sit.hqx` & `fitsio-1.2.0/cfitsio-4.2.0/cfitsio_mac.sit.hqx`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/cfortran.h` & `fitsio-1.2.0/cfitsio-4.2.0/cfortran.h`

 * *Files 0% similar despite different names*

```diff
@@ -49,14 +49,27 @@
                 (KMCCARTY)
       May 2008: Revert commenting out of "extern" in COMMON_BLOCK_DEF macro.
 		Add braces around do-nothing ";" in 3 empty while blocks to
 		get rid of compiler warnings.  Thanks to ROOT developers
 		Jacek Holeczek and Rene Brun for these suggestions. (KMCCARTY)
       Dec 2008  Added typedef for LONGLONG to support Borland compiler (WDP)
       Jan 2020  Added __attribute__((unused)) for GCC to prevent warnings (C. Markwardt)
+      Jan 2022  Changed H_CF_SPECIAL definition from 'unsigned' to 'size_t'.
+                This determines the type of the hidden length argument which
+                gets added to functions passing strings from Fortran to C.
+                This change was first required when testing Homebrew
+                compilers native to Mac/ARM Silicon. (C. Gordon)
+      Apr 2022  Made equivalent 'unsigned'/'size_t' change to STRING_cfKK(B)
+                definition.  This is required for passing strings from
+                C to Fortran.  To avoid duplication, defined an 'if' block
+                for setting new CF_STRLENTYPE variable.  H_CF_SPECIAL and
+                STRING_cfKK(B) are now set to this.
+      May 2022  Set ALL Mac/ARM platforms to 'size_t' for CF_STRLENTYPE
+                since Clang/Clang++ will not pass GNUC>7 test, yet its
+                (3rd-party) Fortran still needs this.
  *******/
 
 #ifndef __CFORTRAN__PCTYPE__UNUSED__
 #ifdef __GNUC__
 #define __CFORTRAN__PCTYPE__UNUSED__ __attribute__ ((unused))
 #else
 #define __CFORTRAN__PCTYPE__UNUSED__
@@ -429,14 +442,27 @@
 #ifdef OLD_VAXC                          /* Allow %CC-I-PARAMNOTUSED.         */
 #pragma standard                         
 #endif
 
 #define AcfCOMMA ,
 #define AcfCOLON ;
 
+
+/* Use CF_STRLENTYPE = size_t for all Fortran newer than GNU version 7.x.
+   Apple clang identifies itself as GNUC=4, but we want it to use size_t too.
+   Note that 2 assumptions are in play here:
+   1) Aside from clang, the C version (GNUC) also represents the version
+      of Fortran being used!
+   2) No one is pairing clang with gfortran older than v8.x anymore. */
+#if (defined(__GNUC__) && !defined(__clang__)) && __GNUC__ < 8
+#define  CF_STRLENTYPE       unsigned
+#else
+#define  CF_STRLENTYPE       size_t
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /*               UTILITIES USED WITHIN CFORTRAN.H                          */
 
 #define _cfMIN(A,B) (A<B?A:B)
 
 /* 970211 - XIX.145:
@@ -873,15 +899,15 @@
 #if defined(AbsoftUNIXFortran)
 #define  DEFAULT_cfKK(B) , unsigned B
 #else
 #define  DEFAULT_cfKK(B)
 #endif
 #define  LOGICAL_cfKK(B) DEFAULT_cfKK(B)
 #define PLOGICAL_cfKK(B) DEFAULT_cfKK(B)
-#define   STRING_cfKK(B) , unsigned B
+#define   STRING_cfKK(B) , CF_STRLENTYPE B
 #define  PSTRING_cfKK(B) STRING_cfKK(B)
 #define  STRINGV_cfKK(B) STRING_cfKK(B)
 #define PSTRINGV_cfKK(B) STRING_cfKK(B)
 #define  ZTRINGV_cfKK(B) STRING_cfKK(B)
 #define PZTRINGV_cfKK(B) STRING_cfKK(B)
 #endif
 
@@ -1697,15 +1723,15 @@
 #define PSTRINGV_cfS(M,I,A) STRINGV_cfS(M,I,A)
 #define  ZTRINGV_cfS(M,I,A)
 #define PZTRINGV_cfS(M,I,A)
 
 #define   HCF(TN,I)         _(TN,_cfSTR)(3,H,cfCOMMA, H,_(C,I),0,0)
 #define  HHCF(TN,I)         _(TN,_cfSTR)(3,H,cfCOMMA,HH,_(C,I),0,0)
 #define HHHCF(TN,I)         _(TN,_cfSTR)(3,H,cfCOLON, H,_(C,I),0,0)
-#define  H_CF_SPECIAL       unsigned
+#define  H_CF_SPECIAL       CF_STRLENTYPE
 #define HH_CF_SPECIAL
 #define  DEFAULT_cfH(M,I,A)
 #define  LOGICAL_cfH(S,U,B)
 #define PLOGICAL_cfH(S,U,B)
 #define   STRING_cfH(S,U,B) _(A,S) _(U,_CF_SPECIAL) B
 #define  STRINGV_cfH(S,U,B) STRING_cfH(S,U,B)
 #define  PSTRING_cfH(S,U,B) STRING_cfH(S,U,B)
```

### Comparing `fitsio-1.1.9/cfitsio3490/checksum.c` & `fitsio-1.2.0/cfitsio-4.2.0/checksum.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/config.guess` & `fitsio-1.2.0/cfitsio-4.2.0/config.guess`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright 1992-2018 Free Software Foundation, Inc.
+#   Copyright 1992-2021 Free Software Foundation, Inc.
 
-timestamp='2018-02-24'
+timestamp='2021-01-25'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 3 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful, but
@@ -23,20 +23,20 @@
 # the same distribution terms that you use for the rest of that
 # program.  This Exception is an additional permission under section 7
 # of the GNU General Public License, version 3 ("GPLv3").
 #
 # Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
 #
 # You can get the latest version of this script from:
-# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+# https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
 #
 # Please send patches to <config-patches@gnu.org>.
 
 
-me=`echo "$0" | sed -e 's,.*/,,'`
+me=$(echo "$0" | sed -e 's,.*/,,')
 
 usage="\
 Usage: $0 [OPTION]
 
 Output the configuration name of the system \`$me' is run on.
 
 Options:
@@ -46,15 +46,15 @@
 
 Report bugs and patches to <config-patches@gnu.org>."
 
 version="\
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright 1992-2018 Free Software Foundation, Inc.
+Copyright 1992-2021 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
 
 help="
 Try \`$me --help' for more information."
 
@@ -80,86 +80,100 @@
 done
 
 if test $# != 0; then
   echo "$me: too many arguments$help" >&2
   exit 1
 fi
 
-trap 'exit 1' 1 2 15
-
 # CC_FOR_BUILD -- compiler used by this script. Note that the use of a
 # compiler to aid in system detection is discouraged as it requires
 # temporary files to be created and, as you can see below, it is a
 # headache to deal with in a portable fashion.
 
 # Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
 # use `HOST_CC' if defined, but it is deprecated.
 
 # Portable tmp directory creation inspired by the Autoconf team.
 
-set_cc_for_build='
-trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
-trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
-: ${TMPDIR=/tmp} ;
- { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
- { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
- { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
-dummy=$tmp/dummy ;
-tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
-case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int x;" > "$dummy.c" ;
-	for c in cc gcc c89 c99 ; do
-	  if ($c -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac ; set_cc_for_build= ;'
+tmp=
+# shellcheck disable=SC2172
+trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
+
+set_cc_for_build() {
+    # prevent multiple calls if $tmp is already set
+    test "$tmp" && return 0
+    : "${TMPDIR=/tmp}"
+    # shellcheck disable=SC2039
+    { tmp=$( (umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null) && test -n "$tmp" && test -d "$tmp" ; } ||
+	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
+    dummy=$tmp/dummy
+    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
+	,,)    echo "int x;" > "$dummy.c"
+	       for driver in cc gcc c89 c99 ; do
+		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+		       CC_FOR_BUILD="$driver"
+		       break
+		   fi
+	       done
+	       if test x"$CC_FOR_BUILD" = x ; then
+		   CC_FOR_BUILD=no_compiler_found
+	       fi
+	       ;;
+	,,*)   CC_FOR_BUILD=$CC ;;
+	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+    esac
+}
 
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
 # (ghazi@noc.rutgers.edu 1994-08-24)
-if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+if test -f /.attbin/uname ; then
 	PATH=$PATH:/.attbin ; export PATH
 fi
 
-UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
-UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
-UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+UNAME_MACHINE=$( (uname -m) 2>/dev/null) || UNAME_MACHINE=unknown
+UNAME_RELEASE=$( (uname -r) 2>/dev/null) || UNAME_RELEASE=unknown
+UNAME_SYSTEM=$( (uname -s) 2>/dev/null) || UNAME_SYSTEM=unknown
+UNAME_VERSION=$( (uname -v) 2>/dev/null) || UNAME_VERSION=unknown
 
 case "$UNAME_SYSTEM" in
 Linux|GNU|GNU/*)
-	# If the system lacks a compiler, then just pick glibc.
-	# We could probably try harder.
-	LIBC=gnu
+	LIBC=unknown
 
-	eval "$set_cc_for_build"
+	set_cc_for_build
 	cat <<-EOF > "$dummy.c"
 	#include <features.h>
 	#if defined(__UCLIBC__)
 	LIBC=uclibc
 	#elif defined(__dietlibc__)
 	LIBC=dietlibc
-	#else
+	#elif defined(__GLIBC__)
 	LIBC=gnu
+	#else
+	#include <stdarg.h>
+	/* First heuristic to detect musl libc.  */
+	#ifdef __DEFINED_va_list
+	LIBC=musl
+	#endif
 	#endif
 	EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
+	eval "$($CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g')"
 
-	# If ldd exists, use it to detect musl libc.
-	if command -v ldd >/dev/null && \
-		ldd --version 2>&1 | grep -q ^musl
-	then
-	    LIBC=musl
+	# Second heuristic to detect musl libc.
+	if [ "$LIBC" = unknown ] &&
+	   command -v ldd >/dev/null &&
+	   ldd --version 2>&1 | grep -q ^musl; then
+		LIBC=musl
+	fi
+
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	if [ "$LIBC" = unknown ]; then
+		LIBC=gnu
 	fi
 	;;
 esac
 
 # Note: order is significant - the case branches are not exclusive.
 
 case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
@@ -170,40 +184,40 @@
 	# switched to ELF, *-*-netbsd* would select the old
 	# object file format.  This provides both forward
 	# compatibility and a consistent mechanism for selecting the
 	# object file format.
 	#
 	# Note: NetBSD doesn't particularly care about the vendor
 	# portion of the name.  We always set it to "unknown".
-	sysctl="sysctl -n hw.machine_arch"
-	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
-	    "/sbin/$sysctl" 2>/dev/null || \
-	    "/usr/sbin/$sysctl" 2>/dev/null || \
-	    echo unknown)`
+	UNAME_MACHINE_ARCH=$( (uname -p 2>/dev/null || \
+	    /sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    /usr/sbin/sysctl -n hw.machine_arch 2>/dev/null || \
+	    echo unknown))
 	case "$UNAME_MACHINE_ARCH" in
+	    aarch64eb) machine=aarch64_be-unknown ;;
 	    armeb) machine=armeb-unknown ;;
 	    arm*) machine=arm-unknown ;;
 	    sh3el) machine=shl-unknown ;;
 	    sh3eb) machine=sh-unknown ;;
 	    sh5el) machine=sh5le-unknown ;;
 	    earmv*)
-		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
-		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		arch=$(echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,')
+		endian=$(echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p')
 		machine="${arch}${endian}"-unknown
 		;;
 	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
 	esac
 	# The Operating System including object format, if it has switched
 	# to ELF recently (or will in the future) and ABI.
 	case "$UNAME_MACHINE_ARCH" in
 	    earm*)
 		os=netbsdelf
 		;;
 	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval "$set_cc_for_build"
+		set_cc_for_build
 		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
 			| grep -q __ELF__
 		then
 		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
 		    # Return netbsd for either.  FIX?
 		    os=netbsd
 		else
@@ -214,85 +228,91 @@
 		os=netbsd
 		;;
 	esac
 	# Determine ABI tags.
 	case "$UNAME_MACHINE_ARCH" in
 	    earm*)
 		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
-		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+		abi=$(echo "$UNAME_MACHINE_ARCH" | sed -e "$expr")
 		;;
 	esac
 	# The OS release
 	# Debian GNU/NetBSD machines have a different userland, and
 	# thus, need a distinct triplet. However, they do not need
 	# kernel version information, so it can be replaced with a
 	# suitable tag, in the style of linux-gnu.
 	case "$UNAME_VERSION" in
 	    Debian*)
 		release='-gnu'
 		;;
 	    *)
-		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
+		release=$(echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2)
 		;;
 	esac
 	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
 	# contains redundant information, the shorter form:
 	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "$machine-${os}${release}${abi}"
+	echo "$machine-${os}${release}${abi-}"
 	exit ;;
     *:Bitrig:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	UNAME_MACHINE_ARCH=$(arch | sed 's/Bitrig.//')
 	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
 	exit ;;
     *:OpenBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	UNAME_MACHINE_ARCH=$(arch | sed 's/OpenBSD.//')
 	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
 	exit ;;
     *:LibertyBSD:*:*)
-	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	UNAME_MACHINE_ARCH=$(arch | sed 's/^.*BSD\.//')
 	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
 	exit ;;
     *:MidnightBSD:*:*)
 	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
 	exit ;;
     *:ekkoBSD:*:*)
 	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
 	exit ;;
     *:SolidBSD:*:*)
 	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
 	exit ;;
+    *:OS108:*:*)
+	echo "$UNAME_MACHINE"-unknown-os108_"$UNAME_RELEASE"
+	exit ;;
     macppc:MirBSD:*:*)
 	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
 	exit ;;
     *:MirBSD:*:*)
 	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
 	exit ;;
     *:Sortix:*:*)
 	echo "$UNAME_MACHINE"-unknown-sortix
 	exit ;;
+    *:Twizzler:*:*)
+	echo "$UNAME_MACHINE"-unknown-twizzler
+	exit ;;
     *:Redox:*:*)
 	echo "$UNAME_MACHINE"-unknown-redox
 	exit ;;
     mips:OSF1:*.*)
-        echo mips-dec-osf1
-        exit ;;
+	echo mips-dec-osf1
+	exit ;;
     alpha:OSF1:*:*)
 	case $UNAME_RELEASE in
 	*4.0)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		UNAME_RELEASE=$(/usr/sbin/sizer -v | awk '{print $3}')
 		;;
 	*5.*)
-		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		UNAME_RELEASE=$(/usr/sbin/sizer -v | awk '{print $4}')
 		;;
 	esac
 	# According to Compaq, /usr/sbin/psrinfo has been available on
 	# OSF/1 and Tru64 systems produced since 1995.  I hope that
 	# covers most systems running today.  This code pipes the CPU
 	# types through head -n 1, so we only detect the type of CPU 0.
-	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	ALPHA_CPU_TYPE=$(/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1)
 	case "$ALPHA_CPU_TYPE" in
 	    "EV4 (21064)")
 		UNAME_MACHINE=alpha ;;
 	    "EV4.5 (21064)")
 		UNAME_MACHINE=alpha ;;
 	    "LCA4 (21066/21068)")
 		UNAME_MACHINE=alpha ;;
@@ -322,15 +342,15 @@
 		UNAME_MACHINE=alphaev79 ;;
 	esac
 	# A Pn.n version is a patched version.
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
+	echo "$UNAME_MACHINE"-dec-osf"$(echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz)"
 	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
 	exitcode=$?
 	trap '' 0
 	exit $exitcode ;;
     Amiga*:UNIX_System_V:4.0:*)
 	echo m68k-unknown-sysv4
 	exit ;;
@@ -356,80 +376,80 @@
 	echo arm-unknown-riscos
 	exit ;;
     SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
 	exit ;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
 	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
-	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+	if test "$( (/bin/universe) 2>/dev/null)" = att ; then
 		echo pyramid-pyramid-sysv3
 	else
 		echo pyramid-pyramid-bsd
 	fi
 	exit ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
 	exit ;;
     DRS?6000:unix:4.0:6*)
 	echo sparc-icl-nx6
 	exit ;;
     DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
-	case `/usr/bin/uname -p` in
+	case $(/usr/bin/uname -p) in
 	    sparc) echo sparc-icl-nx7; exit ;;
 	esac ;;
     s390x:SunOS:*:*)
-	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	echo "$UNAME_MACHINE"-ibm-solaris2"$(echo "$UNAME_RELEASE" | sed -e 's/[^.]*//')"
 	exit ;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo sparc-hal-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
-	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	echo sparc-sun-solaris2"$(echo "$UNAME_RELEASE" | sed -e 's/[^.]*//')"
 	exit ;;
     i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
 	echo i386-pc-auroraux"$UNAME_RELEASE"
 	exit ;;
     i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
-	eval "$set_cc_for_build"
+	set_cc_for_build
 	SUN_ARCH=i386
 	# If there is a compiler, see if it is configured for 64-bit objects.
 	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
 	# This test works for both compilers.
-	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
 	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
 		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
 		grep IS_64BIT_ARCH >/dev/null
 	    then
 		SUN_ARCH=x86_64
 	    fi
 	fi
-	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo "$SUN_ARCH"-pc-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     sun4*:SunOS:6*:*)
 	# According to config.sub, this is the proper way to canonicalize
 	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
 	# it's likely to be more like Solaris than SunOS4.
-	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo sparc-sun-solaris3"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     sun4*:SunOS:*:*)
-	case "`/usr/bin/arch -k`" in
+	case "$(/usr/bin/arch -k)" in
 	    Series*|S4*)
-		UNAME_RELEASE=`uname -v`
+		UNAME_RELEASE=$(uname -v)
 		;;
 	esac
 	# Japanese Language versions have a version number like `4.1.3-JL'.
-	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
+	echo sparc-sun-sunos"$(echo "$UNAME_RELEASE"|sed -e 's/-/_/')"
 	exit ;;
     sun3*:SunOS:*:*)
 	echo m68k-sun-sunos"$UNAME_RELEASE"
 	exit ;;
     sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	UNAME_RELEASE=$( (sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null)
 	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
-	case "`/bin/arch`" in
+	case "$(/bin/arch)" in
 	    sun3)
 		echo m68k-sun-sunos"$UNAME_RELEASE"
 		;;
 	    sun4)
 		echo sparc-sun-sunos"$UNAME_RELEASE"
 		;;
 	esac
@@ -478,15 +498,15 @@
     VAX*:ULTRIX*:*:*)
 	echo vax-dec-ultrix"$UNAME_RELEASE"
 	exit ;;
     2020:CLIX:*:* | 2430:CLIX:*:*)
 	echo clipper-intergraph-clix"$UNAME_RELEASE"
 	exit ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval "$set_cc_for_build"
+	set_cc_for_build
 	sed 's/^	//' << EOF > "$dummy.c"
 #ifdef __cplusplus
 #include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
 #endif
@@ -501,16 +521,16 @@
 	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
 	#endif
 	#endif
 	  exit (-1);
 	}
 EOF
 	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
-	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
-	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
+	  dummyarg=$(echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p') &&
+	  SYSTEM_NAME=$("$dummy" "$dummyarg") &&
 	    { echo "$SYSTEM_NAME"; exit; }
 	echo mips-mips-riscos"$UNAME_RELEASE"
 	exit ;;
     Motorola:PowerMAX_OS:*:*)
 	echo powerpc-motorola-powermax
 	exit ;;
     Motorola:*:4.3:PL8-*)
@@ -529,19 +549,19 @@
 	echo m88k-motorola-sysv4
 	exit ;;
     m88k:*:3*:R3*)
 	echo m88k-motorola-sysv3
 	exit ;;
     AViiON:dgux:*:*)
 	# DG/UX returns AViiON for all architectures
-	UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
+	UNAME_PROCESSOR=$(/usr/bin/uname -p)
+	if test "$UNAME_PROCESSOR" = mc88100 || test "$UNAME_PROCESSOR" = mc88110
 	then
-	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
-	       [ "$TARGET_BINARY_INTERFACE"x = x ]
+	    if test "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx || \
+	       test "$TARGET_BINARY_INTERFACE"x = x
 	    then
 		echo m88k-dg-dgux"$UNAME_RELEASE"
 	    else
 		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
 	    fi
 	else
 	    echo i586-dg-dgux"$UNAME_RELEASE"
@@ -557,66 +577,66 @@
     XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
 	echo m88k-tektronix-sysv3
 	exit ;;
     Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
 	echo m68k-tektronix-bsd
 	exit ;;
     *:IRIX*:*:*)
-	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
+	echo mips-sgi-irix"$(echo "$UNAME_RELEASE"|sed -e 's/-/_/g')"
 	exit ;;
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
 	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
-	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+	exit ;;               # Note that: echo "'$(uname -s)'" gives 'AIX '
     i*86:AIX:*:*)
 	echo i386-ibm-aix
 	exit ;;
     ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
+	if test -x /usr/bin/oslevel ; then
+		IBM_REV=$(/usr/bin/oslevel)
 	else
 		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
 	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
 	exit ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval "$set_cc_for_build"
+		set_cc_for_build
 		sed 's/^		//' << EOF > "$dummy.c"
 		#include <sys/systemcfg.h>
 
 		main()
 			{
 			if (!__power_pc())
 				exit(1);
 			puts("powerpc-ibm-aix3.2.5");
 			exit(0);
 			}
 EOF
-		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=$("$dummy")
 		then
 			echo "$SYSTEM_NAME"
 		else
 			echo rs6000-ibm-aix3.2.5
 		fi
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
 		echo rs6000-ibm-aix3.2.4
 	else
 		echo rs6000-ibm-aix3.2
 	fi
 	exit ;;
     *:AIX:*:[4567])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	IBM_CPU_ID=$(/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }')
 	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
-	if [ -x /usr/bin/lslpp ] ; then
-		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
-			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
+	if test -x /usr/bin/lslpp ; then
+		IBM_REV=$(/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/)
 	else
 		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
 	fi
 	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
 	exit ;;
     *:AIX:*:*)
 	echo rs6000-ibm-aix
@@ -636,35 +656,35 @@
     9000/[34]??:4.3bsd:1.*:*)
 	echo m68k-hp-bsd
 	exit ;;
     hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
 	echo m68k-hp-bsd4.4
 	exit ;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	HPUX_REV=$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//')
 	case "$UNAME_MACHINE" in
 	    9000/31?)            HP_ARCH=m68000 ;;
 	    9000/[34]??)         HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
-		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		if test -x /usr/bin/getconf; then
+		    sc_cpu_version=$(/usr/bin/getconf SC_CPU_VERSION 2>/dev/null)
+		    sc_kernel_bits=$(/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null)
 		    case "$sc_cpu_version" in
 		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
 		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
 		      532)                      # CPU_PA_RISC2_0
 			case "$sc_kernel_bits" in
 			  32) HP_ARCH=hppa2.0n ;;
 			  64) HP_ARCH=hppa2.0w ;;
 			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
 			esac ;;
 		    esac
 		fi
-		if [ "$HP_ARCH" = "" ]; then
-		    eval "$set_cc_for_build"
+		if test "$HP_ARCH" = ""; then
+		    set_cc_for_build
 		    sed 's/^		//' << EOF > "$dummy.c"
 
 		#define _HPUX_SOURCE
 		#include <stdlib.h>
 		#include <unistd.h>
 
 		int main ()
@@ -690,21 +710,21 @@
 			    puts ("hppa2.0"); break;
 		#endif
 			default: puts ("hppa1.0"); break;
 			}
 		    exit (0);
 		}
 EOF
-		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=$("$dummy")
 		    test -z "$HP_ARCH" && HP_ARCH=hppa
 		fi ;;
 	esac
-	if [ "$HP_ARCH" = hppa2.0w ]
+	if test "$HP_ARCH" = hppa2.0w
 	then
-	    eval "$set_cc_for_build"
+	    set_cc_for_build
 
 	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
 	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
 	    # generating 64-bit code.  GNU and HP use different nomenclature:
 	    #
 	    # $ CC_FOR_BUILD=cc ./config.guess
 	    # => hppa2.0w-hp-hpux11.23
@@ -718,19 +738,19 @@
 	    else
 		HP_ARCH=hppa64
 	    fi
 	fi
 	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
 	exit ;;
     ia64:HP-UX:*:*)
-	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	HPUX_REV=$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//')
 	echo ia64-hp-hpux"$HPUX_REV"
 	exit ;;
     3050*:HI-UX:*:*)
-	eval "$set_cc_for_build"
+	set_cc_for_build
 	sed 's/^	//' << EOF > "$dummy.c"
 	#include <unistd.h>
 	int
 	main ()
 	{
 	  long cpu = sysconf (_SC_CPU_VERSION);
 	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
@@ -748,15 +768,15 @@
 	    }
 	  else if (CPU_IS_HP_MC68K (cpu))
 	    puts ("m68k-hitachi-hiuxwe2");
 	  else puts ("unknown-hitachi-hiuxwe2");
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=$("$dummy") &&
 		{ echo "$SYSTEM_NAME"; exit; }
 	echo unknown-hitachi-hiuxwe2
 	exit ;;
     9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
 	echo hppa1.1-hp-bsd
 	exit ;;
     9000/8??:4.3bsd:*:*)
@@ -768,15 +788,15 @@
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
 	echo hppa1.1-hp-osf
 	exit ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
 	exit ;;
     i*86:OSF1:*:*)
-	if [ -x /usr/sbin/sysversion ] ; then
+	if test -x /usr/sbin/sysversion ; then
 	    echo "$UNAME_MACHINE"-unknown-osf1mk
 	else
 	    echo "$UNAME_MACHINE"-unknown-osf1
 	fi
 	exit ;;
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
@@ -817,42 +837,53 @@
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     *:UNICOS/mp:*:*)
 	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
 	exit ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
-	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
-	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	FUJITSU_PROC=$(uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz)
+	FUJITSU_SYS=$(uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///')
+	FUJITSU_REL=$(echo "$UNAME_RELEASE" | sed -e 's/ /_/')
 	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     5000:UNIX_System_V:4.*:*)
-	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
-	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	FUJITSU_SYS=$(uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///')
+	FUJITSU_REL=$(echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/')
 	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
 	exit ;;
     i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
 	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
 	exit ;;
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi"$UNAME_RELEASE"
 	exit ;;
     *:BSD/OS:*:*)
 	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
 	exit ;;
+    arm:FreeBSD:*:*)
+	UNAME_PROCESSOR=$(uname -p)
+	set_cc_for_build
+	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_PCS_VFP
+	then
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"$(echo ${UNAME_RELEASE}|sed -e 's/[-(].*//')"-gnueabi
+	else
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"$(echo ${UNAME_RELEASE}|sed -e 's/[-(].*//')"-gnueabihf
+	fi
+	exit ;;
     *:FreeBSD:*:*)
-	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	UNAME_PROCESSOR=$(/usr/bin/uname -p)
 	case "$UNAME_PROCESSOR" in
 	    amd64)
 		UNAME_PROCESSOR=x86_64 ;;
 	    i386)
 		UNAME_PROCESSOR=i586 ;;
 	esac
-	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+	echo "$UNAME_PROCESSOR"-unknown-freebsd"$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')"
 	exit ;;
     i*:CYGWIN*:*)
 	echo "$UNAME_MACHINE"-pc-cygwin
 	exit ;;
     *:MINGW64*:*)
 	echo "$UNAME_MACHINE"-pc-mingw64
 	exit ;;
@@ -877,39 +908,39 @@
 		echo ia64-unknown-interix"$UNAME_RELEASE"
 		exit ;;
 	esac ;;
     i*:UWIN*:*)
 	echo "$UNAME_MACHINE"-pc-uwin
 	exit ;;
     amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
-	echo x86_64-unknown-cygwin
+	echo x86_64-pc-cygwin
 	exit ;;
     prep*:SunOS:5.*:*)
-	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	echo powerpcle-unknown-solaris2"$(echo "$UNAME_RELEASE"|sed -e 's/[^.]*//')"
 	exit ;;
     *:GNU:*:*)
 	# the GNU system
-	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
+	echo "$(echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,')-unknown-$LIBC$(echo "$UNAME_RELEASE"|sed -e 's,/.*$,,')"
 	exit ;;
     *:GNU/*:*:*)
 	# other systems with GNU libc and userland
-	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
+	echo "$UNAME_MACHINE-unknown-$(echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]")$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')-$LIBC"
 	exit ;;
-    i*86:Minix:*:*)
-	echo "$UNAME_MACHINE"-pc-minix
+    *:Minix:*:*)
+	echo "$UNAME_MACHINE"-unknown-minix
 	exit ;;
     aarch64:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     aarch64_be:Linux:*:*)
 	UNAME_MACHINE=aarch64_be
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	case $(sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null) in
 	  EV5)   UNAME_MACHINE=alphaev5 ;;
 	  EV56)  UNAME_MACHINE=alphaev56 ;;
 	  PCA56) UNAME_MACHINE=alphapca56 ;;
 	  PCA57) UNAME_MACHINE=alphapca56 ;;
 	  EV6)   UNAME_MACHINE=alphaev6 ;;
 	  EV67)  UNAME_MACHINE=alphaev67 ;;
 	  EV68*) UNAME_MACHINE=alphaev68 ;;
@@ -918,15 +949,15 @@
 	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     arc:Linux:*:* | arceb:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     arm*:Linux:*:*)
-	eval "$set_cc_for_build"
+	set_cc_for_build
 	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
 	    | grep -q __ARM_EABI__
 	then
 	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	else
 	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
 		| grep -q __ARM_PCS_VFP
@@ -960,38 +991,69 @@
 	exit ;;
     ia64:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     k1om:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+    loongarch32:Linux:*:* | loongarch64:Linux:*:* | loongarchx32:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     m32r*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     m68*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
-	eval "$set_cc_for_build"
+	set_cc_for_build
+	IS_GLIBC=0
+	test x"${LIBC}" = xgnu && IS_GLIBC=1
 	sed 's/^	//' << EOF > "$dummy.c"
 	#undef CPU
-	#undef ${UNAME_MACHINE}
-	#undef ${UNAME_MACHINE}el
+	#undef mips
+	#undef mipsel
+	#undef mips64
+	#undef mips64el
+	#if ${IS_GLIBC} && defined(_ABI64)
+	LIBCABI=gnuabi64
+	#else
+	#if ${IS_GLIBC} && defined(_ABIN32)
+	LIBCABI=gnuabin32
+	#else
+	LIBCABI=${LIBC}
+	#endif
+	#endif
+
+	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa64r6
+	#else
+	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa32r6
+	#else
+	#if defined(__mips64)
+	CPU=mips64
+	#else
+	CPU=mips
+	#endif
+	#endif
+	#endif
+
 	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
-	CPU=${UNAME_MACHINE}el
+	MIPS_ENDIAN=el
 	#else
 	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
-	CPU=${UNAME_MACHINE}
+	MIPS_ENDIAN=
 	#else
-	CPU=
+	MIPS_ENDIAN=
 	#endif
 	#endif
 EOF
-	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU'`"
-	test "x$CPU" != x && { echo "$CPU-unknown-linux-$LIBC"; exit; }
+	eval "$($CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI')"
+	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
 	;;
     mips64el:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     openrisc*:Linux:*:*)
 	echo or1k-unknown-linux-"$LIBC"
 	exit ;;
@@ -1002,15 +1064,15 @@
 	echo sparc-unknown-linux-"$LIBC"
 	exit ;;
     parisc64:Linux:*:* | hppa64:Linux:*:*)
 	echo hppa64-unknown-linux-"$LIBC"
 	exit ;;
     parisc:Linux:*:* | hppa:Linux:*:*)
 	# Look for CPU level
-	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	case $(grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2) in
 	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
 	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
 	  *)    echo hppa-unknown-linux-"$LIBC" ;;
 	esac
 	exit ;;
     ppc64:Linux:*:*)
 	echo powerpc64-unknown-linux-"$LIBC"
@@ -1020,15 +1082,15 @@
 	exit ;;
     ppc64le:Linux:*:*)
 	echo powerpc64le-unknown-linux-"$LIBC"
 	exit ;;
     ppcle:Linux:*:*)
 	echo powerpcle-unknown-linux-"$LIBC"
 	exit ;;
-    riscv32:Linux:*:* | riscv64:Linux:*:*)
+    riscv32:Linux:*:* | riscv32be:Linux:*:* | riscv64:Linux:*:* | riscv64be:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
 	exit ;;
     sh64*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
@@ -1042,19 +1104,25 @@
     tile*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     vax:Linux:*:*)
 	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
 	exit ;;
     x86_64:Linux:*:*)
-	if objdump -f /bin/sh | grep -q elf32-x86-64; then
-	    echo "$UNAME_MACHINE"-pc-linux-"$LIBC"x32
-	else
-	    echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
+	set_cc_for_build
+	LIBCABI=$LIBC
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __ILP32__'; echo IS_X32; echo '#endif') | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_X32 >/dev/null
+	    then
+		LIBCABI="$LIBC"x32
+	    fi
 	fi
+	echo "$UNAME_MACHINE"-pc-linux-"$LIBCABI"
 	exit ;;
     xtensa*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
     i*86:DYNIX/ptx:4*:*)
 	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
 	# earlier versions are messed up and put the nodename in both
@@ -1086,36 +1154,36 @@
     i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
 	echo i386-unknown-lynxos"$UNAME_RELEASE"
 	exit ;;
     i*86:*DOS:*:*)
 	echo "$UNAME_MACHINE"-pc-msdosdjgpp
 	exit ;;
     i*86:*:4.*:*)
-	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
+	UNAME_REL=$(echo "$UNAME_RELEASE" | sed 's/\/MP$//')
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
 		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
 	else
 		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
 	fi
 	exit ;;
     i*86:*:5:[678]*)
 	# UnixWare 7.x, OpenUNIX and OpenServer 6.
-	case `/bin/uname -X | grep "^Machine"` in
+	case $(/bin/uname -X | grep "^Machine") in
 	    *486*)	     UNAME_MACHINE=i486 ;;
 	    *Pentium)	     UNAME_MACHINE=i586 ;;
 	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
 	esac
-	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}{$UNAME_VERSION}"
+	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
 	exit ;;
     i*86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
-		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		UNAME_REL=$(sed -n 's/.*Version //p' </usr/options/cb.name)
 		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
 	elif /bin/uname -X 2>/dev/null >/dev/null ; then
-		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		UNAME_REL=$( (/bin/uname -X|grep Release|sed -e 's/.*= //'))
 		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
 		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
 			&& UNAME_MACHINE=i586
 		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
 			&& UNAME_MACHINE=i686
 		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
 			&& UNAME_MACHINE=i686
@@ -1157,26 +1225,26 @@
 	echo m68k-diab-dnix
 	exit ;;
     M68*:*:R3V[5678]*:*)
 	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
     3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
-	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	&& OS_REL=.$(sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid)
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
 	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && { echo i486-ncr-sysv4; exit; } ;;
     NCR*:*:4.2:* | MPRAS*:*:4.2:*)
 	OS_REL='.3'
 	test -r /etc/.relid \
-	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	    && OS_REL=.$(sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid)
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
 	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
 	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
 	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
     m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
@@ -1201,15 +1269,15 @@
 	echo mips-sni-sysv4
 	exit ;;
     RM*:SINIX-*:*:*)
 	echo mips-sni-sysv4
 	exit ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
-		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		UNAME_MACHINE=$( (uname -p) 2>/dev/null)
 		echo "$UNAME_MACHINE"-sni-sysv4
 	else
 		echo ns32k-sni-sysv
 	fi
 	exit ;;
     PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
 			# says <Richard.M.Bartel@ccMail.Census.GOV>
@@ -1235,15 +1303,15 @@
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux"$UNAME_RELEASE"
 	exit ;;
     news*:NEWS-OS:6*:*)
 	echo mips-sony-newsos6
 	exit ;;
     R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
-	if [ -d /usr/nec ]; then
+	if test -d /usr/nec; then
 		echo mips-nec-sysv"$UNAME_RELEASE"
 	else
 		echo mips-unknown-sysv"$UNAME_RELEASE"
 	fi
 	exit ;;
     BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
 	echo powerpc-be-beos
@@ -1283,52 +1351,56 @@
 	exit ;;
     Power*:Rhapsody:*:*)
 	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
     *:Rhapsody:*:*)
 	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
 	exit ;;
+    arm64:Darwin:*:*)
+	echo aarch64-apple-darwin"$UNAME_RELEASE"
+	exit ;;
     *:Darwin:*:*)
-	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
-	eval "$set_cc_for_build"
-	if test "$UNAME_PROCESSOR" = unknown ; then
-	    UNAME_PROCESSOR=powerpc
-	fi
-	if test "`echo "$UNAME_RELEASE" | sed -e 's/\..*//'`" -le 10 ; then
-	    if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
-		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
-		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		       grep IS_64BIT_ARCH >/dev/null
-		then
-		    case $UNAME_PROCESSOR in
-			i386) UNAME_PROCESSOR=x86_64 ;;
-			powerpc) UNAME_PROCESSOR=powerpc64 ;;
-		    esac
-		fi
-		# On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
-		if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
-		       (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
-		       grep IS_PPC >/dev/null
-		then
-		    UNAME_PROCESSOR=powerpc
-		fi
+	UNAME_PROCESSOR=$(uname -p)
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	if command -v xcode-select > /dev/null 2> /dev/null && \
+		! xcode-select --print-path > /dev/null 2> /dev/null ; then
+	    # Avoid executing cc if there is no toolchain installed as
+	    # cc will be a stub that puts up a graphical alert
+	    # prompting the user to install developer tools.
+	    CC_FOR_BUILD=no_compiler_found
+	else
+	    set_cc_for_build
+	fi
+	if test "$CC_FOR_BUILD" != no_compiler_found; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+	    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_PPC >/dev/null
+	    then
+		UNAME_PROCESSOR=powerpc
 	    fi
 	elif test "$UNAME_PROCESSOR" = i386 ; then
-	    # Avoid executing cc on OS X 10.9, as it ships with a stub
-	    # that puts up a graphical alert prompting to install
-	    # developer tools.  Any system running Mac OS X 10.7 or
-	    # later (Darwin 11 and later) is required to have a 64-bit
-	    # processor. This is not true of the ARM version of Darwin
-	    # that Apple uses in portable devices.
-	    UNAME_PROCESSOR=x86_64
+	    # uname -m returns i386 or x86_64
+	    UNAME_PROCESSOR=$UNAME_MACHINE
 	fi
 	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
 	exit ;;
     *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	UNAME_PROCESSOR=`uname -p`
+	UNAME_PROCESSOR=$(uname -p)
 	if test "$UNAME_PROCESSOR" = x86; then
 		UNAME_PROCESSOR=i386
 		UNAME_MACHINE=pc
 	fi
 	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
 	exit ;;
     *:QNX:*:4*)
@@ -1358,14 +1430,15 @@
     DS/*:UNIX_System_V:*:*)
 	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
 	exit ;;
     *:Plan9:*:*)
 	# "uname -m" is not consistent, so use $cputype instead. 386
 	# is converted to i386 for consistency with other x86
 	# operating systems.
+	# shellcheck disable=SC2154
 	if test "$cputype" = 386; then
 	    UNAME_MACHINE=i386
 	else
 	    UNAME_MACHINE="$cputype"
 	fi
 	echo "$UNAME_MACHINE"-unknown-plan9
 	exit ;;
@@ -1387,43 +1460,183 @@
     *:ITS:*:*)
 	echo pdp10-unknown-its
 	exit ;;
     SEI:*:*:SEIUX)
 	echo mips-sei-seiux"$UNAME_RELEASE"
 	exit ;;
     *:DragonFly:*:*)
-	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+	echo "$UNAME_MACHINE"-unknown-dragonfly"$(echo "$UNAME_RELEASE"|sed -e 's/[-(].*//')"
 	exit ;;
     *:*VMS:*:*)
-	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	UNAME_MACHINE=$( (uname -p) 2>/dev/null)
 	case "$UNAME_MACHINE" in
 	    A*) echo alpha-dec-vms ; exit ;;
 	    I*) echo ia64-dec-vms ; exit ;;
 	    V*) echo vax-dec-vms ; exit ;;
 	esac ;;
     *:XENIX:*:SysV)
 	echo i386-pc-xenix
 	exit ;;
     i*86:skyos:*:*)
-	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
+	echo "$UNAME_MACHINE"-pc-skyos"$(echo "$UNAME_RELEASE" | sed -e 's/ .*$//')"
 	exit ;;
     i*86:rdos:*:*)
 	echo "$UNAME_MACHINE"-pc-rdos
 	exit ;;
-    i*86:AROS:*:*)
-	echo "$UNAME_MACHINE"-pc-aros
+    *:AROS:*:*)
+	echo "$UNAME_MACHINE"-unknown-aros
 	exit ;;
     x86_64:VMkernel:*:*)
 	echo "$UNAME_MACHINE"-unknown-esx
 	exit ;;
     amd64:Isilon\ OneFS:*:*)
 	echo x86_64-unknown-onefs
 	exit ;;
+    *:Unleashed:*:*)
+	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
+	exit ;;
 esac
 
+# No uname command or uname output not recognized.
+set_cc_for_build
+cat > "$dummy.c" <<EOF
+#ifdef _SEQUENT_
+#include <sys/types.h>
+#include <sys/utsname.h>
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+  "4"
+#else
+  ""
+#endif
+  ); exit (0);
+#endif
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=$( (hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null);
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+  struct utsname un;
+
+  uname(&un);
+  if (strncmp(un.version, "V2", 2) == 0) {
+    printf ("i386-sequent-ptx2\n"); exit (0);
+  }
+  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+    printf ("i386-sequent-ptx1\n"); exit (0);
+  }
+  printf ("i386-sequent-ptx\n"); exit (0);
+#endif
+
+#if defined (vax)
+#if !defined (ultrix)
+#include <sys/param.h>
+#if defined (BSD)
+#if BSD == 43
+  printf ("vax-dec-bsd4.3\n"); exit (0);
+#else
+#if BSD == 199006
+  printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#endif
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("mips-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=$($dummy) &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
+
 echo "$0: unable to guess system type" >&2
 
 case "$UNAME_MACHINE:$UNAME_SYSTEM" in
     mips:Linux | mips64:Linux)
 	# If we got here on MIPS GNU/Linux, output extra information.
 	cat >&2 <<EOF
 
@@ -1435,46 +1648,53 @@
 
 cat >&2 <<EOF
 
 This script (version $timestamp), has failed to recognize the
 operating system you are using. If your script is old, overwrite *all*
 copies of config.guess and config.sub with the latest versions from:
 
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.guess
 and
-  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+  https://git.savannah.gnu.org/cgit/config.git/plain/config.sub
+EOF
+
+year=$(echo $timestamp | sed 's,-.*,,')
+# shellcheck disable=SC2003
+if test "$(expr "$(date +%Y)" - "$year")" -lt 3 ; then
+   cat >&2 <<EOF
 
 If $0 has already been updated, send the following data and any
 information you think might be pertinent to config-patches@gnu.org to
 provide the necessary information to handle your system.
 
 config.guess timestamp = $timestamp
 
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
-
-hostinfo               = `(hostinfo) 2>/dev/null`
-/bin/universe          = `(/bin/universe) 2>/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
-/bin/arch              = `(/bin/arch) 2>/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+uname -m = $( (uname -m) 2>/dev/null || echo unknown)
+uname -r = $( (uname -r) 2>/dev/null || echo unknown)
+uname -s = $( (uname -s) 2>/dev/null || echo unknown)
+uname -v = $( (uname -v) 2>/dev/null || echo unknown)
+
+/usr/bin/uname -p = $( (/usr/bin/uname -p) 2>/dev/null)
+/bin/uname -X     = $( (/bin/uname -X) 2>/dev/null)
+
+hostinfo               = $( (hostinfo) 2>/dev/null)
+/bin/universe          = $( (/bin/universe) 2>/dev/null)
+/usr/bin/arch -k       = $( (/usr/bin/arch -k) 2>/dev/null)
+/bin/arch              = $( (/bin/arch) 2>/dev/null)
+/usr/bin/oslevel       = $( (/usr/bin/oslevel) 2>/dev/null)
+/usr/convex/getsysinfo = $( (/usr/convex/getsysinfo) 2>/dev/null)
 
 UNAME_MACHINE = "$UNAME_MACHINE"
 UNAME_RELEASE = "$UNAME_RELEASE"
 UNAME_SYSTEM  = "$UNAME_SYSTEM"
 UNAME_VERSION = "$UNAME_VERSION"
 EOF
+fi
 
 exit 1
 
 # Local variables:
-# eval: (add-hook 'write-file-functions 'time-stamp)
+# eval: (add-hook 'before-save-hook 'time-stamp)
 # time-stamp-start: "timestamp='"
 # time-stamp-format: "%:y-%02m-%02d"
 # time-stamp-end: "'"
 # End:
```

### Comparing `fitsio-1.1.9/cfitsio3490/configure` & `fitsio-1.2.0/cfitsio-4.2.0/configure`

 * *Files 20% similar despite different names*

```diff
@@ -1,140 +1,120 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69.
+# Generated by GNU Autoconf 2.71.
 #
 #
-# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
+# Copyright (C) 1992-1996, 1998-2017, 2020-2021 Free Software Foundation,
+# Inc.
 #
 #
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## -------------------- ##
 ## M4sh Initialization. ##
 ## -------------------- ##
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+as_nop=:
+if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
-else
+else $as_nop
   case `(set -o) 2>/dev/null` in #(
   *posix*) :
     set -o posix ;; #(
   *) :
      ;;
 esac
 fi
 
 
+
+# Reset variables that may have inherited troublesome values from
+# the environment.
+
+# IFS needs to be set, to space, tab, and newline, in precisely that order.
+# (If _AS_PATH_WALK were called with IFS unset, it would have the
+# side effect of setting IFS to empty, thus disabling word splitting.)
+# Quoting is to prevent editors from complaining about space-tab.
 as_nl='
 '
 export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
+IFS=" ""	$as_nl"
+
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# Ensure predictable behavior from utilities with locale-dependent output.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# We cannot yet rely on "unset" to work, but we need these variables
+# to be unset--not just set to an empty or harmless value--now, to
+# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
+# also avoids known problems related to "unset" and subshell syntax
+# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
+for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
+do eval test \${$as_var+y} \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+
+# Ensure that fds 0, 1, and 2 are open.
+if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
+if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
+if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi
 
 # The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
+if ${PATH_SEPARATOR+false} :; then
   PATH_SEPARATOR=:
   (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
     (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
       PATH_SEPARATOR=';'
   }
 fi
 
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
 # Find who we are.  Look in the path if we contain no directory separator.
 as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
   done
 IFS=$as_save_IFS
 
      ;;
 esac
 # We did not find ourselves, most probably we were run as `sh COMMAND'
 # in which case we are not to be found in the path.
 if test "x$as_myself" = x; then
   as_myself=$0
 fi
 if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
   exit 1
 fi
 
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 # Use a proper internal environment variable to ensure we don't fall
   # into an infinite loop, continuously re-executing ourselves.
   if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
     _as_can_reexec=no; export _as_can_reexec;
     # We cannot yet assume a decent shell, so we have to provide a
 # neutralization value for shells without unset; and this also
@@ -148,28 +128,30 @@
   *v* ) as_opts=-v ;;
   *x* ) as_opts=-x ;;
   * ) as_opts= ;;
 esac
 exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
 # Admittedly, this is quite paranoid, since all the known shells bail
 # out after a failed `exec'.
-$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
-as_fn_exit 255
+printf "%s\n" "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
   fi
   # We don't want this to propagate to other subprocesses.
           { _as_can_reexec=; unset _as_can_reexec;}
 if test "x$CONFIG_SHELL" = x; then
-  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  as_bourne_compatible="as_nop=:
+if test \${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '\${1+\"\$@\"}'='\"\$@\"'
   setopt NO_GLOB_SUBST
-else
+else \$as_nop
   case \`(set -o) 2>/dev/null\` in #(
   *posix*) :
     set -o posix ;; #(
   *) :
      ;;
 esac
 fi
@@ -181,65 +163,82 @@
 as_fn_ret_failure () { return 1; }
 
 exitcode=0
 as_fn_success || { exitcode=1; echo as_fn_success failed.; }
 as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
 as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
 as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
-if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+if ( set x; as_fn_ret_success y && test x = \"\$1\" )
+then :
 
-else
+else \$as_nop
   exitcode=1; echo positional parameters were not saved.
 fi
 test x\$exitcode = x0 || exit 1
+blah=\$(echo \$(echo blah))
+test x\"\$blah\" = xblah || exit 1
 test -x / || exit 1"
   as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
   as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
   eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
-  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
-test \$(( 1 + 1 )) = 2 || exit 1"
-  if (eval "$as_required") 2>/dev/null; then :
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1"
+  if (eval "$as_required") 2>/dev/null
+then :
   as_have_required=yes
-else
+else $as_nop
   as_have_required=no
 fi
-  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null
+then :
 
-else
+else $as_nop
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 as_found=false
 for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
   as_found=:
   case $as_dir in #(
 	 /*)
 	   for as_base in sh bash ksh sh5; do
 	     # Try only shells that exist, to save several forks.
-	     as_shell=$as_dir/$as_base
+	     as_shell=$as_dir$as_base
 	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+		    as_run=a "$as_shell" -c "$as_bourne_compatible""$as_required" 2>/dev/null
+then :
   CONFIG_SHELL=$as_shell as_have_required=yes
-		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+		   if as_run=a "$as_shell" -c "$as_bourne_compatible""$as_suggested" 2>/dev/null
+then :
   break 2
 fi
 fi
 	   done;;
        esac
   as_found=false
 done
-$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
-	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
-  CONFIG_SHELL=$SHELL as_have_required=yes
-fi; }
 IFS=$as_save_IFS
+if $as_found
+then :
+
+else $as_nop
+  if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      as_run=a "$SHELL" -c "$as_bourne_compatible""$as_required" 2>/dev/null
+then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi
+fi
 
 
-      if test "x$CONFIG_SHELL" != x; then :
+      if test "x$CONFIG_SHELL" != x
+then :
   export CONFIG_SHELL
              # We cannot yet assume a decent shell, so we have to provide a
 # neutralization value for shells without unset; and this also
 # works around shells that cannot unset nonexistent variables.
 # Preserve -v and -x to the replacement shell.
 BASH_ENV=/dev/null
 ENV=/dev/null
@@ -249,26 +248,27 @@
   *v* ) as_opts=-v ;;
   *x* ) as_opts=-x ;;
   * ) as_opts= ;;
 esac
 exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
 # Admittedly, this is quite paranoid, since all the known shells bail
 # out after a failed `exec'.
-$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+printf "%s\n" "$0: could not re-execute with $CONFIG_SHELL" >&2
 exit 255
 fi
 
-    if test x$as_have_required = xno; then :
-  $as_echo "$0: This script requires a shell more modern than all"
-  $as_echo "$0: the shells that I found on your system."
-  if test x${ZSH_VERSION+set} = xset ; then
-    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
-    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+    if test x$as_have_required = xno
+then :
+  printf "%s\n" "$0: This script requires a shell more modern than all"
+  printf "%s\n" "$0: the shells that I found on your system."
+  if test ${ZSH_VERSION+y} ; then
+    printf "%s\n" "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    printf "%s\n" "$0: be upgraded to zsh 4.3.4 or later."
   else
-    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+    printf "%s\n" "$0: Please tell bug-autoconf@gnu.org about your system,
 $0: including any error possibly output before this
 $0: message. Then install a modern shell, or manually run
 $0: the script under such a shell if you do have one."
   fi
   exit 1
 fi
 fi
@@ -287,14 +287,15 @@
 # Portably unset VAR.
 as_fn_unset ()
 {
   { eval $1=; unset $1;}
 }
 as_unset=as_fn_unset
 
+
 # as_fn_set_status STATUS
 # -----------------------
 # Set $? to STATUS, without forking.
 as_fn_set_status ()
 {
   return $1
 } # as_fn_set_status
@@ -304,38 +305,46 @@
 # Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
 as_fn_exit ()
 {
   set +e
   as_fn_set_status $1
   exit $1
 } # as_fn_exit
+# as_fn_nop
+# ---------
+# Do nothing but, unlike ":", preserve the value of $?.
+as_fn_nop ()
+{
+  return $?
+}
+as_nop=as_fn_nop
 
 # as_fn_mkdir_p
 # -------------
 # Create "$as_dir" as a directory, including parents if necessary.
 as_fn_mkdir_p ()
 {
 
   case $as_dir in #(
   -*) as_dir=./$as_dir;;
   esac
   test -d "$as_dir" || eval $as_mkdir_p || {
     as_dirs=
     while :; do
       case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
       *) as_qdir=$as_dir;;
       esac
       as_dirs="'$as_qdir' $as_dirs"
       as_dir=`$as_dirname -- "$as_dir" ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
 	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
+printf "%s\n" X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\(\/\/\)[^/].*/{
 	    s//\1/
 	    q
@@ -366,57 +375,75 @@
 } # as_fn_executable_p
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
 # advantage of any shell optimizations that allow amortized linear growth over
 # repeated appends, instead of the typical quadratic growth present in naive
 # implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
+then :
   eval 'as_fn_append ()
   {
     eval $1+=\$2
   }'
-else
+else $as_nop
   as_fn_append ()
   {
     eval $1=\$$1\$2
   }
 fi # as_fn_append
 
 # as_fn_arith ARG...
 # ------------------
 # Perform arithmetic evaluation on the ARGs, and store the result in the
 # global $as_val. Take advantage of shells that can avoid forks. The arguments
 # must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
+then :
   eval 'as_fn_arith ()
   {
     as_val=$(( $* ))
   }'
-else
+else $as_nop
   as_fn_arith ()
   {
     as_val=`expr "$@" || test $? -eq 1`
   }
 fi # as_fn_arith
 
+# as_fn_nop
+# ---------
+# Do nothing but, unlike ":", preserve the value of $?.
+as_fn_nop ()
+{
+  return $?
+}
+as_nop=as_fn_nop
+# as_fn_nop
+# ---------
+# Do nothing but, unlike ":", preserve the value of $?.
+as_fn_nop ()
+{
+  return $?
+}
+as_nop=as_fn_nop
 
 # as_fn_error STATUS ERROR [LINENO LOG_FD]
 # ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
 # script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
   as_status=$1; test $as_status -eq 0 && as_status=1
   if test "$4"; then
     as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $2" >&2
+  printf "%s\n" "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
 if expr a : '\(a\)' >/dev/null 2>&1 &&
    test "X`expr 00001 : '.*\(...\)'`" = X001; then
   as_expr=expr
 else
@@ -435,15 +462,15 @@
   as_dirname=false
 fi
 
 as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
+printf "%s\n" X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\/\(\/\/\)$/{
 	    s//\1/
 	    q
@@ -479,41 +506,52 @@
       N
       :loop
       s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
       t loop
       s/-\n.*//
     ' >$as_me.lineno &&
   chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+    { printf "%s\n" "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
 
   # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
   # already done that, so ensure we don't try to do so again and fall
   # in an infinite loop.  This has already happened in practice.
   _as_can_reexec=no; export _as_can_reexec
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
   # original and so on.  Autoconf is especially sensitive to this).
   . "./$as_me.lineno"
   # Exit status is that of the last command.
   exit
 }
 
+
+# Determine whether it's possible to make 'echo' print without a newline.
+# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
+# for compatibility with existing Makefiles.
 ECHO_C= ECHO_N= ECHO_T=
 case `echo -n x` in #(((((
 -n*)
   case `echo 'xy\c'` in
   *c*) ECHO_T='	';;	# ECHO_T is single tab character.
   xy)  ECHO_C='\c';;
   *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
        ECHO_T='	';;
   esac;;
 *)
   ECHO_N='-n';;
 esac
 
+# For backward compatibility with old third-party macros, we provide
+# the shell variables $as_echo and $as_echo_n.  New code should use
+# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
+as_echo='printf %s\n'
+as_echo_n='printf %s'
+
+
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
   rm -f conf$$.dir/conf$$.file
 else
   rm -f conf$$.dir
   mkdir conf$$.dir 2>/dev/null
 fi
@@ -571,58 +609,54 @@
 LIBOBJS=
 cross_compiling=no
 subdirs=
 MFLAGS=
 MAKEFLAGS=
 
 # Identity of this package.
-PACKAGE_NAME=
-PACKAGE_TARNAME=
-PACKAGE_VERSION=
-PACKAGE_STRING=
-PACKAGE_BUGREPORT=
-PACKAGE_URL=
+PACKAGE_NAME=''
+PACKAGE_TARNAME=''
+PACKAGE_VERSION=''
+PACKAGE_STRING=''
+PACKAGE_BUGREPORT=''
+PACKAGE_URL=''
 
 ac_unique_file="fitscore.c"
 # Factoring default headers for most tests.
 ac_includes_default="\
-#include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
+#include <stddef.h>
+#ifdef HAVE_STDIO_H
+# include <stdio.h>
 #endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef STDC_HEADERS
+#ifdef HAVE_STDLIB_H
 # include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
 #endif
 #ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-#  include <memory.h>
-# endif
 # include <string.h>
 #endif
-#ifdef HAVE_STRINGS_H
-# include <strings.h>
-#endif
 #ifdef HAVE_INTTYPES_H
 # include <inttypes.h>
 #endif
 #ifdef HAVE_STDINT_H
 # include <stdint.h>
 #endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif"
 
+ac_header_c_list=
 ac_default_prefix=`pwd`
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
 my_shmem
 LDFLAGS_BIN
 F77_WRAPPERS
 CFITSIO_SHLIB_SONAME
@@ -637,25 +671,23 @@
 SSE_FLAGS
 RANLIB
 ARCHIVE
 AR
 FC
 INSTALL_ROOT
 GSIFTP_SRC
-EGREP
-GREP
-CPP
 OBJEXT
 EXEEXT
 ac_ct_CC
 CPPFLAGS
 LDFLAGS
 CFLAGS
 CC
 CFITSIO_SONAME
+CFITSIO_MICRO
 CFITSIO_MINOR
 CFITSIO_MAJOR
 target_os
 target_vendor
 target_cpu
 target
 host_os
@@ -681,14 +713,15 @@
 pdfdir
 dvidir
 htmldir
 infodir
 docdir
 oldincludedir
 includedir
+runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
 datadir
 datarootdir
 libexecdir
 sbindir
@@ -707,28 +740,29 @@
 ac_subst_files=''
 ac_user_opts='
 enable_option_checking
 enable_curl
 enable_reentrant
 enable_sse2
 enable_ssse3
+enable_symbols
 enable_hera
 with_bzip2
 with_gsiftp
 with_gsiftp_flavour
+with_zlib_check
 '
       ac_precious_vars='build_alias
 host_alias
 target_alias
 CC
 CFLAGS
 LDFLAGS
 LIBS
-CPPFLAGS
-CPP'
+CPPFLAGS'
 
 
 # Initialize some variables set by options.
 ac_init_help=
 ac_init_version=false
 ac_unrecognized_opts=
 ac_unrecognized_sep=
@@ -759,14 +793,15 @@
 sbindir='${exec_prefix}/sbin'
 libexecdir='${exec_prefix}/libexec'
 datarootdir='${prefix}/share'
 datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE}'
 infodir='${datarootdir}/info'
 htmldir='${docdir}'
 dvidir='${docdir}'
 pdfdir='${docdir}'
@@ -788,16 +823,14 @@
 
   case $ac_option in
   *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
   *=)   ac_optarg= ;;
   *)    ac_optarg=yes ;;
   esac
 
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
   case $ac_dashdash$ac_option in
   --)
     ac_dashdash=yes ;;
 
   -bindir | --bindir | --bindi | --bind | --bin | --bi)
     ac_prev=bindir ;;
   -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
@@ -830,17 +863,17 @@
   | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
     datarootdir=$ac_optarg ;;
 
   -disable-* | --disable-*)
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "enable_$ac_useropt"
 "*) ;;
       *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
 	 ac_unrecognized_sep=', ';;
     esac
@@ -856,17 +889,17 @@
   -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
     dvidir=$ac_optarg ;;
 
   -enable-* | --enable-*)
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error $? "invalid feature name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "enable_$ac_useropt"
 "*) ;;
       *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
 	 ac_unrecognized_sep=', ';;
     esac
@@ -1011,14 +1044,23 @@
   -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
     psdir=$ac_optarg ;;
 
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
   | --sbi=* | --sb=*)
     sbindir=$ac_optarg ;;
 
   -sharedstatedir | --sharedstatedir | --sharedstatedi \
@@ -1060,33 +1102,33 @@
   -version | --version | --versio | --versi | --vers | -V)
     ac_init_version=: ;;
 
   -with-* | --with-*)
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "with_$ac_useropt"
 "*) ;;
       *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
 	 ac_unrecognized_sep=', ';;
     esac
     eval with_$ac_useropt=\$ac_optarg ;;
 
   -without-* | --without-*)
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error $? "invalid package name: \`$ac_useropt'"
     ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
       *"
 "with_$ac_useropt"
 "*) ;;
       *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
 	 ac_unrecognized_sep=', ';;
     esac
@@ -1122,17 +1164,17 @@
       as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
     esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
 
   *)
     # FIXME: should be removed in autoconf 3.0.
-    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+      printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
     : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
     ;;
 
   esac
 done
 
 if test -n "$ac_prev"; then
@@ -1140,23 +1182,23 @@
   as_fn_error $? "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
     fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
-    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+    *)     printf "%s\n" "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
 
 # Check all directory arguments for consistency.
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+		libdir localedir mandir runstatedir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
   case $ac_val in
     */ )
       ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
       eval $ac_var=\$ac_val;;
@@ -1204,15 +1246,15 @@
   ac_srcdir_defaulted=yes
   # Try the directory containing this script, then the parent directory.
   ac_confdir=`$as_dirname -- "$as_myself" ||
 $as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_myself" : 'X\(//\)[^/]' \| \
 	 X"$as_myself" : 'X\(//\)$' \| \
 	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_myself" |
+printf "%s\n" X"$as_myself" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\(\/\/\)[^/].*/{
 	    s//\1/
 	    q
@@ -1301,14 +1343,15 @@
 Fine tuning of the installation directories:
   --bindir=DIR            user executables [EPREFIX/bin]
   --sbindir=DIR           system admin executables [EPREFIX/sbin]
   --libexecdir=DIR        program executables [EPREFIX/libexec]
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
   --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
   --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
   --infodir=DIR           info documentation [DATAROOTDIR/info]
   --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
@@ -1340,34 +1383,36 @@
   --disable-curl          Disable linking with the curl library. Disables
                           remote file i/o support
   --enable-reentrant      Enable reentrant multithreading
   --enable-sse2           Enable use of instructions in the SSE2 extended
                           instruction set
   --enable-ssse3          Enable use of instructions in the SSSE3 extended
                           instruction set
+  --enable-symbols        Enable debugging symbols by turning optimization off
   --enable-hera           Build for HERA (ASD use only)
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-bzip2[=PATH]     Enable bzip2 support. Optional path to the location
                           of include/bzlib.h and lib/libbz2
   --with-gsiftp[=PATH]    Enable Globus Toolkit gsiftp protocol support
   --with-gsiftp-flavour[=PATH]
                           Define Globus Toolkit gsiftp protocol flavour
+  --without-zlib-check    Disable check for zlib compression library e.g. for
+                          cross-compilers
 
 Some influential environment variables:
   CC          C compiler command
   CFLAGS      C compiler flags
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
   LIBS        libraries to pass to the linker, e.g. -l<library>
   CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
               you have headers in a nonstandard directory <include dir>
-  CPP         C preprocessor
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
 
 Report bugs to the package provider.
 _ACEOF
 ac_status=$?
@@ -1380,17 +1425,17 @@
       { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
       continue
     ac_builddir=.
 
 case "$ac_dir" in
 .) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
 *)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  ac_dir_suffix=/`printf "%s\n" "$ac_dir" | sed 's|^\.[\\/]||'`
   # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  ac_top_builddir_sub=`printf "%s\n" "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
   case $ac_top_builddir_sub in
   "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
   *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
   esac ;;
 esac
 ac_abs_top_builddir=$ac_pwd
 ac_abs_builddir=$ac_pwd$ac_dir_suffix
@@ -1410,35 +1455,36 @@
     ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_build_prefix$srcdir
     ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
 esac
 ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
 
     cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
+    # Check for configure.gnu first; this name is used for a wrapper for
+    # Metaconfig's "Configure" on case-insensitive file systems.
     if test -f "$ac_srcdir/configure.gnu"; then
       echo &&
       $SHELL "$ac_srcdir/configure.gnu" --help=recursive
     elif test -f "$ac_srcdir/configure"; then
       echo &&
       $SHELL "$ac_srcdir/configure" --help=recursive
     else
-      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+      printf "%s\n" "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi || ac_status=$?
     cd "$ac_pwd" || { ac_status=$?; break; }
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
 configure
-generated by GNU Autoconf 2.69
+generated by GNU Autoconf 2.71
 
-Copyright (C) 2012 Free Software Foundation, Inc.
+Copyright (C) 2021 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
   exit
 fi
 
 ## ------------------------ ##
@@ -1447,37 +1493,38 @@
 
 # ac_fn_c_try_compile LINENO
 # --------------------------
 # Try to compile conftest.$ac_ext, and return whether this succeeded.
 ac_fn_c_try_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
+  rm -f conftest.$ac_objext conftest.beam
   if { { ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compile") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
     grep -v '^ *+' conftest.err >conftest.er1
     cat conftest.er1 >&5
     mv -f conftest.er1 conftest.err
   fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
+       } && test -s conftest.$ac_objext
+then :
   ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
 fi
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
@@ -1485,279 +1532,110 @@
 
 # ac_fn_c_try_link LINENO
 # -----------------------
 # Try to link conftest.$ac_ext, and return whether this succeeded.
 ac_fn_c_try_link ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
+  rm -f conftest.$ac_objext conftest.beam conftest$ac_exeext
   if { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
     grep -v '^ *+' conftest.err >conftest.er1
     cat conftest.er1 >&5
     mv -f conftest.er1 conftest.err
   fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext && {
 	 test "$cross_compiling" = yes ||
 	 test -x conftest$ac_exeext
-       }; then :
+       }
+then :
   ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 	ac_retval=1
 fi
   # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
   # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
   # interfere with the next link command; also delete a directory that is
   # left behind by Apple's compiler.  We do this before executing the actions.
   rm -rf conftest.dSYM conftest_ipa8_conftest.oo
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
   as_fn_set_status $ac_retval
 
 } # ac_fn_c_try_link
 
-# ac_fn_c_try_cpp LINENO
-# ----------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } > conftest.i && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_cpp
-
-# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists, giving a warning if it cannot be compiled using
-# the include files in INCLUDES and setting the cache variable VAR
-# accordingly.
-ac_fn_c_check_header_mongrel ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if eval \${$3+:} false; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
-$as_echo_n "checking $2 usability... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_header_compiler=yes
-else
-  ac_header_compiler=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
-$as_echo_n "checking $2 presence... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <$2>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  ac_header_preproc=yes
-else
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
-  yes:no: )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=\$ac_header_compiler"
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_header_mongrel
-
-# ac_fn_c_try_run LINENO
-# ----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_c_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_run
-
 # ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
 # -------------------------------------------------------
 # Tests whether HEADER exists and can be compiled using the include files in
 # INCLUDES, setting the cache variable VAR accordingly.
 ac_fn_c_check_header_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 $4
 #include <$2>
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   eval "$3=yes"
-else
+else $as_nop
   eval "$3=no"
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_header_compile
 
 # ac_fn_c_check_func LINENO FUNC VAR
 # ----------------------------------
 # Tests whether FUNC exists, setting the cache variable VAR accordingly
 ac_fn_c_check_func ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 /* Define $2 to an innocuous variant, in case <limits.h> declares $2.
    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
 #define $2 innocuous_$2
 
 /* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+   which can conflict with char $2 (); below.  */
 
+#include <limits.h>
 #undef $2
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
 #ifdef __cplusplus
 extern "C"
@@ -1767,43 +1645,64 @@
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined __stub_$2 || defined __stub___$2
 choke me
 #endif
 
 int
-main ()
+main (void)
 {
 return $2 ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   eval "$3=yes"
-else
+else $as_nop
   eval "$3=no"
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 fi
 eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
   eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
 
 } # ac_fn_c_check_func
+ac_configure_args_raw=
+for ac_arg
+do
+  case $ac_arg in
+  *\'*)
+    ac_arg=`printf "%s\n" "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+  esac
+  as_fn_append ac_configure_args_raw " '$ac_arg'"
+done
+
+case $ac_configure_args_raw in
+  *$as_nl*)
+    ac_safe_unquote= ;;
+  *)
+    ac_unsafe_z='|&;<>()$`\\"*?[ ''	' # This string ends in space, tab.
+    ac_unsafe_a="$ac_unsafe_z#~"
+    ac_safe_unquote="s/ '\\([^$ac_unsafe_a][^$ac_unsafe_z]*\\)'/ \\1/g"
+    ac_configure_args_raw=`      printf "%s\n" "$ac_configure_args_raw" | sed "$ac_safe_unquote"`;;
+esac
+
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.69.  Invocation command line was
+generated by GNU Autoconf 2.71.  Invocation command line was
 
-  $ $0 $@
+  $ $0$ac_configure_args_raw
 
 _ACEOF
 exec 5>>config.log
 {
 cat <<_ASUNAME
 ## --------- ##
 ## Platform. ##
@@ -1828,16 +1727,20 @@
 
 _ASUNAME
 
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    $as_echo "PATH: $as_dir"
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    printf "%s\n" "PATH: $as_dir"
   done
 IFS=$as_save_IFS
 
 } >&5
 
 cat >&5 <<_ACEOF
 
@@ -1864,15 +1767,15 @@
   do
     case $ac_arg in
     -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
     -q | -quiet | --quiet | --quie | --qui | --qu | --q \
     | -silent | --silent | --silen | --sile | --sil)
       continue ;;
     *\'*)
-      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+      ac_arg=`printf "%s\n" "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
     case $ac_pass in
     1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
     2)
       as_fn_append ac_configure_args1 " '$ac_arg'"
       if test $ac_must_keep_next = true; then
 	ac_must_keep_next=false # Got value, back to normal.
@@ -1899,31 +1802,33 @@
 
 # When interrupted or exit'd, cleanup temporary files, and complete
 # config.log.  We remove comments because anyway the quotes in there
 # would cause problems or look ugly.
 # WARNING: Use '\'' to represent an apostrophe within the trap.
 # WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
 trap 'exit_status=$?
+  # Sanitize IFS.
+  IFS=" ""	$as_nl"
   # Save into config.log some information that might help in debugging.
   {
     echo
 
-    $as_echo "## ---------------- ##
+    printf "%s\n" "## ---------------- ##
 ## Cache variables. ##
 ## ---------------- ##"
     echo
     # The following way of writing the cache mishandles newlines in values,
 (
   for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
     eval ac_val=\$$ac_var
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      *_cv_*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+printf "%s\n" "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
       *) { eval $ac_var=; unset $ac_var;} ;;
       esac ;;
     esac
@@ -1939,265 +1844,641 @@
       sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
       ;;
     esac |
     sort
 )
     echo
 
-    $as_echo "## ----------------- ##
+    printf "%s\n" "## ----------------- ##
 ## Output variables. ##
 ## ----------------- ##"
     echo
     for ac_var in $ac_subst_vars
     do
       eval ac_val=\$$ac_var
       case $ac_val in
-      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      *\'\''*) ac_val=`printf "%s\n" "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
       esac
-      $as_echo "$ac_var='\''$ac_val'\''"
+      printf "%s\n" "$ac_var='\''$ac_val'\''"
     done | sort
     echo
 
     if test -n "$ac_subst_files"; then
-      $as_echo "## ------------------- ##
+      printf "%s\n" "## ------------------- ##
 ## File substitutions. ##
 ## ------------------- ##"
       echo
       for ac_var in $ac_subst_files
       do
 	eval ac_val=\$$ac_var
 	case $ac_val in
-	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	*\'\''*) ac_val=`printf "%s\n" "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
 	esac
-	$as_echo "$ac_var='\''$ac_val'\''"
+	printf "%s\n" "$ac_var='\''$ac_val'\''"
       done | sort
       echo
     fi
 
     if test -s confdefs.h; then
-      $as_echo "## ----------- ##
+      printf "%s\n" "## ----------- ##
 ## confdefs.h. ##
 ## ----------- ##"
       echo
       cat confdefs.h
       echo
     fi
     test "$ac_signal" != 0 &&
-      $as_echo "$as_me: caught signal $ac_signal"
-    $as_echo "$as_me: exit $exit_status"
+      printf "%s\n" "$as_me: caught signal $ac_signal"
+    printf "%s\n" "$as_me: exit $exit_status"
   } >&5
   rm -f core *.core core.conftest.* &&
     rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
     exit $exit_status
 ' 0
 for ac_signal in 1 2 13 15; do
   trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
 done
 ac_signal=0
 
 # confdefs.h avoids OS command line length limits that DEFS can exceed.
 rm -f -r conftest* confdefs.h
 
-$as_echo "/* confdefs.h */" > confdefs.h
+printf "%s\n" "/* confdefs.h */" > confdefs.h
 
 # Predefined preprocessor variables.
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
+printf "%s\n" "#define PACKAGE_NAME \"$PACKAGE_NAME\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
+printf "%s\n" "#define PACKAGE_TARNAME \"$PACKAGE_TARNAME\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
+printf "%s\n" "#define PACKAGE_VERSION \"$PACKAGE_VERSION\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
+printf "%s\n" "#define PACKAGE_STRING \"$PACKAGE_STRING\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
+printf "%s\n" "#define PACKAGE_BUGREPORT \"$PACKAGE_BUGREPORT\"" >>confdefs.h
 
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_URL "$PACKAGE_URL"
-_ACEOF
+printf "%s\n" "#define PACKAGE_URL \"$PACKAGE_URL\"" >>confdefs.h
 
 
 # Let the site file select an alternate cache file if it wants to.
 # Prefer an explicitly selected file to automatically selected ones.
-ac_site_file1=NONE
-ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  # We do not want a PATH search for config.site.
-  case $CONFIG_SITE in #((
-    -*)  ac_site_file1=./$CONFIG_SITE;;
-    */*) ac_site_file1=$CONFIG_SITE;;
-    *)   ac_site_file1=./$CONFIG_SITE;;
-  esac
+  ac_site_files="$CONFIG_SITE"
 elif test "x$prefix" != xNONE; then
-  ac_site_file1=$prefix/share/config.site
-  ac_site_file2=$prefix/etc/config.site
+  ac_site_files="$prefix/share/config.site $prefix/etc/config.site"
 else
-  ac_site_file1=$ac_default_prefix/share/config.site
-  ac_site_file2=$ac_default_prefix/etc/config.site
+  ac_site_files="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
 fi
-for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+
+for ac_site_file in $ac_site_files
 do
-  test "x$ac_site_file" = xNONE && continue
-  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
-$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+  case $ac_site_file in #(
+  */*) :
+     ;; #(
+  *) :
+    ac_site_file=./$ac_site_file ;;
+esac
+  if test -f "$ac_site_file" && test -r "$ac_site_file"; then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+printf "%s\n" "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
     . "$ac_site_file" \
-      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+      || { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "failed to load site script $ac_site_file
 See \`config.log' for more details" "$LINENO" 5; }
   fi
 done
 
 if test -r "$cache_file"; then
   # Some versions of bash will fail to source /dev/null (special files
   # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
   if test /dev/null != "$cache_file" && test -f "$cache_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
-$as_echo "$as_me: loading cache $cache_file" >&6;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+printf "%s\n" "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
       [\\/]* | ?:[\\/]* ) . "$cache_file";;
       *)                      . "./$cache_file";;
     esac
   fi
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
-$as_echo "$as_me: creating cache $cache_file" >&6;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+printf "%s\n" "$as_me: creating cache $cache_file" >&6;}
   >$cache_file
 fi
 
+# Test code for whether the C compiler supports C89 (global declarations)
+ac_c_conftest_c89_globals='
+/* Does the compiler advertise C89 conformance?
+   Do not test the value of __STDC__, because some compilers set it to 0
+   while being otherwise adequately conformant. */
+#if !defined __STDC__
+# error "Compiler does not advertise C89 conformance"
+#endif
+
+#include <stddef.h>
+#include <stdarg.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7 src/conf.sh.  */
+struct buf { int x; };
+struct buf * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not \xHH hex character constants.
+   These do not provoke an error unfortunately, instead are silently treated
+   as an "x".  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously \x00 != x always comes out true, for an
+   array size at least.  It is necessary to write \x00 == 0 to get something
+   that is true only with -std.  */
+int osf4_cc_array ['\''\x00'\'' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) '\''x'\''
+int xlc6_cc_array[FOO(a) == '\''x'\'' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, int *(*)(struct buf *, struct stat *, int),
+               int, int);'
+
+# Test code for whether the C compiler supports C89 (body of main).
+ac_c_conftest_c89_main='
+ok |= (argc == 0 || f (e, argv, 0) != argv[0] || f (e, argv, 1) != argv[1]);
+'
+
+# Test code for whether the C compiler supports C99 (global declarations)
+ac_c_conftest_c99_globals='
+// Does the compiler advertise C99 conformance?
+#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L
+# error "Compiler does not advertise C99 conformance"
+#endif
+
+#include <stdbool.h>
+extern int puts (const char *);
+extern int printf (const char *, ...);
+extern int dprintf (int, const char *, ...);
+extern void *malloc (size_t);
+
+// Check varargs macros.  These examples are taken from C99 6.10.3.5.
+// dprintf is used instead of fprintf to avoid needing to declare
+// FILE and stderr.
+#define debug(...) dprintf (2, __VA_ARGS__)
+#define showlist(...) puts (#__VA_ARGS__)
+#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))
+static void
+test_varargs_macros (void)
+{
+  int x = 1234;
+  int y = 5678;
+  debug ("Flag");
+  debug ("X = %d\n", x);
+  showlist (The first, second, and third items.);
+  report (x>y, "x is %d but y is %d", x, y);
+}
+
+// Check long long types.
+#define BIG64 18446744073709551615ull
+#define BIG32 4294967295ul
+#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)
+#if !BIG_OK
+  #error "your preprocessor is broken"
+#endif
+#if BIG_OK
+#else
+  #error "your preprocessor is broken"
+#endif
+static long long int bignum = -9223372036854775807LL;
+static unsigned long long int ubignum = BIG64;
+
+struct incomplete_array
+{
+  int datasize;
+  double data[];
+};
+
+struct named_init {
+  int number;
+  const wchar_t *name;
+  double average;
+};
+
+typedef const char *ccp;
+
+static inline int
+test_restrict (ccp restrict text)
+{
+  // See if C++-style comments work.
+  // Iterate through items via the restricted pointer.
+  // Also check for declarations in for loops.
+  for (unsigned int i = 0; *(text+i) != '\''\0'\''; ++i)
+    continue;
+  return 0;
+}
+
+// Check varargs and va_copy.
+static bool
+test_varargs (const char *format, ...)
+{
+  va_list args;
+  va_start (args, format);
+  va_list args_copy;
+  va_copy (args_copy, args);
+
+  const char *str = "";
+  int number = 0;
+  float fnumber = 0;
+
+  while (*format)
+    {
+      switch (*format++)
+	{
+	case '\''s'\'': // string
+	  str = va_arg (args_copy, const char *);
+	  break;
+	case '\''d'\'': // int
+	  number = va_arg (args_copy, int);
+	  break;
+	case '\''f'\'': // float
+	  fnumber = va_arg (args_copy, double);
+	  break;
+	default:
+	  break;
+	}
+    }
+  va_end (args_copy);
+  va_end (args);
+
+  return *str && number && fnumber;
+}
+'
+
+# Test code for whether the C compiler supports C99 (body of main).
+ac_c_conftest_c99_main='
+  // Check bool.
+  _Bool success = false;
+  success |= (argc != 0);
+
+  // Check restrict.
+  if (test_restrict ("String literal") == 0)
+    success = true;
+  char *restrict newvar = "Another string";
+
+  // Check varargs.
+  success &= test_varargs ("s, d'\'' f .", "string", 65, 34.234);
+  test_varargs_macros ();
+
+  // Check flexible array members.
+  struct incomplete_array *ia =
+    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));
+  ia->datasize = 10;
+  for (int i = 0; i < ia->datasize; ++i)
+    ia->data[i] = i * 1.234;
+
+  // Check named initializers.
+  struct named_init ni = {
+    .number = 34,
+    .name = L"Test wide string",
+    .average = 543.34343,
+  };
+
+  ni.number = 58;
+
+  int dynamic_array[ni.number];
+  dynamic_array[0] = argv[0][0];
+  dynamic_array[ni.number - 1] = 543;
+
+  // work around unused variable warnings
+  ok |= (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == '\''x'\''
+	 || dynamic_array[ni.number - 1] != 543);
+'
+
+# Test code for whether the C compiler supports C11 (global declarations)
+ac_c_conftest_c11_globals='
+// Does the compiler advertise C11 conformance?
+#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L
+# error "Compiler does not advertise C11 conformance"
+#endif
+
+// Check _Alignas.
+char _Alignas (double) aligned_as_double;
+char _Alignas (0) no_special_alignment;
+extern char aligned_as_int;
+char _Alignas (0) _Alignas (int) aligned_as_int;
+
+// Check _Alignof.
+enum
+{
+  int_alignment = _Alignof (int),
+  int_array_alignment = _Alignof (int[100]),
+  char_alignment = _Alignof (char)
+};
+_Static_assert (0 < -_Alignof (int), "_Alignof is signed");
+
+// Check _Noreturn.
+int _Noreturn does_not_return (void) { for (;;) continue; }
+
+// Check _Static_assert.
+struct test_static_assert
+{
+  int x;
+  _Static_assert (sizeof (int) <= sizeof (long int),
+                  "_Static_assert does not work in struct");
+  long int y;
+};
+
+// Check UTF-8 literals.
+#define u8 syntax error!
+char const utf8_literal[] = u8"happens to be ASCII" "another string";
+
+// Check duplicate typedefs.
+typedef long *long_ptr;
+typedef long int *long_ptr;
+typedef long_ptr long_ptr;
+
+// Anonymous structures and unions -- taken from C11 6.7.2.1 Example 1.
+struct anonymous
+{
+  union {
+    struct { int i; int j; };
+    struct { int k; long int l; } w;
+  };
+  int m;
+} v1;
+'
+
+# Test code for whether the C compiler supports C11 (body of main).
+ac_c_conftest_c11_main='
+  _Static_assert ((offsetof (struct anonymous, i)
+		   == offsetof (struct anonymous, w.k)),
+		  "Anonymous union alignment botch");
+  v1.i = 2;
+  v1.w.k = 5;
+  ok |= v1.i != 5;
+'
+
+# Test code for whether the C compiler supports C11 (complete).
+ac_c_conftest_c11_program="${ac_c_conftest_c89_globals}
+${ac_c_conftest_c99_globals}
+${ac_c_conftest_c11_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  ${ac_c_conftest_c99_main}
+  ${ac_c_conftest_c11_main}
+  return ok;
+}
+"
+
+# Test code for whether the C compiler supports C99 (complete).
+ac_c_conftest_c99_program="${ac_c_conftest_c89_globals}
+${ac_c_conftest_c99_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  ${ac_c_conftest_c99_main}
+  return ok;
+}
+"
+
+# Test code for whether the C compiler supports C89 (complete).
+ac_c_conftest_c89_program="${ac_c_conftest_c89_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  return ok;
+}
+"
+
+as_fn_append ac_header_c_list " stdio.h stdio_h HAVE_STDIO_H"
+as_fn_append ac_header_c_list " stdlib.h stdlib_h HAVE_STDLIB_H"
+as_fn_append ac_header_c_list " string.h string_h HAVE_STRING_H"
+as_fn_append ac_header_c_list " inttypes.h inttypes_h HAVE_INTTYPES_H"
+as_fn_append ac_header_c_list " stdint.h stdint_h HAVE_STDINT_H"
+as_fn_append ac_header_c_list " strings.h strings_h HAVE_STRINGS_H"
+as_fn_append ac_header_c_list " sys/stat.h sys_stat_h HAVE_SYS_STAT_H"
+as_fn_append ac_header_c_list " sys/types.h sys_types_h HAVE_SYS_TYPES_H"
+as_fn_append ac_header_c_list " unistd.h unistd_h HAVE_UNISTD_H"
+
+# Auxiliary files required by this configure script.
+ac_aux_files="config.guess config.sub"
+
+# Locations in which to look for auxiliary files.
+ac_aux_dir_candidates="${srcdir}${PATH_SEPARATOR}${srcdir}/..${PATH_SEPARATOR}${srcdir}/../.."
+
+# Search for a directory containing all of the required auxiliary files,
+# $ac_aux_files, from the $PATH-style list $ac_aux_dir_candidates.
+# If we don't find one directory that contains all the files we need,
+# we report the set of missing files from the *first* directory in
+# $ac_aux_dir_candidates and give up.
+ac_missing_aux_files=""
+ac_first_candidate=:
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: looking for aux files: $ac_aux_files" >&5
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in $ac_aux_dir_candidates
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+  as_found=:
+
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}:  trying $as_dir" >&5
+  ac_aux_dir_found=yes
+  ac_install_sh=
+  for ac_aux in $ac_aux_files
+  do
+    # As a special case, if "install-sh" is required, that requirement
+    # can be satisfied by any of "install-sh", "install.sh", or "shtool",
+    # and $ac_install_sh is set appropriately for whichever one is found.
+    if test x"$ac_aux" = x"install-sh"
+    then
+      if test -f "${as_dir}install-sh"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}install-sh found" >&5
+        ac_install_sh="${as_dir}install-sh -c"
+      elif test -f "${as_dir}install.sh"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}install.sh found" >&5
+        ac_install_sh="${as_dir}install.sh -c"
+      elif test -f "${as_dir}shtool"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}shtool found" >&5
+        ac_install_sh="${as_dir}shtool install -c"
+      else
+        ac_aux_dir_found=no
+        if $ac_first_candidate; then
+          ac_missing_aux_files="${ac_missing_aux_files} install-sh"
+        else
+          break
+        fi
+      fi
+    else
+      if test -f "${as_dir}${ac_aux}"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}${ac_aux} found" >&5
+      else
+        ac_aux_dir_found=no
+        if $ac_first_candidate; then
+          ac_missing_aux_files="${ac_missing_aux_files} ${ac_aux}"
+        else
+          break
+        fi
+      fi
+    fi
+  done
+  if test "$ac_aux_dir_found" = yes; then
+    ac_aux_dir="$as_dir"
+    break
+  fi
+  ac_first_candidate=false
+
+  as_found=false
+done
+IFS=$as_save_IFS
+if $as_found
+then :
+
+else $as_nop
+  as_fn_error $? "cannot find required auxiliary files:$ac_missing_aux_files" "$LINENO" 5
+fi
+
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+if test -f "${ac_aux_dir}config.guess"; then
+  ac_config_guess="$SHELL ${ac_aux_dir}config.guess"
+fi
+if test -f "${ac_aux_dir}config.sub"; then
+  ac_config_sub="$SHELL ${ac_aux_dir}config.sub"
+fi
+if test -f "$ac_aux_dir/configure"; then
+  ac_configure="$SHELL ${ac_aux_dir}configure"
+fi
+
 # Check that the precious variables saved in the cache have kept the same
 # value.
 ac_cache_corrupted=false
 for ac_var in $ac_precious_vars; do
   eval ac_old_set=\$ac_cv_env_${ac_var}_set
   eval ac_new_set=\$ac_env_${ac_var}_set
   eval ac_old_val=\$ac_cv_env_${ac_var}_value
   eval ac_new_val=\$ac_env_${ac_var}_value
   case $ac_old_set,$ac_new_set in
     set,)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+printf "%s\n" "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,set)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+printf "%s\n" "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,);;
     *)
       if test "x$ac_old_val" != "x$ac_new_val"; then
 	# differences in whitespace do not lead to failure.
 	ac_old_val_w=`echo x $ac_old_val`
 	ac_new_val_w=`echo x $ac_new_val`
 	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
-$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+printf "%s\n" "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
 	  ac_cache_corrupted=:
 	else
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
-$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+printf "%s\n" "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
 	  eval $ac_var=\$ac_old_val
 	fi
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
-$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
-$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+printf "%s\n" "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+printf "%s\n" "$as_me:   current value: \`$ac_new_val'" >&2;}
       fi;;
   esac
   # Pass precious variables to config.status.
   if test "$ac_new_set" = set; then
     case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *\'*) ac_arg=$ac_var=`printf "%s\n" "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
     *) ac_arg=$ac_var=$ac_new_val ;;
     esac
     case " $ac_configure_args " in
       *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
       *) as_fn_append ac_configure_args " '$ac_arg'" ;;
     esac
   fi
 done
 if $ac_cache_corrupted; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
-$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+printf "%s\n" "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`${MAKE-make} distclean' and/or \`rm $cache_file'
+	    and start over" "$LINENO" 5
 fi
 ## -------------------- ##
 ## Main body of script. ##
 ## -------------------- ##
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error $? "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
-fi
 
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
 
 
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
-$as_echo_n "checking build system type... " >&6; }
-if ${ac_cv_build+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  # Make sure we can run config.sub.
+$SHELL "${ac_aux_dir}config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL ${ac_aux_dir}config.sub" "$LINENO" 5
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+printf %s "checking build system type... " >&6; }
+if test ${ac_cv_build+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_build_alias=$build_alias
 test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+  ac_build_alias=`$SHELL "${ac_aux_dir}config.guess"`
 test "x$ac_build_alias" = x &&
   as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+ac_cv_build=`$SHELL "${ac_aux_dir}config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL ${ac_aux_dir}config.sub $ac_build_alias failed" "$LINENO" 5
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
-$as_echo "$ac_cv_build" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+printf "%s\n" "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
 *) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
 set x $ac_cv_build
@@ -2208,29 +2489,30 @@
 # Remember, the first character of IFS is used to create $*,
 # except with old shells:
 build_os=$*
 IFS=$ac_save_IFS
 case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
-$as_echo_n "checking host system type... " >&6; }
-if ${ac_cv_host+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+printf %s "checking host system type... " >&6; }
+if test ${ac_cv_host+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test "x$host_alias" = x; then
   ac_cv_host=$ac_cv_build
 else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+  ac_cv_host=`$SHELL "${ac_aux_dir}config.sub" $host_alias` ||
+    as_fn_error $? "$SHELL ${ac_aux_dir}config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
-$as_echo "$ac_cv_host" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+printf "%s\n" "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
 *) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
 set x $ac_cv_host
@@ -2241,29 +2523,30 @@
 # Remember, the first character of IFS is used to create $*,
 # except with old shells:
 host_os=$*
 IFS=$ac_save_IFS
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
-$as_echo_n "checking target system type... " >&6; }
-if ${ac_cv_target+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking target system type" >&5
+printf %s "checking target system type... " >&6; }
+if test ${ac_cv_target+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test "x$target_alias" = x; then
   ac_cv_target=$ac_cv_host
 else
-  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $target_alias failed" "$LINENO" 5
+  ac_cv_target=`$SHELL "${ac_aux_dir}config.sub" $target_alias` ||
+    as_fn_error $? "$SHELL ${ac_aux_dir}config.sub $target_alias failed" "$LINENO" 5
 fi
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
-$as_echo "$ac_cv_target" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_target" >&5
+printf "%s\n" "$ac_cv_target" >&6; }
 case $ac_cv_target in
 *-*-*) ;;
 *) as_fn_error $? "invalid value of canonical target" "$LINENO" 5;;
 esac
 target=$ac_cv_target
 ac_save_IFS=$IFS; IFS='-'
 set x $ac_cv_target
@@ -2284,237 +2567,282 @@
   test "$program_prefix$program_suffix$program_transform_name" = \
     NONENONEs,x,x, &&
   program_prefix=${target_alias}-
 
 #--------------------------------------------------------------------
 # CFITSIO Version Numbers:
 #--------------------------------------------------------------------
-CFITSIO_MAJOR=3
+CFITSIO_MAJOR=4
+
+CFITSIO_MINOR=2
 
-CFITSIO_MINOR=49
+CFITSIO_MICRO=0
 
 # Increment soname each time the interface changes:
-CFITSIO_SONAME=9
+CFITSIO_SONAME=10
 
 
 #--------------------------------------------------------------------
 # Command options
 #--------------------------------------------------------------------
 
 ADD_CURL=yes
 # Check whether --enable-curl was given.
-if test "${enable_curl+set}" = set; then :
+if test ${enable_curl+y}
+then :
   enableval=$enable_curl;  if test $enableval = no; then ADD_CURL=no; fi
 
 fi
 
 if test "x$ADD_CURL" = xno; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Not linking with curl for remote file i/o support" >&5
-$as_echo "$as_me: WARNING: Not linking with curl for remote file i/o support" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: Not linking with curl for remote file i/o support" >&5
+printf "%s\n" "$as_me: WARNING: Not linking with curl for remote file i/o support" >&2;}
 fi
 
 # Check whether --enable-reentrant was given.
-if test "${enable_reentrant+set}" = set; then :
+if test ${enable_reentrant+y}
+then :
   enableval=$enable_reentrant;  if test $enableval = yes; then BUILD_REENTRANT=yes; fi
 
 fi
 
 
 SSE_FLAGS=""
 # Check whether --enable-sse2 was given.
-if test "${enable_sse2+set}" = set; then :
+if test ${enable_sse2+y}
+then :
   enableval=$enable_sse2;  if test $enableval = yes; then SSE_FLAGS="-msse2"; fi
 
 fi
 
 
 # Check whether --enable-ssse3 was given.
-if test "${enable_ssse3+set}" = set; then :
+if test ${enable_ssse3+y}
+then :
   enableval=$enable_ssse3;  if test $enableval = yes; then SSE_FLAGS="$SSE_FLAGS -mssse3"; fi
 
 fi
 
 
+SYMBOLS=""
+# Check whether --enable-symbols was given.
+if test ${enable_symbols+y}
+then :
+  enableval=$enable_symbols;  if test $enableval = yes; then SYMBOLS=yes; fi
+
+fi
+
+
 # Define BUILD_HERA when building for HERA project to activate code in
 # drvrfile.c (by way of fitsio2.h):
 # Check whether --enable-hera was given.
-if test "${enable_hera+set}" = set; then :
+if test ${enable_hera+y}
+then :
   enableval=$enable_hera;  if test $enableval = yes; then BUILD_HERA=yes; fi
 
 fi
 
 if test "x$BUILD_HERA" = xyes; then
-  $as_echo "#define BUILD_HERA 1" >>confdefs.h
+  printf "%s\n" "#define BUILD_HERA 1" >>confdefs.h
 
 fi
 
 # Optional support for bzip2 compression:
+
+
+
+
+
+
+
+
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 fi
 if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_CC" = x; then
     CC=""
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
   fi
 else
   CC="$ac_cv_prog_CC"
 fi
 
 if test -z "$CC"; then
           if test -n "$ac_tool_prefix"; then
     # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
   fi
 fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
   ac_prog_rejected=no
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    if test "$as_dir$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
      fi
     ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 if test $ac_prog_rejected = yes; then
@@ -2522,183 +2850,297 @@
   set dummy $ac_cv_prog_CC
   shift
   if test $# != 0; then
     # We chose a different compiler from the bogus one.
     # However, it has the same basename, so the bogon will be chosen
     # first if we set CC to just the basename; use the full file name.
     shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+    ac_cv_prog_CC="$as_dir$ac_word${1+' '}$@"
   fi
 fi
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 fi
 if test -z "$CC"; then
   if test -n "$ac_tool_prefix"; then
   for ac_prog in cl.exe
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
     test -n "$CC" && break
   done
 fi
 if test -z "$CC"; then
   ac_ct_CC=$CC
   for ac_prog in cl.exe
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
   test -n "$ac_ct_CC" && break
 done
 
   if test "x$ac_ct_CC" = x; then
     CC=""
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}clang", so it can be a program name with args.
+set dummy ${ac_tool_prefix}clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "clang", so it can be a program name with args.
+set dummy clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
   fi
+else
+  CC="$ac_cv_prog_CC"
 fi
 
 fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+test -z "$CC" && { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "no acceptable C compiler found in \$PATH
 See \`config.log' for more details" "$LINENO" 5; }
 
 # Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
+for ac_option in --version -v -V -qversion -version; do
   { { ac_try="$ac_compiler $ac_option >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
     sed '10a\
 ... rest of stderr output deleted ...
          10q' conftest.err >conftest.er1
     cat conftest.er1 >&5
   fi
   rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
 done
 
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
-$as_echo_n "checking whether the C compiler works... " >&6; }
-ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+printf %s "checking whether the C compiler works... " >&6; }
+ac_link_default=`printf "%s\n" "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
 
 # The possible output files:
 ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
 
 ac_rmfiles=
 for ac_file in $ac_files
 do
@@ -2711,19 +3153,20 @@
 
 if { { ac_try="$ac_link_default"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link_default") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
   # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
 # So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
 # in a Makefile.  We should not override ac_cv_exeext if it was cached,
 # so that the user can short-circuit this test for compilers unknown to
 # Autoconf.
 for ac_file in $ac_files ''
 do
@@ -2732,15 +3175,15 @@
     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
 	;;
     [ab].out )
 	# We found the default executable, but exeext='' is most
 	# certainly right.
 	break;;
     *.* )
-	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	if test ${ac_cv_exeext+y} && test "$ac_cv_exeext" != no;
 	then :; else
 	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
 	fi
 	# We set ac_cv_exeext here because the later test for it is not
 	# safe: cross compilers may not add the suffix if given an `-o'
 	# argument, so we may need to know it at that point already.
 	# Even if this section looks crufty: it has the advantage of
@@ -2748,876 +3191,571 @@
 	break;;
     * )
 	break;;
   esac
 done
 test "$ac_cv_exeext" = no && ac_cv_exeext=
 
-else
+else $as_nop
   ac_file=''
 fi
-if test -z "$ac_file"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-$as_echo "$as_me: failed program was:" >&5
+if test -z "$ac_file"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error 77 "C compiler cannot create executables
 See \`config.log' for more details" "$LINENO" 5; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
-$as_echo_n "checking for C compiler default output file name... " >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
-$as_echo "$ac_file" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+printf %s "checking for C compiler default output file name... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+printf "%s\n" "$ac_file" >&6; }
 ac_exeext=$ac_cv_exeext
 
 rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
 ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
-$as_echo_n "checking for suffix of executables... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+printf %s "checking for suffix of executables... " >&6; }
 if { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
   # If both `conftest.exe' and `conftest' are `present' (well, observable)
 # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
 # work properly (i.e., refer to `conftest.exe'), while it won't with
 # `rm'.
 for ac_file in conftest.exe conftest conftest.*; do
   test -f "$ac_file" || continue
   case $ac_file in
     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
 	  break;;
     * ) break;;
   esac
 done
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+else $as_nop
+  { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest conftest$ac_cv_exeext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
-$as_echo "$ac_cv_exeext" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+printf "%s\n" "$ac_cv_exeext" >&6; }
 
 rm -f conftest.$ac_ext
 EXEEXT=$ac_cv_exeext
 ac_exeext=$EXEEXT
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdio.h>
 int
-main ()
+main (void)
 {
 FILE *f = fopen ("conftest.out", "w");
  return ferror (f) || fclose (f) != 0;
 
   ;
   return 0;
 }
 _ACEOF
 ac_clean_files="$ac_clean_files conftest.out"
 # Check that the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
-$as_echo_n "checking whether we are cross compiling... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+printf %s "checking whether we are cross compiling... " >&6; }
 if test "$cross_compiling" != yes; then
   { { ac_try="$ac_link"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_link") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
   if { ac_try='./conftest$ac_cv_exeext'
   { { case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_try") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }; }; then
     cross_compiling=no
   else
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot run C compiled programs.
+	{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details" "$LINENO" 5; }
     fi
   fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
-$as_echo "$cross_compiling" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+printf "%s\n" "$cross_compiling" >&6; }
 
 rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
 ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
-$as_echo_n "checking for suffix of object files... " >&6; }
-if ${ac_cv_objext+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+printf %s "checking for suffix of object files... " >&6; }
+if test ${ac_cv_objext+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.o conftest.obj
 if { { ac_try="$ac_compile"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compile") 2>&5
   ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
   for ac_file in conftest.o conftest.obj conftest.*; do
   test -f "$ac_file" || continue;
   case $ac_file in
     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
     *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
        break;;
   esac
 done
-else
-  $as_echo "$as_me: failed program was:" >&5
+else $as_nop
+  printf "%s\n" "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "cannot compute suffix of object files: cannot compile
 See \`config.log' for more details" "$LINENO" 5; }
 fi
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
-$as_echo "$ac_cv_objext" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+printf "%s\n" "$ac_cv_objext" >&6; }
 OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C" >&5
+printf %s "checking whether the compiler supports GNU C... " >&6; }
+if test ${ac_cv_c_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 #ifndef __GNUC__
        choke me
 #endif
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_compiler_gnu=yes
-else
+else $as_nop
   ac_compiler_gnu=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_c_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
 if test $ac_compiler_gnu = yes; then
   GCC=yes
 else
   GCC=
 fi
-ac_test_CFLAGS=${CFLAGS+set}
+ac_test_CFLAGS=${CFLAGS+y}
 ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+printf %s "checking whether $CC accepts -g... " >&6; }
+if test ${ac_cv_prog_cc_g+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_save_c_werror_flag=$ac_c_werror_flag
    ac_c_werror_flag=yes
    ac_cv_prog_cc_g=no
    CFLAGS="-g"
    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_g=yes
-else
+else $as_nop
   CFLAGS=""
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-else
+else $as_nop
   ac_c_werror_flag=$ac_save_c_werror_flag
 	 CFLAGS="-g"
 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_g=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
    ac_c_werror_flag=$ac_save_c_werror_flag
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+printf "%s\n" "$ac_cv_prog_cc_g" >&6; }
+if test $ac_test_CFLAGS; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
   if test "$GCC" = yes; then
     CFLAGS="-g -O2"
   else
     CFLAGS="-g"
   fi
 else
   if test "$GCC" = yes; then
     CFLAGS="-O2"
   else
     CFLAGS=
   fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if ${ac_cv_prog_cc_c89+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
+ac_prog_cc_stdc=no
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features" >&5
+printf %s "checking for $CC option to enable C11 features... " >&6; }
+if test ${ac_cv_prog_cc_c11+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c11=no
 ac_save_CC=$CC
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-struct stat;
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
+$ac_c_conftest_c11_program
 _ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+for ac_arg in '' -std=gnu11
 do
   CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_c89=$ac_arg
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c11=$ac_arg
 fi
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c11" != "xno" && break
 done
 rm -f conftest.$ac_ext
 CC=$ac_save_CC
-
 fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
 
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+if test "x$ac_cv_prog_cc_c11" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c11" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11" >&5
+printf "%s\n" "$ac_cv_prog_cc_c11" >&6; }
+     CC="$CC $ac_cv_prog_cc_c11"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11
+  ac_prog_cc_stdc=c11
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features" >&5
+printf %s "checking for $CC option to enable C99 features... " >&6; }
+if test ${ac_cv_prog_cc_c99+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c99=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
+$ac_c_conftest_c99_program
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
+for ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c99=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c99" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+if test "x$ac_cv_prog_cc_c99" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c99" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99" >&5
+printf "%s\n" "$ac_cv_prog_cc_c99" >&6; }
+     CC="$CC $ac_cv_prog_cc_c99"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99
+  ac_prog_cc_stdc=c99
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features" >&5
+printf %s "checking for $CC option to enable C89 features... " >&6; }
+if test ${ac_cv_prog_cc_c89+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <ac_nonexistent.h>
+$ac_c_conftest_c89_program
 _ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c89=$ac_arg
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
 done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
 
-else
-  # Broken: fails on valid input.
-continue
+if test "x$ac_cv_prog_cc_c89" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c89" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+printf "%s\n" "$ac_cv_prog_cc_c89" >&6; }
+     CC="$CC $ac_cv_prog_cc_c89"
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89
+  ac_prog_cc_stdc=c89
 fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
 fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if ${ac_cv_path_GREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+ac_header= ac_cache=
+for ac_item in $ac_header_c_list
 do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      as_fn_executable_p "$ac_path_GREP" || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
+  if test $ac_cache; then
+    ac_fn_c_check_header_compile "$LINENO" $ac_header ac_cv_header_$ac_cache "$ac_includes_default"
+    if eval test \"x\$ac_cv_header_$ac_cache\" = xyes; then
+      printf "%s\n" "#define $ac_item 1" >> confdefs.h
     fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_GREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if ${ac_cv_path_EGREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      as_fn_executable_p "$ac_path_EGREP" || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_EGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+    ac_header= ac_cache=
+  elif test $ac_header; then
+    ac_cache=$ac_item
+  else
+    ac_header=$ac_item
   fi
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if ${ac_cv_header_stdc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
+done
 
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
 
-fi
 
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
 
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
 
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
 
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
 
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
 
-fi
+if test $ac_cv_header_stdlib_h = yes && test $ac_cv_header_string_h = yes
+then :
 
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+printf "%s\n" "#define STDC_HEADERS 1" >>confdefs.h
 
 fi
 
-done
-
-
-
 # Check whether --with-bzip2 was given.
-if test "${with_bzip2+set}" = set; then :
+if test ${with_bzip2+y}
+then :
   withval=$with_bzip2;  if test "x$withval" != "xno"; then
         if test "x$withval" = "xyes" ; then
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lbz2" >&5
-$as_echo_n "checking for main in -lbz2... " >&6; }
-if ${ac_cv_lib_bz2_main+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for main in -lbz2" >&5
+printf %s "checking for main in -lbz2... " >&6; }
+if test ${ac_cv_lib_bz2_main+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lbz2  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 
 int
-main ()
+main (void)
 {
 return main ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_bz2_main=yes
-else
+else $as_nop
   ac_cv_lib_bz2_main=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bz2_main" >&5
-$as_echo "$ac_cv_lib_bz2_main" >&6; }
-if test "x$ac_cv_lib_bz2_main" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBBZ2 1
-_ACEOF
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_bz2_main" >&5
+printf "%s\n" "$ac_cv_lib_bz2_main" >&6; }
+if test "x$ac_cv_lib_bz2_main" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBBZ2 1" >>confdefs.h
 
   LIBS="-lbz2 $LIBS"
 
-else
+else $as_nop
   as_fn_error $? "Unable to locate bz2 library needed when enabling bzip2 support; try specifying the path" "$LINENO" 5
 fi
 
         else
             BZIP2_PATH="${withval}"
         fi
-        for ac_header in bzlib.h
+               for ac_header in bzlib.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "bzlib.h" "ac_cv_header_bzlib_h" "$ac_includes_default"
-if test "x$ac_cv_header_bzlib_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_BZLIB_H 1
-_ACEOF
+  ac_fn_c_check_header_compile "$LINENO" "bzlib.h" "ac_cv_header_bzlib_h" "$ac_includes_default"
+if test "x$ac_cv_header_bzlib_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_BZLIB_H 1" >>confdefs.h
 
-$as_echo "#define HAVE_BZIP2 1" >>confdefs.h
+printf "%s\n" "#define HAVE_BZIP2 1" >>confdefs.h
 
 fi
 
 done
-
     fi
 
 
 fi
 
 
 # Optional Globus Toolkit support:
 
 # Check whether --with-gsiftp was given.
-if test "${with_gsiftp+set}" = set; then :
+if test ${with_gsiftp+y}
+then :
   withval=$with_gsiftp;  if test "x$withval" != "xno"; then
         if test "x$withval" != "xyes" ; then
             GSIFTP_PATH="${withval}"
         fi
 
-$as_echo "#define HAVE_GSIFTP 1" >>confdefs.h
+printf "%s\n" "#define HAVE_GSIFTP 1" >>confdefs.h
 
         USE_GSIFTP=yes
     fi
 
 
 fi
 
@@ -3627,22 +3765,39 @@
 else
    GSIFTP_SRC=""
 fi
 
 
 
 # Check whether --with-gsiftp-flavour was given.
-if test "${with_gsiftp_flavour+set}" = set; then :
+if test ${with_gsiftp_flavour+y}
+then :
   withval=$with_gsiftp_flavour;  if test "x$withval" != "xno"; then
         if test "x$withval" != "xyes" ; then
             GSIFTP_FLAVOUR="${withval}"
         fi
 
-$as_echo "#define GSIFTP_FLAVOUR 1" >>confdefs.h
+printf "%s\n" "#define GSIFTP_FLAVOUR 1" >>confdefs.h
+
+    fi
+
+
+fi
+
+
+# Optionally disable check for zlib:
+ZLIB_CHECK=yes
 
+# Check whether --with-zlib-check was given.
+if test ${with_zlib_check+y}
+then :
+  withval=$with_zlib_check;  if test "x$withval" = "xno"; then
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cfitsio: ZLIB is required!" >&5
+printf "%s\n" "$as_me: WARNING: cfitsio: ZLIB is required!" >&2;}
+       ZLIB_CHECK=no
     fi
 
 
 fi
 
 
 #--------------------------------------------------------------------
@@ -3720,46 +3875,51 @@
 # Try first to find a proprietary C compiler, then gcc
 if test "x$EXT" != xcygwin && test "x$EXT" != xdarwin && test "x$EXT" != xlnx && test "x$EXT" != xmingw32; then
   if test "x$CC" = x; then
     for ac_prog in cc
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
   test -n "$CC" && break
 done
 
   fi
@@ -3768,169 +3928,189 @@
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 fi
 if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_CC" = x; then
     CC=""
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
   fi
 else
   CC="$ac_cv_prog_CC"
 fi
 
 if test -z "$CC"; then
           if test -n "$ac_tool_prefix"; then
     # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
   fi
 fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
   ac_prog_rejected=no
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    if test "$as_dir$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
      fi
     ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 if test $ac_prog_rejected = yes; then
@@ -3938,434 +4118,626 @@
   set dummy $ac_cv_prog_CC
   shift
   if test $# != 0; then
     # We chose a different compiler from the bogus one.
     # However, it has the same basename, so the bogon will be chosen
     # first if we set CC to just the basename; use the full file name.
     shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+    ac_cv_prog_CC="$as_dir$ac_word${1+' '}$@"
   fi
 fi
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 fi
 if test -z "$CC"; then
   if test -n "$ac_tool_prefix"; then
   for ac_prog in cl.exe
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
     test -n "$CC" && break
   done
 fi
 if test -z "$CC"; then
   ac_ct_CC=$CC
   for ac_prog in cl.exe
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
   test -n "$ac_ct_CC" && break
 done
 
   if test "x$ac_ct_CC" = x; then
     CC=""
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     CC=$ac_ct_CC
   fi
 fi
 
 fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}clang", so it can be a program name with args.
+set dummy ${ac_tool_prefix}clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
 
 
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "clang", so it can be a program name with args.
+set dummy clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+
+
+test -z "$CC" && { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in \`$ac_pwd':" >&2;}
 as_fn_error $? "no acceptable C compiler found in \$PATH
 See \`config.log' for more details" "$LINENO" 5; }
 
 # Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
 set X $ac_compile
 ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
+for ac_option in --version -v -V -qversion -version; do
   { { ac_try="$ac_compiler $ac_option >&5"
 case "(($ac_try" in
   *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
   *) ac_try_echo=$ac_try;;
 esac
 eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
+printf "%s\n" "$ac_try_echo"; } >&5
   (eval "$ac_compiler $ac_option >&5") 2>conftest.err
   ac_status=$?
   if test -s conftest.err; then
     sed '10a\
 ... rest of stderr output deleted ...
          10q' conftest.err >conftest.er1
     cat conftest.er1 >&5
   fi
   rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
 done
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C" >&5
+printf %s "checking whether the compiler supports GNU C... " >&6; }
+if test ${ac_cv_c_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 #ifndef __GNUC__
        choke me
 #endif
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_compiler_gnu=yes
-else
+else $as_nop
   ac_compiler_gnu=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_c_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
 if test $ac_compiler_gnu = yes; then
   GCC=yes
 else
   GCC=
 fi
-ac_test_CFLAGS=${CFLAGS+set}
+ac_test_CFLAGS=${CFLAGS+y}
 ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+printf %s "checking whether $CC accepts -g... " >&6; }
+if test ${ac_cv_prog_cc_g+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_save_c_werror_flag=$ac_c_werror_flag
    ac_c_werror_flag=yes
    ac_cv_prog_cc_g=no
    CFLAGS="-g"
    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_g=yes
-else
+else $as_nop
   CFLAGS=""
       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-else
+else $as_nop
   ac_c_werror_flag=$ac_save_c_werror_flag
 	 CFLAGS="-g"
 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_g=yes
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
    ac_c_werror_flag=$ac_save_c_werror_flag
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+printf "%s\n" "$ac_cv_prog_cc_g" >&6; }
+if test $ac_test_CFLAGS; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
   if test "$GCC" = yes; then
     CFLAGS="-g -O2"
   else
     CFLAGS="-g"
   fi
 else
   if test "$GCC" = yes; then
     CFLAGS="-O2"
   else
     CFLAGS=
   fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if ${ac_cv_prog_cc_c89+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
+ac_prog_cc_stdc=no
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features" >&5
+printf %s "checking for $CC option to enable C11 features... " >&6; }
+if test ${ac_cv_prog_cc_c11+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c11=no
 ac_save_CC=$CC
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-struct stat;
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+$ac_c_conftest_c11_program
+_ACEOF
+for ac_arg in '' -std=gnu11
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c11=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c11" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+fi
 
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+if test "x$ac_cv_prog_cc_c11" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c11" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11" >&5
+printf "%s\n" "$ac_cv_prog_cc_c11" >&6; }
+     CC="$CC $ac_cv_prog_cc_c11"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11
+  ac_prog_cc_stdc=c11
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features" >&5
+printf %s "checking for $CC option to enable C99 features... " >&6; }
+if test ${ac_cv_prog_cc_c99+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c99=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c99_program
+_ACEOF
+for ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c99=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c99" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+fi
 
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
+if test "x$ac_cv_prog_cc_c99" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c99" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99" >&5
+printf "%s\n" "$ac_cv_prog_cc_c99" >&6; }
+     CC="$CC $ac_cv_prog_cc_c99"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99
+  ac_prog_cc_stdc=c99
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features" >&5
+printf %s "checking for $CC option to enable C89 features... " >&6; }
+if test ${ac_cv_prog_cc_c89+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c89_program
 _ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
 do
   CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
+  if ac_fn_c_try_compile "$LINENO"
+then :
   ac_cv_prog_cc_c89=$ac_arg
 fi
-rm -f core conftest.err conftest.$ac_objext
+rm -f core conftest.err conftest.$ac_objext conftest.beam
   test "x$ac_cv_prog_cc_c89" != "xno" && break
 done
 rm -f conftest.$ac_ext
 CC=$ac_save_CC
-
 fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
 
+if test "x$ac_cv_prog_cc_c89" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else $as_nop
+  if test "x$ac_cv_prog_cc_c89" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+printf "%s\n" "$ac_cv_prog_cc_c89" >&6; }
+     CC="$CC $ac_cv_prog_cc_c89"
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89
+  ac_prog_cc_stdc=c89
+fi
 fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
+
+#-------------------------------------------------------------------------------
+# Handle --enable-symbols=yes
+#-------------------------------------------------------------------------------
+
+# Remove existing/default optimization:
+if test "x$SYMBOLS" = "xyes"; then
+
+   COPT_DEFAULT=`echo $CFLAGS | tr " " "\012" | grep "^\-O[0-9]"`
+
+   CFLAGS=`echo $CFLAGS | sed "s:$COPT_DEFAULT::g"`
+fi
+
+#-------------------------------------------------------------------------------
+
 LDFLAGS="$CFLAGS"
 LDFLAGS_BIN="$LDFLAGS"
 
 if test "x$FC" = "xnone" ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: cfitsio: == Fortran compiler search has been overridden" >&5
-$as_echo "$as_me: cfitsio: == Fortran compiler search has been overridden" >&6;}
-  { $as_echo "$as_me:${as_lineno-$LINENO}: cfitsio: == Cfitsio will be built without Fortran wrapper support" >&5
-$as_echo "$as_me: cfitsio: == Cfitsio will be built without Fortran wrapper support" >&6;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: cfitsio: == Fortran compiler search has been overridden" >&5
+printf "%s\n" "$as_me: cfitsio: == Fortran compiler search has been overridden" >&6;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: cfitsio: == Cfitsio will be built without Fortran wrapper support" >&5
+printf "%s\n" "$as_me: cfitsio: == Cfitsio will be built without Fortran wrapper support" >&6;}
   FC=
   F77_WRAPPERS=
 else
   for ac_prog in gfortran g95 g77 f77 ifort f95 f90 xlf cf77 gf77 af77 ncf f2c
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_FC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_FC+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$FC"; then
   ac_cv_prog_FC="$FC" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_FC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 FC=$ac_cv_prog_FC
 if test -n "$FC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $FC" >&5
-$as_echo "$FC" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $FC" >&5
+printf "%s\n" "$FC" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
   test -n "$FC" && break
 done
 test -n "$FC" || FC="notfound"
 
   if test $FC = 'notfound' ; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cfitsio: == No acceptable Fortran compiler found in \$PATH" >&5
-$as_echo "$as_me: WARNING: cfitsio: == No acceptable Fortran compiler found in \$PATH" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: cfitsio: == Adding wrapper support for GNU Fortran by default" >&5
-$as_echo "$as_me: cfitsio: == Adding wrapper support for GNU Fortran by default" >&6;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cfitsio: == No acceptable Fortran compiler found in \$PATH" >&5
+printf "%s\n" "$as_me: WARNING: cfitsio: == No acceptable Fortran compiler found in \$PATH" >&2;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: cfitsio: == Adding wrapper support for GNU Fortran by default" >&5
+printf "%s\n" "$as_me: cfitsio: == Adding wrapper support for GNU Fortran by default" >&6;}
     CFORTRANFLAGS="-Dg77Fortran"
     F77_WRAPPERS="\${FITSIO_SRC}"
   else
     CFORTRANFLAGS=
     F77_WRAPPERS="\${FITSIO_SRC}"
     echo $ac_n "checking whether we are using GNU Fortran""... $ac_c" 1>&6
     if test `$FC --version -c < /dev/null 2> /dev/null | grep -c GNU` -gt 0 -o \
@@ -4386,181 +4758,197 @@
   fi
 fi
 
 # ar & ranlib required
 #---------------------
 # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AR+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_AR+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$AR"; then
   ac_cv_prog_AR="$AR" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_AR="ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
   test -z "$ac_cv_prog_AR" && ac_cv_prog_AR="noar"
 fi
 fi
 AR=$ac_cv_prog_AR
 if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+printf "%s\n" "$AR" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 if test $AR = noar; then
   as_fn_error $? "ar not found in your \$PATH. See your sysdamin." "$LINENO" 5
 fi
 ARCHIVE="$AR rv"
 
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_RANLIB+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$RANLIB"; then
   ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 RANLIB=$ac_cv_prog_RANLIB
 if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+printf "%s\n" "$RANLIB" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
 fi
 if test -z "$ac_cv_prog_RANLIB"; then
   ac_ct_RANLIB=$RANLIB
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_RANLIB+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$ac_ct_RANLIB"; then
   ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
 if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+printf "%s\n" "$ac_ct_RANLIB" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
   if test "x$ac_ct_RANLIB" = x; then
     RANLIB=":"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
     RANLIB=$ac_ct_RANLIB
   fi
 else
   RANLIB="$ac_cv_prog_RANLIB"
 fi
 
 
-for ac_header in stdlib.h string.h math.h limits.h
+       for ac_header in stdlib.h string.h math.h limits.h
 do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  as_ac_Header=`printf "%s\n" "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"
+then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define `printf "%s\n" "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
  ANSI_HEADER=yes
-else
+else $as_nop
   ANSI_HEADER=no
 fi
 
 done
-
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 void d( int , double)
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   PROTO=yes
-else
+else $as_nop
   PROTO=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 if test $ANSI_HEADER = no -o $PROTO = no; then
      echo "   *********** WARNING: CFITSIO CONFIGURE FAILURE ************  "
      echo "cfitsio: ANSI C environment NOT found. Aborting cfitsio configure."
      if test $ANSI_HEADER = no; then
         echo "cfitsio: You're missing a needed ANSI header file."
      fi
      if test $PROTO = no; then
@@ -4571,41 +4959,42 @@
      echo "     *******************************************************  "
      exit 0;
 fi
 
 if test "x$SSE_FLAGS" != x; then
     SAVE_CFLAGS="$CFLAGS"
     CFLAGS="$CFLAGS $SSE_FLAGS"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts $SSE_FLAGS" >&5
-$as_echo_n "checking whether $CC accepts $SSE_FLAGS... " >&6; }
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts $SSE_FLAGS" >&5
+printf %s "checking whether $CC accepts $SSE_FLAGS... " >&6; }
     ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
-main ()
+main (void)
 {
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
   c_has_option=yes
-else
+else $as_nop
   c_has_option=no
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $c_has_option" >&5
-$as_echo "$c_has_option" >&6; }
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $c_has_option" >&5
+printf "%s\n" "$c_has_option" >&6; }
     ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
     if test "$c_has_option" = no; then SSE_FLAGS=""; fi
@@ -4639,24 +5028,24 @@
 #                  CFLAGS="$CFLAGS $C_UNIV_SWITCH"
 #                fi
                 # LDFLAGS used by utilities:
                 LDFLAGS_BIN="$LDFLAGS_BIN -Wl,-rpath,\${CFITSIO_LIB}"
                 ;;
         esac
         # For large file support (but may break Absoft compilers):
-        $as_echo "#define _LARGEFILE_SOURCE 1" >>confdefs.h
+        printf "%s\n" "#define _LARGEFILE_SOURCE 1" >>confdefs.h
 
-        $as_echo "#define _FILE_OFFSET_BITS 64" >>confdefs.h
+        printf "%s\n" "#define _FILE_OFFSET_BITS 64" >>confdefs.h
 
 	;;
     *haiku*)
         # For large file support:
-        $as_echo "#define _LARGEFILE_SOURCE 1" >>confdefs.h
+        printf "%s\n" "#define _LARGEFILE_SOURCE 1" >>confdefs.h
 
-        $as_echo "#define _FILE_OFFSET_BITS 64" >>confdefs.h
+        printf "%s\n" "#define _FILE_OFFSET_BITS 64" >>confdefs.h
 
         ;;
     *hpux*)
 	if test "x$CFORTRANFLAGS" = x ; then
 		CFORTRANFLAGS="-Dappendus"
 	fi
 	CFLAGS="$CFLAGS -DPG_PPU"
@@ -4664,104 +5053,103 @@
 	;;
     *irix*)
 	CFLAGS="$CFLAGS -DHAVE_POSIX_SIGNALS"
 	RANLIB="touch"
 	;;
     *linux*)
         # For large file support:
-        $as_echo "#define _LARGEFILE_SOURCE 1" >>confdefs.h
+        printf "%s\n" "#define _LARGEFILE_SOURCE 1" >>confdefs.h
 
-        $as_echo "#define _FILE_OFFSET_BITS 64" >>confdefs.h
+        printf "%s\n" "#define _FILE_OFFSET_BITS 64" >>confdefs.h
 
         # LDFLAGS used by utilities:
         LDFLAGS_BIN="$LDFLAGS_BIN -Wl,-rpath,\${CFITSIO_LIB}"
 	;;
     *mingw32*)
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for large file support" >&5
-$as_echo_n "checking for large file support... " >&6; }
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for large file support" >&5
+printf %s "checking for large file support... " >&6; }
         cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdio.h>
 int
-main ()
+main (void)
 {
 _FILE_OFFSET_BITS_SET_FSEEKO
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-            $as_echo "#define _LARGEFILE_SOURCE 1" >>confdefs.h
+            printf "%s\n" "#define _LARGEFILE_SOURCE 1" >>confdefs.h
 
-            $as_echo "#define _FILE_OFFSET_BITS 64" >>confdefs.h
+            printf "%s\n" "#define _FILE_OFFSET_BITS 64" >>confdefs.h
 
-            { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
         ;;
     *solaris*)
         if test "x$CFORTRANFLAGS" = x ; then
                 CFORTRANFLAGS="-Dsolaris"
         fi
         # We need libm on Solaris:
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for frexp in -lm" >&5
-$as_echo_n "checking for frexp in -lm... " >&6; }
-if ${ac_cv_lib_m_frexp+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for frexp in -lm" >&5
+printf %s "checking for frexp in -lm... " >&6; }
+if test ${ac_cv_lib_m_frexp+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lm  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char frexp ();
 int
-main ()
+main (void)
 {
 return frexp ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_m_frexp=yes
-else
+else $as_nop
   ac_cv_lib_m_frexp=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_frexp" >&5
-$as_echo "$ac_cv_lib_m_frexp" >&6; }
-if test "x$ac_cv_lib_m_frexp" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBM 1
-_ACEOF
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_frexp" >&5
+printf "%s\n" "$ac_cv_lib_m_frexp" >&6; }
+if test "x$ac_cv_lib_m_frexp" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBM 1" >>confdefs.h
 
   LIBS="-lm $LIBS"
 
 fi
 
         # For large file support:
-        $as_echo "#define _LARGEFILE_SOURCE 1" >>confdefs.h
+        printf "%s\n" "#define _LARGEFILE_SOURCE 1" >>confdefs.h
 
-        $as_echo "#define _FILE_OFFSET_BITS 64" >>confdefs.h
+        printf "%s\n" "#define _FILE_OFFSET_BITS 64" >>confdefs.h
 
 	;;
     *)
 		echo "cfitsio: == Don't know what do do with $host"
 	;;
 esac
 
@@ -4776,16 +5164,16 @@
 		gcc_test=`echo $GCCVERSION | grep -c '2\.[45678]'`
 
 		if test $gcc_test -gt 0
 		then
 
 		    CFLAGS=`echo $CFLAGS | sed 's:-O[^ ]* *::'`
 
-		    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: This gcc is pretty old. Disabling optimization to be safe." >&5
-$as_echo "$as_me: WARNING: This gcc is pretty old. Disabling optimization to be safe." >&2;}
+		    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: This gcc is pretty old. Disabling optimization to be safe." >&5
+printf "%s\n" "$as_me: WARNING: This gcc is pretty old. Disabling optimization to be safe." >&2;}
 		fi
 		;;
 	no)
 		echo "cfitsio: Old CFLAGS is $CFLAGS"
 		CFLAGS=`echo $CFLAGS | sed -e "s/-g/-O/"`
 		case $host in
 		    *solaris*)
@@ -4820,57 +5208,57 @@
   cygwin|mingw32)
     SHLIB_LD="$CC -shared"
     SHLIB_SUFFIX=".dll"
     ;;
   darwin)
 
     SHLIB_SUFFIX=".dylib"
-    CFITSIO_SHLIB="lib\${PACKAGE}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}\${SHLIB_SUFFIX}"
+    CFITSIO_SHLIB="lib\${PACKAGE}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}\${SHLIB_SUFFIX}"
     CFITSIO_SHLIB_SONAME="lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX}"
     case $host in
         *darwin[56789]*)
-            SHLIB_LD="$CC -dynamiclib -install_name lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+            SHLIB_LD="$CC -dynamiclib -install_name lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
             ;;
         *)
             # Build 'Universal' binaries (i386 & x86_64 architectures) and
             # use rpath token on Darwin 10.x or newer:
-            SHLIB_LD="$CC -dynamiclib $C_UNIV_SWITCH -headerpad_max_install_names -install_name @rpath/lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+            SHLIB_LD="$CC -dynamiclib $C_UNIV_SWITCH -headerpad_max_install_names -install_name @rpath/lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
             ;;
     esac
 
     lhea_shlib_cflags="-fPIC -fno-common"
     ;;
   haiku)
     SHLIB_LD=":"
-    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
     CFITSIO_SHLIB_SONAME="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}"
     ;;
   hpu)
     SHLIB_LD="ld -b"
     SHLIB_SUFFIX=".sl"
     ;;
   lnx)
     SHLIB_LD=":"
-    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
     CFITSIO_SHLIB_SONAME="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}"
     ;;
   osf)
     SHLIB_LD="ld -shared -expect_unresolved '*'"
     LD_FLAGS="-taso"
     ;;
   sol)
     SHLIB_LD="/usr/ccs/bin/ld -G"
     lhea_shlib_cflags="-KPIC"
     ;;
   sgi)
     SHLIB_LD="ld -shared -rdata_shared"
     ;;
   *)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Unable to determine how to make a shared library" >&5
-$as_echo "$as_me: WARNING: Unable to determine how to make a shared library" >&2;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: Unable to determine how to make a shared library" >&5
+printf "%s\n" "$as_me: WARNING: Unable to determine how to make a shared library" >&2;}
     ;;
 esac
 # Darwin uses gcc (=cc), but needs different flags (see above)
 if test "x$EXT" != xdarwin && test "x$EXT" != xcygwin && test "x$EXT" != xmingw32; then
   if test "x$GCC" = xyes; then
     SHLIB_LD="$CC -shared -Wl,-soname,lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}"
     lhea_shlib_cflags='-fPIC'
@@ -4887,46 +5275,51 @@
 CURL_INC=""
 CURL_LIB=""
 CURL_LIB_PATH=""
 if test "x$ADD_CURL" = xyes; then
   # Use curl-config to get compiler & linker flags, if available.
   # Extract the first word of "curl-config", so it can be a program name with args.
 set dummy curl-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CURLCONFIG+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CURLCONFIG+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   if test -n "$CURLCONFIG"; then
   ac_cv_prog_CURLCONFIG="$CURLCONFIG" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
     for ac_exec_ext in '' $ac_executable_extensions; do
-  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
     ac_cv_prog_CURLCONFIG="curl-config"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
   done
 IFS=$as_save_IFS
 
 fi
 fi
 CURLCONFIG=$ac_cv_prog_CURLCONFIG
 if test -n "$CURLCONFIG"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CURLCONFIG" >&5
-$as_echo "$CURLCONFIG" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CURLCONFIG" >&5
+printf "%s\n" "$CURLCONFIG" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
 
 
   if test "x$CURLCONFIG" != x; then
     CURL_LIB=`$CURLCONFIG --libs`
     CURL_INC=`$CURLCONFIG --cflags`
     if test "x$CURL_LIB" != x; then
@@ -4937,32 +5330,81 @@
         if test "x$CURL_LIB_PATH" != x; then
           LIBS_CURL="-Wl,-rpath,$CURL_LIB_PATH $CURL_LIB"
         fi
       fi
       if test `echo $host | grep -c cygwin` -ne 0 -o `echo $host | grep -c mingw32` -ne 0; then
           LIBS="$CURL_LIB $LIBS"
       fi
-      $as_echo "#define CFITSIO_HAVE_CURL 1" >>confdefs.h
+      printf "%s\n" "#define CFITSIO_HAVE_CURL 1" >>confdefs.h
 
     fi
     if test "x$CURL_INC" != x; then
       CFLAGS="$CURL_INC $CFLAGS"
     fi
   # No curl-config:
   else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: curl-config not found. Disabling curl support." >&5
-$as_echo "$as_me: WARNING: curl-config not found. Disabling curl support." >&2;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: curl-config not found. Disabling curl support." >&5
+printf "%s\n" "$as_me: WARNING: curl-config not found. Disabling curl support." >&2;}
   # Incomplete stubs for possible future use:
   #  AC_CHECK_LIB([curl],[main],[],
   #       [AC_MSG_WARN(Not building curl support for CFITSIO)])
   #  AC_CHECK_HEADER(curl.h,[])
   fi
 fi
 
 
+# ZLIB (required):
+if test "x$ZLIB_CHECK" = xyes; then
+   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for inflateEnd in -lz" >&5
+printf %s "checking for inflateEnd in -lz... " >&6; }
+if test ${ac_cv_lib_z_inflateEnd+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char inflateEnd ();
+int
+main (void)
+{
+return inflateEnd ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_z_inflateEnd=yes
+else $as_nop
+  ac_cv_lib_z_inflateEnd=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_inflateEnd" >&5
+printf "%s\n" "$ac_cv_lib_z_inflateEnd" >&6; }
+if test "x$ac_cv_lib_z_inflateEnd" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBZ 1" >>confdefs.h
+
+  LIBS="-lz $LIBS"
+
+else $as_nop
+  as_fn_error $? "Unable to locate zlib compression library" "$LINENO" 5
+fi
+
+fi
+
 # GSIFTP flags:
 if test "x$GSIFTP_PATH" != x -a "x$GSIFTP_FLAVOUR" != x; then
    CFLAGS="$CFLAGS -I${GSIFTP_PATH}/include/${GSIFTP_FLAVOUR}"
    LIBS="$LIBS -L${GSIFTP_PATH}/lib -lglobus_ftp_client_${GSIFTP_FLAVOUR}"
 fi
 
 # BZIP2 flags:
@@ -4972,420 +5414,434 @@
 fi
 
 
 
 
 # ================= test for the unix ftruncate function ================
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ftruncate works" >&5
-$as_echo_n "checking whether ftruncate works... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether ftruncate works" >&5
+printf %s "checking whether ftruncate works... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <unistd.h>
 
 int
-main ()
+main (void)
 {
 
 ftruncate(0, 0);
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
 
-$as_echo "#define HAVE_FTRUNCATE 1" >>confdefs.h
+printf "%s\n" "#define HAVE_FTRUNCATE 1" >>confdefs.h
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 
 # ---------------------------------------------------------
 # some systems define long long for 64-bit ints
 # ---------------------------------------------------------
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether long long is defined" >&5
-$as_echo_n "checking whether long long is defined... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether long long is defined" >&5
+printf %s "checking whether long long is defined... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <stdlib.h>
 
 int
-main ()
+main (void)
 {
 
 long long filler;
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-$as_echo "#define HAVE_LONGLONG 1" >>confdefs.h
+printf "%s\n" "#define HAVE_LONGLONG 1" >>confdefs.h
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 
 # ==================== SHARED MEMORY DRIVER SECTION =======================
 #
 # 09-Mar-98 : modified by JB/ISDC
 # 3 checks added to support autoconfiguration of shared memory
 # driver. First generic check is made whether shared memory is supported
 # at all, then 2 more specific checks are made (architecture dependent).
 # Currently tested on : sparc-solaris, intel-linux, sgi-irix, dec-alpha-osf
 
 # -------------------------------------------------------------------------
 # check is System V IPC is supported on this machine
 # -------------------------------------------------------------------------
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether system V style IPC services are supported" >&5
-$as_echo_n "checking whether system V style IPC services are supported... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether system V style IPC services are supported" >&5
+printf %s "checking whether system V style IPC services are supported... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/ipc.h>
 #include <sys/shm.h>
 #include <sys/sem.h>
 
 int
-main ()
+main (void)
 {
 
 shmat(0, 0, 0);
 shmdt(0);
 shmget(0, 0, 0);
 semget(0, 0, 0);
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
 
-$as_echo "#define HAVE_SHMEM_SERVICES 1" >>confdefs.h
+printf "%s\n" "#define HAVE_SHMEM_SERVICES 1" >>confdefs.h
 
 my_shmem=\${SOURCES_SHMEM}
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 
 
 
 # -------------------------------------------------------------------------
 # some systems define flock_t, for others we have to define it ourselves
 # -------------------------------------------------------------------------
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether flock_t is defined in sys/fcntl.h" >&5
-$as_echo_n "checking whether flock_t is defined in sys/fcntl.h... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether flock_t is defined in sys/fcntl.h" >&5
+printf %s "checking whether flock_t is defined in sys/fcntl.h... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/fcntl.h>
 
 int
-main ()
+main (void)
 {
 
 flock_t filler;
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-$as_echo "#define HAVE_FLOCK_T 1" >>confdefs.h
+printf "%s\n" "#define HAVE_FLOCK_T 1" >>confdefs.h
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 
 if test "$HAVE_FLOCK_T" != 1; then
-   { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether flock_t is defined in sys/flock.h" >&5
-$as_echo_n "checking whether flock_t is defined in sys/flock.h... " >&6; }
+   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether flock_t is defined in sys/flock.h" >&5
+printf %s "checking whether flock_t is defined in sys/flock.h... " >&6; }
    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/flock.h>
 
 int
-main ()
+main (void)
 {
 
    flock_t filler;
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-   $as_echo "#define HAVE_FLOCK_T 1" >>confdefs.h
+   printf "%s\n" "#define HAVE_FLOCK_T 1" >>confdefs.h
 
-   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+   { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
 # ------------------------------------------------------------------------------
 # Define _REENTRANT & add -lpthread to LIBS if reentrant multithreading enabled:
 # ------------------------------------------------------------------------------
 if test "x$BUILD_REENTRANT" = xyes; then
-  $as_echo "#define _REENTRANT 1" >>confdefs.h
+  printf "%s\n" "#define _REENTRANT 1" >>confdefs.h
 
-  $as_echo "#define _XOPEN_SOURCE 700" >>confdefs.h
+  printf "%s\n" "#define _XOPEN_SOURCE 700" >>confdefs.h
 
   # Additional definition needed to get 'union semun' when using
   # _XOPEN_SOURCE on a Mac:
   if test "x$EXT" = xdarwin; then
-    $as_echo "#define _DARWIN_C_SOURCE 1" >>confdefs.h
+    printf "%s\n" "#define _DARWIN_C_SOURCE 1" >>confdefs.h
 
   fi
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lpthread" >&5
-$as_echo_n "checking for main in -lpthread... " >&6; }
-if ${ac_cv_lib_pthread_main+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for main in -lpthread" >&5
+printf %s "checking for main in -lpthread... " >&6; }
+if test ${ac_cv_lib_pthread_main+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lpthread  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 
 int
-main ()
+main (void)
 {
 return main ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_lib_pthread_main=yes
-else
+else $as_nop
   ac_cv_lib_pthread_main=no
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_main" >&5
-$as_echo "$ac_cv_lib_pthread_main" >&6; }
-if test "x$ac_cv_lib_pthread_main" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBPTHREAD 1
-_ACEOF
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_main" >&5
+printf "%s\n" "$ac_cv_lib_pthread_main" >&6; }
+if test "x$ac_cv_lib_pthread_main" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBPTHREAD 1" >>confdefs.h
 
   LIBS="-lpthread $LIBS"
 
-else
+else $as_nop
   as_fn_error $? "Unable to locate pthread library needed when enabling reentrant multithreading" "$LINENO" 5
 fi
 
 fi
 
 # -------------------------------------------------------------------------
 # there are some idiosyncrasies with semun defs (used in semxxx). Solaris
 # does not define it at all
 # -------------------------------------------------------------------------
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether union semun is defined" >&5
-$as_echo_n "checking whether union semun is defined... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether union semun is defined" >&5
+printf %s "checking whether union semun is defined... " >&6; }
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 #include <sys/ipc.h>
 #include <sys/shm.h>
 #include <sys/sem.h>
 
 int
-main ()
+main (void)
 {
 
 union semun filler;
 
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
+if ac_fn_c_try_compile "$LINENO"
+then :
 
-$as_echo "#define HAVE_UNION_SEMUN 1" >>confdefs.h
+printf "%s\n" "#define HAVE_UNION_SEMUN 1" >>confdefs.h
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
 fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
 
 # -------------------------------------------------------------------------
 # fmemopen is not available on e.g. older Macs:
 # -------------------------------------------------------------------------
 
 ac_fn_c_check_func "$LINENO" "fmemopen" "ac_cv_func_fmemopen"
-if test "x$ac_cv_func_fmemopen" = xyes; then :
-  $as_echo "#define HAVE_FMEMOPEN 1" >>confdefs.h
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Disabling support for compressed files via FTPS" >&5
-$as_echo "$as_me: WARNING: Disabling support for compressed files via FTPS" >&2;}
+if test "x$ac_cv_func_fmemopen" = xyes
+then :
+  printf "%s\n" "#define HAVE_FMEMOPEN 1" >>confdefs.h
+
+else $as_nop
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: Disabling support for compressed files via FTPS" >&5
+printf "%s\n" "$as_me: WARNING: Disabling support for compressed files via FTPS" >&2;}
 fi
 
 
 # ==================== END OF SHARED MEMORY DRIVER SECTION ================
 # ================= test for the unix networking functions ================
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing gethostbyname" >&5
-$as_echo_n "checking for library containing gethostbyname... " >&6; }
-if ${ac_cv_search_gethostbyname+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing gethostbyname" >&5
+printf %s "checking for library containing gethostbyname... " >&6; }
+if test ${ac_cv_search_gethostbyname+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char gethostbyname ();
 int
-main ()
+main (void)
 {
 return gethostbyname ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' nsl network; do
+for ac_lib in '' nsl network
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_gethostbyname=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_gethostbyname+:} false; then :
+  if test ${ac_cv_search_gethostbyname+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_gethostbyname+:} false; then :
+if test ${ac_cv_search_gethostbyname+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_gethostbyname=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_gethostbyname" >&5
-$as_echo "$ac_cv_search_gethostbyname" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_gethostbyname" >&5
+printf "%s\n" "$ac_cv_search_gethostbyname" >&6; }
 ac_res=$ac_cv_search_gethostbyname
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
   cfitsio_have_nsl=1
-else
+else $as_nop
   cfitsio_have_nsl=0
 fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing connect" >&5
-$as_echo_n "checking for library containing connect... " >&6; }
-if ${ac_cv_search_connect+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing connect" >&5
+printf %s "checking for library containing connect... " >&6; }
+if test ${ac_cv_search_connect+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
   ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
 char connect ();
 int
-main ()
+main (void)
 {
 return connect ();
   ;
   return 0;
 }
 _ACEOF
-for ac_lib in '' socket network; do
+for ac_lib in '' socket network
+do
   if test -z "$ac_lib"; then
     ac_res="none required"
   else
     ac_res=-l$ac_lib
     LIBS="-l$ac_lib -lnsl $ac_func_search_save_LIBS"
   fi
-  if ac_fn_c_try_link "$LINENO"; then :
+  if ac_fn_c_try_link "$LINENO"
+then :
   ac_cv_search_connect=$ac_res
 fi
-rm -f core conftest.err conftest.$ac_objext \
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
     conftest$ac_exeext
-  if ${ac_cv_search_connect+:} false; then :
+  if test ${ac_cv_search_connect+y}
+then :
   break
 fi
 done
-if ${ac_cv_search_connect+:} false; then :
+if test ${ac_cv_search_connect+y}
+then :
 
-else
+else $as_nop
   ac_cv_search_connect=no
 fi
 rm conftest.$ac_ext
 LIBS=$ac_func_search_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_connect" >&5
-$as_echo "$ac_cv_search_connect" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_connect" >&5
+printf "%s\n" "$ac_cv_search_connect" >&6; }
 ac_res=$ac_cv_search_connect
-if test "$ac_res" != no; then :
+if test "$ac_res" != no
+then :
   test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
   cfitsio_have_socket=1
-else
+else $as_nop
   cfitsio_have_socket=0
 fi
 
 
 if test "$cfitsio_have_nsl" = 1 -a "$cfitsio_have_socket" = 1; then
-   $as_echo "#define HAVE_NET_SERVICES 1" >>confdefs.h
+   printf "%s\n" "#define HAVE_NET_SERVICES 1" >>confdefs.h
 
 fi
 
 # ==================== END OF unix networking SECTION ================
 
 ac_config_files="$ac_config_files Makefile"
 
@@ -5412,16 +5868,16 @@
 # and sets the high bit in the cache file unless we assign to the vars.
 (
   for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
     eval ac_val=\$$ac_var
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      *_cv_*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+printf "%s\n" "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
       *) { eval $ac_var=; unset $ac_var;} ;;
       esac ;;
     esac
@@ -5443,38 +5899,38 @@
     esac |
     sort
 ) |
   sed '
      /^ac_cv_env_/b end
      t clear
      :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     s/^\([^=]*\)=\(.*[{}].*\)$/test ${\1+y} || &/
      t end
      s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
     if test "x$cache_file" != "x/dev/null"; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+printf "%s\n" "$as_me: updating cache $cache_file" >&6;}
       if test ! -f "$cache_file" || test -h "$cache_file"; then
 	cat confcache >"$cache_file"
       else
         case $cache_file in #(
         */* | ?:*)
 	  mv -f confcache "$cache_file"$$ &&
 	  mv -f "$cache_file"$$ "$cache_file" ;; #(
         *)
 	  mv -f confcache "$cache_file" ;;
 	esac
       fi
     fi
   else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+printf "%s\n" "$as_me: not updating unwritable cache $cache_file" >&6;}
   fi
 fi
 rm -f confcache
 
 test "x$prefix" = xNONE && prefix=$ac_default_prefix
 # Let make expand exec_prefix.
 test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
@@ -5519,15 +5975,15 @@
 
 ac_libobjs=
 ac_ltlibobjs=
 U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  ac_i=`printf "%s\n" "$ac_i" | sed "$ac_script"`
   # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
   #    will be set to the directory where LIBOBJS objects are built.
   as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
   as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -5535,16 +5991,16 @@
 
 
 
 : "${CONFIG_STATUS=./config.status}"
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+printf "%s\n" "$as_me: creating $CONFIG_STATUS" >&6;}
 as_write_fail=0
 cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
 #! $SHELL
 # Generated by $as_me.
 # Run this file to recreate the current configuration.
 # Compiler output produced by configure, useful for debugging
 # configure, is in config.log if it exists.
@@ -5559,150 +6015,130 @@
 cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
 ## -------------------- ##
 ## M4sh Initialization. ##
 ## -------------------- ##
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+as_nop=:
+if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
-else
+else $as_nop
   case `(set -o) 2>/dev/null` in #(
   *posix*) :
     set -o posix ;; #(
   *) :
      ;;
 esac
 fi
 
 
+
+# Reset variables that may have inherited troublesome values from
+# the environment.
+
+# IFS needs to be set, to space, tab, and newline, in precisely that order.
+# (If _AS_PATH_WALK were called with IFS unset, it would have the
+# side effect of setting IFS to empty, thus disabling word splitting.)
+# Quoting is to prevent editors from complaining about space-tab.
 as_nl='
 '
 export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
+IFS=" ""	$as_nl"
+
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# Ensure predictable behavior from utilities with locale-dependent output.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# We cannot yet rely on "unset" to work, but we need these variables
+# to be unset--not just set to an empty or harmless value--now, to
+# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
+# also avoids known problems related to "unset" and subshell syntax
+# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
+for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
+do eval test \${$as_var+y} \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+
+# Ensure that fds 0, 1, and 2 are open.
+if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
+if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
+if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi
 
 # The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
+if ${PATH_SEPARATOR+false} :; then
   PATH_SEPARATOR=:
   (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
     (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
       PATH_SEPARATOR=';'
   }
 fi
 
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
 # Find who we are.  Look in the path if we contain no directory separator.
 as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
   done
 IFS=$as_save_IFS
 
      ;;
 esac
 # We did not find ourselves, most probably we were run as `sh COMMAND'
 # in which case we are not to be found in the path.
 if test "x$as_myself" = x; then
   as_myself=$0
 fi
 if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
   exit 1
 fi
 
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
 # as_fn_error STATUS ERROR [LINENO LOG_FD]
 # ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
 # script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
   as_status=$1; test $as_status -eq 0 && as_status=1
   if test "$4"; then
     as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $2" >&2
+  printf "%s\n" "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
 
+
 # as_fn_set_status STATUS
 # -----------------------
 # Set $? to STATUS, without forking.
 as_fn_set_status ()
 {
   return $1
 } # as_fn_set_status
@@ -5721,43 +6157,46 @@
 # ---------------
 # Portably unset VAR.
 as_fn_unset ()
 {
   { eval $1=; unset $1;}
 }
 as_unset=as_fn_unset
+
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
 # advantage of any shell optimizations that allow amortized linear growth over
 # repeated appends, instead of the typical quadratic growth present in naive
 # implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
+then :
   eval 'as_fn_append ()
   {
     eval $1+=\$2
   }'
-else
+else $as_nop
   as_fn_append ()
   {
     eval $1=\$$1\$2
   }
 fi # as_fn_append
 
 # as_fn_arith ARG...
 # ------------------
 # Perform arithmetic evaluation on the ARGs, and store the result in the
 # global $as_val. Take advantage of shells that can avoid forks. The arguments
 # must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
+then :
   eval 'as_fn_arith ()
   {
     as_val=$(( $* ))
   }'
-else
+else $as_nop
   as_fn_arith ()
   {
     as_val=`expr "$@" || test $? -eq 1`
   }
 fi # as_fn_arith
 
 
@@ -5780,15 +6219,15 @@
   as_dirname=false
 fi
 
 as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
+printf "%s\n" X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\/\(\/\/\)$/{
 	    s//\1/
 	    q
@@ -5802,27 +6241,37 @@
 # Avoid depending upon Character Ranges.
 as_cr_letters='abcdefghijklmnopqrstuvwxyz'
 as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
 as_cr_Letters=$as_cr_letters$as_cr_LETTERS
 as_cr_digits='0123456789'
 as_cr_alnum=$as_cr_Letters$as_cr_digits
 
+
+# Determine whether it's possible to make 'echo' print without a newline.
+# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
+# for compatibility with existing Makefiles.
 ECHO_C= ECHO_N= ECHO_T=
 case `echo -n x` in #(((((
 -n*)
   case `echo 'xy\c'` in
   *c*) ECHO_T='	';;	# ECHO_T is single tab character.
   xy)  ECHO_C='\c';;
   *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
        ECHO_T='	';;
   esac;;
 *)
   ECHO_N='-n';;
 esac
 
+# For backward compatibility with old third-party macros, we provide
+# the shell variables $as_echo and $as_echo_n.  New code should use
+# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
+as_echo='printf %s\n'
+as_echo_n='printf %s'
+
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
   rm -f conf$$.dir/conf$$.file
 else
   rm -f conf$$.dir
   mkdir conf$$.dir 2>/dev/null
 fi
@@ -5856,24 +6305,24 @@
   case $as_dir in #(
   -*) as_dir=./$as_dir;;
   esac
   test -d "$as_dir" || eval $as_mkdir_p || {
     as_dirs=
     while :; do
       case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
       *) as_qdir=$as_dir;;
       esac
       as_dirs="'$as_qdir' $as_dirs"
       as_dir=`$as_dirname -- "$as_dir" ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
 	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
+printf "%s\n" X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\(\/\/\)[^/].*/{
 	    s//\1/
 	    q
@@ -5928,15 +6377,15 @@
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.69.  Invocation command line was
+generated by GNU Autoconf 2.71.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
   $ $0 $@
 
@@ -5977,22 +6426,24 @@
 
 Configuration files:
 $config_files
 
 Report bugs to the package provider."
 
 _ACEOF
+ac_cs_config=`printf "%s\n" "$ac_configure_args" | sed "$ac_safe_unquote"`
+ac_cs_config_escaped=`printf "%s\n" "$ac_cs_config" | sed "s/^ //; s/'/'\\\\\\\\''/g"`
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_config='$ac_cs_config_escaped'
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.69,
+configured by $0, generated by GNU Autoconf 2.71,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2012 Free Software Foundation, Inc.
+Copyright (C) 2021 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
 ac_pwd='$ac_pwd'
 srcdir='$srcdir'
 test -n "\$AWK" || AWK=awk
 _ACEOF
@@ -6021,29 +6472,29 @@
   esac
 
   case $ac_option in
   # Handling of the options.
   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
+    printf "%s\n" "$ac_cs_version"; exit ;;
   --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
+    printf "%s\n" "$ac_cs_config"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
     case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *\'*) ac_optarg=`printf "%s\n" "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
     '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
   --he | --h |  --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
+    printf "%s\n" "$ac_cs_usage"; exit ;;
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil | --si | --s)
     ac_cs_silent=: ;;
 
   # This is an error.
   -*) as_fn_error $? "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
@@ -6063,29 +6514,29 @@
 fi
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
   set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  \printf "%s\n" "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
   export CONFIG_SHELL
   exec "\$@"
 fi
 
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 exec 5>>config.log
 {
   echo
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
-  $as_echo "$ac_log"
+  printf "%s\n" "$ac_log"
 } >&5
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
@@ -6102,15 +6553,15 @@
 
 
 # If the user did not use the arguments to specify the items to instantiate,
 # then the envvar interface is used.  Set only those that are not.
 # We use the long form for the default assignment because of an extremely
 # bizarre bug on SunOS 4.1.3.
 if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test ${CONFIG_FILES+y} || CONFIG_FILES=$config_files
 fi
 
 # Have a temporary directory for convenience.  Make it in the build tree
 # simply because there is no reason against having it here, and in addition,
 # creating and moving files from /tmp can sometimes cause problems.
 # Hook for its removal unless debugging.
 # Note that there is a small window in which the directory will not be cleaned:
@@ -6330,33 +6781,33 @@
 	 test -f "$ac_f" ||
 	   case $ac_f in
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
 	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      case $ac_f in *\'*) ac_f=`printf "%s\n" "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
     done
 
     # Let's still pretend it is `configure' which instantiates (i.e., don't
     # use $as_me), people would be surprised to read:
     #    /* config.h.  Generated by config.status.  */
     configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	  printf "%s\n" "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
 	`' by configure.'
     if test x"$ac_file" != x-; then
       configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+printf "%s\n" "$as_me: creating $ac_file" >&6;}
     fi
     # Neutralize special characters interpreted by sed in replacement strings.
     case $configure_input in #(
     *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
+       ac_sed_conf_input=`printf "%s\n" "$configure_input" |
        sed 's/[\\\\&|]/\\\\&/g'`;; #(
     *) ac_sed_conf_input=$configure_input;;
     esac
 
     case $ac_tag in
     *:-:* | *:-) cat >"$ac_tmp/stdin" \
       || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
@@ -6365,15 +6816,15 @@
   esac
 
   ac_dir=`$as_dirname -- "$ac_file" ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$ac_file" : 'X\(//\)[^/]' \| \
 	 X"$ac_file" : 'X\(//\)$' \| \
 	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
+printf "%s\n" X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\(\/\/\)[^/].*/{
 	    s//\1/
 	    q
@@ -6389,17 +6840,17 @@
 	  s/.*/./; q'`
   as_dir="$ac_dir"; as_fn_mkdir_p
   ac_builddir=.
 
 case "$ac_dir" in
 .) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
 *)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  ac_dir_suffix=/`printf "%s\n" "$ac_dir" | sed 's|^\.[\\/]||'`
   # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  ac_top_builddir_sub=`printf "%s\n" "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
   case $ac_top_builddir_sub in
   "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
   *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
   esac ;;
 esac
 ac_abs_top_builddir=$ac_pwd
 ac_abs_builddir=$ac_pwd$ac_dir_suffix
@@ -6444,16 +6895,16 @@
 /@docdir@/p
 /@infodir@/p
 /@localedir@/p
 /@mandir@/p'
 case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
 *datarootdir*) ac_datarootdir_seen=yes;;
 *@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+printf "%s\n" "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
   ac_datarootdir_hack='
   s&@datadir@&$datadir&g
   s&@docdir@&$docdir&g
   s&@infodir@&$infodir&g
   s&@localedir@&$localedir&g
@@ -6487,17 +6938,17 @@
 eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
   >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
   { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
       "$ac_tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+printf "%s\n" "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&2;}
 
   rm -f "$ac_tmp/stdin"
   case $ac_file in
   -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
   *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
   esac \
@@ -6536,16 +6987,16 @@
   $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
   $ac_cs_success || as_fn_exit 1
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+printf "%s\n" "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
 ac_config_files="$ac_config_files cfitsio.pc"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -6569,16 +7020,16 @@
 # and sets the high bit in the cache file unless we assign to the vars.
 (
   for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
     eval ac_val=\$$ac_var
     case $ac_val in #(
     *${as_nl}*)
       case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      *_cv_*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+printf "%s\n" "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
       esac
       case $ac_var in #(
       _ | IFS | as_nl) ;; #(
       BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
       *) { eval $ac_var=; unset $ac_var;} ;;
       esac ;;
     esac
@@ -6600,38 +7051,38 @@
     esac |
     sort
 ) |
   sed '
      /^ac_cv_env_/b end
      t clear
      :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     s/^\([^=]*\)=\(.*[{}].*\)$/test ${\1+y} || &/
      t end
      s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
     if test "x$cache_file" != "x/dev/null"; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+printf "%s\n" "$as_me: updating cache $cache_file" >&6;}
       if test ! -f "$cache_file" || test -h "$cache_file"; then
 	cat confcache >"$cache_file"
       else
         case $cache_file in #(
         */* | ?:*)
 	  mv -f confcache "$cache_file"$$ &&
 	  mv -f "$cache_file"$$ "$cache_file" ;; #(
         *)
 	  mv -f confcache "$cache_file" ;;
 	esac
       fi
     fi
   else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+printf "%s\n" "$as_me: not updating unwritable cache $cache_file" >&6;}
   fi
 fi
 rm -f confcache
 
 test "x$prefix" = xNONE && prefix=$ac_default_prefix
 # Let make expand exec_prefix.
 test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
@@ -6676,15 +7127,15 @@
 
 ac_libobjs=
 ac_ltlibobjs=
 U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  ac_i=`printf "%s\n" "$ac_i" | sed "$ac_script"`
   # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
   #    will be set to the directory where LIBOBJS objects are built.
   as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
   as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -6692,16 +7143,16 @@
 
 
 
 : "${CONFIG_STATUS=./config.status}"
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+printf "%s\n" "$as_me: creating $CONFIG_STATUS" >&6;}
 as_write_fail=0
 cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
 #! $SHELL
 # Generated by $as_me.
 # Run this file to recreate the current configuration.
 # Compiler output produced by configure, useful for debugging
 # configure, is in config.log if it exists.
@@ -6716,150 +7167,130 @@
 cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
 ## -------------------- ##
 ## M4sh Initialization. ##
 ## -------------------- ##
 
 # Be more Bourne compatible
 DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+as_nop=:
+if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
   emulate sh
   NULLCMD=:
   # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
   setopt NO_GLOB_SUBST
-else
+else $as_nop
   case `(set -o) 2>/dev/null` in #(
   *posix*) :
     set -o posix ;; #(
   *) :
      ;;
 esac
 fi
 
 
+
+# Reset variables that may have inherited troublesome values from
+# the environment.
+
+# IFS needs to be set, to space, tab, and newline, in precisely that order.
+# (If _AS_PATH_WALK were called with IFS unset, it would have the
+# side effect of setting IFS to empty, thus disabling word splitting.)
+# Quoting is to prevent editors from complaining about space-tab.
 as_nl='
 '
 export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
+IFS=" ""	$as_nl"
+
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# Ensure predictable behavior from utilities with locale-dependent output.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# We cannot yet rely on "unset" to work, but we need these variables
+# to be unset--not just set to an empty or harmless value--now, to
+# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
+# also avoids known problems related to "unset" and subshell syntax
+# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
+for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
+do eval test \${$as_var+y} \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+
+# Ensure that fds 0, 1, and 2 are open.
+if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
+if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
+if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi
 
 # The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
+if ${PATH_SEPARATOR+false} :; then
   PATH_SEPARATOR=:
   (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
     (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
       PATH_SEPARATOR=';'
   }
 fi
 
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
 # Find who we are.  Look in the path if we contain no directory separator.
 as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
   done
 IFS=$as_save_IFS
 
      ;;
 esac
 # We did not find ourselves, most probably we were run as `sh COMMAND'
 # in which case we are not to be found in the path.
 if test "x$as_myself" = x; then
   as_myself=$0
 fi
 if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
   exit 1
 fi
 
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
 # as_fn_error STATUS ERROR [LINENO LOG_FD]
 # ----------------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
 # script with STATUS, using 1 if that was 0.
 as_fn_error ()
 {
   as_status=$1; test $as_status -eq 0 && as_status=1
   if test "$4"; then
     as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
   fi
-  $as_echo "$as_me: error: $2" >&2
+  printf "%s\n" "$as_me: error: $2" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
 
+
 # as_fn_set_status STATUS
 # -----------------------
 # Set $? to STATUS, without forking.
 as_fn_set_status ()
 {
   return $1
 } # as_fn_set_status
@@ -6878,43 +7309,46 @@
 # ---------------
 # Portably unset VAR.
 as_fn_unset ()
 {
   { eval $1=; unset $1;}
 }
 as_unset=as_fn_unset
+
 # as_fn_append VAR VALUE
 # ----------------------
 # Append the text in VALUE to the end of the definition contained in VAR. Take
 # advantage of any shell optimizations that allow amortized linear growth over
 # repeated appends, instead of the typical quadratic growth present in naive
 # implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
+then :
   eval 'as_fn_append ()
   {
     eval $1+=\$2
   }'
-else
+else $as_nop
   as_fn_append ()
   {
     eval $1=\$$1\$2
   }
 fi # as_fn_append
 
 # as_fn_arith ARG...
 # ------------------
 # Perform arithmetic evaluation on the ARGs, and store the result in the
 # global $as_val. Take advantage of shells that can avoid forks. The arguments
 # must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
+then :
   eval 'as_fn_arith ()
   {
     as_val=$(( $* ))
   }'
-else
+else $as_nop
   as_fn_arith ()
   {
     as_val=`expr "$@" || test $? -eq 1`
   }
 fi # as_fn_arith
 
 
@@ -6937,15 +7371,15 @@
   as_dirname=false
 fi
 
 as_me=`$as_basename -- "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
 	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
+printf "%s\n" X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\/\(\/\/\)$/{
 	    s//\1/
 	    q
@@ -6959,27 +7393,37 @@
 # Avoid depending upon Character Ranges.
 as_cr_letters='abcdefghijklmnopqrstuvwxyz'
 as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
 as_cr_Letters=$as_cr_letters$as_cr_LETTERS
 as_cr_digits='0123456789'
 as_cr_alnum=$as_cr_Letters$as_cr_digits
 
+
+# Determine whether it's possible to make 'echo' print without a newline.
+# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
+# for compatibility with existing Makefiles.
 ECHO_C= ECHO_N= ECHO_T=
 case `echo -n x` in #(((((
 -n*)
   case `echo 'xy\c'` in
   *c*) ECHO_T='	';;	# ECHO_T is single tab character.
   xy)  ECHO_C='\c';;
   *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
        ECHO_T='	';;
   esac;;
 *)
   ECHO_N='-n';;
 esac
 
+# For backward compatibility with old third-party macros, we provide
+# the shell variables $as_echo and $as_echo_n.  New code should use
+# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
+as_echo='printf %s\n'
+as_echo_n='printf %s'
+
 rm -f conf$$ conf$$.exe conf$$.file
 if test -d conf$$.dir; then
   rm -f conf$$.dir/conf$$.file
 else
   rm -f conf$$.dir
   mkdir conf$$.dir 2>/dev/null
 fi
@@ -7013,24 +7457,24 @@
   case $as_dir in #(
   -*) as_dir=./$as_dir;;
   esac
   test -d "$as_dir" || eval $as_mkdir_p || {
     as_dirs=
     while :; do
       case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
       *) as_qdir=$as_dir;;
       esac
       as_dirs="'$as_qdir' $as_dirs"
       as_dir=`$as_dirname -- "$as_dir" ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
 	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
+printf "%s\n" X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\(\/\/\)[^/].*/{
 	    s//\1/
 	    q
@@ -7085,15 +7529,15 @@
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # Save the log message, to keep $0 and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.69.  Invocation command line was
+generated by GNU Autoconf 2.71.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
   $ $0 $@
 
@@ -7134,22 +7578,24 @@
 
 Configuration files:
 $config_files
 
 Report bugs to the package provider."
 
 _ACEOF
+ac_cs_config=`printf "%s\n" "$ac_configure_args" | sed "$ac_safe_unquote"`
+ac_cs_config_escaped=`printf "%s\n" "$ac_cs_config" | sed "s/^ //; s/'/'\\\\\\\\''/g"`
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_config='$ac_cs_config_escaped'
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.69,
+configured by $0, generated by GNU Autoconf 2.71,
   with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2012 Free Software Foundation, Inc.
+Copyright (C) 2021 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
 ac_pwd='$ac_pwd'
 srcdir='$srcdir'
 test -n "\$AWK" || AWK=awk
 _ACEOF
@@ -7178,29 +7624,29 @@
   esac
 
   case $ac_option in
   # Handling of the options.
   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
+    printf "%s\n" "$ac_cs_version"; exit ;;
   --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
+    printf "%s\n" "$ac_cs_config"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
     case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *\'*) ac_optarg=`printf "%s\n" "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
     '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
   --he | --h |  --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
+    printf "%s\n" "$ac_cs_usage"; exit ;;
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil | --si | --s)
     ac_cs_silent=: ;;
 
   # This is an error.
   -*) as_fn_error $? "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
@@ -7220,29 +7666,29 @@
 fi
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 if \$ac_cs_recheck; then
   set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
   shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  \printf "%s\n" "running CONFIG_SHELL=$SHELL \$*" >&6
   CONFIG_SHELL='$SHELL'
   export CONFIG_SHELL
   exec "\$@"
 fi
 
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 exec 5>>config.log
 {
   echo
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
-  $as_echo "$ac_log"
+  printf "%s\n" "$ac_log"
 } >&5
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
@@ -7260,15 +7706,15 @@
 
 
 # If the user did not use the arguments to specify the items to instantiate,
 # then the envvar interface is used.  Set only those that are not.
 # We use the long form for the default assignment because of an extremely
 # bizarre bug on SunOS 4.1.3.
 if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test ${CONFIG_FILES+y} || CONFIG_FILES=$config_files
 fi
 
 # Have a temporary directory for convenience.  Make it in the build tree
 # simply because there is no reason against having it here, and in addition,
 # creating and moving files from /tmp can sometimes cause problems.
 # Hook for its removal unless debugging.
 # Note that there is a small window in which the directory will not be cleaned:
@@ -7488,33 +7934,33 @@
 	 test -f "$ac_f" ||
 	   case $ac_f in
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
 	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      case $ac_f in *\'*) ac_f=`printf "%s\n" "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
     done
 
     # Let's still pretend it is `configure' which instantiates (i.e., don't
     # use $as_me), people would be surprised to read:
     #    /* config.h.  Generated by config.status.  */
     configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	  printf "%s\n" "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
 	`' by configure.'
     if test x"$ac_file" != x-; then
       configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+printf "%s\n" "$as_me: creating $ac_file" >&6;}
     fi
     # Neutralize special characters interpreted by sed in replacement strings.
     case $configure_input in #(
     *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
+       ac_sed_conf_input=`printf "%s\n" "$configure_input" |
        sed 's/[\\\\&|]/\\\\&/g'`;; #(
     *) ac_sed_conf_input=$configure_input;;
     esac
 
     case $ac_tag in
     *:-:* | *:-) cat >"$ac_tmp/stdin" \
       || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
@@ -7523,15 +7969,15 @@
   esac
 
   ac_dir=`$as_dirname -- "$ac_file" ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$ac_file" : 'X\(//\)[^/]' \| \
 	 X"$ac_file" : 'X\(//\)$' \| \
 	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
+printf "%s\n" X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
 	    s//\1/
 	    q
 	  }
 	  /^X\(\/\/\)[^/].*/{
 	    s//\1/
 	    q
@@ -7547,17 +7993,17 @@
 	  s/.*/./; q'`
   as_dir="$ac_dir"; as_fn_mkdir_p
   ac_builddir=.
 
 case "$ac_dir" in
 .) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
 *)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  ac_dir_suffix=/`printf "%s\n" "$ac_dir" | sed 's|^\.[\\/]||'`
   # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  ac_top_builddir_sub=`printf "%s\n" "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
   case $ac_top_builddir_sub in
   "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
   *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
   esac ;;
 esac
 ac_abs_top_builddir=$ac_pwd
 ac_abs_builddir=$ac_pwd$ac_dir_suffix
@@ -7602,16 +8048,16 @@
 /@docdir@/p
 /@infodir@/p
 /@localedir@/p
 /@mandir@/p'
 case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
 *datarootdir*) ac_datarootdir_seen=yes;;
 *@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+printf "%s\n" "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
   ac_datarootdir_hack='
   s&@datadir@&$datadir&g
   s&@docdir@&$docdir&g
   s&@infodir@&$infodir&g
   s&@localedir@&$localedir&g
@@ -7645,17 +8091,17 @@
 eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
   >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
   { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
   { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
       "$ac_tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+printf "%s\n" "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
 which seems to be undefined.  Please make sure it is defined" >&2;}
 
   rm -f "$ac_tmp/stdin"
   case $ac_file in
   -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
   *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
   esac \
@@ -7694,22 +8140,23 @@
   $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
   $ac_cs_success || as_fn_exit 1
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+printf "%s\n" "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
 fi
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
-$as_echo "" >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     Congratulations, Makefile update was successful." >&5
-$as_echo "    Congratulations, Makefile update was successful." >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result:     You may want to run \"make\" now." >&5
-$as_echo "    You may want to run \"make\" now." >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: " >&5
-$as_echo "" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: " >&5
+printf "%s\n" "" >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result:     Congratulations, Makefile update was successful." >&5
+printf "%s\n" "    Congratulations, Makefile update was successful." >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result:     You may want to run make now." >&5
+printf "%s\n" "    You may want to run make now." >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: " >&5
+printf "%s\n" "" >&6; }
+
```

### Comparing `fitsio-1.1.9/cfitsio3490/configure.in` & `fitsio-1.2.0/cfitsio-4.2.0/configure.in`

 * *Files 2% similar despite different names*

```diff
@@ -10,18 +10,19 @@
 AC_INIT
 AC_CONFIG_SRCDIR([fitscore.c])
 AC_CANONICAL_TARGET([])
 
 #--------------------------------------------------------------------
 # CFITSIO Version Numbers:
 #--------------------------------------------------------------------
-AC_SUBST(CFITSIO_MAJOR,3)
-AC_SUBST(CFITSIO_MINOR,49)
+AC_SUBST(CFITSIO_MAJOR,4)
+AC_SUBST(CFITSIO_MINOR,2)
+AC_SUBST(CFITSIO_MICRO,0)
 # Increment soname each time the interface changes:
-AC_SUBST(CFITSIO_SONAME,9)
+AC_SUBST(CFITSIO_SONAME,10)
 
 #--------------------------------------------------------------------
 # Command options
 #--------------------------------------------------------------------
 
 ADD_CURL=yes
 AC_ARG_ENABLE(
@@ -48,14 +49,21 @@
 
 AC_ARG_ENABLE(
   ssse3,
   [AS_HELP_STRING([--enable-ssse3],[Enable use of instructions in the SSSE3 extended instruction set])],
   [ if test $enableval = yes; then SSE_FLAGS="$SSE_FLAGS -mssse3"; fi ]
 )
 
+SYMBOLS=""
+AC_ARG_ENABLE(
+  symbols,
+  [AS_HELP_STRING([--enable-symbols],[Enable debugging symbols by turning optimization off])],
+  [ if test $enableval = yes; then SYMBOLS=yes; fi ]
+)
+
 # Define BUILD_HERA when building for HERA project to activate code in
 # drvrfile.c (by way of fitsio2.h):
 AC_ARG_ENABLE(
   hera,
   [AS_HELP_STRING([--enable-hera],[Build for HERA (ASD use only)])],
   [ if test $enableval = yes; then BUILD_HERA=yes; fi ]
 )
@@ -107,14 +115,26 @@
             GSIFTP_FLAVOUR="${withval}"
         fi
         AC_DEFINE(GSIFTP_FLAVOUR,1,[Define Globus Toolkit architecture])
     fi
   ]
 )
 
+# Optionally disable check for zlib:
+ZLIB_CHECK=yes
+AC_ARG_WITH(
+  zlib-check,
+  [AS_HELP_STRING([--without-zlib-check],[Disable check for zlib compression library e.g. for cross-compilers])],
+  [ if test "x$withval" = "xno"; then
+       AC_MSG_WARN(cfitsio: ZLIB is required!)
+       ZLIB_CHECK=no
+    fi
+  ]
+)
+
 #--------------------------------------------------------------------
 # Check for install location prefix
 #--------------------------------------------------------------------
 
 AC_PREFIX_DEFAULT(`pwd`)
 
 # make will complain about duplicate targets for the install directories
@@ -186,14 +206,29 @@
 # Try first to find a proprietary C compiler, then gcc
 if test "x$EXT" != xcygwin && test "x$EXT" != xdarwin && test "x$EXT" != xlnx && test "x$EXT" != xmingw32; then
   if test "x$CC" = x; then
     AC_CHECK_PROGS(CC, cc)
   fi
 fi
 AC_PROG_CC
+
+#-------------------------------------------------------------------------------
+# Handle --enable-symbols=yes
+#-------------------------------------------------------------------------------
+
+# Remove existing/default optimization:
+if test "x$SYMBOLS" = "xyes"; then
+   changequote(,)
+   COPT_DEFAULT=`echo $CFLAGS | tr " " "\012" | grep "^\-O[0-9]"`
+   changequote([,])
+   CFLAGS=`echo $CFLAGS | sed "s:$COPT_DEFAULT::g"`
+fi
+
+#-------------------------------------------------------------------------------
+
 LDFLAGS="$CFLAGS"
 LDFLAGS_BIN="$LDFLAGS"
 
 if test "x$FC" = "xnone" ; then
   AC_MSG_NOTICE(cfitsio: == Fortran compiler search has been overridden)
   AC_MSG_NOTICE(cfitsio: == Cfitsio will be built without Fortran wrapper support)
   FC=
@@ -407,41 +442,41 @@
   cygwin|mingw32)
     SHLIB_LD="$CC -shared"
     SHLIB_SUFFIX=".dll"
     ;;
   darwin)
     changequote(,)
     SHLIB_SUFFIX=".dylib"
-    CFITSIO_SHLIB="lib\${PACKAGE}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}\${SHLIB_SUFFIX}"
+    CFITSIO_SHLIB="lib\${PACKAGE}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}\${SHLIB_SUFFIX}"
     CFITSIO_SHLIB_SONAME="lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX}"
     case $host in
         *darwin[56789]*)
-            SHLIB_LD="$CC -dynamiclib -install_name lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+            SHLIB_LD="$CC -dynamiclib -install_name lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
             ;;
         *)
             # Build 'Universal' binaries (i386 & x86_64 architectures) and
             # use rpath token on Darwin 10.x or newer:
-            SHLIB_LD="$CC -dynamiclib $C_UNIV_SWITCH -headerpad_max_install_names -install_name @rpath/lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+            SHLIB_LD="$CC -dynamiclib $C_UNIV_SWITCH -headerpad_max_install_names -install_name @rpath/lib\${PACKAGE}.\${CFITSIO_SONAME}\${SHLIB_SUFFIX} -compatibility_version \${CFITSIO_SONAME} -current_version \${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
             ;;
     esac
     changequote([,])
     lhea_shlib_cflags="-fPIC -fno-common"
     ;;
   haiku)
     SHLIB_LD=":"
-    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
     CFITSIO_SHLIB_SONAME="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}"
     ;;
   hpu)
     SHLIB_LD="ld -b" 
     SHLIB_SUFFIX=".sl"
     ;;
   lnx)
     SHLIB_LD=":"
-    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}"
+    CFITSIO_SHLIB="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}.\${CFITSIO_MAJOR}.\${CFITSIO_MINOR}.\${CFITSIO_MICRO}"
     CFITSIO_SHLIB_SONAME="lib\${PACKAGE}\${SHLIB_SUFFIX}.\${CFITSIO_SONAME}"
     ;;
   osf)
     SHLIB_LD="ld -shared -expect_unresolved '*'"
     LD_FLAGS="-taso"
     ;;
   sol)
@@ -503,14 +538,19 @@
   #  AC_CHECK_LIB([curl],[main],[],
   #       [AC_MSG_WARN(Not building curl support for CFITSIO)])
   #  AC_CHECK_HEADER(curl.h,[])
   fi
 fi
 AC_SUBST(LIBS_CURL)
 
+# ZLIB (required):
+if test "x$ZLIB_CHECK" = xyes; then
+   AC_CHECK_LIB([z], [inflateEnd], [],[AC_MSG_ERROR(Unable to locate zlib compression library)])
+fi
+
 # GSIFTP flags:
 if test "x$GSIFTP_PATH" != x -a "x$GSIFTP_FLAVOUR" != x; then
    CFLAGS="$CFLAGS -I${GSIFTP_PATH}/include/${GSIFTP_FLAVOUR}"
    LIBS="$LIBS -L${GSIFTP_PATH}/lib -lglobus_ftp_client_${GSIFTP_FLAVOUR}"
 fi
 
 # BZIP2 flags:
@@ -661,10 +701,10 @@
 AC_OUTPUT
 AC_CONFIG_FILES([cfitsio.pc])
 AC_OUTPUT
 
 
 AC_MSG_RESULT([])
 AC_MSG_RESULT([    Congratulations, Makefile update was successful.])
-AC_MSG_RESULT([    You may want to run \"make\" now.])
+AC_MSG_RESULT([    You may want to run make now.])
 AC_MSG_RESULT([])
```

### Comparing `fitsio-1.1.9/cfitsio3490/cookbook.c` & `fitsio-1.2.0/cfitsio-4.2.0/cookbook.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/cookbook.f` & `fitsio-1.2.0/cfitsio-4.2.0/cookbook.f`

 * *Files 0% similar despite different names*

```diff
@@ -629,15 +629,15 @@
 C  This example reads and prints out all the data in the ASCII and
 C  the binary tables that were previously created by WRITEASCII and
 C  WRITEBINTABLE.  Note that the exact same FITSIO routines are
 C  used to read both types of tables.
 
       integer status,unit,readwrite,blocksize,hdutype,ntable
       integer felem,nelems,nullj,diameter,nfound,irow,colnum
-      real nulle,density
+      real nulle,density(1)
       character filename*40,nullstr*1,name*8,ttype(3)*10
       logical anynull
 
 C  The STATUS parameter must always be initialized.
       status=0
 
 C  Get an unused Logical Unit Number to use to open the FITS file.
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/cfitsio.tex` & `fitsio-1.2.0/cfitsio-4.2.0/docs/cfitsio.tex`

 * *Files 1% similar despite different names*

```diff
@@ -27,30 +27,30 @@
 \end{center}
 \begin{center}
 {\LARGE \bf for C Programmers}\\
 \end{center}
 \medskip
 \medskip
 \begin{center}
-{\Large Version 3.4 \\}
+{\Large Version 4.2 \\}
 \end{center}
 \bigskip
 \vskip 2.5cm
 \begin{center}
 {HEASARC\\
 Code 662\\
 Goddard Space Flight Center\\
 Greenbelt, MD 20771\\
 USA}
 \end{center}
 
 \vfill
 \bigskip
 \begin{center}
-{\Large Aug 2020\\}
+{\Large Nov 2022\\}
 \end{center}
 \vfill
 \end{titlepage}
 
 \clearpage
 
 \tableofcontents
@@ -429,20 +429,15 @@
 absence of leading zeros, or 3 digit exponents in numbers,
 which can be ignored).
 
 The Fortran wrappers in CFITSIO may be tested with the testf77
 program on Unix systems with:
 
 \begin{verbatim}
-    % f77 -o testf77 testf77.f -L. -lcfitsio -lnsl -lsocket
-  or
-    % f77 -f -o testf77 testf77.f -L. -lcfitsio    (under SUN O/S)
-  or
-    % f77 -o testf77 testf77.f -Wl,-L. -lcfitsio -lm -lnsl -lsocket (HP/UX)
-
+    % gfortran -o testf77 testf77.f -L. -lcfitsio -lz -lcurl
     % testf77 > testf77.lis
     % diff testf77.lis testf77.out
     % cmp testf77.fit testf77.std
 \end{verbatim}
 On machines running SUN O/S, Fortran programs must be compiled with the
 '-f' option to force double precision variables to be aligned on 8-byte
 boundarys to make the fortran-declared variables compatible with C.  A
@@ -1106,15 +1101,15 @@
 2147483648 for unsigned 32-bit integers, and TFORMn = '1K' and TZEROn =
 9223372036854775808 for unsigned 64-bit integers).  The 'S' TFORMn value tells
 CFITSIO to write the keywords appropriate for a signed 8-bit byte column
 with TFORMn = '1B' and TZEROn = -128.  The calls to fits\_write\_col
 then write the arrays of unsigned integer values to the columns.
 
 
-\section{Dealing with Character Strings}
+\section{Dealing with Character Strings \label{character-strings}}
 
 The character string values in a FITS header or in an ASCII column in a
 FITS table extension are generally padded out with non-significant
 space characters (ASCII 32) to fill up the header record or the column
 width.  When reading a FITS string value, the CFITSIO routines will
 strip off these non-significant trailing spaces and will return a
 null-terminated string value containing only the significant
@@ -1126,14 +1121,25 @@
 significant.
 
 Similarly, when writing string values to a FITS file the
 CFITSIO routines expect to get a null-terminated string as input;
 CFITSIO will pad the string with blanks if necessary when writing it
 to the FITS file.
 
+The FITS standard does not require trailing spaces to be treated in
+this way, but it does allow a more seamless transition from the
+FORTRAN FITS world where trailing spaces are often treated as
+insignificant.  Users who wish the greatest fidelity when transferring
+strings can use the \verb+_byt+ variants of column readers and writers
+(functions fits\_\{read,write\}\_col\_byt).  These routines will
+transfer the raw fixed-length vectors of character bytes of the
+column, including any trailing blanks of course. The \verb+_byt+
+variants make no attempt to null-terminate any elements.  A NULL
+string would be indicated by its first character being a NUL byte.
+
 When calling CFITSIO routines that return a character string it is
 vital that the size of the char array be large enough to hold the
 entire string of characters, otherwise CFITSIO will overwrite whatever
 memory locations follow the char array, possibly causing the program to
 execute incorrectly.  This type of error can be difficult to debug, so
 programmers should always ensure that the char arrays are allocated
 enough space to hold the longest possible string, {\bf including} the
@@ -1657,15 +1663,15 @@
 \item[1 ] Open an existing data file. \label{ffopen}
 
 
 \begin{verbatim}
 int fits_open_file / ffopen
     (fitsfile **fptr, char *filename, int iomode, > int *status)
 
-int fits_open_diskfile / ffdkopen
+int fits_open_diskfile / ffdkopn
     (fitsfile **fptr, char *filename, int iomode, > int *status)
 
 int fits_open_data / ffdopn
     (fitsfile **fptr, char *filename, int iomode, > int *status)
 
 int fits_open_table / fftopn
     (fitsfile **fptr, char *filename, int iomode, > int *status)
@@ -2766,15 +2772,17 @@
 compression factors.
 
 When floating point images are being quantized, one must also specify what
 quantization method is to be used.  The default algorithm is called
 ``SUBTRACTIVE\_DITHER\_1''.  A second variation called ``SUBTRACTIVE\_DITHER\_2''
 is also available, which does the same thing except that any pixels with a
 value of 0.0 are not dithered and instead the zero values are exactly
-preserved in the compressed image.  One may also turn off dithering
+preserved in the compressed image.  This is intended for the special case
+where ``bad pixels'' in the image have been artifically set to zero to indicate that they have no valid value.  It is not currently supported with HCOMPRESS, 
+and if requested while using HCOMPRESS, it will be replaced with ``SUBTRACTIVE\_DITHER\_1''.  One may also turn off dithering
 completely with the ``NO\_DITHER'' option, but this is not recommended
 because it can cause larger systematic errors in measurements of the
 position or brightness of objects in the compressed image.
 
 There are 3 methods for specifying all the parameters needed to write a FITS
 image in the tile compressed format.  The parameters may either be specified
 at run time as part of the file name of the output compressed FITS file, or
@@ -2994,15 +3002,15 @@
     copying zero or more rows from the input table.  This is useful in
     cases where a task will filter rows from the input before transferring
     to the output, so a ``pristine'' output table with zero rows is
     desired to start.  The input file must be open and point to a binary table
     extension.  The output file must be open for writing; a new
     extension is created with the same table structure as the input.
     Optionally, a range of nrows may be copied starting from firstrow,
-    similar to fits_copy_rows(). The value nrows may be 0.  Note that
+    similar to fits\_copy\_rows(). The value nrows may be 0.  Note that
     the first row in a table is at row = 1.
    \label{ffcpht}
 \end{description}
 
 \begin{verbatim}
   int fits_copy_hdutab / ffcpht
       (fitsfile *infptr, fitsfile *outfptr, LONGLONG firstrow,
@@ -3297,21 +3305,30 @@
 \end{verbatim}
 
 \begin{description}
 \item[4 ] Copy 'nrows' consecutive rows from one table to another, beginning
     with row 'firstrow'.  These rows will be appended to any existing
     rows in the output table.
    Note that the first row in a table is at row = 1. 
-   \label{ffcprw}
+
+   The \verb|fits_copy_selrows| form copies only selected rows to the output.
+   Which rows are transferred is determined by an array of flags, \verb|row_status[]|,
+   which could be returned by \verb|fits_find_rows()| or constructed by the user.
+   FITS row N is copied if \verb|row_status[N-first_row]| is non-zero.  
+   \label{ffcprw} \label{ffcpsr}
 \end{description}
 
 \begin{verbatim}
   int fits_copy_rows / ffcprw
       (fitsfile *infptr, fitsfile *outfptr, LONGLONG firstrow,
        LONGLONG nrows, > int *status);
+
+  int fits_copy_selrows / ffcpsr
+      (fitsfile *infptr, fitsfile *outfptr, LONGLONG firstrow,
+       LONGLONG nrows, char *row_status, > int *status);
 \end{verbatim}
 
 \begin{description}
 \item[5 ] Modify the vector length of a binary table column (e.g.,
     change a column from TFORMn = '1E' to '20E').  The vector
    length may be increased or decreased from the current value. \label{ffmvec}
 \end{description}
@@ -3354,22 +3371,32 @@
 Note that within the context of these routines, the TSTRING data type
 corresponds to a C 'char**' data type, i.e., a pointer to an array of
 pointers to an array of characters.  This is different from the keyword
 reading and writing routines where TSTRING corresponds to a C 'char*'
 data type, i.e., a single pointer to an array of characters.  When
 reading strings from a table, the char arrays obviously must have been
 allocated long enough to hold the whole FITS table string.
+See section \ref{character-strings}
+(``Dealing with Character Strings'') for more information.
+
+For complex and double complex data types, \verb+nelements+ is the number
+of numerical pairs; the number of floats or doubles stored by
+\+array+ must be \verb+2*nelements+.
+
+For the logical data (TLOGICAL), the C storage type is a \verb+char+
+single-byte character.  A FITS value of `\verb+T+'rue reads as 1 and
+`\verb+F+' reads as 0; other non-FITS characters are preserved untranslated.
 
 Numerical data values are automatically scaled by the TSCALn and TZEROn
 keyword values (if they exist).
 
-In the case of binary tables with vector elements, the 'felem'
+In the case of binary tables with vector elements, the \verb+firstelem+
 parameter defines the starting element (beginning with 1, not 0) within
 the cell (a cell is defined as the intersection of a row and a column
-and may contain a single value or a vector of values).  The felem
+and may contain a single value or a vector of values).  The \verb+firstelem+
 parameter is ignored when dealing with ASCII tables. Similarly, in the
 case of binary tables the 'nelements' parameter specifies the total
 number of vector values to be read or written (continuing on subsequent
 rows if required) and not the number of table cells.
 
 
 \begin{description}
@@ -3385,15 +3412,25 @@
    For floating point columns  the special IEEE NaN (Not-a-Number)
    value will be written into the FITS file.  If a null pointer is
    entered for nulval, then the null value is ignored and this routine
    behaves the same as the first routine.  The third routine
    simply writes undefined pixel values to the column.  The fourth routine
    fills every column in the table with null values, in the specified
    rows (ignoring any columns that do not have a defined null value).
-   \label{ffpcl} \label{ffpcn} \label{ffpclu}
+
+   The \verb+fits_write_cols()+ variant writes multiple columns in a
+   single pass, which may be significantly faster for large data
+   files.  The ``chunk'' size is determined automatically based upon
+   CFITSIO's buffer sizes.  Only whole rows can be written, of any
+   type except TBIT or TSTRING.  For this variant, datatype, colnum,
+   array and nulval are arrays of the equivalent single-column
+   parameter (i.e. \verb+datatype[i]+ is the data type of column
+   \verb+i+). 
+
+   \label{ffpcl} \label{ffpcn} \label{ffpclu} \label{ffpcln}
 
 \begin{verbatim}
   int fits_write_col / ffpcl
       (fitsfile *fptr, int datatype, int colnum, LONGLONG firstrow,
        LONGLONG firstelem, LONGLONG nelements, DTYPE *array, > int *status)
 
   int fits_write_colnull / ffpcn
@@ -3403,26 +3440,35 @@
 
    int fits_write_col_null / ffpclu
        (fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
         LONGLONG nelements, > int *status)
 
    int fits_write_nullrows / ffprwu
        (fitsfile *fptr, LONGLONG firstrow, LONGLONG nelements, > int *status)
+
+  int fits_write_cols / ffpcln
+      (fitsfile *fptr, int ncols, int *datatype, int *colnum, LONGLONG firstrow, 
+       LONGLONG nrows, DTYPE **array, DTYPE **nulval, int *status)
+
 \end{verbatim}
 
 \begin{description}
 \item[2 ] Read elements from an ASCII or binary table column.  The data type
-    parameter specifies the data type of the `nulval' and `array'  pointers;
+    parameter specifies the data type of the `nulval' and `array'  pointers.
+    The caller is required to allocate the storage of \verb+array+ before calling.  
     Undefined array elements will be returned with a value = *nullval,
     (note that this parameter gives the address of the null value, not the
     null value itself) unless nulval = 0 or *nulval = 0, in which case
     no checking for undefined pixels will be performed.  The second
     routine is similar except that any undefined pixels will have the
     corresponding nullarray element set equal to TRUE (= 1).
 
+    Reading data as TSTRING values is different than for other data types
+    as described above.
+
     Any column, regardless of it's intrinsic data type, may be read as a
     string.  It should be noted however that reading a numeric column
     as a string is 10 - 100 times slower than reading the same column
     as a number due to the large overhead in constructing the formatted
     strings.  The display format of the returned strings will be
     determined by the TDISPn keyword, if it exists, otherwise by the
     data type of the column.  The length of the returned strings (not
@@ -3438,25 +3484,38 @@
     Ew.d   Exponential floating point
     Dw.d   Exponential floating point
     Gw.d   General; uses Fw.d if significance not lost, else Ew.d
 \end{verbatim}
     where w is the width in characters of the displayed values, m is the minimum
     number of digits displayed, and d is the number of digits to the right of the
     decimal.  The .m field is optional.
-   \label{ffgcv} \label{ffgcf}
+
+   The \verb+fits_read_cols()+ variant read multiple columns in a
+   single pass, which may be significantly faster for large data
+   files.  The ``chunk'' size is determined automatically based upon
+   CFITSIO's buffer sizes.  Only whole rows can be read, of any type
+   except TBIT or TSTRING.  For this variant, datatype, colnum, array
+   and nulval are arrays of the equivalent single-column parameter
+   (i.e. \verb+datatype[i]+ is the data type of column \verb+i+).
+
+   \label{ffgcv} \label{ffgcf} \label{ffgcvn}
 \end{description}
 
 \begin{verbatim}
   int fits_read_col / ffgcv
       (fitsfile *fptr, int datatype, int colnum, LONGLONG firstrow, LONGLONG firstelem,
        LONGLONG nelements, DTYPE *nulval, DTYPE *array, int *anynul, int *status)
 
   int fits_read_colnull / ffgcf
       (fitsfile *fptr, int datatype, int colnum, LONGLONG firstrow, LONGLONG firstelem,
       LONGLONG nelements, DTYPE *array, char *nullarray, int *anynul, int *status)
+
+  int fits_read_cols / ffgcvn
+      (fitsfile *fptr, int ncols, int *datatype, int *colnum, LONGLONG firstrow, 
+       LONGLONG nrows, DTYPE **nulval, DTYPE **array, int **anynul, int *status)
 \end{verbatim}
 
 
 \subsection{Row Selection and Calculator Routines}
 
 These routines all parse and evaluate an input string containing a user
 defined arithmetic expression.  The first 3 routines select rows in a
@@ -3935,15 +3994,16 @@
 
 The following utility routines may be useful for certain applications.
 
 
 \begin{description}
 \item[1 ] Return the revision number of the CFITSIO library.
     The revision number will be incremented with each new
-   release of CFITSIO. \label{ffvers}
+   release of CFITSIO. The 3 fields of the version string M.xx.yy
+   are converted to a float as: M + .01*xx + .0001*yy. \label{ffvers}
 \end{description}
 
 \begin{verbatim}
   float fits_get_version / ffvers ( > float *version)
 \end{verbatim}
 
 \begin{description}
@@ -4918,15 +4978,16 @@
 have the expected values.  The iteratorCol.fptr and iteratorCol.colnum
 structure elements can be used if the work function needs to read or
 write the values of other keywords in the FITS file associated with
 the array.  This should generally only be done during the
 initialization step or during the clean up step after the last set of
 data has been processed.  Extra FITS file I/O during the main
 processing loop of the work function can seriously degrade the speed of
-the program.
+the program.  Note that the behavior of the \verb|fits_iterate_data()|
+is undefined if narrays is zero.
 
 If variable-length array columns are being processed, then the iterator
 will operate on one row of the table at a time.  In this case the
 the repeat element in the interatorCol structure will be set equal to
 the number of elements in the current row that is being processed.
 
 One important feature of the iterator is that the first element in each
@@ -7050,19 +7111,23 @@
       (fitsfile *fptr, LONGLONG firstrow, LONGLONG firstchar, LONGLONG nchars,
        unsigned char *values, > int *status)
 \end{verbatim}
 
 
 \subsection{Write Column Data Routines}
 
+This subsection describes specialized routines for writing data to
+FITS tables.  Please see section \ref{specialized-read-column-data}
+(``Read Column Data Routines'') for more information about how values
+are stored in C.
 
 \begin{description}
 \item[1 ] Write elements into an ASCII or binary table column (in the CDU).
     The data type of the array is implied by the suffix of the
-   routine name. \label{ffpcls}
+   routine name.  \label{ffpcls}
 \end{description}
 
 \begin{verbatim}
   int fits_write_col_str / ffpcls
       (fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
        LONGLONG nelements, char **array, > int *status)
 
@@ -7138,15 +7203,15 @@
 
 \begin{verbatim}
     int fits_write_descript / ffpdes
         (fitsfile *fptr, int colnum, LONGLONG rownum, LONGLONG repeat,
          LONGLONG offset, > int *status)
 \end{verbatim}
 
-\subsection{Read Column Data Routines}
+\subsection{Read Column Data Routines \label{specialized-read-column-data}}
 
 Two types of routines are provided to get the column data which differ
 in the way undefined pixels are handled.  The first set of routines
 (ffgcv) simply return an array of data elements in which undefined
 pixels are set equal to a value specified by the user in the 'nullval'
 parameter.  If nullval = 0, then no checks for undefined pixels will be
 performed, thus increasing the speed of the program.  The second set of
@@ -7178,19 +7243,42 @@
     where w is the width in characters of the displayed values, m is
     the minimum number of digits displayed, and d is the number of
     digits to the right of the decimal.  The .m field is optional.
 
 
 \begin{description}
 \item[1 ] Read elements from an ASCII or binary table column (in the CDU).  These
-    routines return the values of the table column array elements.  Undefined
+    routines return the values of the table column array elements.  The caller
+    is required to allocate the storage \verb+array+ before calling.  Undefined
     array elements will be returned with a value = nulval, unless nulval = 0
     (or = ' ' for ffgcvs) in which case no checking for undefined values will
     be performed. The anynul parameter is set to true if any of the returned
-   elements are undefined. \label{ffgcvx}
+    elements are undefined. 
+
+    For the \verb+_log+ (logical) variant, the C storage type is a
+    \verb+char+ single-byte character.  A FITS value of `\verb+T+'rue
+    reads as 1 and `\verb+F+' reads as 0; other non-FITS characters 
+    are preserved untranslated.
+
+    For the \verb+_str+ (string) variant the number
+    of elements is the number of strings, and the caller must allocate storage
+    for both the array of pointers \verb+array+ and the character array data
+    itself (use \verb+fits_get_col_display_width+ or \verb+fits_get_coltype+ to 
+    determine the number of characters).  See section \ref{character-strings}
+    (``Dealing with Character Strings'') for more information.  Also, when
+    the \verb+_byt+ variant is used to read a column stored in the file as 
+    string data (TFORMn = 'nA'), the subroutine will read the character
+    bytes (instead of attempting to perform a numerical conversion as other
+    integer variants would do), with no attempt at null termination.
+
+    For the \verb+_cmp+ and \verb+_dblcmp+
+    (complex and double complex) variants, \verb+nelements+ is the number
+    of numerical pairs; the number of floats or doubles that must be 
+    pre-allocated is \verb+2*nelements+.
+\label{ffgcvx}
 \end{description}
 
 \begin{verbatim}
   int fits_read_col_str / ffgcvs
       (fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
        LONGLONG nelements, char *nulstr, > char **array, int *anynul,
        int *status)
@@ -8515,16 +8603,16 @@
 
 The above expressions will only delete the {\it first}
 item which matches the pattern.  If following columns or keywords
 in the same CHDU match the pattern, they will not be deleted.
 To delete {\it zero or more} keywords that match the pattern, add a
 trailing \verb|'+'|.
 \begin{verbatim}
-  -VEL*;        # remove all columns (or keywords) beginning with VEL
-  -VEL_?;       # remove all columns (or keyword) VEL_? where ? is any character
+  -VEL*+;       # remove all columns (or keywords) beginning with VEL
+  -VEL_?+;      # remove all columns (or keyword) VEL_? where ? is any character
   -#DEC_*+;     # remove all keywords beginning with DEC_
   -#TUNIT#+;    # remove all keywords TUNIT ending w. number
 \end{verbatim}
 Note that, as a 0-or-more matching pattern, this form will succeed if
 the requested column or keyword is not present.  In that case, the
 deletion expression will silently proceed as if no deletion was requested.
 
@@ -8643,14 +8731,15 @@
 %%      the following other locations where calculator 
 %%      expressions are documented:
 %%         heacore/cfitsio/docs/cfitsio.tex
 %%         heacore/cfitsio/docs/fitsio.tex
 %%         heatools/help/calc_express.html
 %%         heatools/help/rowfilter.html
 %%         heatools/help/colfilter.html
+%%         heatools/help/binfilter.html
 %%         heatools/ftcalc/ftcalc.html
 %%         heatools/ftselect/ftselect.html
 %%         ftools/futils/tasks/fselect/fselect.hlp
 %%         ftools/futils/tasks/fcalc/fcalc.hlp
 %%         ftools/guis/fv/doc/expressions.html
 %%   -->
 
@@ -8686,14 +8775,16 @@
     "arc cosine"         arccos(x)  "arc sine"             arcsin(x)
     "arc tangent"        arctan(x)  "arc tangent"          arctan2(y,x)
     "hyperbolic cos"     cosh(x)    "hyperbolic sin"       sinh(x)
     "hyperbolic tan"     tanh(x)    "round to nearest int" round(x)
     "round down to int"  floor(x)   "round up to int"      ceil(x)
     "exponential"        exp(x)     "square root"          sqrt(x)
     "natural log"        log(x)     "common log"           log10(x)
+    "error function"     erf(x)     "complement of erf"    erfc(x)
+    "gamma function"     gamma(x)
     "modulus"            x % y      
     "bitwise AND"        x & y      "bitwise OR"           x | y
     "bitwise XOR"        x ^^ y     (bitwise operators are 32-bit int only)
     "random # [0.0,1.0)" random()
     "random Gaussian"    randomn()  "random Poisson"       randomp(x)
     "minimum"            min(x,y)   "maximum"              max(x,y)
     "cumulative sum"     accum(x)   "sequential difference" seqdiff(x)
@@ -8810,20 +8901,23 @@
     not   actually   required  for  evaluation,  e.g. "TRUE  .or.  NULL"
     evaluates to TRUE. The  following  two  functions  allow  some  NULL
     detection  and  handling:
 
 \begin{verbatim}
          "a null value?"              ISNULL(x)
          "define a value for null"    DEFNULL(x,y)
+         "declare certain value null" SETNULL(x,y)
 \end{verbatim}
-    The former
-    returns a boolean value of TRUE if the  argument  x  is  NULL.   The
-    later  "defines"  a  value  to  be  substituted  for NULL values; it
+    ISNULL(x)
+    returns a boolean value of TRUE if the  argument  x  is  NULL. DEFNULL(x,y)
+    "defines"  a  value  to  be  substituted  for NULL values; it
     returns the value of x if x is not NULL, otherwise  it  returns  the
-    value of y.
+    value of y.  SETNULL(x,y) allows NULL values to be inserted into
+    a variable; if x==y, a NULL value is returned; otherwise y is returned
+    (x and y must be numerical, and x must be a scalar).
 
 \subsection{Bit Masks}
 
     Bit  masks can be used to select out rows from bit columns (TFORMn =
     \#X) in FITS files. To represent the mask,  binary,  octal,  and  hex
     formats are allowed:
 
@@ -8899,22 +8993,25 @@
     dimensions.
 
     Arithmetic and logical operations are all performed on an element by
     element basis.  Comparing two vector columns,  eg  "COL1  ==  COL2",
     thus  results  in  another vector of boolean values indicating which
     elements of the two vectors are equal.
 
-    Eight functions are available that operate on a vector and return a
-    scalar result:
+    Several functions are available that operate on a vector.  All but
+    the last two return a scalar result:
 
 \begin{verbatim}
     "minimum"      MIN(V)          "maximum"               MAX(V)
     "average"      AVERAGE(V)      "median"                MEDIAN(V)
     "summation"    SUM(V)          "standard deviation"    STDDEV(V)
     "# of values"  NELEM(V)        "# of non-null values"  NVALID(V)
+    "# axes"       NAXIS(V)        "axis dimension"        NAXES(V,n)
+    "axis pos'n"   AXISELEM(V,n)   "vector element pos'n"  ELEMENTNUM(V)
+                                   "promote to array"      ARRAY(X,d)
 \end{verbatim}
     where V represents the name of a vector column or a manually
     constructed vector using curly brackets as described below.  The
     first 6 of these functions ignore any null values in the vector when
     computing the result.  The STDDEV() function computes the sample
     standard deviation, i.e. it is proportional to 1/SQRT(N-1) instead
     of 1/SQRT(N), where N is NVALID(V).
@@ -8931,14 +9028,36 @@
 \begin{verbatim}
               SUM( COL1 > COL2 ) == NELEM( COL1 )
 \end{verbatim}
 
     which will return TRUE if all elements  of  COL1  are  greater  than
     their corresponding elements in COL2.
 
+    The NAXIS(V) function returns the number of axes of the vector,
+    for example a 2D array would be NAXIS(V) == 2.  The NAXES(V,n)
+    function returns the dimension of axis n, for example a 4x2 array
+    would have NAXES(V,1) == 4.  The ELEMENTNUM(V) and AXISELEM(V,n)
+    functions return vectors of the same size as the input vector V.
+    ELEMENTNUM(V) returns the vector element position for each element
+    in the vector, starting from 1 in each row.  The AXISELEM(V,n)
+    function is similar but returns the element position of axis n
+    only.
+
+    The ARRAY(X,d) function promotes scalar value X to a vector (or
+    array) table element.  X may be any scalar-valued item, including
+    a column, an expression, or a constant value.  The resulting
+    vector or array will have the same scalar value replicated into
+    each element position.  This may be a useful way to construct
+    large arrays without using the cumbersome \{vector\} notation. The
+    dimensions of the new array are given by the second argument, d.
+    d can either be a single constant integer value, or a vector of up
+    to five dimensions of the form \{Nx,Ny,...\}.  Thus, ARRAY(TIME,4)
+    would promote TIME to be a 4-vector, and ARRAY(0, \{2,3,1\}) would
+    construct an array of all 0's with dimensions $2\times 3\times 1$.
+
     To  specify  a  single  element  of  a  vector, give the column name
     followed by  a  comma-separated  list  of  coordinates  enclosed  in
     square  brackets.  For example, if a vector column named PHAS exists
     in the table as a one dimensional, 256  component  list  of  numbers
     from  which  you  wanted to select the 57th component for use in the
     expression, then PHAS[57] would do the  trick.   Higher  dimensional
     arrays  of  data  may appear in a column.  But in order to interpret
@@ -8984,28 +9103,34 @@
     Using the same column name on the left and right side of the equals
     sign while using the \verb+COLUMN{-N}+ notation will not produce the desired
     result.  For example,
 \begin{verbatim}
               COUNT = COUNT{-1} + 1;   # BAD - do not use
 \end{verbatim}
     will not produce an increasing counter.  Such recursive
-    calculations are often not possible with the calculator syntax.   
-
-\subsection{Good Time Interval Filtering}
-
-    A common filtering method involves selecting rows which have a time
-    value which lies within what is called a Good Time Interval or GTI.
-    The time intervals are defined in a separate FITS table extension
-    which contains 2 columns giving the start and stop time of each
-    good interval.  The filtering operation accepts only those rows of
-    the input table which have an associated time which falls within
-    one of the time intervals defined in the GTI extension. A high
-    level function, gtifilter(a,b,c,d), is available which evaluates
-    each row of the input table  and returns TRUE  or FALSE depending
-    whether the row is inside or outside the  good time interval.  The
+    calculations are often not possible with the calculator syntax.  
+    However, for cases where the user wishes a row counter, the special 
+    variable \verb+#ROW+ can be utilized.
+
+\subsection{Good Time Interval Filtering and Calculation}
+
+    There are two functions for filtering and calculating based
+    on Good Time Intervals, or GTIs.  GTIs are commonly used to
+    express fragmented time ranges that are not easy to express with a
+    single start and stop time.  The time intervals are defined in a
+    FITS table extension which contains 2 columns giving the
+    start and stop time of each good interval.
+
+    A common filtering method involves selecting rows which have a
+    time value which lies within any GTI.  The gtifilter() filtering
+    operation accepts only those rows of the input table which have an
+    associated time which falls within one of the time intervals
+    defined in a separate GTI extension.  gtifilter(a,b,c,d) evaluates
+    each row of the input table and returns TRUE or FALSE depending
+    whether the row is inside or outside the good time interval.  The
     syntax is
 
 \begin{verbatim}
       gtifilter( [ "gtifile" [, expr [, "STARTCOL", "STOPCOL" ] ] ] )
     or
       gtifilter( [ 'gtifile' [, expr [, 'STARTCOL', 'STOPCOL' ] ] ] )
 \end{verbatim}
@@ -9041,14 +9166,84 @@
     "START"  and "STOP".  The wildcards ('*') allow slight variations in
     naming conventions  such  as  "TSTART"  or  "STARTTIME".   The  same
     default  values  apply for unspecified parameters when the first one
     or  two  parameters  are  specified.   The  function   automatically
     searches   for   TIMEZERO/I/F   keywords  in  the  current  and  GTI
     extensions, applying a relative time offset, if necessary.
 
+    The related function, gtifind(a,b,c,d), is similar to gtifilter()
+    but instead of returning true/false, gtifind() returns the GTI
+    number that brackets the requested time sample.  gtifind() returns
+    the row number in the GTI table that matches the time sample, or
+    -1 if the time sample is not within any GTI.  gtifind() is
+    particularly useful when entries in a table must be categorized by
+    which GTI the fall within.  For example, if events in an event
+    list must be separated by good time interval.  The results of
+    gtifind() can be used with histogram binning techniques to bin an
+    event list by which GTI.
+    
+\begin{verbatim}
+      gtifind( "gtifile" , expr [, "STARTCOL", "STOPCOL" ] )
+\end{verbatim}
+
+    The requirements for specifying the gtifile are the same as for
+    gtifilter() as described above.  Like gtifilter(), the expr is
+    the time-like expression and is optional (defaulting to TIME).
+    The start and stop columns default to START and STOP.
+
+    The function, gtioverlap(a,b,c,d,e), computes the overlap
+    between a user-requested time range and the entries in a GTI.  The
+    cases of no overlap, partial overlap, or overlap of many GTIs
+    within the user requested range are handled.  gtioverlap() is very
+    useful for calculating exposure times and fractional exposures of
+    individual time bins, say for a light curve.  The syntax of
+    gtioverlap() is
+
+\begin{verbatim}
+      gtioverlap( "gtifile" , startExpr, stopExpr [, "STARTCOL", "STOPCOL" ] )
+    or
+      gtioverlap( 'gtifile' , startExpr, stopExpr [, 'STARTCOL', 'STOPCOL' ] )
+\end{verbatim}
+
+    The requirements for specifying the gtifile are the same as for
+    gtifilter() as described above.  Unlike gtifilter(), the startExpr
+    and stopExpr are not optional.  startExpr provides a start of the
+    user requested time interval.  startExpr is typically TIME, but
+    can be any valid expression.  Likewise, stopExpr provides the stop
+    of the user requested time interval, and can be an expression.
+    For example, for a light curve with a TIME column and time bin
+    size of 1.0 seconds, the expression
+
+\begin{verbatim}
+      gtioverlap('gtifile',TIME,TIME+1.0)
+\end{verbatim}
+
+    would calculate the amount of overlap exposure time between each
+    one second time bin and the GTI in 'gtifile'.  In this case the
+    time bin is assumed to begin at the time specified by TIME and end
+    1 second later.  Neither startExpr nor stopExpr are required to be
+    constant, and a light curve is not required to have a constant bin
+    size.  For tables, the overlap is calculated for each entry in the
+    table.
+
+    It is also possible to calculate a single overlap value, which
+    would typically be placed in a keyword.  For example, a way to to
+    compute the total overlap exposure of a file whose TIME column is
+    bounded by the keywords TSTART and TSTOP, overlapping with the
+    specified GTI, would be
+
+\begin{verbatim}
+      #EXPOSURE = gtioverlap('gtifile',#TSTART,#TSTOP)
+\end{verbatim}
+
+    The \verb+#EXPOSURE+ syntax with a leading \+#+ ensures that the 
+    requested values are treated as keywords.  Otherwise, a column
+    named EXPOSURE will be created with the (constant) exposure value
+    in each entry.  
+
 
 \subsection{Spatial Region Filtering}
 
     Another common  filtering method selects rows based on whether the
     spatial position associated with each row is located within a given
     2-dimensional region.  The syntax for this high-level filter is
 
@@ -9283,21 +9478,36 @@
 CFITSIO will first try to use the 'preferred column' as specified by
 the CPREF keyword if it exists (e.g., 'CPREF = 'DETX,DETY'), otherwise
 column names 'X', 'Y', 'Z', and 'T' will be assumed for each of the 4
 axes, respectively.  In cases where the column name could be confused
 with an arithmetic expression, enclose the column name in parentheses to
 force the name to be interpreted literally.
 
-Each column name may be followed by an equals sign and then the lower
-and upper range of the histogram, and the size of the histogram bins,
-separated by colons.  Spaces are allowed before and after the equals
-sign but not within the 'min:max:binsize' string.  The min, max and
-binsize values may be integer or floating point numbers, or they may be
-the names of keywords in the header of the table.  If the latter, then
-the value of that keyword is substituted into the expression.
+In addition to binning by a FITS column, any arbitrary calculator
+expression may be specified as well.  Usage of this form would appear
+as:
+
+\begin{verbatim}
+ [bin  Xcol(arbitrary expression)=min:max:binsize, ... ]
+\end{verbatim}
+
+The column name must still be specified, and is used to label
+coordinate axes of the resulting image.  The expression appears
+immediately after the name, enclosed in parentheses.  The expression
+may use any combination of columns, keywords, functions and constants
+and allowed by the CFITSIO calculator.
+
+The column name (and optional expression) may be followed by an equals
+sign and then the lower and upper range of the histogram, and the size
+of the histogram bins, separated by colons.  Spaces are allowed before
+and after the equals sign but not within the 'min:max:binsize' string.
+The min, max and binsize values may be integer or floating point
+numbers, or they may be the names of keywords in the header of the
+table.  If the latter, then the value of that keyword is substituted
+into the expression.
 
 Default values for the min, max and binsize quantities will be
 used if not explicitly given in the binning expression as shown
 in these examples:
 
 \begin{verbatim}
     [bin x = :512:2]  - use default minimum value
@@ -9313,44 +9523,56 @@
 CFITSIO  will use the value of the TLMINn, TLMAXn, and TDBINn keywords,
 if they exist, for the default min, max, and binsize, respectively.  If
 they do not exist then CFITSIO will use the actual minimum and maximum
 values in the column for the histogram min and max values.  The default
 binsize will be set to 1, or (max - min) / 10., whichever is smaller,
 so that the histogram will have at least 10 bins along each axis.
 
+Please note that if explicit min and max values (or TLMINn/TLMAXn keywords)
+are not present, then CFITSIO must check every value of the binned quantity
+in advance to determine the binning limits.  This is especially relevant 
+for binning expressions, which must be evaluated multiple times to determine
+the limits of the expression.  Thus, it is always advisable to specify 
+min and max limits where possible.
+
 A shortcut notation is allowed if all the columns/axes have the same
 binning specification.  In this case all the column names may be listed
 within parentheses, followed by the (single) binning specification, as
 in:
 
 \begin{verbatim}
     [bin (X,Y)=1:512:2]
     [bin (X,Y) = 5]
 \end{verbatim}
 
-The optional weighting factor is the last item in the binning specifier
-and, if present, is separated from the list of columns by a
+The optional weighting factor is the last item in the binning
+specifier and, if present, is separated from the list of columns by a
 semi-colon.  As the histogram is accumulated, this weight is used to
-incremented the value of the appropriated bin in the histogram.  If the
-weighting factor is not specified, then the default weight = 1 is
+incremented the value of the appropriated bin in the histogram.  If
+the weighting factor is not specified, then the default weight = 1 is
 assumed.  The weighting factor may be a constant integer or floating
 point number, or the name of a keyword containing the weighting value.
-Or the weighting factor may be the name of a table column in which case
-the value in that column, on a row by row basis, will be used.
+The weighting factor may also be the name of a table column in which
+case the value in that column, on a row by row basis, will be used.
+It may also be an expression, enclosed in parenthesis, in which case
+the weighting value will be evaluated for each binned row and applied
+accordingly.
 
 In some cases, the column or keyword may give the reciprocal of the
 actual weight value that is needed.  In this case, precede the weight
 keyword or column name by a slash '/' to tell CFITSIO to use the
-reciprocal of the value when constructing the histogram.
-
-For  complex or commonly  used  histograms, one  can also  place its
-description  into  a  text  file and  import   it  into  the binning
-specification  using the  syntax [bin  @filename.txt].  The file's
-contents  can extend over   multiple lines, although  it must still
-conform to the  no-spaces rule  for the min:max:binsize syntax and each
+reciprocal of the value when constructing the histogram.  An expression,
+enclosed in parentheses, may also appear after the slash, to
+indicate the reciprocal value of the expression.
+
+For complex or commonly used histograms, one can also place its
+description into a text file and import it into the binning
+specification using the syntax [bin @filename.txt].  The file's
+contents can extend over multiple lines, although it must still
+conform to the no-spaces rule for the min:max:binsize syntax and each
 axis specification must still be comma-separated.  Any lines in the
 external text file that begin with 2 slash characters ('//') will be
 ignored and may be used to add comments into the file.
 
  Examples:
 
 
@@ -9371,14 +9593,30 @@
                                        with 0.1 unit size bins.
 
     [bin pha, time=8000.:8100.:0.1]  - 2-D image using default binning
                                        of the PHA column for the X axis,
                                        and 1000 bins in the range
                                        8000. to 8100. for the Y axis.
 
+    [bin pha, gti_num(gtifind())=1:2:1] - a 2-D image, where PHA is the
+                                       X axis and the Y axis is an expression
+                                       which evaluates to the GTI number, 
+                                       as determined using the
+                                       GTIFIND() function.
+
+    [bin time=0:4000:2000, HR( (LC2/LC1).lt.1.5 ? 1 : 2 )=1:2:1] - a 2-D
+                                       histogram which determines the number
+                                       of samples in two time bins between 0 and
+                                       4000 and separating hardness ratio, 
+                                       evaluated as (LC2/LC1), between less than
+                                       1.5 or greater than 1.5.  The ?: 
+                                       conditional function is used to decide
+                                       less (or greater) than 1.5 and assign
+                                       HR bin 1 or 2.
+
     [bin @binFilter.txt]             - Use the contents of the text file
                                        binFilter.txt for the binning
                                        specifications.
 
 \end{verbatim}
 \chapter{Template Files }
 
@@ -10157,14 +10395,15 @@
 fits\_copy\_header    & \pageref{ffcphd} \\
 fits\_copy\_image2cell & \pageref{copycell} \\
 fits\_copy\_image\_section  & \pageref{ffcpimg} \\
 fits\_copy\_key           & \pageref{ffcpky} \\
 fits\_copy\_member    & \pageref{ffgmcp} \\
 fits\_copy\_pixlist2image & \pageref{copypixlist2image} \\
 fits\_copy\_rows &   \pageref{ffcprw} \\
+fits\_copy\_selrows &   \pageref{ffcpsr} \\
 fits\_create\_diskfile    & \pageref{ffinit} \\
 fits\_create\_file    & \pageref{ffinit} \\
 
 \end{tabular}
 \begin{tabular}{lr}
 fits\_create\_group  & \pageref{ffgtcr} \\
 fits\_create\_hdu     & \pageref{ffcrhd} \\
@@ -10292,14 +10531,15 @@
 fits\_read\_btblhdr      & \pageref{ffghbn} \\
 fits\_read\_card         & \pageref{ffgcrd} \\
 fits\_read\_col        & \pageref{ffgcv} \\
 fits\_read\_col\_bit\_ & \pageref{ffgcx} \\
 fits\_read\_col\_TYP    & \pageref{ffgcvx} \\
 fits\_read\_colnull    & \pageref{ffgcf} \\
 fits\_read\_colnull\_TYP    & \pageref{ffgcfx} \\
+fits\_read\_cols        & \pageref{ffgcvn} \\
 fits\_read\_descript & \pageref{ffgdes} \\
 fits\_read\_descripts & \pageref{ffgdes} \\
 fits\_read\_errmsg    & \pageref{ffgmsg} \\
 fits\_read\_ext        & \pageref{ffgextn} \\
 fits\_read\_grppar\_TYP  & \pageref{ffggpx} \\
 fits\_read\_img         & \pageref{ffgpv} \\
 fits\_read\_img\_coord & \pageref{ffgics} \\
@@ -10379,14 +10619,15 @@
 fits\_write\_chksum   & \pageref{ffpcks} \\
 fits\_write\_col         & \pageref{ffpcl} \\
 fits\_write\_col\_bit     & \pageref{ffpclx} \\
 fits\_write\_col\_TYP     & \pageref{ffpcls} \\
 fits\_write\_col\_null      & \pageref{ffpclu} \\
 fits\_write\_colnull      & \pageref{ffpcn} \\
 fits\_write\_colnull\_TYP & \pageref{ffpcnx} \\
+fits\_write\_cols         & \pageref{ffpcln} \\
 \end{tabular}
 \newpage
 \begin{tabular}{lr}
 fits\_write\_comment      & \pageref{ffpcom} \\
 fits\_write\_date         & \pageref{ffpdat} \\
 fits\_write\_descript  & \pageref{ffpdes} \\
 fits\_write\_errmark   & \pageref{ffpmrk} \\
@@ -10442,24 +10683,25 @@
 ffcpdt      & \pageref{ffcpdt} \\
 ffcpfl      & \pageref{ffcpfl} \\
 ffcphd   & \pageref{ffcphd} \\
 ffcpht   & \pageref{ffcpht} \\
 ffcpimg  & \pageref{ffcpimg} \\
 ffcpky       & \pageref{ffcpky} \\
 ffcprw      &   \pageref{ffcprw} \\
+ffcpsr      &   \pageref{ffcpsr} \\
 ffcrhd     & \pageref{ffcrhd} \\
 ffcrim     & \pageref{ffcrim} \\
 ffcrow    & \pageref{ffcrow} \\
 ffcrtb     & \pageref{ffcrtb} \\
 ffdcol   & \pageref{ffdcol} \\
 ffdelt    & \pageref{ffdelt} \\
 ffdhdu     & \pageref{ffdhdu} \\
 ffdkey     & \pageref{ffdkey} \\
 ffdkinit  & \pageref{ffinit} \\
-ffdkopen      & \pageref{ffopen} \\
+ffdkopn      & \pageref{ffopen} \\
 ffdopn      & \pageref{ffopen} \\
 ffdrec  & \pageref{ffdrec} \\
 ffdrow  & \pageref{ffdrow} \\
 ffdrrg  & \pageref{ffdrrg} \\
 ffdrws & \pageref{ffdrws} \\
 ffdstr     & \pageref{ffdkey} \\
 ffdsum  & \pageref{ffdsum} \\
@@ -10490,14 +10732,15 @@
 ffgcf\_    & \pageref{ffgcfx} \\
 ffgcks     & \pageref{ffgcks} \\
 ffgcnn    & \pageref{ffgcnn} \\
 ffgcno     & \pageref{ffgcno} \\
 ffgcrd         & \pageref{ffgcrd} \\
 ffgcv        & \pageref{ffgcv} \\
 ffgcv\_    & \pageref{ffgcvx} \\
+ffgcvn       & \pageref{ffgcvn} \\
 ffgcx     & \pageref{ffgcx} \\
 ffgdes & \pageref{ffgdes} \\
 ffgdess & \pageref{ffgdes} \\
 ffgerr  & \pageref{ffgerr} \\
 ffgextn        & \pageref{ffgextn} \\
 ffggp\_  & \pageref{ffggpx} \\
 ffghad    & \pageref{ffghad} \\
@@ -10609,14 +10852,15 @@
 ffnkey      & \pageref{ffnkey} \\
 ffomem   & \pageref{ffomem} \\
 ffopen      & \pageref{ffopen} \\
 ffp2d\_   & \pageref{ffp2dx} \\
 ffp3d\_   & \pageref{ffp3dx} \\
 ffpcks   & \pageref{ffpcks} \\
 ffpcl         & \pageref{ffpcl} \\
+ffpcln         & \pageref{ffpcln} \\
 ffpcls     & \pageref{ffpcls} \\
 ffpcl\_     & \pageref{ffpclx} \\
 ffpclu      & \pageref{ffpclu} \\
 ffpcn    & \pageref{ffpcn} \\
 ffpcn\_ & \pageref{ffpcnx} \\
 ffpcom      & \pageref{ffpcom} \\
 ffpdat         & \pageref{ffpdat} \\
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/cfitsio.toc` & `fitsio-1.2.0/cfitsio-4.2.0/docs/cfitsio.toc`

 * *Files 25% similar despite different names*

```diff
@@ -1,127 +1,127 @@
-\contentsline {chapter}{\numberline {1}Introduction }{1}{chapter.1}
-\contentsline {section}{\numberline {1.1} A Brief Overview}{1}{section.1.1}
-\contentsline {section}{\numberline {1.2}Sources of FITS Software and Information}{1}{section.1.2}
-\contentsline {section}{\numberline {1.3}Acknowledgments}{2}{section.1.3}
-\contentsline {section}{\numberline {1.4}Legal Stuff}{4}{section.1.4}
-\contentsline {chapter}{\numberline {2} Creating the CFITSIO Library }{5}{chapter.2}
-\contentsline {section}{\numberline {2.1}Building the Library}{5}{section.2.1}
-\contentsline {subsection}{\numberline {2.1.1}Unix Systems}{5}{subsection.2.1.1}
-\contentsline {subsection}{\numberline {2.1.2}VMS}{7}{subsection.2.1.2}
-\contentsline {subsection}{\numberline {2.1.3}Windows PCs}{7}{subsection.2.1.3}
-\contentsline {subsection}{\numberline {2.1.4}Macintosh PCs}{7}{subsection.2.1.4}
-\contentsline {section}{\numberline {2.2}Testing the Library}{7}{section.2.2}
-\contentsline {section}{\numberline {2.3}Linking Programs with CFITSIO}{9}{section.2.3}
-\contentsline {section}{\numberline {2.4}Using CFITSIO in Multi-threaded Environments}{9}{section.2.4}
-\contentsline {section}{\numberline {2.5}Getting Started with CFITSIO}{9}{section.2.5}
-\contentsline {section}{\numberline {2.6}Example Program}{10}{section.2.6}
-\contentsline {chapter}{\numberline {3} A FITS Primer }{13}{chapter.3}
-\contentsline {chapter}{\numberline {4} Programming Guidelines }{15}{chapter.4}
-\contentsline {section}{\numberline {4.1}CFITSIO Definitions}{15}{section.4.1}
-\contentsline {section}{\numberline {4.2}Current Header Data Unit (CHDU)}{18}{section.4.2}
-\contentsline {section}{\numberline {4.3}Function Names and Variable Datatypes}{18}{section.4.3}
-\contentsline {section}{\numberline {4.4}Support for Unsigned Integers and Signed Bytes}{20}{section.4.4}
-\contentsline {section}{\numberline {4.5}Dealing with Character Strings}{22}{section.4.5}
-\contentsline {section}{\numberline {4.6}Implicit Data Type Conversion}{23}{section.4.6}
-\contentsline {section}{\numberline {4.7}Data Scaling}{23}{section.4.7}
-\contentsline {section}{\numberline {4.8}Support for IEEE Special Values}{24}{section.4.8}
-\contentsline {section}{\numberline {4.9}Error Status Values and the Error Message Stack}{24}{section.4.9}
-\contentsline {section}{\numberline {4.10}Variable-Length Arrays in Binary Tables}{25}{section.4.10}
-\contentsline {section}{\numberline {4.11}Multiple Access to the Same FITS File}{27}{section.4.11}
-\contentsline {section}{\numberline {4.12}When the Final Size of the FITS HDU is Unknown}{27}{section.4.12}
-\contentsline {section}{\numberline {4.13}CFITSIO Size Limitations}{28}{section.4.13}
-\contentsline {chapter}{\numberline {5}Basic CFITSIO Interface Routines }{31}{chapter.5}
-\contentsline {section}{\numberline {5.1}CFITSIO Error Status Routines}{31}{section.5.1}
-\contentsline {section}{\numberline {5.2}FITS File Access Routines}{32}{section.5.2}
-\contentsline {section}{\numberline {5.3}HDU Access Routines}{35}{section.5.3}
-\contentsline {section}{\numberline {5.4}Header Keyword Read/Write Routines}{37}{section.5.4}
-\contentsline {subsection}{\numberline {5.4.1}Keyword Reading Routines}{38}{subsection.5.4.1}
-\contentsline {subsection}{\numberline {5.4.2}Keyword Writing Routines}{41}{subsection.5.4.2}
-\contentsline {section}{\numberline {5.5}Primary Array or IMAGE Extension I/O Routines}{43}{section.5.5}
-\contentsline {section}{\numberline {5.6}Image Compression}{47}{section.5.6}
-\contentsline {section}{\numberline {5.7}ASCII and Binary Table Routines}{52}{section.5.7}
-\contentsline {subsection}{\numberline {5.7.1}Create New Table}{52}{subsection.5.7.1}
-\contentsline {subsection}{\numberline {5.7.2}Column Information Routines}{53}{subsection.5.7.2}
-\contentsline {subsection}{\numberline {5.7.3}Routines to Edit Rows or Columns}{56}{subsection.5.7.3}
-\contentsline {subsection}{\numberline {5.7.4}Read and Write Column Data Routines}{58}{subsection.5.7.4}
-\contentsline {subsection}{\numberline {5.7.5}Row Selection and Calculator Routines}{60}{subsection.5.7.5}
-\contentsline {subsection}{\numberline {5.7.6}Column Binning or Histogramming Routines}{62}{subsection.5.7.6}
-\contentsline {section}{\numberline {5.8}Utility Routines}{64}{section.5.8}
-\contentsline {subsection}{\numberline {5.8.1}File Checksum Routines}{64}{subsection.5.8.1}
-\contentsline {subsection}{\numberline {5.8.2}Date and Time Utility Routines}{65}{subsection.5.8.2}
-\contentsline {subsection}{\numberline {5.8.3}General Utility Routines}{67}{subsection.5.8.3}
-\contentsline {chapter}{\numberline {6} The CFITSIO Iterator Function }{77}{chapter.6}
-\contentsline {section}{\numberline {6.1}The Iterator Work Function}{78}{section.6.1}
-\contentsline {section}{\numberline {6.2}The Iterator Driver Function}{80}{section.6.2}
-\contentsline {section}{\numberline {6.3}Guidelines for Using the Iterator Function}{81}{section.6.3}
-\contentsline {section}{\numberline {6.4}Complete List of Iterator Routines}{82}{section.6.4}
-\contentsline {chapter}{\numberline {7} World Coordinate System Routines }{85}{chapter.7}
-\contentsline {section}{\numberline {7.1} Self-contained WCS Routines}{86}{section.7.1}
-\contentsline {chapter}{\numberline {8} Hierarchical Grouping Routines }{89}{chapter.8}
-\contentsline {section}{\numberline {8.1}Grouping Table Routines}{90}{section.8.1}
-\contentsline {section}{\numberline {8.2}Group Member Routines}{92}{section.8.2}
-\contentsline {chapter}{\numberline {9} Specialized CFITSIO Interface Routines }{95}{chapter.9}
-\contentsline {section}{\numberline {9.1}FITS File Access Routines}{95}{section.9.1}
-\contentsline {subsection}{\numberline {9.1.1}File Access}{95}{subsection.9.1.1}
-\contentsline {subsection}{\numberline {9.1.2}Download Utility Functions}{99}{subsection.9.1.2}
-\contentsline {section}{\numberline {9.2}HDU Access Routines}{100}{section.9.2}
-\contentsline {section}{\numberline {9.3}Specialized Header Keyword Routines}{102}{section.9.3}
-\contentsline {subsection}{\numberline {9.3.1}Header Information Routines}{102}{subsection.9.3.1}
-\contentsline {subsection}{\numberline {9.3.2}Read and Write the Required Keywords}{102}{subsection.9.3.2}
-\contentsline {subsection}{\numberline {9.3.3}Write Keyword Routines}{104}{subsection.9.3.3}
-\contentsline {subsection}{\numberline {9.3.4}Insert Keyword Routines}{106}{subsection.9.3.4}
-\contentsline {subsection}{\numberline {9.3.5}Read Keyword Routines}{107}{subsection.9.3.5}
-\contentsline {subsection}{\numberline {9.3.6}Modify Keyword Routines}{109}{subsection.9.3.6}
-\contentsline {subsection}{\numberline {9.3.7}Update Keyword Routines}{110}{subsection.9.3.7}
-\contentsline {section}{\numberline {9.4}Define Data Scaling and Undefined Pixel Parameters}{111}{section.9.4}
-\contentsline {section}{\numberline {9.5}Specialized FITS Primary Array or IMAGE Extension I/O Routines}{112}{section.9.5}
-\contentsline {section}{\numberline {9.6}Specialized FITS ASCII and Binary Table Routines}{115}{section.9.6}
-\contentsline {subsection}{\numberline {9.6.1}General Column Routines}{115}{subsection.9.6.1}
-\contentsline {subsection}{\numberline {9.6.2}Low-Level Table Access Routines}{117}{subsection.9.6.2}
-\contentsline {subsection}{\numberline {9.6.3}Write Column Data Routines}{117}{subsection.9.6.3}
-\contentsline {subsection}{\numberline {9.6.4}Read Column Data Routines}{118}{subsection.9.6.4}
-\contentsline {chapter}{\numberline {10} Extended File Name Syntax }{123}{chapter.10}
-\contentsline {section}{\numberline {10.1}Overview}{123}{section.10.1}
-\contentsline {section}{\numberline {10.2}Filetype}{126}{section.10.2}
-\contentsline {subsection}{\numberline {10.2.1}Notes about HTTP proxy servers}{127}{subsection.10.2.1}
-\contentsline {subsection}{\numberline {10.2.2}Notes about HTTPS and FTPS file access}{127}{subsection.10.2.2}
-\contentsline {subsection}{\numberline {10.2.3}Notes about the stream filetype driver}{128}{subsection.10.2.3}
-\contentsline {subsection}{\numberline {10.2.4}Notes about the gsiftp filetype}{129}{subsection.10.2.4}
-\contentsline {subsection}{\numberline {10.2.5}Notes about the root filetype}{129}{subsection.10.2.5}
-\contentsline {subsection}{\numberline {10.2.6}Notes about the shmem filetype:}{131}{subsection.10.2.6}
-\contentsline {section}{\numberline {10.3}Base Filename}{131}{section.10.3}
-\contentsline {section}{\numberline {10.4}Output File Name when Opening an Existing File}{133}{section.10.4}
-\contentsline {section}{\numberline {10.5}Template File Name when Creating a New File}{135}{section.10.5}
-\contentsline {section}{\numberline {10.6}Image Tile-Compression Specification}{135}{section.10.6}
-\contentsline {section}{\numberline {10.7}HDU Location Specification}{135}{section.10.7}
-\contentsline {section}{\numberline {10.8}Image Section}{137}{section.10.8}
-\contentsline {section}{\numberline {10.9}Image Transform Filters}{138}{section.10.9}
-\contentsline {section}{\numberline {10.10}Column and Keyword Filtering Specification}{139}{section.10.10}
-\contentsline {section}{\numberline {10.11}Row Filtering Specification}{143}{section.10.11}
-\contentsline {subsection}{\numberline {10.11.1}General Syntax}{143}{subsection.10.11.1}
-\contentsline {subsection}{\numberline {10.11.2}Bit Masks}{146}{subsection.10.11.2}
-\contentsline {subsection}{\numberline {10.11.3}Vector Columns}{147}{subsection.10.11.3}
-\contentsline {subsection}{\numberline {10.11.4}Row Access}{149}{subsection.10.11.4}
-\contentsline {subsection}{\numberline {10.11.5}Good Time Interval Filtering}{149}{subsection.10.11.5}
-\contentsline {subsection}{\numberline {10.11.6}Spatial Region Filtering}{150}{subsection.10.11.6}
-\contentsline {subsection}{\numberline {10.11.7}Example Row Filters}{152}{subsection.10.11.7}
-\contentsline {section}{\numberline {10.12} Binning or Histogramming Specification}{153}{section.10.12}
-\contentsline {chapter}{\numberline {11}Template Files }{157}{chapter.11}
-\contentsline {section}{\numberline {11.1}Detailed Template Line Format}{157}{section.11.1}
-\contentsline {section}{\numberline {11.2}Auto-indexing of Keywords}{158}{section.11.2}
-\contentsline {section}{\numberline {11.3}Template Parser Directives}{159}{section.11.3}
-\contentsline {section}{\numberline {11.4}Formal Template Syntax}{160}{section.11.4}
-\contentsline {section}{\numberline {11.5}Errors}{160}{section.11.5}
-\contentsline {section}{\numberline {11.6}Examples}{160}{section.11.6}
-\contentsline {chapter}{\numberline {12} Local FITS Conventions }{163}{chapter.12}
-\contentsline {section}{\numberline {12.1}64-Bit Long Integers}{163}{section.12.1}
-\contentsline {section}{\numberline {12.2}Long String Keyword Values.}{163}{section.12.2}
-\contentsline {section}{\numberline {12.3}Arrays of Fixed-Length Strings in Binary Tables}{165}{section.12.3}
-\contentsline {section}{\numberline {12.4}Keyword Units Strings}{165}{section.12.4}
-\contentsline {section}{\numberline {12.5}HIERARCH Convention for Extended Keyword Names}{165}{section.12.5}
-\contentsline {section}{\numberline {12.6}Tile-Compressed Image Format}{166}{section.12.6}
-\contentsline {chapter}{\numberline {13} Optimizing Programs }{169}{chapter.13}
-\contentsline {section}{\numberline {13.1}How CFITSIO Manages Data I/O}{169}{section.13.1}
-\contentsline {section}{\numberline {13.2}Optimization Strategies}{170}{section.13.2}
-\contentsline {chapter}{\numberline {A}Index of Routines }{175}{appendix.A}
-\contentsline {chapter}{\numberline {B}Parameter Definitions }{181}{appendix.B}
-\contentsline {chapter}{\numberline {C}CFITSIO Error Status Codes }{187}{appendix.C}
+\contentsline {chapter}{\numberline {1}Introduction }{1}
+\contentsline {section}{\numberline {1.1} A Brief Overview}{1}
+\contentsline {section}{\numberline {1.2}Sources of FITS Software and Information}{1}
+\contentsline {section}{\numberline {1.3}Acknowledgments}{2}
+\contentsline {section}{\numberline {1.4}Legal Stuff}{4}
+\contentsline {chapter}{\numberline {2} Creating the CFITSIO Library }{5}
+\contentsline {section}{\numberline {2.1}Building the Library}{5}
+\contentsline {subsection}{\numberline {2.1.1}Unix Systems}{5}
+\contentsline {subsection}{\numberline {2.1.2}VMS}{7}
+\contentsline {subsection}{\numberline {2.1.3}Windows PCs}{7}
+\contentsline {subsection}{\numberline {2.1.4}Macintosh PCs}{7}
+\contentsline {section}{\numberline {2.2}Testing the Library}{7}
+\contentsline {section}{\numberline {2.3}Linking Programs with CFITSIO}{9}
+\contentsline {section}{\numberline {2.4}Using CFITSIO in Multi-threaded Environments}{9}
+\contentsline {section}{\numberline {2.5}Getting Started with CFITSIO}{9}
+\contentsline {section}{\numberline {2.6}Example Program}{10}
+\contentsline {chapter}{\numberline {3} A FITS Primer }{13}
+\contentsline {chapter}{\numberline {4} Programming Guidelines }{15}
+\contentsline {section}{\numberline {4.1}CFITSIO Definitions}{15}
+\contentsline {section}{\numberline {4.2}Current Header Data Unit (CHDU)}{18}
+\contentsline {section}{\numberline {4.3}Function Names and Variable Datatypes}{18}
+\contentsline {section}{\numberline {4.4}Support for Unsigned Integers and Signed Bytes}{20}
+\contentsline {section}{\numberline {4.5}Dealing with Character Strings }{22}
+\contentsline {section}{\numberline {4.6}Implicit Data Type Conversion}{23}
+\contentsline {section}{\numberline {4.7}Data Scaling}{23}
+\contentsline {section}{\numberline {4.8}Support for IEEE Special Values}{24}
+\contentsline {section}{\numberline {4.9}Error Status Values and the Error Message Stack}{25}
+\contentsline {section}{\numberline {4.10}Variable-Length Arrays in Binary Tables}{25}
+\contentsline {section}{\numberline {4.11}Multiple Access to the Same FITS File}{27}
+\contentsline {section}{\numberline {4.12}When the Final Size of the FITS HDU is Unknown}{28}
+\contentsline {section}{\numberline {4.13}CFITSIO Size Limitations}{28}
+\contentsline {chapter}{\numberline {5}Basic CFITSIO Interface Routines }{31}
+\contentsline {section}{\numberline {5.1}CFITSIO Error Status Routines}{31}
+\contentsline {section}{\numberline {5.2}FITS File Access Routines}{32}
+\contentsline {section}{\numberline {5.3}HDU Access Routines}{35}
+\contentsline {section}{\numberline {5.4}Header Keyword Read/Write Routines}{37}
+\contentsline {subsection}{\numberline {5.4.1}Keyword Reading Routines}{38}
+\contentsline {subsection}{\numberline {5.4.2}Keyword Writing Routines}{41}
+\contentsline {section}{\numberline {5.5}Primary Array or IMAGE Extension I/O Routines}{43}
+\contentsline {section}{\numberline {5.6}Image Compression}{47}
+\contentsline {section}{\numberline {5.7}ASCII and Binary Table Routines}{52}
+\contentsline {subsection}{\numberline {5.7.1}Create New Table}{52}
+\contentsline {subsection}{\numberline {5.7.2}Column Information Routines}{53}
+\contentsline {subsection}{\numberline {5.7.3}Routines to Edit Rows or Columns}{56}
+\contentsline {subsection}{\numberline {5.7.4}Read and Write Column Data Routines}{58}
+\contentsline {subsection}{\numberline {5.7.5}Row Selection and Calculator Routines}{61}
+\contentsline {subsection}{\numberline {5.7.6}Column Binning or Histogramming Routines}{62}
+\contentsline {section}{\numberline {5.8}Utility Routines}{65}
+\contentsline {subsection}{\numberline {5.8.1}File Checksum Routines}{65}
+\contentsline {subsection}{\numberline {5.8.2}Date and Time Utility Routines}{66}
+\contentsline {subsection}{\numberline {5.8.3}General Utility Routines}{67}
+\contentsline {chapter}{\numberline {6} The CFITSIO Iterator Function }{79}
+\contentsline {section}{\numberline {6.1}The Iterator Work Function}{80}
+\contentsline {section}{\numberline {6.2}The Iterator Driver Function}{82}
+\contentsline {section}{\numberline {6.3}Guidelines for Using the Iterator Function}{83}
+\contentsline {section}{\numberline {6.4}Complete List of Iterator Routines}{84}
+\contentsline {chapter}{\numberline {7} World Coordinate System Routines }{87}
+\contentsline {section}{\numberline {7.1} Self-contained WCS Routines}{88}
+\contentsline {chapter}{\numberline {8} Hierarchical Grouping Routines }{91}
+\contentsline {section}{\numberline {8.1}Grouping Table Routines}{92}
+\contentsline {section}{\numberline {8.2}Group Member Routines}{94}
+\contentsline {chapter}{\numberline {9} Specialized CFITSIO Interface Routines }{97}
+\contentsline {section}{\numberline {9.1}FITS File Access Routines}{97}
+\contentsline {subsection}{\numberline {9.1.1}File Access}{97}
+\contentsline {subsection}{\numberline {9.1.2}Download Utility Functions}{101}
+\contentsline {section}{\numberline {9.2}HDU Access Routines}{102}
+\contentsline {section}{\numberline {9.3}Specialized Header Keyword Routines}{104}
+\contentsline {subsection}{\numberline {9.3.1}Header Information Routines}{104}
+\contentsline {subsection}{\numberline {9.3.2}Read and Write the Required Keywords}{104}
+\contentsline {subsection}{\numberline {9.3.3}Write Keyword Routines}{106}
+\contentsline {subsection}{\numberline {9.3.4}Insert Keyword Routines}{108}
+\contentsline {subsection}{\numberline {9.3.5}Read Keyword Routines}{109}
+\contentsline {subsection}{\numberline {9.3.6}Modify Keyword Routines}{111}
+\contentsline {subsection}{\numberline {9.3.7}Update Keyword Routines}{112}
+\contentsline {section}{\numberline {9.4}Define Data Scaling and Undefined Pixel Parameters}{113}
+\contentsline {section}{\numberline {9.5}Specialized FITS Primary Array or IMAGE Extension I/O Routines}{114}
+\contentsline {section}{\numberline {9.6}Specialized FITS ASCII and Binary Table Routines}{117}
+\contentsline {subsection}{\numberline {9.6.1}General Column Routines}{117}
+\contentsline {subsection}{\numberline {9.6.2}Low-Level Table Access Routines}{119}
+\contentsline {subsection}{\numberline {9.6.3}Write Column Data Routines}{119}
+\contentsline {subsection}{\numberline {9.6.4}Read Column Data Routines }{120}
+\contentsline {chapter}{\numberline {10} Extended File Name Syntax }{125}
+\contentsline {section}{\numberline {10.1}Overview}{125}
+\contentsline {section}{\numberline {10.2}Filetype}{128}
+\contentsline {subsection}{\numberline {10.2.1}Notes about HTTP proxy servers}{129}
+\contentsline {subsection}{\numberline {10.2.2}Notes about HTTPS and FTPS file access}{129}
+\contentsline {subsection}{\numberline {10.2.3}Notes about the stream filetype driver}{130}
+\contentsline {subsection}{\numberline {10.2.4}Notes about the gsiftp filetype}{131}
+\contentsline {subsection}{\numberline {10.2.5}Notes about the root filetype}{131}
+\contentsline {subsection}{\numberline {10.2.6}Notes about the shmem filetype:}{133}
+\contentsline {section}{\numberline {10.3}Base Filename}{133}
+\contentsline {section}{\numberline {10.4}Output File Name when Opening an Existing File}{135}
+\contentsline {section}{\numberline {10.5}Template File Name when Creating a New File}{137}
+\contentsline {section}{\numberline {10.6}Image Tile-Compression Specification}{137}
+\contentsline {section}{\numberline {10.7}HDU Location Specification}{137}
+\contentsline {section}{\numberline {10.8}Image Section}{139}
+\contentsline {section}{\numberline {10.9}Image Transform Filters}{140}
+\contentsline {section}{\numberline {10.10}Column and Keyword Filtering Specification}{141}
+\contentsline {section}{\numberline {10.11}Row Filtering Specification}{145}
+\contentsline {subsection}{\numberline {10.11.1}General Syntax}{145}
+\contentsline {subsection}{\numberline {10.11.2}Bit Masks}{148}
+\contentsline {subsection}{\numberline {10.11.3}Vector Columns}{149}
+\contentsline {subsection}{\numberline {10.11.4}Row Access}{151}
+\contentsline {subsection}{\numberline {10.11.5}Good Time Interval Filtering and Calculation}{151}
+\contentsline {subsection}{\numberline {10.11.6}Spatial Region Filtering}{153}
+\contentsline {subsection}{\numberline {10.11.7}Example Row Filters}{156}
+\contentsline {section}{\numberline {10.12} Binning or Histogramming Specification}{157}
+\contentsline {chapter}{\numberline {11}Template Files }{161}
+\contentsline {section}{\numberline {11.1}Detailed Template Line Format}{161}
+\contentsline {section}{\numberline {11.2}Auto-indexing of Keywords}{162}
+\contentsline {section}{\numberline {11.3}Template Parser Directives}{163}
+\contentsline {section}{\numberline {11.4}Formal Template Syntax}{164}
+\contentsline {section}{\numberline {11.5}Errors}{164}
+\contentsline {section}{\numberline {11.6}Examples}{164}
+\contentsline {chapter}{\numberline {12} Local FITS Conventions }{167}
+\contentsline {section}{\numberline {12.1}64-Bit Long Integers}{167}
+\contentsline {section}{\numberline {12.2}Long String Keyword Values.}{167}
+\contentsline {section}{\numberline {12.3}Arrays of Fixed-Length Strings in Binary Tables}{169}
+\contentsline {section}{\numberline {12.4}Keyword Units Strings}{169}
+\contentsline {section}{\numberline {12.5}HIERARCH Convention for Extended Keyword Names}{169}
+\contentsline {section}{\numberline {12.6}Tile-Compressed Image Format}{170}
+\contentsline {chapter}{\numberline {13} Optimizing Programs }{173}
+\contentsline {section}{\numberline {13.1}How CFITSIO Manages Data I/O}{173}
+\contentsline {section}{\numberline {13.2}Optimization Strategies}{174}
+\contentsline {chapter}{\numberline {A}Index of Routines }{179}
+\contentsline {chapter}{\numberline {B}Parameter Definitions }{185}
+\contentsline {chapter}{\numberline {C}CFITSIO Error Status Codes }{191}
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/cfortran.doc` & `fitsio-1.2.0/cfitsio-4.2.0/docs/cfortran.doc`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/docs/changes.txt` & `fitsio-1.2.0/cfitsio-4.2.0/docs/changes.txt`

 * *Files 0% similar despite different names*

```diff
@@ -1,8 +1,127 @@
                    Log of Changes Made to CFITSIO
+
+Version 4.2.0 - Nov 2022
+  
+  - This release includes patches to security vulnerabilities.  We
+    strongly encourage this upgrade, particularly for those running 
+    CFITSIO in web accessible applications.
+    
+  - Fix to fits_read_key function, which was failing to properly read
+    keywords declared type TUINT on compilers where sizeof(int) =
+    sizeof(long).
+
+  - Added new functions fits_read_cols and fits_write_cols to efficiently 
+    read or write multiple columns in a single function call
+
+  - Added new function fits_copy_selrows to copy only selected rows, such
+    as the selected rows returned by fits_find_rows
+
+  - Added new calculator functions ERF(X), ERFC(X) and GAMMA(X), which are
+    mathematical special functions of the same name
+
+  - Added new calculator function GTIFIND() which reports which GTI row
+    brackets a given time sample
+
+  - Added new calculator functions which operate upon vector table
+    values NAXIS(V), NAXES(V,n), ELEMENTNUM(V) and AXISELEM(V,n),
+    and ARRAY(X,d) which promotes scalar X to a vector or array
+    with given dimensions.
+
+  - The CFITSIO histogramming code now handles binning by any
+    arbitrary calculator expression rather than just a column name.
+    Both the binned columns as well as the optional weights may be
+    calculator expressions, enclosed in parentheses.  
+
+  - Binning of vector columns or expressions is now supported, as long
+    as all binned inputs (as well as the optional weighting) have the
+    same vector dimensions.  Binning of variable-length columns remains
+    unsupported.
+
+  - A bug that caused histogram weights from columns that are null values
+    to be tallied along with non-null values has been fixed.
+
+  - The CFITSIO calculator and histogramming functionality is now
+    fully reentrant and does not require multithreading interlocks.
+
+  - A long-standing segmentation fault bug in the histogramming code
+    related to binning any value using the "reciprocal" /XXXX notation
+    has been fixed.
+    
+  - Added mutex locks for thread safety in ftgiou and ftfiou.
+  
+  - Added several Fortran wrappers to support image read/write when
+    'fpixel' and 'nelements' are 8-byte integers.
+    
+  - Fixed bug which was adding spaces to some cases of long string key
+    value output.
+
+Version 4.1.0 - Feb 2022
+                   
+  - Calls to the zlib inflate() function in zcompress.c now handle
+    the Z_BUF_ERROR return value rather than exiting.
+
+  - The SUBTRACTIVE_DITHER_2 option has been removed when using the
+    HCOMPRESS algorithm.  
+    
+  - Updated fits_get_version function to return a float calculated
+    from 3 version fields.
+                       
+  - Added handling of SBYTE_IMG and ULONGLONG_IMG types to the
+    fits_resize_img function.
+    
+  - Updates made to C/Fortran interfacing in cfortran.h and f77_wrap.h
+    specifically driven by new Mac/ARM architecture.
+    
+  - Fix to the fits_insert_col functions to handle columns with
+    TULONGLONG data.
+                   
+Version 4.0.0 - May 2021                   
+
+  - Removed separate directory for zlib/gzip code, and updated
+    configuration to check for zlib on the user's system (required).
+    When use of cURL is enabled, it may also pull in zlib such
+    that user applications may not need to link with it separately.
+
+  - Changed version numbering to 3-field format.
+      
+  - Added new calculator functions SETNULL(x,y) to allow substitution of
+    NULL values into tables, and GTIOVERLAP() for calculating the amount
+    of GTI overlap exposure for a time bin.
+    
+  - Fix added for proper handling of string columns with zero repeat
+    count.
+    
+  - Fix to column filtering expressions which write #NULL values to
+    columns of type (J) format.
+    
+  - Fix to memory clearing when using polygon shapes in region files.
+     
+  - Fix to fits_str2time function so that it now flags a particular case
+    of bad syntax which was previously getting through.
+    
+  - In ffgclb and ffpclb (read/write byte columns), the "undocumented"
+    feature of being able to transfer columns 'A' string columnss as
+    byte arrays is now handled correctly, with improved error checking
+    via updates to ffgcprll.  More documentation on string handling is
+    in cfitsio.tex.
+
+  - Fix bug in 'colfilter' functionality.  When performing a
+    column deletion of the form -COLNAM*, and multiple matches
+    existed, then none of the matches got deleted.  Now the
+    first is deleted as expected.
+    
+  - Improved handling of corner case in ffpkn functions.
+
+  - In ffgky, modified TULONG case to allow it to read unsigned
+    values greater than the 8-byte signed limit.
+    
+  - Fix to parsing of corner case of extended file syntax.
+
+  - Major updates to CMake configuration.
 		   
 Version 3.49 - Aug 2020
 
   - Fix to imcompress.c.  It now turns off quantization if ZSCALE
     and ZZERO columns are missing.  Treatment will be the same as
     if ZQUANTIZ were set to 'NONE', even if ZQUANTIZ is present
     and set to something else.
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/fitsio.doc` & `fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.doc`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/docs/fitsio.pdf` & `fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.pdf`

 * *Installing the 'pypdf' Python module from the 'python3-pypdf' package may produce a better output.*

 * *Files 23% similar despite different names*

#### pdftotext {} -

```diff
@@ -1,20 +1,20 @@
 FITSIO User’s Guide
 A Subroutine Interface to FITS Format Files
 for Fortran Programmers
 
-Version 3.0
+Version 4.2
 
 HEASARC
 Code 662
 Goddard Space Flight Center
 Greenbelt, MD 20771
 USA
 
-April 2016
+Nov 2022
 
 ii
 
 Contents
 1 Introduction
 
 1
@@ -224,23 +224,23 @@
 
 6.6
 
 FITS Primary Array or IMAGE Extension I/O Subroutines
 
 6.7
 
-FITS ASCII and Binary Table Data I/O Subroutines . . . . . . . . . . . . . . . . . . 55
+FITS ASCII and Binary Table Data I/O Subroutines . . . . . . . . . . . . . . . . . . 56
 
 . . . . . . . . . . . . . 52
 
 6.7.1
 
 Column Information Subroutines
 
-. . . . . . . . . . . . . . . . . . . . . . . . 55
+. . . . . . . . . . . . . . . . . . . . . . . . 56
 
 6.7.2
 
 Low-Level Table Access Subroutines . . . . . . . . . . . . . . . . . . . . . . . 58
 
 6.7.3
 
@@ -347,60 +347,60 @@
 8.11 Row Filtering Specification . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
 8.11.1 General Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
 8.11.2 Bit Masks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
 8.11.3 Vector Columns
 
 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
 
-8.11.4 Good Time Interval Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
-8.11.5 Spatial Region Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
-8.11.6 Example Row Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
-8.12 Binning or Histogramming Specification . . . . . . . . . . . . . . . . . . . . . . . . . 107
+8.11.4 Good Time Interval Filtering and Calculation . . . . . . . . . . . . . . . . . . 103
+8.11.5 Spatial Region Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
+8.11.6 Example Row Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
+8.12 Binning or Histogramming Specification . . . . . . . . . . . . . . . . . . . . . . . . . 108
 9 Template Files
 
-111
+113
 
 vi
 
 CONTENTS
 9.1
 
-Detailed Template Line Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
+Detailed Template Line Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
 
 9.2
 
-Auto-indexing of Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
+Auto-indexing of Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
 
 9.3
 
-Template Parser Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
+Template Parser Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
 
 9.4
 
-Formal Template Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
+Formal Template Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
 
 9.5
 
-Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
+Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
 
 9.6
 
-Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
+Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
 
 10 Summary of all FITSIO User-Interface Subroutines
 
-117
+119
 
 11 Parameter Definitions
 
-125
+127
 
 12 FITSIO Error Status Codes
 
-131
+133
 
 Chapter 1
 
 Introduction
 This document describes the Fortran-callable subroutine interface that is provided as part of the
 CFITSIO library (which is written in ANSI C). This is a companion document to the CFITSIO
 User’s Guide which should be consulted for further information about the underlying CFITSIO
@@ -608,43 +608,35 @@
 $ run testprog
 The testprog program should produce a FITS file called ‘testprog.fit’ that is identical to the ‘testprog.std’ FITS file included with this release. The diagnostic messages (which were piped to the file
 testprog.lis in the Unix example) should be identical to the listing contained in the file testprog.out.
 The ’diff’ and ’cmp’ commands shown above should not report any differences in the files. (There
 may be some minor formatting differences, such as the presence or absence of leading zeros, or 3
 digit exponents in numbers, which can be ignored).
 The Fortran wrappers in CFITSIO may be tested with the testf77 program. On Unix systems the
-fortran compilation and link command may be called ’f77’ or ’g77’, depending on the system.
-% f77 -o testf77 testf77.f -L. -lcfitsio -lnsl -lsocket
-or
-% f77 -f -o testf77 testf77.f -L. -lcfitsio
-(under SUN O/S)
-or
-% f77 -o testf77 testf77.f -Wl,-L. -lcfitsio -lm -lnsl -lsocket (HP/UX)
-or
-% g77 -o testf77 -s testf77.f -lcfitsio -lcc_dynamic -lncurses (Mac OS-X)
+Fortran compiler is typically called ’gfortran’. % gfortran -o testf77 testf77.f -L. -lcfitsio -lz -lcurl
 % testf77 > testf77.lis
 % diff testf77.lis testf77.out
 % cmp testf77.fit testf77.std
 On machines running SUN O/S, Fortran programs must be compiled with the ’-f’ option to force
 double precision variables to be aligned on 8-byte boundaries to make the fortran-declared variables
 compatible with C. A similar compiler option may be required on other platforms. Failing to use
 this option may cause the program to crash on FITSIO routines that read or write double precision
 variables.
 On Windows platforms, linking Fortran programs with a C library often depends on the particular
 compilers involved. Some users have found the following commands work when using the Intel
 Fortran compiler:
+ifort /libs.dll cfitsio.lib /MD testf77.f /Gm
+or possibly,
+ifort /libs:dll cfitsio.lib /MD /fpp /extfpp:cfortran.h,fitsio.h
+/iface:cvf testf77.f
 
 2.3. LINKING PROGRAMS WITH FITSIO
 
 7
 
-ifort /libs.dll cfitsio.lib /MD testf77.f /Gm
-or possibly,
-ifort /libs:dll cfitsio.lib /MD /fpp /extfpp:cfortran.h,fitsio.h
-/iface:cvf testf77.f
 Also note that on some systems the output listing of the testf77 program may differ slightly from
 the testf77.std template if leading zeros are not printed by default before the decimal point when
 using F format.
 A few other utility programs are included with CFITSIO:
 speed - measures the maximum throughput (in MB per second)
 for writing and reading FITS files with CFITSIO
 listhead - lists all the header keywords in any FITS file
@@ -673,25 +665,25 @@
 
 2.4
 
 Getting Started with FITSIO
 
 In order to effectively use the FITSIO library as quickly as possible, it is recommended that new
 users follow these steps:
+1. Read the following ‘FITS Primer’ chapter for a brief overview of the structure of FITS files.
+This is especially important for users who have not previously dealt with the FITS table and image
+extensions.
+2. Write a simple program to read or write a FITS file using the Basic Interface routines.
 
 8
 
 CHAPTER 2.
 
 CREATING FITSIO/CFITSIO
 
-1. Read the following ‘FITS Primer’ chapter for a brief overview of the structure of FITS files.
-This is especially important for users who have not previously dealt with the FITS table and image
-extensions.
-2. Write a simple program to read or write a FITS file using the Basic Interface routines.
 3. Refer to the cookbook.f program that is included with this release for examples of routines that
 perform various common FITS file operations.
 4. Read Chapters 4 and 5 to become familiar with the conventions and advanced features of the
 FITSIO interface.
 5. Scan through the more extensive set of routines that are provided in the ‘Advanced Interface’.
 These routines perform more specialized functions than are provided by the Basic Interface routines.
 
@@ -732,25 +724,22 @@
 
 initialize parameters about the FITS image (300 x 200 16-bit integers)
 simple=.true.
 bitpix=16
 naxis=2
 naxes(1)=300
 naxes(2)=200
-
-2.6. LEGAL STUFF
-
-9
-
 extend=.true.
+
 C
 
 write the required header keywords
 call ftphpr(unit,simple,bitpix,naxis,naxes,0,1,extend,status)
 
+2.6. LEGAL STUFF
 C
 
 initialize the values in the image with a linear ramp function
 do j=1,naxes(2)
 do i=1,naxes(1)
 array(i,j)=i+j
 end do
@@ -776,37 +765,37 @@
 call ftfiou(unit, status)
 end
 
 2.6
 
 Legal Stuff
 
+9
+
 Copyright (Unpublished–all rights reserved under the copyright laws of the United States), U.S.
 Government as represented by the Administrator of the National Aeronautics and Space Administration. No copyright is claimed in the United States under Title 17, U.S. Code.
 Permission to freely use, copy, modify, and distribute this software and its documentation without
 fee is hereby granted, provided that this copyright notice and disclaimer of warranty appears in all
 copies.
 DISCLAIMER:
 THE SOFTWARE IS PROVIDED ’AS IS’ WITHOUT ANY WARRANTY OF ANY KIND, EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO,
 ANY WARRANTY THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY
 IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE SOFTWARE, OR ANY WARRANTY THAT THE
 SOFTWARE WILL BE ERROR FREE. IN NO EVENT SHALL NASA BE LIABLE FOR ANY
-DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN ANY WAY CON-
+DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY, CONTRACT, TORT , OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED
+FROM, OR AROSE OUT OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.”
 
 10
 
+2.7
+
 CHAPTER 2.
 
 CREATING FITSIO/CFITSIO
 
-NECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY, CONTRACT, TORT , OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED
-FROM, OR AROSE OUT OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.”
-
-2.7
-
 Acknowledgments
 
 The development of many of the powerful features in CFITSIO was made possible through collaborations with many people or organizations from around the world. The following, in particular,
 have made especially significant contributions:
 Programmers from the Integral Science Data Center, Switzerland (namely, Jurek Borkowski, Bruce
 O’Neel, and Don Jennings), designed the concept for the plug-in I/O drivers that was introduced
 with CFITSIO 2.0. The use of ‘drivers’ greatly simplified the low-level I/O, which in turn made
@@ -832,25 +821,25 @@
 The syntax used by CFITSIO for filtering or binning input FITS files is based on ideas developed
 for the AXAF Science Center Data Model by Jonathan McDowell, Antonella Fruscione, Aneta
 Siemiginowska and Bill Joye. See http://heasarc.gsfc.nasa.gov/docs/journal/axaf7.html for further
 description of the AXAF Data Model.
 The file decompression code were taken directly from the gzip (GNU zip) program developed by
 Jean-loup Gailly and others.
 Doug Mink, SAO, provided the routines for converting IRAF format images into FITS format.
-
-2.7. ACKNOWLEDGMENTS
-
-11
-
 Martin Reinecke (Max Planck Institute, Garching)) provided the modifications to cfortran.h that
 are necessary to support 64-bit integer values when calling C routines from fortran programs. The
 cfortran.h macros were originally developed by Burkhard Burow (CERN).
 Julian Taylor (ESO, Garching) provided the fast byte-swapping algorithms that use the SSE2 and
 SSSE3 machine instructions available on x86 64 CPUs.
 In addition, many other people have made valuable contributions to the development of CFITSIO.
+
+2.7. ACKNOWLEDGMENTS
+
+11
+
 These include (with apologies to others that may have inadvertently been omitted):
 Steve Allen, Carl Akerlof, Keith Arnaud, Morten Krabbe Barfoed, Kent Blackburn, G Bodammer,
 Romke Bontekoe, Lucio Chiappetti, Keith Costorf, Robin Corbet, John Davis, Richard Fink, Ning
 Gan, Emily Greene, Joe Harrington, Cheng Ho, Phil Hodge, Jim Ingham, Yoshitaka Ishisaki, Diab
 Jerius, Mark Levine, Todd Karakaskian, Edward King, Scott Koch, Claire Larkin, Rob Managan,
 Eric Mandel, John Mattox, Carsten Meyer, Emi Miyata, Stefan Mochnacki, Mike Noble, Oliver
 Oberdorf, Clive Page, Arvind Parmar, Jeff Pedelty, Tim Pearson, Maren Purves, Scott Randall,
@@ -1601,15 +1590,16 @@
 Refer to Chapter 9 for the definition of all the parameters used by these interface routines.
 
 5.1
 
 FITSIO Error Status Routines
 
 1 Return the current version number of the fitsio library. The version number will be incremented
-with each new release of CFITSIO.
+with each new release of CFITSIO. The 3 fields of the version string M.xx.yy are converted
+to a float as: M + .01*xx + .0001*yy.
 FTVERS( > version)
 2 Return the descriptive text string corresponding to a FITSIO error status code. The 30character length string contains a brief description of the cause of the error.
 FTGERR(status, > errtext)
 3 Return the top (oldest) 80-character error message from the internal FITSIO stack of error
 messages and shift any remaining messages on the stack up one level. Any FITSIO error will
 generate one or more messages on the stack. Call this routine repeatedly to get each message
 in sequence. The error stack is empty when a blank string is returned.
@@ -2590,33 +2580,40 @@
 FTGISZ(unit, maxdim, > naxes,status)
 FTGISZLL(unit, maxdim, > naxesll,status)
 4 Get the parameters that define the type and size of the image. This routine simply combines
 calls to the above 3 routines. The FTGIPRLL routine returns an array of 64-bit integers
 instead of 32-bit integers.
 FTGIPR(unit, maxdim, > bitpix, naxis, naxes, int *status)
 FTGIPRLL(unit, maxdim, > bitpix, naxis, naxesll, int *status)
-5 Put elements into the data array
+5 Put elements into the data array. The FTPPR[]LL routines accept 64-bit integers for fpixel and
+nelements.
 FTPPR[BIJKED](unit,group,fpixel,nelements,values, > status)
+FTPPR[BIJKED]LL(unit,group,fpixelll,nelementsll,values, > status)
 6 Put elements into the data array, substituting the appropriate FITS null value for all elements
-which are equal to the value of NULLVAL. For integer FITS arrays, the null value defined by
-the previous call to FTPNUL will be substituted; for floating point FITS arrays (BITPIX =
--32 or -64) then the special IEEE NaN (Not-a-Number) value will be substituted.
+which are equal to the value of NULLVAL. For integer FITS arrays, the null value defined
+by the previous call to FTPNUL will be substituted; for floating point FITS arrays (BITPIX
+= -32 or -64) then the special IEEE NaN (Not-a-Number) value will be substituted. The
+FTPPN[]LL routines accept 64-bit integers for fpixel and nelements.
 FTPPN[BIJKED](unit,group,fpixel,nelements,values,nullval > status)
-7 Set data array elements as undefined
-FTPPRU(unit,group,fpixel,nelements, > status)
+FTPPN[BIJKED]LL(unit,group,fpixelll,nelementsll,values,nullval > status)
 
 54
 
 CHAPTER 6.
 
 ADVANCED INTERFACE SUBROUTINES
 
+7 Set data array elements as undefined. FTPPRULL accepts 64-bit integers for fpixel and nelements.
+FTPPRU(unit,group,fpixel,nelements, > status)
+FTPPRULL(unit,group,fpixelll,nelementsll, > status)
 8 Get elements from the data array. Undefined array elements will be returned with a value =
 nullval, unless nullval = 0 in which case no checks for undefined pixels will be performed.
+FTGPV[]LL accepts 64-bit integers for fpixel and nelements.
 FTGPV[BIJKED](unit,group,fpixel,nelements,nullval, > values,anyf,status)
+FTGPV[BIJKED]LL(unit,group,fpixelll,nelementsll,nullval, > values,anyf,status)
 9 Get elements and nullflags from data array. Any undefined array elements will have the corresponding flagvals element set equal to .TRUE.
 FTGPF[BIJKED](unit,group,fpixel,nelements, > values,flagvals,anyf,status)
 10 Put values into group parameters
 FTPGP[BIJKED](unit,group,fparm,nparm,values, > status)
 11 Get values from group parameters
 FTGGP[BIJKED](unit,group,fparm,nparm, > values,status)
 The following 4 subroutines transfer FITS images with 2 or 3 dimensions to or from a data array
@@ -2629,24 +2626,24 @@
 X an Y directions. This has the effect of taking a contiguous set of pixel value in the FITS array
 and writing them to a non-contiguous array in program memory (i.e., there are now some blank
 pixels around the edge of the image in the program array).
 11 Put 2-D image into the data array
 FTP2D[BIJKED](unit,group,dim1,naxis1,naxis2,image, > status)
 12 Put 3-D cube into the data array
 FTP3D[BIJKED](unit,group,dim1,dim2,naxis1,naxis2,naxis3,cube, > status)
+
+6.6. FITS PRIMARY ARRAY OR IMAGE EXTENSION I/O SUBROUTINES
+
+55
+
 13 Get 2-D image from the data array. Undefined pixels in the array will be set equal to the value
 of ’nullval’, unless nullval=0 in which case no testing for undefined pixels will be performed.
 FTG2D[BIJKED](unit,group,nullval,dim1,naxis1,naxis2, > image,anyf,status)
 14 Get 3-D cube from the data array. Undefined pixels in the array will be set equal to the value
 of ’nullval’, unless nullval=0 in which case no testing for undefined pixels will be performed.
-
-6.7. FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES
-
-55
-
 FTG3D[BIJKED](unit,group,nullval,dim1,dim2,naxis1,naxis2,naxis3, >
 cube,anyf,status)
 The following subroutines transfer a rectangular subset of the pixels in a FITS N-dimensional
 image to or from an array which has been declared in the calling program. The fpixels and lpixels
 parameters are integer arrays which specify the starting and ending pixels in each dimension of the
 FITS image that are to be read or written. (Note that these are the starting and ending pixels
 in the FITS image, not in the declared array). The array parameter is treated simply as a large
@@ -2667,33 +2664,32 @@
 FTGSV[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs,nullval, >
 array,anyf,status)
 17 Get an arbitrary data subsection from the data array. Any Undefined pixels in the array will
 have the corresponding ’flagvals’ element set equal to .TRUE.
 FTGSF[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs, >
 array,flagvals,anyf,status)
 
+56
+
+CHAPTER 6.
+
+ADVANCED INTERFACE SUBROUTINES
+
 6.7
 
 FITS ASCII and Binary Table Data I/O Subroutines
 
 6.7.1
 
 Column Information Subroutines
 
 1 Get the number of rows or columns in the current FITS table. The number of rows is given
 by the NAXIS2 keyword and the number of columns is given by the TFIELDS keyword in
 the header of the table. The FTGNRWLL routine is identical to FTGNRW except that the
 number of rows is returned as a 64-bit integer rather than a 32-bit integer.
-
-56
-
-CHAPTER 6.
-
-ADVANCED INTERFACE SUBROUTINES
-
 FTGNRW(unit, > nrows, status)
 FTGNRWLL(unit, > nrowsll, status)
 FTGNCL(unit, > ncols, status)
 2 Get the table column number (and name) of the column whose name matches an input template
 name. The table column names are defined by the TTYPEn keywords in the FITS header. If a
 column does not have a TTYPEn keyword, then these routines assume that the name consists
 of all blank characters. These 2 subroutines perform the same function except that FTGCNO
@@ -2718,28 +2714,28 @@
 Note that the FITS Standard recommends that only letters, digits, and the underscore character be used in column names (with no embedded spaces in the name). Trailing blank
 characters are not significant.
 FTGCNO(unit,casesen,coltemplate, > colnum,status)
 FTGCNN(unit,casesen,coltemplate, > colname,colnum,status)
 3 Get the datatype of a column in an ASCII or binary table. This routine returns an integer
 code value corresponding to the datatype of the column. (See the FTBNFM and FTASFM
 subroutines in the Utilities section of this document for a list of the code values). The vector
+
+6.7. FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES
+
+57
+
 repeat count (which is alway 1 for ASCII table columns) is also returned. If the specified
 column has an ASCII character datatype (code = 16) then the width of a unit string in the
 column is also returned. Note that this routine supports the local convention for specifying
 arrays of strings within a binary table character column, using the syntax TFORM = ’rAw’
 where ’r’ is the total number of characters (= the width of the column) and ’w’ is the width
 of a unit string within the column. Thus if the column has TFORM = ’60A12’ then this
 routine will return datacode = 16, repeat = 60, and width = 12. (The TDIMn keyword may
 also be used to specify the unit string length; The pair of keywords TFORMn = ’60A’ and
 TDIMn = ’(12,5)’ would have the same effect as TFORMn = ’60A12’).
-
-6.7. FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES
-
-57
-
 The second routine, FTEQTY is similar except that in the case of scaled integer columns it
 returns the ’equivalent’ data type that is needed to store the scaled values, and not necessarily
 the physical data type of the unscaled values as stored in the FITS table. For example if
 a ’1I’ column in a binary table has TSCALn = 1 and TZEROn = 32768, then this column
 effectively contains unsigned short integer values, and thus the returned value of typecode will
 be the code for an unsigned short integer, not a signed short integer. Similarly, if a column
 has TTYPEn = ’1I’ and TSCALn = 0.12, then the returned typecode will be the code for a
@@ -2761,25 +2757,25 @@
 ’n’ is an integer expressing the width of the field in characters. For example, if TFORM =
 ’160A8’ then FTGBCL will return DATATYPE=’A8’ and REPEAT=20. All the returned
 parameters are scalar quantities.
 FTGBCL(unit,colnum, >
 ttype,tunit,datatype,repeat,tscal,tzero,tnull,tdisp,status)
 7 Put (append) a TDIMn keyword whose value has the form ’(l,m,n...)’ where l, m, n... are the
 dimensions of a multidimensional array column in a binary table.
-FTPTDM(unit,colnum,naxis,naxes, > status)
-8 Return the number of and size of the dimensions of a table column. Normally this information
-is given by the TDIMn keyword, but if this keyword is not present then this routine returns
-NAXIS = 1 and NAXES(1) equal to the repeat count in the TFORM keyword.
 
 58
 
 CHAPTER 6.
 
 ADVANCED INTERFACE SUBROUTINES
 
+FTPTDM(unit,colnum,naxis,naxes, > status)
+8 Return the number of and size of the dimensions of a table column. Normally this information
+is given by the TDIMn keyword, but if this keyword is not present then this routine returns
+NAXIS = 1 and NAXES(1) equal to the repeat count in the TFORM keyword.
 FTGTDM(unit,colnum,maxdim, > naxis,naxes,status)
 9 Decode the input TDIMn keyword string (e.g. ’(100,200)’) and return the number of and size
 of the dimensions of a binary table column. If the input tdimstr character string is null, then
 this routine returns naxis = 1 and naxes[0] equal to the repeat count in the TFORM keyword.
 This routine is called by FTGTDM.
 FTDTDM(unit,tdimstr,colnum,maxdim, > naxis,naxes, status)
 10 Return the optimal number of rows to read or write at one time for maximum I/O efficiency.
@@ -2804,23 +2800,23 @@
 1 Read a consecutive string of characters from an ASCII table into a character variable (spanning
 columns and multiple rows if necessary) This routine should not be used with binary tables
 because of complications related to passing string variables between C and Fortran.
 FTGTBS(unit,frow,startchar,nchars, > string,status)
 2 Write a consecutive string of characters to an ASCII table from a character variable (spanning
 columns and multiple rows if necessary) This routine should not be used with binary tables
 because of complications related to passing string variables between C and Fortran.
-FTPTBS(unit,frow,startchar,nchars,string, > status)
-3 Read a consecutive array of bytes from an ASCII or binary table into a numeric variable (spanning columns and multiple rows if necessary). The array parameter may be declared as any
-numerical datatype as long as the array is at least ’nchars’ bytes long, e.g., if nchars = 17,
-then declare the array as INTEGER*4 ARRAY(5).
 
 6.7. FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES
 
 59
 
+FTPTBS(unit,frow,startchar,nchars,string, > status)
+3 Read a consecutive array of bytes from an ASCII or binary table into a numeric variable (spanning columns and multiple rows if necessary). The array parameter may be declared as any
+numerical datatype as long as the array is at least ’nchars’ bytes long, e.g., if nchars = 17,
+then declare the array as INTEGER*4 ARRAY(5).
 FTGTBB(unit,frow,startchar,nchars, > array,status)
 4 Write a consecutive array of bytes to an ASCII or binary table from a numeric variable (spanning columns and multiple rows if necessary) The array parameter may be declared as any
 numerical datatype as long as the array is at least ’nchars’ bytes long, e.g., if nchars = 17,
 then declare the array as INTEGER*4 ARRAY(5).
 FTPTBB(unit,frow,startchar,nchars,array, > status)
 
 6.7.3
@@ -2844,26 +2840,26 @@
 3 Delete a list of rows from an ASCII or binary table (in the CDU). In the first routine, ’rowrange’
 is a character string listing the rows or row ranges to delete (e.g., ’2-4, 5, 8-9’). In the second
 routine, ’rowlist’ is an integer array of row numbers to be deleted from the table. nrows is
 the number of row numbers in the list. The first row in the table is 1 not 0. The list of row
 numbers must be sorted in ascending order.
 FTDRRG(unit,rowrange, > status)
 FTDRWS(unit,rowlist,nrows, > status)
-4 Insert a blank column (or columns) into an existing ASCII or binary table (in the CDU).
-COLNUM specifies the column number that the (first) new column should occupy in the
-table. NCOLS specifies how many columns are to be inserted. Any existing columns from
-this position and higher are moved over to allow room for the new column(s). The index
-number on all the following keywords will be incremented if necessary to reflect the new
 
 60
 
 CHAPTER 6.
 
 ADVANCED INTERFACE SUBROUTINES
 
+4 Insert a blank column (or columns) into an existing ASCII or binary table (in the CDU).
+COLNUM specifies the column number that the (first) new column should occupy in the
+table. NCOLS specifies how many columns are to be inserted. Any existing columns from
+this position and higher are moved over to allow room for the new column(s). The index
+number on all the following keywords will be incremented if necessary to reflect the new
 position of the column(s) in the table: TBCOLn, TFORMn, TTYPEn, TUNITn, TNULLn,
 TSCALn, TZEROn, TDISPn, TDIMn, TLMINn, TLMAXn, TDMINn, TDMAXn, TCTYPn,
 TCRPXn, TCRVLn, TCDLTn, TCROTn, and TCUNIn.
 FTICOL(unit,colnum,ttype,tform, > status)
 FTICLS(unit,colnum,ncols,ttype,tform, > status)
 5 Modify the vector length of a binary table column (e.g., change a column from TFORMn =
 ’1E’ to ’20E’). The vector length may be increased or decreased from the current value.
@@ -2891,23 +2887,23 @@
 read from the FITS array. The fttscl subroutine MUST be used to define the scaling parameters
 when writing data to the table or to override the default scaling values given in the header when
 reading from the table. Note that it is *not* necessary to insert rows in a table before writing data
 to those rows (indeed, it would be inefficient to do so). Instead, one may simply write data to any
 row of the table, whether that row of data already exists or not.
 In the case of binary tables with vector elements, the ’felem’ parameter defines the starting pixel
 within the element vector. This parameter is ignored with ASCII tables. Similarly, in the case
-of binary tables the ’nelements’ parameter specifies the total number of vector values read or
-written (continuing on subsequent rows if required) and not the number of table elements. Two
-sets of subroutines are provided to get the column data which differ in the way undefined pixels
-are handled. The first set of routines (FTGCV) simply return an array of data elements in which
 
 6.7. FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES
 
 61
 
+of binary tables the ’nelements’ parameter specifies the total number of vector values read or
+written (continuing on subsequent rows if required) and not the number of table elements. Two
+sets of subroutines are provided to get the column data which differ in the way undefined pixels
+are handled. The first set of routines (FTGCV) simply return an array of data elements in which
 undefined pixels are set equal to a value specified by the user in the ’nullval’ parameter. An
 additional feature of these subroutines is that if the user sets nullval = 0, then no checks for
 undefined pixels will be performed, thus increasing the speed of the program. The second set of
 routines (FTGCF) returns the data element array and in addition a logical array of flags which
 defines whether the corresponding data pixel is undefined.
 Any column, regardless of it’s intrinsic datatype, may be read as a string. It should be noted
 however that reading a numeric column as a string is 10 - 100 times slower than reading the same
@@ -2946,24 +2942,24 @@
 the null value defined by the previous call to FTSNUL will be substituted; For integer FITS
 columns, in a binary table the null value defined by the previous call to FTTNUL will be
 substituted; For floating point FITS columns a special IEEE NaN (Not-a-Number) value will
 be substituted.
 The alternate version of these routines, whose names end in ’LL’ after the datatype character,
 support large tables with more then 2*31 rows. When calling these routines, the frow and
 felem parameters *must* be 64-bit integer*8 variables, instead of normal 4-byte integers.
-FTPCN[SBIJKED](unit,colnum,frow,felem,nelements,values,nullval > status)
-FTPCN[SBIJKED]LL(unit,colnum,(I*8) frow,(I*8) felem,nelements,values,
-nullval > status)
 
 62
 
 CHAPTER 6.
 
 ADVANCED INTERFACE SUBROUTINES
 
+FTPCN[SBIJKED](unit,colnum,frow,felem,nelements,values,nullval > status)
+FTPCN[SBIJKED]LL(unit,colnum,(I*8) frow,(I*8) felem,nelements,values,
+nullval > status)
 3 Put bit values into a binary byte (’B’) or bit (’X’) table column (in the CDU). LRAY is an
 array of logical values corresponding to the sequence of bits to be written. If LRAY is true
 then the corresponding bit is set to 1, otherwise the bit is set to 0. Note that in the case of
 ’X’ columns, FITSIO will write to all 8 bits of each byte whether they are formally valid or
 not. Thus if the column is defined as ’4X’, and one calls FTPCLX with fbit=1 and nbit=8,
 then all 8 bits will be written into the first byte (as opposed to writing the first 4 bits into
 the first row and then the next 4 bits into the next row), even though the last 4 bits of each
@@ -2992,20 +2988,20 @@
 will have the corresponding flagvals element set equal to .TRUE. The ANYF parameter is
 set to true if any of the returned elements are undefined. (The SPP FSGCFS routine has an
 additional integer argument after the VALUES character string which specifies the size of the
 1st dimension of this 2-D CHAR array).
 The alternate version of these routines, whose names end in ’LL’ after the datatype character,
 support large tables with more then 2*31 rows. When calling these routines, the frow and
 felem parameters *must* be 64-bit integer*8 variables, instead of normal 4-byte integers.
-FTGCF[SLBIJKEDCM](unit,colnum,frow,felem,nelements, >
 
 6.7. FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES
 
 63
 
+FTGCF[SLBIJKEDCM](unit,colnum,frow,felem,nelements, >
 values,flagvals,anyf,status)
 FTGCF[BIJKED]LL(unit,colnum, (I*8) frow, (I*8) felem,nelements, >
 values,flagvals,anyf,status)
 7 Get an arbitrary data subsection from an N-dimensional array in a binary table vector column.
 Undefined pixels in the array will be set equal to the value of ’nullval’, unless nullval=0 in
 which case no testing for undefined pixels will be performed. The first and last rows in the
 table to be read are specified by fpixels(naxis+1) and lpixels(naxis+1), and hence are treated
@@ -3318,16 +3314,15 @@
 character of the second keyword in the header (recall that each header record is 80 characters
 long). Note that this is one of the few FITSIO routines in which the returned value is not
 necessarily equal to the status value).
 FTNCHK(unit, > status)
 7 Parse a header keyword record and return the name of the keyword and the length of the name.
 The keyword name normally occupies the first 8 characters of the record, except under the
 HIERARCH convention where the name can be up to 70 characters in length.
-
-FTGKNM(card, > keyname, keylength, staThe ’\#’ character will match any consecutive str
+FTGKNM(card, > keyname, keylength, staThe ’\#’ character will match any consecutive
 of decimal digits (0 - 9). tus)
 8 Parse a header keyword record. This subroutine parses the input header record to return the
 value (as a character string) and comment strings. If the keyword has no value (columns 9-10
 not equal to ’= ’), then the value string is returned blank and the comment string is set equal
 to column 9 - 80 of the input string.
 FTPSVC(card, > value,comment,status)
 
@@ -4613,14 +4608,20 @@
 exp(x)
 "square root"
 sqrt(x)
 "natural log"
 log(x)
 "common log"
 log10(x)
+"error function"
+erf(x)
+"complement of erf"
+erfc(x)
+"gamma function"
+gamma(x)
 "modulus"
 x % y
 "bitwise AND"
 x & y
 "bitwise OR"
 x | y
 "bitwise XOR"
@@ -4640,21 +4641,21 @@
 "if-then-else"
 b?x:y
 "angular separation" angsep(ra1,dec1,ra2,de2) (all in degrees)
 "substring"
 strmid(s,p,n) "string search"
 strstr(s,r)
 The bitwise operators for AND, OR and XOR operate upon 32-bit integer expressions only.
-Three different random number functions are provided: random(), with no arguments, produces a
-uniform random deviate between 0 and 1; randomn(), also with no arguments, produces a normal
 
 8.11. ROW FILTERING SPECIFICATION
 
 99
 
+Three different random number functions are provided: random(), with no arguments, produces a
+uniform random deviate between 0 and 1; randomn(), also with no arguments, produces a normal
 (Gaussian) random deviate with zero mean and unit standard deviation; randomp(x) produces a
 Poisson random deviate whose expected number of counts is X. X may be any positive real number
 of expected counts, including fractional values, but the return value is an integer.
 When the random functions are used in a vector expression, by default the same random value will
 be used when evaluating each element of the vector. If different random numbers are desired, then
 the name of a vector column should be supplied as the single argument to the random function
 (e.g., ”flux + 0.1 * random(flux)”, where ”flux” is the name of a vector column). This will create
@@ -4692,62 +4693,66 @@
 
 (INT) x
 (FLOAT) i
 
 In addition, several constants are built in for use in numerical expressions:
 #pi
 #deg
-#null
 
 3.1415...
 #pi/180
-undefined value
 
 #e
 #row
-#snull
 
 2.7182...
 current row number
-undefined string
 
 100
 
 CHAPTER 8.
+#null
+
+undefined value
 
 EXTENDED FILE NAME SYNTAX
 
+#snull
+
+undefined string
+
 A string constant must be enclosed in quotes as in ’Crab’. The ”null” constants are useful for
 conditionally setting table values to a NULL, or undefined, value (eg., ”col1==-99 ? #NULL :
 col1”).
 Integer constants may be specified using the following notation,
 13245
 decimal integer
 0x12f3 hexidecimal integer
 0o1373 octal integer
 0b01001 binary integer
 
-Note that integer constants are only allowed to be 32-bit, i.e. between -2( 31)and+2( 31).Integerconstantsmaybeused
+Note that integer constants are only allowed to be 32-bit, i.e. between -2( 31)and+2( 31).Integerconstantsmaybeu
 There is also a function for testing if two values are close to each other, i.e., if they are ”near” each
 other to within a user specified tolerance. The arguments, value 1 and value 2 can be integer or real
 and represent the two values who’s proximity is being tested to be within the specified tolerance,
 also an integer or real:
 near(value_1, value_2, tolerance)
 When a NULL, or undefined, value is encountered in the FITS table, the expression will evaluate to
 NULL unless the undefined value is not actually required for evaluation, e.g. ”TRUE .or. NULL”
 evaluates to TRUE. The following two functions allow some NULL detection and handling:
 "a null value?"
-"define a value for null"
-
 ISNULL(x)
+"define a value for null"
 DEFNULL(x,y)
-
-The former returns a boolean value of TRUE if the argument x is NULL. The later ”defines” a
-value to be substituted for NULL values; it returns the value of x if x is not NULL, otherwise it
-returns the value of y.
+"declare certain value null" SETNULL(x,y)
+ISNULL(x) returns a boolean value of TRUE if the argument x is NULL. DEFNULL(x,y) ”defines”
+a value to be substituted for NULL values; it returns the value of x if x is not NULL, otherwise it
+returns the value of y. SETNULL(x,y) allows NULL values to be inserted into a variable; if x==y,
+a NULL value is returned; otherwise y is returned (x and y must be numerical, and x must be a
+scalar).
 
 8.11.2
 
 Bit Masks
 
 Bit masks can be used to select out rows from bit columns (TFORMn = #X) in FITS files. To
 represent the mask, binary, octal, and hex formats are allowed:
@@ -4755,24 +4760,23 @@
 octal:
 hex:
 
 b0110xx1010000101xxxx0001
 o720x1 -> (b111010000xxx001)
 h0FxD -> (b00001111xxxx1101)
 
+8.11. ROW FILTERING SPECIFICATION
+
+101
+
 In all the representations, an x or X is allowed in the mask as a wild card. Note that the x represents
 a different number of wild card bits in each representation. All representations are case insensitive.
 Although bitmasks may be of arbitrary length and contain a wildcard, they may only be used
 in logical expressions, unlike integer constants (see above) which may be used in any arithmetic
 expression.
-
-8.11. ROW FILTERING SPECIFICATION
-
-101
-
 To construct the boolean expression using the mask as the boolean equal operator described above
 on a bit table column. For example, if you had a 7 bit column named flags in a FITS table and
 wanted all rows having the bit pattern 0010011, the selection expression would be:
 flags == b0010011
 or
 flags .eq. b10011
 It is also possible to test if a range of bits is less than, less than equal, greater than and greater
@@ -4798,59 +4802,89 @@
 Vector columns can also be used in building the expression. No special syntax is required if one
 wants to operate on all elements of the vector. Simply use the column name as for a scalar
 column. Vector columns can be freely intermixed with scalar columns or constants in virtually all
 expressions. The result will be of the same dimension as the vector. Two vectors in an expression,
 though, need to have the same number of elements and have the same dimensions. The only places
 a vector column cannot be used (for now, anyway) are the SAO region functions and the NEAR
 boolean function.
-Arithmetic and logical operations are all performed on an element by element basis. Comparing two
-vector columns, eg ”COL1 == COL2”, thus results in another vector of boolean values indicating
-which elements of the two vectors are equal.
-Eight functions are available that operate on a vector and return a scalar result:
 
 102
 
 CHAPTER 8.
+
+EXTENDED FILE NAME SYNTAX
+
+Arithmetic and logical operations are all performed on an element by element basis. Comparing two
+vector columns, eg ”COL1 == COL2”, thus results in another vector of boolean values indicating
+which elements of the two vectors are equal.
+Several functions are available that operate on a vector. All but the last two return a scalar result:
 "minimum"
 "average"
 "summation"
 "# of values"
+"# axes"
+"axis pos’n"
 
 MIN(V)
 AVERAGE(V)
 SUM(V)
 NELEM(V)
-
-EXTENDED FILE NAME SYNTAX
+NAXIS(V)
+AXISELEM(V,n)
 
 "maximum"
 "median"
 "standard deviation"
 "# of non-null values"
+"axis dimension"
+"vector element pos’n"
+"promote to array"
 
 MAX(V)
 MEDIAN(V)
 STDDEV(V)
 NVALID(V)
+NAXES(V,n)
+ELEMENTNUM(V)
+ARRAY(X,d)
 
 where V represents the name of a vector column or a manually constructed vector using curly
 brackets as described below. The first 6 of these functions ignore any null values in the vector when
 computing the result. The STDDEV() function computes the sample standard deviation, i.e. it is
 proportional to 1/SQRT(N-1) instead of 1/SQRT(N), where N is NVALID(V).
+The NAXIS(V) function returns the number of axes of the vector, for example a 2D array would be
+NAXIS(V) == 2. The NAXES(V,n) function returns the dimension of axis n, for example a 4x2
+array would have NAXES(V,1) == 4. The ELEMENTNUM(V) and AXISELEM(V,n) functions
+return vectors of the same size as the input vector V. ELEMENTNUM(V) returns the vector
+element position for each element in the vector, starting from 1 in each row. The AXISELEM(V,n)
+function is similar but returns the element position of axis n only.
 The SUM function literally sums all the elements in x, returning a scalar value. If x is a boolean
 vector, SUM returns the number of TRUE elements. The NELEM function returns the number
 of elements in vector x whereas NVALID return the number of non-null elements in the vector.
 (NELEM also operates on bit and string columns, returning their column widths.) As an example,
 to test whether all elements of two vectors satisfy a given logical comparison, one can use the
 expression
 SUM( COL1 > COL2 ) == NELEM( COL1 )
 which will return TRUE if all elements of COL1 are greater than their corresponding elements in
 COL2.
+The ARRAY(X,d) function promotes scalar value X to a vector (or array) table element. X may
+be any scalar-valued item, including a column, an expression, or a constant value. The resulting
+vector or array will have the same scalar value replicated into each element position. This may
+be a useful way to construct large arrays without using the cumbersome {vector} notation. The
+dimensions of the new array are given by the second argument, d. d can either be a single constant
+integer value, or a vector of up to five dimensions of the form {Nx,Ny,...}. Thus, ARRAY(TIME,4)
+would promote TIME to be a 4-vector, and ARRAY(0, {2,3,1}) would construct an array of all 0’s
+with dimensions 2 × 3 × 1.
 To specify a single element of a vector, give the column name followed by a comma-separated list
 of coordinates enclosed in square brackets. For example, if a vector column named PHAS exists in
+
+8.11. ROW FILTERING SPECIFICATION
+
+103
+
 the table as a one dimensional, 256 component list of numbers from which you wanted to select the
 57th component for use in the expression, then PHAS[57] would do the trick. Higher dimensional
 arrays of data may appear in a column. But in order to interpret them, the TDIMn keyword
 must appear in the header. Assuming that a (4,4,4,4) array is packed into each row of a column
 named ARRAY4D, the (1,2,3,4) component element of each row is accessed by ARRAY4D[1,2,3,4].
 Arrays up to dimension 5 are currently supported. Each vector index can itself be an expression,
 although it must evaluate to an integer value within the bounds of the vector. Vector columns
@@ -4865,36 +4899,43 @@
 Vectors can be manually constructed within the expression using a comma-separated list of elements
 surrounded by curly braces (’{}’). For example, ’{1,3,6,1}’ is a 4-element vector containing the
 values 1, 3, 6, and 1. The vector can contain only boolean, integer, and real values (or expressions).
 The elements will be promoted to the highest datatype present. Any elements which are themselves
 vectors, will be expanded out with each of its elements becoming an element in the constructed
 vector.
 
-8.11. ROW FILTERING SPECIFICATION
-
 8.11.4
 
-103
+Good Time Interval Filtering and Calculation
 
-Good Time Interval Filtering
-
-A common filtering method involves selecting rows which have a time value which lies within
-what is called a Good Time Interval or GTI. The time intervals are defined in a separate FITS
-table extension which contains 2 columns giving the start and stop time of each good interval.
-The filtering operation accepts only those rows of the input table which have an associated time
-which falls within one of the time intervals defined in the GTI extension. A high level function,
-gtifilter(a,b,c,d), is available which evaluates each row of the input table and returns TRUE or
-FALSE depending whether the row is inside or outside the good time interval. The syntax is
+There are two functions for filtering and calculating based on Good Time Intervals, or GTIs. GTIs
+are commonly used to express fragmented time ranges that are not easy to express with a single
+start and stop time. The time intervals are defined in a FITS table extension which contains 2
+columns giving the start and stop time of each good interval.
+A common filtering method involves selecting rows which have a time value which lies within any
+GTI. The gtifilter() filtering operation accepts only those rows of the input table which have an
+associated time which falls within one of the time intervals defined in a separate GTI extension.
+gtifilter(a,b,c,d) evaluates each row of the input table and returns TRUE or FALSE depending
+whether the row is inside or outside the good time interval. The syntax is
 gtifilter( [ "gtifile" [, expr [, "STARTCOL", "STOPCOL" ] ] ] )
+or
+gtifilter( [ ’gtifile’ [, expr [, ’STARTCOL’, ’STOPCOL’ ] ] ] )
 where each ”[]” demarks optional parameters. Note that the quotes around the gtifile and START/STOP
 column are required. Either single or double quotes may be used. In cases where this expression
 is entered on the Unix command line, enclose the entire expression in double quotes, and then use
 single quotes within the expression to enclose the ’gtifile’ and other terms. It is also usually possible
 to do the reverse, and enclose the whole expression in single quotes and then use double quotes
 within the expression. The gtifile, if specified, can be blank (””) which will mean to use the first
+
+104
+
+CHAPTER 8.
+
+EXTENDED FILE NAME SYNTAX
+
 extension with the name ”*GTI*” in the current file, a plain extension specifier (eg, ”+2”, ”[2]”,
 or ”[STDGTI]”) which will be used to select an extension in the current file, or a regular filename
 with or without an extension specifier which in the latter case will mean to use the first extension
 with an extension name ”*GTI*”. Expr can be any arithmetic expression, including simply the
 time column name. A vector time expression will produce a vector boolean result. STARTCOL
 and STOPCOL are the names of the START/STOP columns in the GTI extension. If one of them
 is specified, they both must be.
@@ -4903,43 +4944,84 @@
 gtifilter( "", TIME, "*START*", "*STOP*" )
 This will search the current file for a GTI extension, filter the TIME column in the current table,
 using START/STOP times taken from columns in the GTI extension with names containing the
 strings ”START” and ”STOP”. The wildcards (’*’) allow slight variations in naming conventions
 such as ”TSTART” or ”STARTTIME”. The same default values apply for unspecified parameters when the first one or two parameters are specified. The function automatically searches for
 TIMEZERO/I/F keywords in the current and GTI extensions, applying a relative time offset, if
 necessary.
+The related function, gtifind(a,b,c,d), is similar to gtifilter() but instead of returning true/false,
+gtifind() returns the GTI number that brackets the requested time sample. gtifind() returns the
+row number in the GTI table that matches the time sample, or -1 if the time sample is not within
+any GTI. gtifind() is particularly useful when entries in a table must be categorized by which GTI
+the fall within. For example, if events in an event list must be separated by good time interval.
+The results of gtifind() can be used with histogram binning techniques to bin an event list by which
+GTI.
+gtifind( "gtifile" , expr [, "STARTCOL", "STOPCOL" ] )
+The requirements for specifying the gtifile are the same as for gtifilter() as described above. Like
+gtifilter(), the expr is the time-like expression and is optional (defaulting to TIME). The start and
+stop columns default to START and STOP.
+The function, gtioverlap(a,b,c,d,e), computes the overlap between a user-requested time range and
+the entries in a GTI. The cases of no overlap, partial overlap, or overlap of many GTIs within the
+user requested range are handled. gtioverlap() is very useful for calculating exposure times and
+fractional exposures of individual time bins, say for a light curve. The syntax of gtioverlap() is
+gtioverlap( "gtifile" , startExpr, stopExpr [, "STARTCOL", "STOPCOL" ] )
+or
+gtioverlap( ’gtifile’ , startExpr, stopExpr [, ’STARTCOL’, ’STOPCOL’ ] )
+The requirements for specifying the gtifile are the same as for gtifilter() as described above. Unlike
+gtifilter(), the startExpr and stopExpr are not optional. startExpr provides a start of the user
+requested time interval. startExpr is typically TIME, but can be any valid expression. Likewise,
+
+8.11. ROW FILTERING SPECIFICATION
+
+105
+
+stopExpr provides the stop of the user requested time interval, and can be an expression. For
+example, for a light curve with a TIME column and time bin size of 1.0 seconds, the expression
+gtioverlap(’gtifile’,TIME,TIME+1.0)
+would calculate the amount of overlap exposure time between each one second time bin and the
+GTI in ’gtifile’. In this case the time bin is assumed to begin at the time specified by TIME and
+end 1 second later. Neither startExpr nor stopExpr are required to be constant, and a light curve
+is not required to have a constant bin size. For tables, the overlap is calculated for each entry in
+the table.
+It is also possible to calculate a single overlap value, which would typically be placed in a keyword.
+For example, a way to to compute the total overlap exposure of a file whose TIME column is
+bounded by the keywords TSTART and TSTOP, overlapping with the specified GTI, would be
+#EXPOSURE = gtioverlap(’gtifile’,#TSTART,#TSTOP)
+The #EXPOSURE syntax with a leading + ensures that the requested values are treated as keywords.
+Otherwise, a column named EXPOSURE will be created with the (constant) exposure value in
+each entry.
 
 8.11.5
 
 Spatial Region Filtering
 
 Another common filtering method selects rows based on whether the spatial position associated
 with each row is located within a given 2-dimensional region. The syntax for this high-level filter
 is
 regfilter( "regfilename" [ , Xexpr, Yexpr [ , "wcs cols" ] ] )
-
-104
-
-CHAPTER 8.
-
-EXTENDED FILE NAME SYNTAX
-
 where each ”[]” demarks optional parameters. The region file name is required and must be enclosed
 in quotes. The remaining parameters are optional. There are 2 supported formats for the region
 file: ASCII file or FITS binary table. The region file contains a list of one or more geometric
 shapes (circle, ellipse, box, etc.) which defines a region on the celestial sphere or an area within a
 particular 2D image. The region file is typically generated using an image display program such
 as fv/POW (distribute by the HEASARC), or ds9 (distributed by the Smithsonian Astrophysical
 Observatory). Users should refer to the documentation provided with these programs for more
 details on the syntax used in the region files. The FITS region file format is defined in a document
 available from the FITS Support Office at http://fits.gsfc.nasa.gov/ registry/ region.html
 In its simplest form, (e.g., regfilter(”region.reg”) ) the coordinates in the default ’X’ and ’Y’ columns
 will be used to determine if each row is inside or outside the area specified in the region file.
 Alternate position column names, or expressions, may be entered if needed, as in
 regfilter("region.reg", XPOS, YPOS)
+
+106
+
+CHAPTER 8.
+
+EXTENDED FILE NAME SYNTAX
+
 Region filtering can be applied most unambiguously if the positions in the region file and in the
 table to be filtered are both give in terms of absolute celestial coordinate units. In this case the
 locations and sizes of the geometric shapes in the region file are specified in angular units on the sky
 (e.g., positions given in R.A. and Dec. and sizes in arcseconds or arcminutes). Similarly, each row
 of the filtered table will have a celestial coordinate associated with it. This association is usually
 implemented using a set of so-called ’World Coordinate System’ (or WCS) FITS keywords that
 define the coordinate transformation that must be applied to the values in the ’X’ and ’Y’ columns
@@ -4958,19 +5040,14 @@
 celestial coordinate of each row in the table with the celestial coordinates in the region file without
 having to know anything about how the image may have been binned.
 The last ”wcs cols” parameter should rarely be needed. If supplied, this string contains the names
 of the 2 columns (space or comma separated) which have the associated WCS keywords. If not
 supplied, the filter will scan the X and Y expressions for column names. If only one is found in
 each expression, those columns will be used, otherwise an error will be returned.
 These region shapes are supported (names are case insensitive):
-
-8.11. ROW FILTERING SPECIFICATION
-
-105
-
 Point
 ( X1, Y1 )
 <- One pixel square region
 Line
 ( X1, Y1, X2, Y2 )
 <- One pixel wide region
 Polygon
@@ -4991,14 +5068,19 @@
 ( Xc, Yc, Rx, Ry, A )
 Elliptannulus ( Xc, Yc, Rinx, Riny, Routx, Routy, Ain, Aout )
 Sector
 ( Xc, Yc, Amin, Amax )
 where (Xc,Yc) is the coordinate of the shape’s center; (X#,Y#) are the coordinates of the shape’s
 edges; Rxxx are the shapes’ various Radii or semi-major/minor axes; and Axxx are the angles of
 rotation (or bounding angles for Sector) in degrees. For rotated shapes, the rotation angle can be
+
+8.11. ROW FILTERING SPECIFICATION
+
+107
+
 left off, indicating no rotation. Common alternate names for the regions can also be used: rotbox
 = box; rotrectangle = rectangle; (rot)rhombus = (rot)diamond; and pie = sector. When a shape’s
 name is preceded by a minus sign, ’-’, the defined region is instead the area *outside* its boundary
 (ie, the region is inverted). All the shapes within a single region file are OR’d together to create
 the region, and the order is significant. The overall way of looking at region files is that if the first
 region is an excluded region then a dummy included region of the whole detector is inserted in the
 front. Then each region specification as it is processed overrides any selections inside of that region
@@ -5017,21 +5099,14 @@
 "point in a rectangular region"
 box(xcntr,ycntr,xfll_wdth,yfll_wdth,rotation,Xcolumn,Ycolumn)
 where
 (xcntr,ycntr) are the (x,y) position of the center of the region
 (xhlf_wdth,yhlf_wdth) are the (x,y) half widths of the region
 (xfll_wdth,yfll_wdth) are the (x,y) full widths of the region
 (radius) is half the diameter of the circle
-
-106
-
-CHAPTER 8.
-
-EXTENDED FILE NAME SYNTAX
-
 (rotation) is the angle(degrees) that the region is rotated with
 respect to (xcntr,ycntr)
 (Xcoord,Ycoord) are the (x,y) coordinates to test, usually column
 names
 NOTE: each parameter can itself be an expression, not merely a
 column name or constant.
 
@@ -5043,14 +5118,20 @@
 
 - Extract all binary stars brighter
 than fifth magnitude (note that
 the initial space is necessary to
 prevent it from being treated as a
 binning specification)
 
+108
+
+CHAPTER 8.
+
+EXTENDED FILE NAME SYNTAX
+
 [#row >= 125 && #row <= 175]
 
 - Extract row numbers 125 through 175
 
 [IMAGE[4,5] .gt. 100]
 
 - Extract all rows that have the
@@ -5083,22 +5164,16 @@
 
 [gtifilter()]
 - Search the current file for a GTI
 extension, filter the TIME
 column in the current table, using
 START/STOP times taken from
 columns in the GTI extension
-
-8.12.
-
-BINNING OR HISTOGRAMMING SPECIFICATION
 [regfilter("pow.reg")]
 
-107
-
 - Extract rows which have a coordinate
 (as given in the X and Y columns)
 within the spatial region specified
 in the pow.reg region file.
 
 [regfilter("pow.reg", Xs, Ys)] - Same as above, except that the
 Xs and Ys columns will be used to
@@ -5107,14 +5182,21 @@
 
 8.12
 
 Binning or Histogramming Specification
 
 The optional binning specifier is enclosed in square brackets and can be distinguished from a general
 row filter specification by the fact that it begins with the keyword ’bin’ not immediately followed
+
+8.12.
+
+BINNING OR HISTOGRAMMING SPECIFICATION
+
+109
+
 by an equals sign. When binning is specified, a temporary N-dimensional FITS primary array
 is created by computing the histogram of the values in the specified columns of a FITS table
 extension. After the histogram is computed the input FITS file containing the table is then closed
 and the temporary FITS primary array is opened and passed to the application program. Thus,
 the application program never sees the original FITS table and only sees the image in the new
 temporary file (which has no additional extensions). Obviously, the application program must be
 expecting to open a FITS image and not a FITS table in this case.
@@ -5133,84 +5215,106 @@
 in which up to 4 columns, each corresponding to an axis of the image, are listed. The column
 names are case insensitive, and the column number may be given instead of the name, preceded by
 a pound sign (e.g., [bin #4=1:512]). If the column name is not specified, then CFITSIO will first
 try to use the ’preferred column’ as specified by the CPREF keyword if it exists (e.g., ’CPREF
 = ’DETX,DETY’), otherwise column names ’X’, ’Y’, ’Z’, and ’T’ will be assumed for each of
 the 4 axes, respectively. In cases where the column name could be confused with an arithmetic
 expression, enclose the column name in parentheses to force the name to be interpreted literally.
-Each column name may be followed by an equals sign and then the lower and upper range of the
-histogram, and the size of the histogram bins, separated by colons. Spaces are allowed before and
-after the equals sign but not within the ’min:max:binsize’ string. The min, max and binsize values
-may be integer or floating point numbers, or they may be the names of keywords in the header of
-the table. If the latter, then the value of that keyword is substituted into the expression.
-
-108
-
-CHAPTER 8.
-
-EXTENDED FILE NAME SYNTAX
-
+In addition to binning by a FITS column, any arbitrary calculator expression may be specified as
+well. Usage of this form would appear as:
+[bin
+
+Xcol(arbitrary expression)=min:max:binsize, ... ]
+
+The column name must still be specified, and is used to label coordinate axes of the resulting image.
+The expression appears immediately after the name, enclosed in parentheses. The expression may
+use any combination of columns, keywords, functions and constants and allowed by the CFITSIO
+calculator.
+The column name (and optional expression) may be followed by an equals sign and then the lower
+and upper range of the histogram, and the size of the histogram bins, separated by colons. Spaces
+are allowed before and after the equals sign but not within the ’min:max:binsize’ string. The min,
+max and binsize values may be integer or floating point numbers, or they may be the names of
+keywords in the header of the table. If the latter, then the value of that keyword is substituted
+into the expression.
 Default values for the min, max and binsize quantities will be used if not explicitly given in the
 binning expression as shown in these examples:
 [bin x = :512:2]
+
+- use default minimum value
+
+110
+
+CHAPTER 8.
 [bin x = 1::2]
 [bin x = 1:512]
 [bin x = 1:]
 [bin x = :512]
 [bin x = 2]
 [bin x]
 [bin 4]
 [bin]
 
-- use default minimum value
+EXTENDED FILE NAME SYNTAX
+
 - use default maximum value
 - use default bin size
 - use default maximum value and bin size
 - use default minimum value and bin size
 - use default minimum and maximum values
 - use default minimum, maximum and bin size
 - default 2-D image, bin size = 4 in both axes
 - default 2-D image
 
 CFITSIO will use the value of the TLMINn, TLMAXn, and TDBINn keywords, if they exist, for
 the default min, max, and binsize, respectively. If they do not exist then CFITSIO will use the
 actual minimum and maximum values in the column for the histogram min and max values. The
 default binsize will be set to 1, or (max - min) / 10., whichever is smaller, so that the histogram
 will have at least 10 bins along each axis.
+Please note that if explicit min and max values (or TLMINn/TLMAXn keywords) are not present,
+then CFITSIO must check every value of the binned quantity in advance to determine the binning
+limits. This is especially relevant for binning expressions, which must be evaluated multiple times
+to determine the limits of the expression. Thus, it is always advisable to specify min and max
+limits where possible.
 A shortcut notation is allowed if all the columns/axes have the same binning specification. In
 this case all the column names may be listed within parentheses, followed by the (single) binning
 specification, as in:
 [bin (X,Y)=1:512:2]
 [bin (X,Y) = 5]
 The optional weighting factor is the last item in the binning specifier and, if present, is separated
 from the list of columns by a semi-colon. As the histogram is accumulated, this weight is used
 to incremented the value of the appropriated bin in the histogram. If the weighting factor is not
-specified, then the default weight = 1 is assumed. The weighting factor may be a constant integer or
-floating point number, or the name of a keyword containing the weighting value. Or the weighting
-factor may be the name of a table column in which case the value in that column, on a row by row
-basis, will be used.
+specified, then the default weight = 1 is assumed. The weighting factor may be a constant integer
+or floating point number, or the name of a keyword containing the weighting value. The weighting
+factor may also be the name of a table column in which case the value in that column, on a row
+by row basis, will be used. It may also be an expression, enclosed in parenthesis, in which case the
+weighting value will be evaluated for each binned row and applied accordingly.
 In some cases, the column or keyword may give the reciprocal of the actual weight value that is
 needed. In this case, precede the weight keyword or column name by a slash ’/’ to tell CFITSIO
-to use the reciprocal of the value when constructing the histogram.
+to use the reciprocal of the value when constructing the histogram. An expression, enclosed in
+parentheses, may also appear after the slash, to indicate the reciprocal value of the expression.
 For complex or commonly used histograms, one can also place its description into a text file and
 import it into the binning specification using the syntax ’[bin @filename.txt]’. The file’s contents can extend over multiple lines, although it must still conform to the no-spaces rule for the
 min:max:binsize syntax and each axis specification must still be comma-separated. Any lines in
 the external text file that begin with 2 slash characters (’//’) will be ignored and may be used to
 add comments into the file.
-Examples:
-[bini detx, dety]
-
-- 2-D, 16-bit integer histogram
 
 8.12.
 
 BINNING OR HISTOGRAMMING SPECIFICATION
+
+111
+
+Examples:
+[bini detx, dety]
+
+- 2-D, 16-bit integer histogram
 of DETX and DETY columns, using
 default values for the histogram
 range and binsize
+
 [bin (detx, dety)=16; /exposure] - 2-D, 32-bit real histogram of DETX
 and DETY columns with a bin size = 16
 in both axes. The histogram values
 are divided by the EXPOSURE keyword
 value.
 [bin time=TSTART:TSTOP:0.1]
 
@@ -5218,23 +5322,35 @@
 the TSTART and TSTOP keywords,
 with 0.1 unit size bins.
 
 [bin pha, time=8000.:8100.:0.1] - 2-D image using default binning
 of the PHA column for the X axis,
 and 1000 bins in the range
 8000. to 8100. for the Y axis.
+[bin pha, gti_num(gtifind())=1:2:1] - a 2-D image, where PHA is the
+X axis and the Y axis is an expression
+which evaluates to the GTI number,
+as determined using the
+GTIFIND() function.
+[bin time=0:4000:2000, HR( (LC2/LC1).lt.1.5 ? 1 : 2 )=1:2:1] - a 2-D
+histogram which determines the number
+of samples in two time bins between 0 and
+4000 and separating hardness ratio,
+evaluated as (LC2/LC1), between less than
+1.5 or greater than 1.5. The ?:
+conditional function is used to decide
+less (or greater) than 1.5 and assign
+HR bin 1 or 2.
 [bin @binFilter.txt]
 
 - Use the contents of the text file
 binFilter.txt for the binning
 specifications.
 
-109
-
-110
+112
 
 CHAPTER 8.
 
 EXTENDED FILE NAME SYNTAX
 
 Chapter 9
 
@@ -5265,17 +5381,17 @@
 line are all blank, then the entire line is treated as a FITS comment keyword (with a blank keyword
 name) and is copied verbatim into the FITS header.
 The KEYVALUE field may have any allowed FITS data type: character string, logical, integer,
 real, complex integer, or complex real. Integer values must be within the allowed range of a ’signed
 long’ variable; some C compilers only suppport 4-byte long integers with a range from -2147483648
 to +2147483647, whereas other C compilers support 8-byte integers with a range of plus or minus
 2**63.
-111
+113
 
-112
+114
 
 CHAPTER 9. TEMPLATE FILES
 
 The character string values need not be enclosed in single quote characters unless they are necessary
 to distinguish the string from a different data type (e.g. 2.0 is a real but ’2.0’ is a string). The
 keyword has an undefined (null) value if the template record only contains blanks following the
 ”=” or between the ”=” and the ”/” comment field delimiter.
@@ -5313,15 +5429,15 @@
 TFORM# = 1D
 TTYPE# = RATE
 TFORM# = 1E
 will create TTYPE1, TFORM1, TTYPE2, and TFORM2 keywords. But if the template looks like,
 
 9.3. TEMPLATE PARSER DIRECTIVES
 
-113
+115
 
 TTYPE# = TIME
 TTYPE# = RATE
 TFORM# = 1D
 TFORM# = 1E
 this results in a FITS files with TTYPE1, TTYPE2, TFORM2, and TFORM2, which is probably
 not what was intended!
@@ -5353,15 +5469,15 @@
 3) bintable (member of GROUP in HDU number 2)
 Technically speaking, the GROUP HDU is a BINTABLE with 6 columns. Applications can define
 additional columns in a GROUP HDU using TFORMn and TTYPEn (where n is 7, 8, ....) keywords
 or their auto-indexing equivalents.
 For a more complicated example of a template file using the group directives, look at the sample.tpl
 file that is included in the CFITSIO distribution.
 
-114
+116
 
 9.4
 
 CHAPTER 9. TEMPLATE FILES
 
 Formal Template Syntax
 
@@ -5403,15 +5519,15 @@
 NAXIS2 = 200 / length of second axis
 OBJECT = NGC 253 / name of observed object
 The allowed values of BITPIX are 8, 16, 32, -32, or -64, representing, respectively, 8-bit integer,
 16-bit integer, 32-bit integer, 32-bit floating point, or 64 bit floating point pixels.
 
 9.6. EXAMPLES
 
-115
+117
 
 2. To create a FITS table, the template first needs to include XTENSION = TABLE or BINTABLE
 to define whether it is an ASCII or binary table, and NAXIS2 to define the number of rows in the
 table. Two template lines are then needed to define the name (TTYPEn) and FITS data format
 (TFORMn) of the columns, as in this example:
 xtension = bintable
 naxis2 = 40
@@ -5426,15 +5542,15 @@
 columns called ’Name’, ’Npoints’, and ’Rate’, with data formats of ’10A’ (ASCII character string),
 ’1J’ (integer) and ’1E’ (floating point), respectively. Note that the other required FITS keywords
 (BITPIX, NAXIS, NAXIS1, PCOUNT, GCOUNT, TFIELDS, and END) do not need to be explicitly defined in the template because their values can be inferred from the other keywords in
 the template. This example also illustrates that the templates are generally case-insensitive (the
 keyword names and TFORMn values are converted to upper-case in the FITS file) and that string
 keyword values generally do not need to be enclosed in quotes.
 
-116
+118
 
 CHAPTER 9. TEMPLATE FILES
 
 Chapter 10
 
 Summary of all FITSIO
 User-Interface Subroutines
@@ -5461,17 +5577,17 @@
 FTFLUS(unit, > status)
 FTCLOS(unit, > status)
 FTDELT(unit, > status)
 FTGIOU( > iounit, status)
 FTFIOU(iounit, > status)
 CFITS2Unit(fitsfile *ptr)
 (C routine)
-117
+119
 
-118
+120
 
 CHAPTER 10.
 
 SUMMARY OF ALL FITSIO USER-INTERFACE SUBROUTINES
 
 CUnit2FITS(int unit)
 (C routine)
@@ -5510,15 +5626,15 @@
 FTPTHP(unit,theap, > status)
 Header Space and Position Subroutines: page 43
 FTHDEF(unit,morekeys, > status)
 FTGHSP(iunit, > keysexist,keysadd,status)
 FTGHPS(iunit, > keysexist,key_no,status)
 Read or Write Standard Header Subroutines: page 43
 
-119
+121
 FTPHPS(unit,bitpix,naxis,naxes, > status)
 FTPHPR(unit,simple,bitpix,naxis,naxes,pcount,gcount,extend, > status)
 FTGHPR(unit,maxdim, > simple,bitpix,naxis,naxes,pcount,gcount,extend,
 status)
 FTPHTB(unit,rowlen,nrows,tfields,ttype,tbcol,tform,tunit,extname, >
 status)
 FTGHTB(unit,maxdim, > rowlen,nrows,tfields,ttype,tbcol,tform,tunit,
@@ -5551,15 +5667,15 @@
 FTIKYU(unit,keyword,comment, > status)
 Read Keyword Subroutines: page 47
 FTGREC(unit,key_no, > card,status)
 FTGKYN(unit,key_no, > keyword,value,comment,status)
 FTGCRD(unit,keyword, > card,status)
 FTGNXK(unit,inclist,ninc,exclist,nexc, > card,status)
 
-120
+122
 
 CHAPTER 10.
 
 SUMMARY OF ALL FITSIO USER-INTERFACE SUBROUTINES
 
 FTGKEY(unit,keyword, > value,comment,status)
 FTGKY[EDJKLS](unit,keyword, > keyval,comment,status)
@@ -5592,15 +5708,15 @@
 FTPNUL(unit,blank, > status)
 FTSNUL(unit,colnum,snull > status)
 FTTNUL(unit,colnum,tnull > status)
 FITS Primary Array or IMAGE Extension I/O Subroutines: page 52
 FTGIDT(unit, > bitpix,status)
 FTGIET(unit, > bitpix,status)
 
-121
+123
 FTGIDM(unit, > naxis,status)
 FTGISZ(unit, maxdim, > naxes,status)
 FTGIPR(unit, maxdim, > bitpix,naxis,naxes,status)
 FTPPR[BIJKED](unit,group,fpixel,nelements,values, > status)
 FTPPN[BIJKED](unit,group,fpixel,nelements,values,nullval > status)
 FTPPRU(unit,group,fpixel,nelements, > status)
 FTGPV[BIJKED](unit,group,fpixel,nelements,nullval, > values,anyf,status)
@@ -5613,15 +5729,15 @@
 FTG3D[BIJKED](unit,group,nullval,dim1,dim2,naxis1,naxis2,naxis3, >
 cube,anyf,status)
 FTPSS[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,array, > status)
 FTGSV[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs,nullval, >
 array,anyf,status)
 FTGSF[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs, >
 array,flagvals,anyf,status)
-Table Column Information Subroutines: page 55
+Table Column Information Subroutines: page 56
 FTGNRW(unit, > nrows, status)
 FTGNCL(unit, > ncols, status)
 FTGCNO(unit,casesen,coltemplate, > colnum,status)
 FTGCNN(unit,casesen,coltemplate, > colnam,colnum,status)
 FTGTCL(unit,colnum, > datacode,repeat,width,status)
 FTEQTY(unit,colnum, > datacode,repeat,width,status)
 FTGCDW(unit,colnum, > dispwidth,status)
@@ -5635,15 +5751,15 @@
 FTGRSZ(unit, > nrows,status)
 Low-Level Table Access Subroutines: page 58
 FTGTBS(unit,frow,startchar,nchars, > string,status)
 FTPTBS(unit,frow,startchar,nchars,string, > status)
 FTGTBB(unit,frow,startchar,nchars, > array,status)
 FTPTBB(unit,frow,startchar,nchars,array, > status)
 
-122
+124
 
 CHAPTER 10.
 
 SUMMARY OF ALL FITSIO USER-INTERFACE SUBROUTINES
 
 Edit Rows or Columns page 59
 FTIROW(unit,frow,nrows, > status)
@@ -5681,15 +5797,15 @@
 array,anynul,status)
 FTCALC(inunit, expr, outunit, parName, parInfo, > status)
 FTCALC_RNG(inunit, expr, outunit, parName, parInfo,
 nranges, firstrow, lastrow, > status)
 FTTEXP(unit, expr, > datatype, nelem, naxis, naxes, status)
 Celestial Coordinate System Subroutines: page 65
 
-123
+125
 FTGICS(unit, > xrval,yrval,xrpix,yrpix,xinc,yinc,rot,coordtype,status)
 FTGTCS(unit,xcol,ycol, >
 xrval,yrval,xrpix,yrpix,xinc,yinc,rot,coordtype,status)
 FTWLDP(xpix,ypix,xrval,yrval,xrpix,yrpix,xinc,yinc,rot,
 coordtype, > xpos,ypos,status)
 FTXYPX(xpos,ypos,xrval,yrval,xrpix,yrpix,xinc,yinc,rot,
 coordtype, > xpix,ypix,status)
@@ -5722,15 +5838,15 @@
 FTKEYN(keyroot,seq_no, > keyword,status)
 FTNKEY(seq_no,keyroot, > keyword,status)
 FTDTYP(value, > dtype,status)
 class = FTGKCL(card)
 FTASFM(tform, > datacode,width,decimals,status)
 FTBNFM(tform, > datacode,repeat,width,status)
 
-124
+126
 
 CHAPTER 10.
 
 SUMMARY OF ALL FITSIO USER-INTERFACE SUBROUTINES
 
 FTGABC(tfields,tform,space, > rowlen,tbcol,status)
 FTGTHD(template, > card,hdtype,status)
@@ -5768,17 +5884,17 @@
 curaddr - (integer) starting address (in bytes) of the CHDU
 current - (integer) if not equal to 0, copy the current HDU
 datacode - (integer) symbolic code of the binary table column datatype
 dataok - (integer) was the data unit verification successful (=1) or
 not (= -1). Equals zero if the DATASUM keyword is not present.
 datasum - (double precision) 32-bit 1’s complement checksum for the data unit
 datatype - (character) datatype (format) of the binary table column
-125
+127
 
-126
+128
 datestr
 
 CHAPTER 11.
 
 PARAMETER DEFINITIONS
 
 - (string) FITS date/time string: ’YYYY-MM-DDThh:mm:ss.ddd’,
@@ -5825,15 +5941,15 @@
 history - (character) the HISTORY keyword comment string
 hour - (integer) hour from 0 - 23
 image - 2D image of the appropriate datatype
 inclist (character array) list of names to be included in search
 incs - (integer array) sampling interval for pixels in each FITS dimension
 intval - (integer) integer part of the keyword value
 
-127
+129
 iounit - (integer) value of an unused I/O unit number
 iunit - (integer) logical unit number associated with the input FITS file, 1-300
 key_no - (integer) sequence number (starting with 1) of the keyword record
 keylength - (integer) length of the keyword name
 keyroot - (character) root string for the keyword name
 keysadd -(integer) number of new keyword records which can fit in the CHU
 keysexist - (integer) number of existing keyword records in the CHU
@@ -5875,15 +5991,15 @@
 offset - (integer) byte offset in the heap to the first element of the array
 offsetll - (integer*8) byte offset in the heap to the first element of the array
 oldkey - (character) old name of keyword to be modified
 ounit - (integer) logical unit number associated with the output FITS file 1-300
 pcount - (integer) value of the PCOUNT keyword (usually = 0)
 previous - (integer) if not equal to 0, copy all previous HDUs in the input file
 
-128
+130
 
 CHAPTER 11.
 
 PARAMETER DEFINITIONS
 
 repeat - (integer) length of element vector (e.g. 12J); ignored for ASCII table
 rot - (double precision) celestial coordinate rotation angle (degrees)
@@ -5929,15 +6045,15 @@
 units - (character) the keyword units string (e.g., ’km/s’)
 value - (character) the keyword value string
 values - array of data values of the appropriate datatype
 varidat - (integer) size in bytes of the ’variable length data area’
 following the binary table data (usually = 0)
 version - (real) current revision number of the library
 
-129
+131
 width - (integer) width of the character string field
 xcol - (integer) number of the column containing the X coordinate values
 xinc - (double precision) X axis coordinate increment at reference pixel (deg)
 xpix - (double precision) X axis pixel location
 xpos - (double precision) X axis celestial coordinate (usually RA) (deg)
 xrpix - (double precision) X axis reference pixel array location
 xrval - (double precision) X axis coordinate value at the reference pixel (deg)
@@ -5945,15 +6061,15 @@
 year - (integer) last 2 digits of the year (00 - 99)
 yinc - (double precision) Y axis coordinate increment at reference pixel (deg)
 ypix - (double precision) y axis pixel location
 ypos - (double precision) y axis celestial coordinate (usually DEC) (deg)
 yrpix - (double precision) Y axis reference pixel array location
 yrval - (double precision) Y axis coordinate value at the reference pixel (deg)
 
-130
+132
 
 CHAPTER 11.
 
 PARAMETER DEFINITIONS
 
 Chapter 12
 
@@ -6018,17 +6134,17 @@
 
 bad argument in shared memory driver
 null pointer passed as an argument
 no more free shared memory handles
 shared memory driver is not initialized
 IPC error returned by a system call
 no memory in shared memory driver
-131
+133
 
-132
+134
 
 CHAPTER 12.
 
 FITSIO ERROR STATUS CODES
 
 157
 158
@@ -6118,15 +6234,15 @@
 column is too wide to fit within the specified width of the ASCII table
 the specified column name template matched more than one column name
 binary table row width is not equal to the sum of the field widths
 unrecognizable type of FITS extension
 unrecognizable FITS record
 END keyword contains non-blank characters in columns 9-80
 
-133
+135
 254
 255
 261
 262
 263
 
 Header fill area contains non-blank characters
@@ -6197,15 +6313,15 @@
 line read seems to be empty (used
 internally)
 cannot unread more then 1 line (or single
 line twice)
 too deep include file nesting (infinite
 loop, template includes itself ?)
 
-134
+136
 
 CHAPTER 12.
 
 366 NGP_ERR_FOPEN
 367 NGP_EOF
 368 NGP_BAD_ARG
 369 NGP_TOKEN_NOT_EXPECT
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/fitsio.ps` & `fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.ps`

 * *Files 13% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 %!PS-Adobe-2.0
-%%Creator: dvips(k) 5.993 Copyright 2013 Radical Eye Software
+%%Creator: dvips(k) 5.997 Copyright 2017 Radical Eye Software
 %%Title: fitsio.dvi
-%%CreationDate: Thu Aug  6 15:03:52 2020
-%%Pages: 140
+%%CreationDate: Wed Nov  2 19:56:30 2022
+%%Pages: 142
 %%PageOrder: Ascend
-%%BoundingBox: 0 0 612 792
+%%BoundingBox: 0 0 596 842
 %%DocumentFonts: CMBX12 CMR12 CMR10 CMBX10 CMSL10 CMTT10 CMSY10 CMMI10
 %%+ CMR8
-%%DocumentPaperSizes: Letter
+%%DocumentPaperSizes: a4
 %%EndComments
 %DVIPSWebPage: (www.radicaleye.com)
 %DVIPSCommandLine: dvips -o fitsio.ps fitsio.dvi
 %DVIPSParameters: dpi=600
-%DVIPSSource:  TeX output 2020.08.06:1503
+%DVIPSSource:  TeX output 2022.11.02:1555
 %%BeginProcSet: tex.pro 0 0
 %!
 /TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
 N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
 mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
 0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
 landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
@@ -74,93 +74,14 @@
 sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
 mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
 exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
 forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
 end
 
 %%EndProcSet
-%%BeginProcSet: special.pro 0 0
-%!
-TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
-/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
-/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
-/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
-/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
-X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
-/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
-/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
-{userdict/md get type/dicttype eq{userdict begin md length 10 add md
-maxlength ge{/md md dup length 20 add dict copy def}if end md begin
-/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
-atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
-itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
-transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
-curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
-pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
-if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
--1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
-get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
-yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
-neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
-noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
-90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
-neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
-1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
-2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
--1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
-TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
-Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
-}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
-save N userdict maxlength dict begin/magscale true def normalscale
-currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
-/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
-psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
-psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
-TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
-@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
-newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
-closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
-/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
-currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
-N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
-neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
-rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
-scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
-lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
-ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
-/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
-pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
-restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
-/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
-setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
-moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
-matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
-savematrix setmatrix}N end
-
-%%EndProcSet
-TeXDict begin @defspecial
-
- systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
-put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
-/cleartomark get put}ifelse
-
- /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
-mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
-dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
-{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
-pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
-exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
-exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
-exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
-exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
-HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
-sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
-exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def
- 
-@fedspecial end
 %%BeginFont: CMR8
 %!PS-AdobeFont-1.0: CMR8 003.002
 %%Title: CMR8
 %Version: 003.002
 %%CreationDate: Mon Jul 13 16:17:00 2009
 %%Creator: David M. Jones
 %Copyright: Copyright (c) 1997, 2009 American Mathematical Society
@@ -173,15 +94,14 @@
 /UniqueID get 5000791 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMR8 def
 /FontBBox {-36 -250 1070 750 }readonly def
-/UniqueID 5000791 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR8.) readonly def
 /FullName (CMR8) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Medium) readonly def
@@ -410,15 +330,14 @@
 /UniqueID get 5087385 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMMI10 def
 /FontBBox {-32 -250 1048 750 }readonly def
-/UniqueID 5087385 def
 /PaintType 0 def
 /FontInfo 10 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMMI10.) readonly def
 /FullName (CMMI10) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Medium) readonly def
@@ -832,15 +751,14 @@
 /UniqueID get 5000769 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMBX12 def
 /FontBBox {-53 -251 1139 750 }readonly def
-/UniqueID 5000769 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMBX12.) readonly def
 /FullName (CMBX12) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Bold) readonly def
@@ -1483,29 +1401,29 @@
 /UniqueID get 5096651 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMSY10 def
 /FontBBox {-29 -960 1116 775 }readonly def
-/UniqueID 5096651 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSY10.) readonly def
 /FullName (CMSY10) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Medium) readonly def
 /ItalicAngle -14.04 def
 /isFixedPitch false def
 /UnderlinePosition -100 def
 /UnderlineThickness 50 def
 end readonly def
 /Encoding 256 array
 0 1 255 {1 index exch /.notdef put} for
+dup 2 /multiply put
 dup 15 /bullet put
 dup 102 /braceleft put
 dup 103 /braceright put
 dup 106 /bar put
 readonly def
 currentdict end
 currentfile eexec
@@ -1688,35 +1606,40 @@
 D4459CFD15BB117B5C9745EF3CD2B296D91FAD48C80B136D94476967E255F808
 AD2B5D522ADEC64176833756510391815A1D4A8DA1D0AEE7CAD36A1D161889F2
 3347D5B6BC503300FDDD48F594F391D5FB42C42113C538E707C16EE24A3F375E
 7C506E8F49CE50FF9DEF3B4A4C1BEB3848EAA3477349833BA22D2A9012287D8B
 A8C4CB4307A1188ACC0E6E9338E1559BE5FAFF381BD82A6C71C267409468B3C0
 2C1A29F4281D565836EAE57F680490FEA4A952FF64C8CD11C377C294DCD1EC25
 CEFB2B6DCE959D0208F85B6E32E9B44FD455F9B134A5306D95EA29F37BB8B86D
-9E592159338E1293F449380E13C21AE42E6E371B75D78AA87381B96012E722B1
-3E1628DC89D9009FB38D9984AECC3367A8436F03DD58F85DD4971868D7949185
-A1073DA64020E32F61C371D29A74A3D9B70EE7F05073531287B2243D355F2FA2
-FCAE099817F63A3235CF8AD47382886B3DCC93B9E205EC405ADD22C031A21714
-FE178378C5E228BAB7950F3FF40CB589F4BB895CB7D6320A1E7D608276EFC3F3
-148DA7EE00DC79E33F1B3D13C0FC26E0424C441C55AE7E3153411881C628B7DB
-E25EB59D686887F5F66117D601DD8B5EFED15B387372AD0BDB339C9A3D9DB135
-F53F30B68802D99EA4ED900E6A375018BD9109755FCF8B4D07E1F717FD46AC4C
-CE5D401AA5635BA4F8BFBD4488691BAFD8B51A85A2F0180FB9CC06A6C5DAEFFA
-CAF15F4D81ED657F9A8D619150A2C87A20879403F7E9469AE85911988ACCD635
-72599A7AA62EBDA42439FEDBC602E0698318FFEEC8EFE7DCA381A7F2E21145FF
-A5549BF6B3BBABD08760336875BA183FF4FA92D4569087FDE0AB50E0B2DD97D4
-DCE9D3D6EBF5A1FAF7C0C4CA715A6A6BA67A7A08145F3D9545265B3862776E4D
-179F3FA9B1AE033885A84C8F91F20615521D85E69BD951B98580E3873206DF82
-AF43C6F1C8D14BA99D15F71E588FC5439AE3E6B1545591BCCB19B119AF4F4362
-4E93255B5034ED730A5B3E6C42C7862662D49A8A4E41FD9740AE6766863D5CD5
-2D8E54C0CD96F5A70B88B015C76E25FE4017A9F55256D3E7B3F0F4F94C90EBB9
-0D67CAC1F26311AE82B804F8A2426910C18253743ED4FE97B183F3F04471D7AA
-8FA7CDFBE63BEFF13C451E52F0137E2D0079D4DD39A80BF5A1E253CD09AD807D
-171B398CB6A28E9B6B7953ED5077897E1D740360E8FE61328BF8AF332205ABF8
-C5F7964B
+9E592159338E1293F449380E13C21AE42E6D6952083BFD432F72DFB7B6F9257F
+5784C683A6E9ACD72334E0EA8060A81E14EE32300055040E24B49810DFA14691
+6C24BF2DE490536C01F7E874AEEF98A27529489EC334D0CD71D022C7F2BBB98A
+F39D6C0A24CF29DB0E4545C4D32475724F30A87F09B0440D5DB8F6D6FE35EF4A
+E22528DAAFC1EF6D0EC88A1B219DB61417DA4DBA42721255EC9BC5BE05026051
+19D8A0F096F8D68C40B3503B07497CD44A236137AB06B407CA6F5F9EE2F4E99D
+735EA287E2C3641BAADF92681D7D2794DD2B3C8D22F78C22D1E3AB2B40478AB8
+1EA3AD94008B0D3A5C125EFD6410D27BDD3C8BD16760A91B021C3011332D045E
+943A0FCE3EE596985F76817964430053449F5D3233033BAFA7ED9006FE3F8F03
+7CF09FCECF6F9848B4911E308C2DBDC25125EEFCF25224F0FDBD646314EE17C2
+08BDB63DFD830CE806A0D5D052D625AD620D280CA2784B6AEDA6506A0259806F
+5D5C7B85E8F7BA376815E2F2215497C3AC9F73E6CE583B5078FEDDD2EAB2D715
+7C1FE58B7AA299FEFF8F9B74132E774432D66B6F51CBFD2D501CF98755BF1710
+67716A231B625079AD782207EEB1BC4F8FB30618FE4B98CE3474535899364083
+B1A82A67CD5E9033553583A876BC1DAC1F7930DC099D806B1E27389125E1B15C
+BB1C66AD365F820FE2A7FCA56F38F9C8BB1658172DA09AB74E85D6DF8F81455E
+28532112209876E18F8816DC08CC1EA309027B54F73921BFACC25D7255F26202
+20C3FCB8E515C7F79EA3054A9B5AC4EDD0AE44B896169E458932B4B8E3EFCA58
+679F2F0B9FBFBC4E524C762D07DCFC8BD7229068C1BF9CB2459B251A59600C8C
+EA5B5D9A1DCEBEBEB971D77F197D2C10067E6D4C013C60B8EB15C457602F3654
+379B45E1CCF06CD4A72D50AEAB4F56AA49FFDB41A137F6EB9AC761F4582E18AC
+E8384F4B9CD7E26FB8A061431204F100081B243EF021572943842B32EE0A1434
+3D615BE9A784FCEA05B8B846DDBB604AE63EB9901008B6D8469EC51784D53D21
+42AAD960B0272DEF6A7CC0C48218F5ADAFB33DB55F35AC8998EA798171E0EFA0
+9AEAFE35DCBFD62B28F52B14D8ACE54352B1E9E1E97171961E0873004EF1B289
+3197CC5D8F426CEC68E7E00FCF5E
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
@@ -1740,15 +1663,14 @@
 /UniqueID get 5000832 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMTT10 def
 /FontBBox {-4 -233 537 696 }readonly def
-/UniqueID 5000832 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMTT10.) readonly def
 /FullName (CMTT10) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Medium) readonly def
@@ -2542,15 +2464,14 @@
 /UniqueID get 5000798 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMSL10 def
 /FontBBox {-62 -250 1123 750 }readonly def
-/UniqueID 5000798 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMSL10.) readonly def
 /FullName (CMSL10) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Medium) readonly def
@@ -3057,15 +2978,14 @@
 /UniqueID get 5000768 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMBX10 def
 /FontBBox {-56 -250 1164 750 }readonly def
-/UniqueID 5000768 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMBX10.) readonly def
 /FullName (CMBX10) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Bold) readonly def
@@ -3674,15 +3594,14 @@
 /UniqueID get 5000793 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMR10 def
 /FontBBox {-40 -250 1009 750 }readonly def
-/UniqueID 5000793 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR10.) readonly def
 /FullName (CMR10) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Medium) readonly def
@@ -4616,15 +4535,14 @@
 /UniqueID get 5000794 eq exch/FontType get 1 eq and}{pop false}ifelse
 {save true}{false}ifelse}{false}ifelse
 11 dict begin
 /FontType 1 def
 /FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
 /FontName /CMR12 def
 /FontBBox {-34 -251 988 750 }readonly def
-/UniqueID 5000794 def
 /PaintType 0 def
 /FontInfo 9 dict dup begin
 /version (003.002) readonly def
 /Notice (Copyright \050c\051 1997, 2009 American Mathematical Society \050<http://www.ams.org>\051, with Reserved Font Name CMR12.) readonly def
 /FullName (CMR12) readonly def
 /FamilyName (Computer Modern) readonly def
 /Weight (Medium) readonly def
@@ -4633,28 +4551,25 @@
 /UnderlinePosition -100 def
 /UnderlineThickness 50 def
 end readonly def
 /Encoding 256 array
 0 1 255 {1 index exch /.notdef put} for
 dup 46 /period put
 dup 48 /zero put
-dup 49 /one put
 dup 50 /two put
-dup 51 /three put
-dup 54 /six put
-dup 65 /A put
+dup 52 /four put
+dup 78 /N put
 dup 86 /V put
 dup 101 /e put
 dup 105 /i put
-dup 108 /l put
 dup 110 /n put
 dup 111 /o put
-dup 112 /p put
 dup 114 /r put
 dup 115 /s put
+dup 118 /v put
 readonly def
 currentdict end
 currentfile eexec
 D9D66F633B846AB284BCF8B0411B772DE5CE3DD325E55798292D7BD972BD75FA
 0E079529AF9C82DF72F64195C9C210DCE34528F540DA1FFD7BEBB9B40787BA93
 51BBFB7CFC5F9152D1E5BB0AD8D016C6CFA4EB41B3C51D091C2D5440E67CFD71
 7C56816B03B901BF4A25A07175380E50A213F877C44778B3C5AADBCC86D6E551
@@ -4833,1656 +4748,436 @@
 34DE10D995ABCAF45FBB3B6B73E80D05F4C51F8C29D4B0F67C8A86432A6C5E86
 F0126AB25A5CA2875B48C61CB8112A4CF9AA08F8B0157396CF63CBECDB8867CC
 AC10F060630C9BFBAD84B1FF01C814878F0C177F552BDC9BB181B14581C6E968
 DAAAB2896FCFB745795C4D2C87CC15BAA041EF80C5BDC12EC1F5786BB41A5A21
 073EE0BC436B346E014DB4099EDC67BC432E470A4B779FD556341061CA3F2BE8
 EFA332637AEC878C2BB189CA3267B2BE5B8178E6B7889A33771F86276E6F0B8E
 8E93B816AC7005575762EF4DE45E2794B7322F9B6D8E634FB8FF250D638EB502
-818321B3C46DB51B8EC6C2EF1D05C716519A3BD6B12A67239898F8A012A2E728
-A6AE0A939A05EBF8642BF7FE7ECFADD91B15EF15CB9FD9B189A89C673790C29E
-22031788A4DA48F9A59693E02266D9BC8B7521204E23A07F6C0E136EA6F70551
-048C10EBDA54D02F35584410F89E68B4AF91361961F71483D243B72B3E700F97
-5E2CE90CDE806AD7D5094CB8251B566E004BA1F67B51A880FB42BEFE8B5C68B0
-B90AEF6C92A918B117C0C969542C89C8FE0067E9C27F17A1D796AE8349B153F7
-6DFD069EF52F41B77E22D9F1D9308B85946E62B3649BD9AF837FAF2FC6C76BA6
-58E3AAF2F6C8325FA609F1E306EF96D0B9DBF0A5DE70D2603194708D9C728DC2
-77BCF00DFE5C410982A77054B16DE17ECEFF2E41314AC13176FD43C5878506B2
-2FD2E7357992F9807E8B525DEE5B7DB31AD8ADDA3464685ADA4A3EF623254FE8
-233F30C377B05984B29625683781BC51E9C8E1085D3BEB9AE8DC09A9E52445F7
-8948FBDA938A1B5BBAA87E2F85C8B07D1BB520EC8E5B55E9264A9F2A3E8D6374
-E96B4BA9ACF61C5B544A657ADA6FA8AD247D7AEDF038A11FB067228B6E6EDCE6
-6B58C1BF14B6584EB442FAF2D78F7D76018C2D80579288D5735F438A42101470
-FB9EF29E348A2DDB82845AE4DCDC9EB997811E2DF7280188D7E79CBF29A60B42
-A1215316AFFC0AD6B6A8ABDDA86603C0D66D4D085276FDE18FAE1DE6900B2AB9
-55F1B96A72F82A2CD29B35A3A62A002FDA029C474A561EA4F5825423A12F9F2E
-5D2B8DC293A27FF2BAC31133D2373364CDA748E1BD82C8E64E291EE8E9E19ED3
-A999FEEFA41C0EC2E9426BD396B797444FE4D311B450F8886921D1CA73700BF4
-0A568DDDCD1D4F37427E85D316839FF966B7D7DE258F8EA1826813FB5960742B
-D36F495BB12C42ECF0E812C41FE897FB6D93C7FEBD9A74BA68C08A3E69B2B695
-21D812991BF5AB64C835E96FF202655D209DB002411E27EB5019472CB348714E
-A6FEA749F6CE93F8D389A6B4055CBAA32546F45C73F49ADD4026C65A42474316
-243F5F79A8AE57430A95E243E1AA0026DBD287342FDE34A7C05AFECC87397E4F
-78DD5739AE1ED0A4C1F698AA664272D52468006CDB9E5F9F57B72C909F9576DB
-F0205DC94A4E783C53D3713BAB6CBDA37BBB1F63F4D6237DDC802A7780F8ECA0
-348451CD0928F0F34F43E95A595233CAAF00546CC785437B3E392A1CD12943B1
-A2BCC8E24691CC31F6DD32F254BFCFA15D01F20AA0A2AEE08723D0C5FF947E52
-3BBD797ECDF13E33D51BA8DAD7999704DBD56D0339BF6E8B6A31DF8DB932690D
-3FDC63940F7AF6A1D65EB05F1577B736FCA16841E0122BA1BABCD6B1DA6C2D6D
-50033CC262E2550866103B9F982912176DA8521BFCAE530CD8271B3A32122C46
-91AE59BFEBE628626195B8E712093A2DDF349697093A5A297E514BC096DFA009
-9C76175EB0FF38807C7FA63400143DC91CDC08EE228780F952E0B7B20D4A280F
-14855E3E42222B344D0285B0352BFCE745A3437CDB5185B30B72293D4D0CFB5F
-5D3837B45636EBC7CF6D820AB6E957C18983C2E2260126F0E88969BC6CF71C9E
-CE8D44B88060CC2F5DFD4CA361808D9C60FBEF8D393D875BAE266281050E2FEF
-569F0772BE42267812CF7731366F02341682B93618B96B647C16A8B54D9CA361
-BCC186D213428D204A7E3E1F0F7D6B8D524A123FCDDBD9DDA2CAFF282F2A49C5
-F1CEC353434236104C654AE7B93AAE0C49561C651D630132FE1ADE0F6C0BBFD2
-FA65C4973E9F5851CE7A7B735BDEB1E64A8BCB16175C2F339923AE8AC47F7251
-082E0F222D160DD481A0E5B9D5DC769E4AB552075D77A22620058BC163EA81AB
-DA41E41F15147E8468E7A247EC1BAAE21B6ACFD357CCD59925F7DED4FF133FFE
-4DD2BA3E6F326450200B6ACF3DD244C32A9EE4989CF36456E0604BDD5E71CAAC
-304D9F8A9D7BCA24048CD1BC51AF4457A85E3855D0C2E88B2D8BC4D42569F28A
-454CF4E5391FB7E1A7B8BC86D5B2C67D33DCED3CA5843E3B94A16C9D6A52D106
-C7602CB589C022FF3A0B18155118D87B44BB756BE237B8AA6FE6C199B906AC94
-E6025FB3C9D25699435270B17B9AFE2EABC1580902F56C80943713172367C9B6
-28D9C16D60EFFB272565720B559E456D3C923E67161ACA65AD4D262217845C1C
-01F1A705908535248E30EEC91E67F320E4D744835F4B51C371A7A242E79EE94F
-00EEAD4E4D9C02BE0818C4AF0C03CC20AAD951EA8BA3CD01B25D94B0ADB26C8C
-6D2B1C8068D9749E3B97E047A8421D2F2BDAAC2B500B37969F67F3B121354E41
-AB81B9427E018F6B5A432FA286ECA989286D926C264111B7312E3DD0018BCA9A
-4749E69893CDBD6A593D00BF86A4CC52668325882D95043079F6AA4C265E4C65
-722EBEFFBB42FFCFEDCB22EBF54E214D5ED8B24799F4455A74ABB0E4CF693A2A
-1DAC3D42C54C6567DF0BA73F2237C28D2FDD30E2C2FD1CE570BBCB4AE5338D38
-DFA6CBFA41BCCE0130783DEE65D75574783F9994FD57C6B5FD08BF09C8A3DEDA
-CCD5AEEB8A2DDA470D26028818AF5AE668021CF79175290E5E0786972B02EB6C
-407C2E22A7F0748722471E0AF10A54F4A2618C6DFA45DE7C0B347691B8668BC1
-9DADADB533C3906B3908B11360021F565A6E9C794636E3DD1D48D0ACCD0F857D
-4D0042C0B43EBE1B44855CCC6EA781D909546FBFDEB17FAECAD30A359D2E93B8
-6A021F617C3D30025EDEBB189F2F426B78B1E8EFB337D864CE8D7F8AEF58EC30
-9C0977051DF2C50704EC7E721AAAA9F7D5E25D24AFE813C5D6D6B9260769852F
-1B9FE5FFFCE13B509FC9F92AE674033BF8088CC775D5D2726A2EE1B3E129E746
-3E2E43B405AA3FC45D55535AA4301B5FCE8C5085325F4DFA75679661DDDA5FBD
-4EC979E3431F87B1B3C31EBA4E87FC35DD9AD053BCAC36E8D6B71663C6AAF015
-B9F8B0A1A0FB002ED22264568E0F53A6D8106513742371EF1A88525E333606EB
-8A9CB8AE57E0E26387C5191FC9E9512E8F5CD3D73ED0FDB4CF1B7462F1691251
-B2A688A476637187F8429325011EBF684FCDA4FCEAFF47CBDCE47A3F5B030631
-31EEF29937C58D61DDE79B99F7BD096E25CB7EDF0871869468BFDC662D4E108F
-E19C6051839E72DD1D05123EBA194F44646A42FF7E25FFDF28968BC6A0501EE4
-CF637B3E62C43EE1E313E25D1C748691B40492FC1BD5DF124481ABFFD1279BC7
-19A2DEBF8CDAAF3BBE77527435F3CFC37A01209613268768C6B26BB3A8D1BA7F
-835F78C5F6D2042BB604B7DEABEF219EED4F966ACAF36CEFA1417252128B821C
-B593D17A6758A357EB7410516821F20C0C8FC4B50E56E909A99E21493FEB5CFD
-1A38B6E656CC3ED1AC9E84BB2B37E9D8BD21B68F26DF07B15E822B8F7BCFC8EE
-48D4929A4EFB25AFE072EAFA6F52BCE0685B30D5DEAFE2DF41A16360BCED7B04
-DA2BAE5185DF8F0B1D342FA4B36A990D11585A882AA79CB1FDAF1A740E40E65B
-E91E511919C342ACED57822C7FA923E6C0975CF4E725929BCB5803A126106EA1
-4162139C2BC341FCC1153C222FCACBE90C05414262AE6EF44CC310BE5290BE6B
-B4F3B825E20BAB48281F53D509095E65538D4BC01ED8F981E40434DB4874283D
-0ADB0ECD7260A5FCD951C9C9C42C4A4753386AC7782AB083BE444F50FEF717A8
-ACF54AB899BED720F0AF5F8C0BC15B36E8B215547A23217D8E950624D8043886
-9015B0CA581E4D51C755156068643CAE01772F3078C74D67AB0287475F3D1447
-737FB52852BB4BA02B7DEE7E0357AE5231FF72E40BD9D830DD46B9758005BF84
-61E93BD6D6E434D000A4BFBB2271DA59BD5D71D924CA594E6923DFCAF61A4B5E
-6F122D62E1ED
+818321B3C46DB51B8EC6C2EF1D05C716519A3BD6B12A67239898F8A012A1D90C
+E474CBFA958CB5149378515861FD2F0249C3F19DCE62964A797CD20753F196A1
+AA97C49E3500A5680480DB03E84FDA076B5B64E413EDA36A71E7B6F8027C64AB
+C35361219E6D0AF45E1F7E8C6B110DB2D63437D845D2BB4F165F2B6E7741D380
+2C7DC3A14EC29EF2E531DC32F5C886F0E8C0F31BC4A353B5271FF7905312CA23
+62C06DBDFD665AFC549295E2F6485DEBF7B3D08FE61A3562C8CC1FD4B93E466B
+3DAE7227A0B6F408F38463429CA7ABD77375F2493227927CDA088B5182A1BDA3
+0F06E40F7FDC29481E9DF2E1073A84073CEDC4C2DF56605EC62212DB877E55A5
+BCC50668CEDAD96F19F87D8E7AEFFCAE082F19466CC69DA34F7CCD6C6CF7ABAA
+9271C886886F9E3BA0FE0A6F82768FB421EAFB7BFE0D6019D015C00C7F0E5A41
+71235A14D5221AFB6847A5B39757C84713C15B36D52D9211659FA118B600B381
+30F5B59DC008F53715BF0104C74DA02FC42941EC35128B7E9EFF92C6D3BEB7BB
+43831A8773958D530FFB29FAEC979C16A7DAEC50FCBF18B473A0805ADDA46EA0
+C4AB11B3E2655B429897ABB811C66C3BB13ED92E7209B2CCDFC5C7BCC7DB67EA
+3FE03EFE8F39B34ECBF780400CFBB3A753057EE1CD087FBEA54B6F511CBB42C3
+2F8B9545E7150CD1FE111D2665222A4C49D8214D7469C77E88EC63B60E1982DC
+86CC0ED541A2F7BAC3561D81A75E09E5C9884AEA4F4FCF526847BFDC0CE1D837
+18AE827E094E58968944084111462DC85ADD6F1E2EB8F1A99AD609B52E171C55
+6AAEA2D5F2215CA8CC45B962A67731C7D5D9CBC4CEB58184393FAA67793DF8AD
+E0E8057B91FDF9F7AE4430936E0CC281A3FEF2B91DE062A82ECD4A911AD07836
+12F0935052131A891FC29CEA1E8BA20EFBF9FFB1C2A72BDEE7367EDFFE114720
+8F24C44AE25069DCA897C925C31CC527EA583A26E726004570C9650E7B5C0254
+7C10F86B974641C6B9765B8D9B732DEF31FB4B2659D4A95E3D2DFD573FF85833
+3240306F04F7531990B180223A9B1BE3EDFB2FAF6C72B0F4887DA6EB496FCC1B
+950D0D13249DEF9F99A5D80DE9E0E8B91474BB703F00823A6293135ED96ED392
+5003BB63C4629668A6F0546CA9FC3309C19302AC65C3A962F4734C8D8522F101
+3BC9DEBE70AD46B5EC732B323A446BF45E0DF54735E79511DD2C862D34440E75
+BCD7857FDE491B2843ECB6B782544D59F30C7FC415D3D9ADAB42448972C497D9
+1504F30DDD3F7322F76EB6C4614022C586E1554F6A5DE631E6E2A15D606F0F36
+9F77A7BDCF1EE8EFDE8CAD70729ED9C281891E842E3537FF61BD20BB073C7165
+CA1FAA103785D6603E14333CAD92A8211432C00DB9BB2660044D7C9027275451
+E23BEAEFE52495EFA7B1EAD8B55FD65697FF0B855FB6D90A87B90FCC38A1DA09
+51EEF9D5344629114D2F051AE76A6E3BDFE669F36ED34FCC3CDDB0A3B62EEFC0
+0CA4414148FB2FEE86D65E6680EB2564A3EFFCF27E20804572E3CE4748C805ED
+0C6815F6575D3CF2A1D81E74860A6AFAA456793CB34559CF5F79CC31A7EEEF14
+795F1CC8EDDCFE7FA8B41A286B113076AA92EC095E0950B6088CADF2B4BC2E9E
+43C521D61964182FAED302FFFADCD6E4E2BD134D503BC03EC24222124B7F1FC3
+F6D8319D8C58BFF0FAE7ABC80753C893A878830087E054FA702FB931416E39AA
+52508178E7CA2FEFE06BC6DB7CA4859DB19F8E3587B0590FD445293006C9D778
+F3A850E24B9E75163FEB830E40541E25AE481DC266C784BE8968101A50C2297B
+796D5245F9CEB50545AAAF3D3056314F371BEF7763A5C5FE01182DE228BD8CD5
+365F2D90F4EAE829C36DEF7A131B5B5A51C12B9645B50A3152F2105BBA6B4E72
+3F5999D1201537B3ECA81989BB7A34912148693E6CE7B4A2D1722E6C8A5AE07B
+9AEE2CB65E136F7A6AEE3FF55AE3D943117D238058608322B3806C5E3F764076
+AEA531962EC5DC5B081B65E04DD73BA79F9B2011C274DA5AC0BD31530C5E9A0E
+75068740992FBD3F43631BBDCDA932A6793343A5CE906E60F9B929212FFDD4AF
+7EDCFA1EA2820F3272E1D17BE4CEEAFB3D82AA6E37A043C195A5ACF432361582
+B175FFCB29674B2FB45C7FECCD9C5E3037F4A3A2DF3686A33FB813DAFA84424D
+32E93D2067B6B9DC830ADB8581A3EF794590D7953E867DE7283C651E27A5A5F0
+EC415DD9679F94C11DF7E7CC42406E3F3BEA9D696D4B0596D01BED18A98E619A
+8192D34D1861FA93501531520FE0B322FA091D0105C2E3CCAA6EA96DF05589F1
+ADBD14BF72D68A8F3A4231D14F3B6C763301D85A705F8CD5700525515BD97424
+E6AEBE3C6B81E06D0551461E01AF0F5A46D5BBA4839CB7F4117D07A24C56056A
+802BC000732A8C05E656CE7BFBB1C3819232B9DD63CE8A8F7DEF874B913D7525
+3455DA9A12CE31FB6401DA02A91B06ABD54E02E023A6E78FBDBF9F588D982800
+9651487980E7F8F69FDF009D43F4883947AB49C13A7CE0560525A8DA4C6B008E
+B84B97F3023A0F733E3FC83F279B76D2EB9F92C73D345E422C7DECDC3447631E
+6DC719847B1E0ABA1525C95323EE65D6DB915BEC2941A6B8FC599B129D0025D5
+6B0FE3E88D967BA1DBD5812A0C6AC0C76903191BF99A3C8CEC0B8A56AC61E35E
+B65A3B3DEDA3C79C18A63379058B19CC7B9D8F4D488653FDC234FEDA9F15DDB8
+3925458C7124CB82C2502DDC9B19CD7E574AA5BEA3DAC4E1E2C7082E6D5176A2
+6F834C6DF83752DDF828349C0B2B235FF3FCF8F496541A6731538D790523D58D
+07527A094C382800C28AF3CA1761042AC967B3852472CBBA32C9823E3A6997FD
+5D61BE25874C048C7FCEC09C5454491913672F9F2CE116A0756F23588F55C76E
+94F7275B505A4078A030A9BB3DC4D29E7966A8F6C67557EDA96E3FDF5A484A68
+18CF48C69993C1CB857FE035094D0DC83DC37B716721C4A58B2210D7D3152195
+AD0D028D291282FB61C8BF14653FA0A79ECB5B602731232527D80B5740AC7E20
+4D91069921230F1ECF2580F0C81D4A97FEAEE504AB1F42A59581391A29E57FE6
+6C59EA1BD911B13596FFD15E2A1E35C54F5706299FADE4C8D38D6F5078FA5D59
+16499FB05BBCC2D20A8A8E8EDF13171BF8EDBF27C95189262E1CF64344BF4BF0
+C4910729FB8E019168039C1813D69FB5142FB1048722205A4F0446EB5EC06056
+0659
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 0000000000000000000000000000000000000000000000000000000000000000
 cleartomark
 {restore}if
 %%EndFont 
-TeXDict begin 40258437 52099151 1000 600 600 (fitsio.dvi)
+TeXDict begin 39158280 55380996 1000 600 600 (fitsio.dvi)
 @start /Fa 215[27 40[{}1 66.4176 /CMR8 rf /Fb 134[45
 52 65 1[52 33 43 41 1[46 44 55 80 27 47 1[31 52 43 45
 42 47 39 39 48 12[53 10[40 10[71 2[25 25 58[{}27 90.9091
 /CMMI10 rf /Fc 133[50 59 59 81 59 62 44 44 46 1[62 56
 62 93 31 59 1[31 62 56 34 51 62 50 62 54 9[116 85 86
 78 62 84 1[77 84 88 106 67 88 1[42 88 88 70 74 86 81
 80 85 6[31 1[56 56 56 56 56 56 56 56 1[56 31 37 32[62
-12[{}58 99.6264 /CMBX12 rf /Fd 149[25 2[45 45 86[45 15[{}4
-90.9091 /CMSY10 rf /Fe 133[60 71 71 97 71 75 52 53 55
-1[75 67 75 112 37 71 1[37 75 67 41 61 75 60 75 65 9[139
-102 103 94 75 100 1[92 101 105 128 81 105 1[50 105 106
-85 88 103 97 96 102 6[37 67 67 67 67 67 67 67 67 67 67
-67 37 45 3[52 52 27[75 78 11[{}63 119.552 /CMBX12 rf
-/Ff 129[48 48 48 48 48 48 48 48 48 48 48 48 48 48 48
-48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 1[48 48
+12[{}58 99.6264 /CMBX12 rf /Fd 149[25 2[45 45 86[45 12[71
+2[{}5 90.9091 /CMSY10 rf /Fe 133[60 71 71 97 71 75 52
+53 55 1[75 67 75 112 37 71 1[37 75 67 41 61 75 60 75
+65 9[139 102 103 94 75 100 1[92 101 105 128 81 105 1[50
+105 106 85 88 103 97 96 102 6[37 67 67 67 67 67 67 67
+67 67 67 67 37 45 3[52 52 27[75 78 11[{}63 119.552 /CMBX12
+rf /Ff 129[48 48 48 48 48 48 48 48 48 48 48 48 48 48
+48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 1[48
 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48
 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48
 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48 48
-48 48 48 48 48 48 48 33[{}93 90.9091 /CMTT10 rf /Fg 139[75
-1[79 1[108 7[108 2[88 3[94 29[140 9[97 97 97 97 97 97
-97 97 97 97 48[{}17 172.188 /CMBX12 rf /Fh 165[56 68
-68 93 68 68 66 51 67 1[62 71 68 83 57 71 1[33 68 71 59
-62 69 66 64 68 6[25 45 45 45 45 45 45 45 45 45 45 45
-25 30 45[{}38 90.9091 /CMSL10 rf /Fi 134[55 55 1[55 58
-41 41 43 1[58 52 58 87 29 2[29 58 52 32 48 58 46 58 51
-11[80 73 58 78 1[71 79 82 4[40 1[82 66 69 80 76 74 79
-7[52 52 52 52 52 52 52 52 52 52 52 1[35 32[58 12[{}49
+48 48 48 48 48 48 48 48 33[{}93 90.9091 /CMTT10 rf /Fg
+139[75 1[79 1[108 7[108 2[88 3[94 29[140 9[97 97 97 97
+97 97 97 97 97 97 48[{}17 172.188 /CMBX12 rf /Fh 165[56
+68 68 93 68 68 66 51 67 1[62 71 68 83 57 71 1[33 68 71
+59 62 69 66 64 68 6[25 45 45 45 45 45 45 45 45 45 45
+45 25 30 45[{}38 90.9091 /CMSL10 rf /Fi 134[55 55 1[55
+58 41 41 43 1[58 52 58 87 29 2[29 58 52 32 48 58 46 58
+51 11[80 73 58 78 1[71 79 82 4[40 1[82 66 69 80 76 74
+79 7[52 52 52 52 52 52 52 52 52 52 52 1[35 32[58 12[{}49
 90.9091 /CMBX10 rf /Fj 132[45 40 48 48 66 48 51 35 36
 36 48 51 45 51 76 25 48 28 25 51 45 28 40 51 40 51 45
 25 2[25 45 25 56 68 68 93 68 68 66 51 67 71 62 71 68
 83 57 71 47 33 68 71 59 62 69 66 64 68 71 43 43 71 25
 25 25 45 45 45 45 45 45 45 45 45 45 45 25 30 25 71 45
 35 35 25 71 76 45 76 45 25 18[76 51 51 53 11[{}93 90.9091
-/CMR10 rf /Fk 140[46 46 1[65 59 65 1[33 2[33 3[52 14[88
-20[88 10[59 2[59 59 59 59 1[33 46[{}16 119.552 /CMR12
-rf /Fl 138[90 63 64 66 2[81 90 134 45 2[45 1[81 49 74
-1[72 90 78 12[112 90 2[110 6[60 2[101 4[122 65[{}21 143.462
-/CMBX12 rf /Fm 134[123 123 1[123 129 90 92 95 1[129 116
-129 194 65 2[65 129 116 71 106 129 103 129 113 11[179
-162 129 173 1[159 175 182 4[87 1[183 146 153 178 168
-165 175 17[116 1[77 5[65 26[129 12[{}40 206.559 /CMBX12
-rf end
+/CMR10 rf /Fk 137[62 2[46 46 2[59 65 4[33 3[52 14[88
+7[88 25[59 1[59 1[59 1[33 46[{}13 119.552 /CMR12 rf /Fl
+138[90 63 64 66 2[81 90 134 45 2[45 1[81 49 74 1[72 90
+78 12[112 90 2[110 6[60 2[101 4[122 65[{}21 143.462 /CMBX12
+rf /Fm 134[123 123 1[123 129 90 92 95 1[129 116 129 194
+65 2[65 129 116 71 106 129 103 129 113 11[179 162 129
+173 1[159 175 182 4[87 1[183 146 153 178 168 165 175
+17[116 1[77 5[65 26[129 12[{}40 206.559 /CMBX12 rf end
 %%EndProlog
 %%BeginSetup
 %%Feature: *Resolution 600dpi
 TeXDict begin
-%%BeginPaperSize: Letter
+%%BeginPaperSize: a4
 /setpagedevice where
-{ pop << /PageSize [612 792] >> setpagedevice }
-{ /letter where { pop letter } if }
+{ pop << /PageSize [595 842] >> setpagedevice }
+{ /a4 where { pop a4 } if }
 ifelse
 %%EndPaperSize
  end
 %%EndSetup
 %%Page: 1 1
-TeXDict begin 1 0 bop 0 0 a
-SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
-(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
-end
- 0 0 a 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191
-a
-SDict begin H.S end
- -8 191 a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.i) cvn /DEST pdfmark end
- -8 191 a 0 464
-a
-SDict begin [/Count -0/Dest (chapter.1) cvn/Title (Introduction ) /OUT
-pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -7/Dest (chapter.2) cvn/Title ( Creating FITSIO/CFITSIO )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.2.1) cvn/Title (Building the Library)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.2.2) cvn/Title (Testing the Library)
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (section.2.3) cvn/Title (Linking Programs with FITSIO)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.2.4) cvn/Title (Getting Started with FITSIO)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.2.5) cvn/Title (Example Program)
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.2.6) cvn/Title (Legal Stuff) /OUT
-pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.2.7) cvn/Title (Acknowledgments)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (chapter.3) cvn/Title ( A FITS Primer )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -13/Dest (chapter.4) cvn/Title (FITSIO Conventions and Guidelines )
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (section.4.1) cvn/Title (CFITSIO Size Limitations)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.4.2) cvn/Title (Multiple Access to the Same FITS File)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.4.3) cvn/Title (Current Header Data Unit \(CHDU\))
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.4.4) cvn/Title (Subroutine Names)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.4.5) cvn/Title (Subroutine Families and Datatypes)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.4.6) cvn/Title (Implicit Data Type Conversion)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.4.7) cvn/Title (Data Scaling)
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (section.4.8) cvn/Title (Error Status Values and the Error Message Stack)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.4.9) cvn/Title (Variable-Length Array Facility in Binary Tables)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.4.10) cvn/Title (Support for IEEE Special Values)
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.4.11) cvn/Title (When the Final Size of the FITS HDU is Unknown)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -4/Dest (section.4.12) cvn/Title (Local FITS Conventions supported by FITSIO)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.4.12.1) cvn/Title (Support for Long String Keyword Values.)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.4.12.2) cvn/Title (Arrays of Fixed-Length Strings in Binary Tables)
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (subsection.4.12.3) cvn/Title (Keyword Units Strings)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.4.12.4) cvn/Title (HIERARCH Convention for Extended Keyword Names)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -2/Dest (section.4.13) cvn/Title (Optimizing Code for Maximum Processing Speed)
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (subsection.4.13.1) cvn/Title (Background Information: How CFITSIO Manages Data I/O)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.4.13.2) cvn/Title (Optimization Strategies)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -4/Dest (chapter.5) cvn/Title ( Basic Interface Routines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.5.1) cvn/Title (FITSIO Error Status Routines )
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (section.5.2) cvn/Title (File I/O Routines)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.5.3) cvn/Title (Keyword I/O Routines)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.5.4) cvn/Title (Data I/O Routines)
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -12/Dest (chapter.6) cvn/Title ( Advanced Interface Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.1) cvn/Title (FITS File Open and Close Subroutines: )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.2) cvn/Title (HDU-Level Operations )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.3) cvn/Title (Define or Redefine the structure of the CHDU )
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -8/Dest (section.6.4) cvn/Title (FITS Header I/O Subroutines)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.4.1) cvn/Title (Header Space and Position Routines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.4.2) cvn/Title (Read or Write Standard Header Routines )
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (subsection.6.4.3) cvn/Title (Write Keyword Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.4.4) cvn/Title (Insert Keyword Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.4.5) cvn/Title (Read Keyword Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.4.6) cvn/Title (Modify Keyword Subroutines )
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.4.7) cvn/Title (Update Keyword Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.4.8) cvn/Title (Delete Keyword Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.5) cvn/Title (Data Scaling and Undefined Pixel Parameters )
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.6.6) cvn/Title (FITS Primary Array or IMAGE Extension I/O Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -4/Dest (section.6.7) cvn/Title (FITS ASCII and Binary Table Data I/O Subroutines)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.7.1) cvn/Title (Column Information Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.7.2) cvn/Title (Low-Level Table Access Subroutines )
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.7.3) cvn/Title (Edit Rows or Columns )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.6.7.4) cvn/Title (Read and Write Column Data Routines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.8) cvn/Title (Row Selection and Calculator Routines )
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.6.9) cvn/Title (Celestial Coordinate System Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.10) cvn/Title (File Checksum Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.11) cvn/Title ( Date and Time Utility Routines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.6.12) cvn/Title (General Utility Subroutines )
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (chapter.7) cvn/Title ( The CFITSIO Iterator Function )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -12/Dest (chapter.8) cvn/Title ( Extended File Name Syntax )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.8.1) cvn/Title (Overview) /OUT
-pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -5/Dest (section.8.2) cvn/Title (Filetype) /OUT
-pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.2.1) cvn/Title (Notes about HTTP proxy servers)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.2.2) cvn/Title (Notes about the stream filetype driver)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.2.3) cvn/Title (Notes about the gsiftp filetype)
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.2.4) cvn/Title (Notes about the root filetype)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.2.5) cvn/Title (Notes about the shmem filetype:)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.8.3) cvn/Title (Base Filename)
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.8.4) cvn/Title (Output File Name when Opening an Existing File)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.8.5) cvn/Title (Template File Name when Creating a New File)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.8.6) cvn/Title (Image Tile-Compression Specification)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.8.7) cvn/Title (HDU Location Specification)
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (section.8.8) cvn/Title (Image Section)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.8.9) cvn/Title (Image Transform Filters)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.8.10) cvn/Title (Column and Keyword Filtering Specification)
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -6/Dest (section.8.11) cvn/Title (Row Filtering Specification)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.11.1) cvn/Title (General Syntax)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.11.2) cvn/Title (Bit Masks)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.11.3) cvn/Title (Vector Columns)
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.11.4) cvn/Title (Good Time Interval Filtering)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.11.5) cvn/Title (Spatial Region Filtering)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (subsection.8.11.6) cvn/Title (Example Row Filters)
-/OUT pdfmark end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.8.12) cvn/Title ( Binning or Histogramming Specification)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -6/Dest (chapter.9) cvn/Title (Template Files )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.9.1) cvn/Title (Detailed Template Line Format)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.9.2) cvn/Title (Auto-indexing of Keywords)
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/Count -0/Dest (section.9.3) cvn/Title (Template Parser Directives)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.9.4) cvn/Title (Formal Template Syntax)
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (section.9.5) cvn/Title (Errors) /OUT pdfmark
-end
- 0 464 a 0 464
-a
-SDict begin [/Count -0/Dest (section.9.6) cvn/Title (Examples) /OUT
-pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (chapter.10) cvn/Title ( Summary of all FITSIO User-Interface Subroutines )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (chapter.11) cvn/Title ( Parameter Definitions )
-/OUT pdfmark end
- 0 464 a 0 464 a
-SDict begin [/Count -0/Dest (chapter.12) cvn/Title ( FITSIO Error Status Codes )
-/OUT pdfmark end
- 0 464
-a 0 464 a
-SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
-end
- 0 464 a 0 464 a
-SDict begin [ {Catalog}<<>> /PUT pdfmark end
- 0 464 a 0 464 a
-SDict begin H.S end
- 0 464 a 0 464
-a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
- 0 464 a 0 464 a
-SDict begin [ {Catalog} <</PageLabels<</Nums[0<</S/r>>4<</S/D>>]>>>>
-/PUT pdfmark end
- 0 464 a 861 1940 a
-Fm(FITSIO)76 b(User's)g(Guide)356 2399 y Fl(A)54 b(Subroutine)d(In)l
-(terface)i(to)g(FITS)h(F)-13 b(ormat)54 b(Files)1055
-2659 y(for)g(F)-13 b(ortran)53 b(Programmers)1667 3155
-y Fk(V)-10 b(ersion)38 b(3.0)1727 4058 y Fj(HEASAR)m(C)1764
-4170 y(Co)s(de)30 b(662)1363 4283 y(Go)s(ddard)f(Space)i(Fligh)m(t)h
-(Cen)m(ter)1522 4396 y(Green)m(b)s(elt,)f(MD)h(20771)1857
-4509 y(USA)1682 5298 y Fk(April)37 b(2016)p eop end
+TeXDict begin 1 0 bop 861 1940 a Fm(FITSIO)76 b(User's)g(Guide)356
+2399 y Fl(A)54 b(Subroutine)d(In)l(terface)i(to)g(FITS)h(F)-13
+b(ormat)54 b(Files)1055 2659 y(for)g(F)-13 b(ortran)53
+b(Programmers)1667 3155 y Fk(V)-10 b(ersion)38 b(4.2)1727
+4058 y Fj(HEASAR)m(C)1764 4170 y(Co)s(de)30 b(662)1363
+4283 y(Go)s(ddard)f(Space)i(Fligh)m(t)h(Cen)m(ter)1522
+4396 y(Green)m(b)s(elt,)f(MD)h(20771)1857 4509 y(USA)1711
+5309 y Fk(No)m(v)38 b(2022)p eop end
 %%Page: 2 2
-TeXDict begin 2 1 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.ii) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(ii)p eop
-end
+TeXDict begin 2 1 bop 0 299 a Fj(ii)p eop end
 %%Page: 3 3
-TeXDict begin 3 2 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.iii) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0 464
-a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter*.1) cvn /DEST pdfmark end
- 0 464 a 803 x Fm(Con)-6 b(ten)g(ts)0
-1858 y
-SDict begin H.S end
- 0 1858 a Fi(1)84 b(In)m(tro)s(duction)748 1858
-y
-SDict begin 13.6 H.L end
- 748 1858 a 748 1858 a
-SDict begin [/Subtype /Link/Dest (chapter.1) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 748 1858 a 3100 w Fi(1)0 2118
-y
-SDict begin H.S end
- 0 2118 a Fi(2)119 b(Creating)34 b(FITSIO/CFITSIO)1475
-2118 y
-SDict begin 13.6 H.L end
- 1475 2118 a 1475 2118 a
-SDict begin [/Subtype /Link/Dest (chapter.2) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 1475 2118 a 2373 w Fi(3)136
-2280 y
-SDict begin H.S end
- 136 2280 a Fj(2.1)94 b(Building)31 b(the)f(Library)1167
-2280 y
-SDict begin 13.6 H.L end
- 1167 2280 a 1167 2280 a
-SDict begin [/Subtype /Link/Dest (section.2.1) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1167 2280 a 58 w Fj(.)45
-b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f
-(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)
-131 b(3)136 2442 y
-SDict begin H.S end
- 136 2442 a Fj(2.2)94 b(T)-8 b(esting)32
-b(the)e(Library)1121 2442 y
-SDict begin 13.6 H.L end
- 1121 2442 a 1121 2442 a
-SDict begin [/Subtype /Link/Dest (section.2.2) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1121
-2442 a 33 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
-h(.)g(.)f(.)h(.)g(.)f(.)131 b(6)136 2604 y
-SDict begin H.S end
- 136 2604 a
-Fj(2.3)94 b(Linking)31 b(Programs)f(with)g(FITSIO)1609
-2604 y
-SDict begin 13.6 H.L end
- 1609 2604 a 1609 2604 a
-SDict begin [/Subtype /Link/Dest (section.2.3) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1609 2604 a 40 w Fj(.)46
-b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)131 b(7)136
-2766 y
-SDict begin H.S end
- 136 2766 a Fj(2.4)94 b(Getting)32 b(Started)f(with)f(FITSIO)1523
-2766 y
-SDict begin 13.6 H.L end
- 1523 2766 a 1523 2766 a
-SDict begin [/Subtype /Link/Dest (section.2.4) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1523 2766 a 55 w Fj(.)46
-b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)131
-b(7)136 2928 y
-SDict begin H.S end
- 136 2928 a Fj(2.5)94 b(Example)31 b(Program)1068
-2928 y
-SDict begin 13.6 H.L end
- 1068 2928 a 1068 2928 a
-SDict begin [/Subtype /Link/Dest (section.2.5) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1068 2928 a 86 w Fj(.)46
+TeXDict begin 3 2 bop 0 1267 a Fm(Con)-6 b(ten)g(ts)0
+1858 y Fi(1)84 b(In)m(tro)s(duction)3136 b(1)0 2118 y(2)119
+b(Creating)34 b(FITSIO/CFITSIO)2405 b(3)136 2280 y Fj(2.1)94
+b(Building)31 b(the)f(Library)58 b(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)131 b(3)136 2442
+y(2.2)94 b(T)-8 b(esting)32 b(the)e(Library)j(.)46 b(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)131
+b(6)136 2604 y(2.3)94 b(Linking)31 b(Programs)f(with)g(FITSIO)40
+b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)131
+b(7)136 2766 y(2.4)94 b(Getting)32 b(Started)f(with)f(FITSIO)55
+b(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)131
+b(7)136 2928 y(2.5)94 b(Example)31 b(Program)86 b(.)46
 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
 (.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-f(.)131 b(8)136 3090 y
-SDict begin H.S end
- 136 3090 a Fj(2.6)94 b(Legal)32
-b(Stu\013)779 3090 y
-SDict begin 13.6 H.L end
- 779 3090 a 779 3090 a
-SDict begin [/Subtype /Link/Dest (section.2.6) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 779 3090 a
-92 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)131 b(9)136 3252 y
-SDict begin H.S end
- 136
-3252 a Fj(2.7)94 b(Ac)m(kno)m(wledgmen)m(ts)1053 3252
-y
-SDict begin 13.6 H.L end
- 1053 3252 a 1053 3252 a
-SDict begin [/Subtype /Link/Dest (section.2.7) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1053 3252 a 30 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)
-g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
-(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(10)0 3511 y
-SDict begin H.S end
- 0 3511 a Fi(3)119 b(A)35 b(FITS)f(Primer)913
-3511 y
-SDict begin 13.6 H.L end
- 913 3511 a 913 3511 a
-SDict begin [/Subtype /Link/Dest (chapter.3) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 913 3511 a 2882 w Fi(13)0
-3771 y
-SDict begin H.S end
- 0 3771 a Fi(4)84 b(FITSIO)34 b(Con)m(v)m(en)m(tions)h(and)g
-(Guidelines)1837 3771 y
-SDict begin 13.6 H.L end
- 1837 3771 a 1837 3771 a
-SDict begin [/Subtype /Link/Dest (chapter.4) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 1837
-3771 a 1958 w Fi(15)136 3933 y
-SDict begin H.S end
- 136 3933 a Fj(4.1)94 b(CFITSIO)29
-b(Size)i(Limitations)1395 3933 y
-SDict begin 13.6 H.L end
- 1395 3933 a 1395 3933
-a
-SDict begin [/Subtype /Link/Dest (section.4.1) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1395 3933 a 42 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
-f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f
-(.)h(.)g(.)f(.)85 b(15)136 4095 y
-SDict begin H.S end
- 136 4095 a Fj(4.2)94
-b(Multiple)32 b(Access)f(to)g(the)g(Same)f(FITS)g(File)1901
-4095 y
-SDict begin 13.6 H.L end
- 1901 4095 a 1901 4095 a
-SDict begin [/Subtype /Link/Dest (section.4.2) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1901 4095 a 31 w Fj(.)45
-b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
-(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(16)136 4257 y
-SDict begin H.S end
- 136
-4257 a Fj(4.3)94 b(Curren)m(t)30 b(Header)h(Data)h(Unit)e(\(CHDU\))1774
-4257 y
-SDict begin 13.6 H.L end
- 1774 4257 a 1774 4257 a
-SDict begin [/Subtype /Link/Dest (section.4.3) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1774 4257 a 87 w Fj(.)46
-b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(16)136 4419 y
-SDict begin H.S end
-
-136 4419 a Fj(4.4)94 b(Subroutine)29 b(Names)1075 4419
-y
-SDict begin 13.6 H.L end
- 1075 4419 a 1075 4419 a
-SDict begin [/Subtype /Link/Dest (section.4.4) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1075 4419 a 79 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)
-f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(16)136 4581 y
-SDict begin H.S end
- 136 4581 a Fj(4.5)94 b(Subroutine)29
-b(F)-8 b(amilies)33 b(and)c(Datat)m(yp)s(es)1746 4581
-y
-SDict begin 13.6 H.L end
- 1746 4581 a 1746 4581 a
-SDict begin [/Subtype /Link/Dest (section.4.5) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1746 4581 a 44 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)
-g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)f(.)85 b(17)136 4742 y
-SDict begin H.S end
- 136 4742 a Fj(4.6)94
-b(Implicit)31 b(Data)h(T)m(yp)s(e)e(Con)m(v)m(ersion)1584
-4742 y
-SDict begin 13.6 H.L end
- 1584 4742 a 1584 4742 a
-SDict begin [/Subtype /Link/Dest (section.4.6) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1584 4742 a 65 w Fj(.)46
-b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(17)136
-4904 y
-SDict begin H.S end
- 136 4904 a Fj(4.7)94 b(Data)32 b(Scaling)853 4904
-y
-SDict begin 13.6 H.L end
- 853 4904 a 853 4904 a
-SDict begin [/Subtype /Link/Dest (section.4.7) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 853 4904 a 89 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
-g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(18)136 5066 y
-SDict begin H.S end
- 136 5066 a Fj(4.8)94 b(Error)30 b(Status)g(V)-8
-b(alues)32 b(and)d(the)i(Error)e(Message)j(Stac)m(k)2312
-5066 y
-SDict begin 13.6 H.L end
- 2312 5066 a 2312 5066 a
-SDict begin [/Subtype /Link/Dest (section.4.8) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2312 5066 a 44 w Fj(.)46
-b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)f(.)85 b(18)136 5228 y
-SDict begin H.S end
- 136 5228 a Fj(4.9)94 b(V)-8
-b(ariable-Length)33 b(Arra)m(y)d(F)-8 b(acilit)m(y)34
-b(in)c(Binary)g(T)-8 b(ables)2259 5228 y
-SDict begin 13.6 H.L end
- 2259 5228 a
-2259 5228 a
-SDict begin [/Subtype /Link/Dest (section.4.9) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2259 5228 a 26 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(19)136
-5390 y
-SDict begin H.S end
- 136 5390 a Fj(4.10)49 b(Supp)s(ort)29 b(for)h(IEEE)g(Sp)s(ecial)
-g(V)-8 b(alues)1652 5390 y
-SDict begin 13.6 H.L end
- 1652 5390 a 1652 5390 a
-SDict begin [/Subtype /Link/Dest (section.4.10) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1652
-5390 a 68 w Fj(.)45 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
+f(.)131 b(8)136 3090 y(2.6)94 b(Legal)32 b(Stu\013)92
+b(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)f(.)131 b(9)136 3252 y(2.7)94
+b(Ac)m(kno)m(wledgmen)m(ts)30 b(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
+(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
+f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(10)0
+3511 y Fi(3)119 b(A)35 b(FITS)f(Primer)2918 b(13)0 3771
+y(4)84 b(FITSIO)34 b(Con)m(v)m(en)m(tions)h(and)g(Guidelines)1993
+b(15)136 3933 y Fj(4.1)94 b(CFITSIO)29 b(Size)i(Limitations)42
+b(.)k(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
 (.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(20)136 5552 y
-SDict begin H.S end
- 136 5552 a Fj(4.11)49 b(When)31 b(the)f(Final)h(Size)g
-(of)g(the)f(FITS)g(HDU)h(is)f(Unkno)m(wn)2393 5552 y
-SDict begin 13.6 H.L end
-
-2393 5552 a 2393 5552 a
-SDict begin [/Subtype /Link/Dest (section.4.11) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2393 5552 a 34 w Fj(.)45 b(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(21)136 5714 y
-SDict begin H.S end
- 136 5714 a Fj(4.12)49 b(Lo)s(cal)32 b(FITS)d(Con)m(v)m
-(en)m(tions)j(supp)s(orted)c(b)m(y)j(FITSIO)2213 5714
-y
-SDict begin 13.6 H.L end
- 2213 5714 a 2213 5714 a
-SDict begin [/Subtype /Link/Dest (section.4.12) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2213 5714 a 72 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)
-g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(21)1912 5942 y(iii)p eop end
+b(15)136 4095 y(4.2)94 b(Multiple)32 b(Access)f(to)g(the)g(Same)f(FITS)
+g(File)h(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f
+(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(16)136
+4257 y(4.3)94 b(Curren)m(t)30 b(Header)h(Data)h(Unit)e(\(CHDU\))87
+b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(16)136 4419
+y(4.4)94 b(Subroutine)29 b(Names)79 b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
+(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(16)136
+4581 y(4.5)94 b(Subroutine)29 b(F)-8 b(amilies)33 b(and)c(Datat)m(yp)s
+(es)44 b(.)i(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
+g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(17)136
+4742 y(4.6)94 b(Implicit)31 b(Data)h(T)m(yp)s(e)e(Con)m(v)m(ersion)65
+b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
+b(17)136 4904 y(4.7)94 b(Data)32 b(Scaling)89 b(.)46
+b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
+(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
+f(.)h(.)g(.)f(.)85 b(18)136 5066 y(4.8)94 b(Error)30
+b(Status)g(V)-8 b(alues)32 b(and)d(the)i(Error)e(Message)j(Stac)m(k)44
+b(.)i(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)f(.)85 b(18)136 5228 y(4.9)94 b(V)-8 b(ariable-Length)33
+b(Arra)m(y)d(F)-8 b(acilit)m(y)34 b(in)c(Binary)g(T)-8
+b(ables)26 b(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(19)136 5390 y(4.10)49
+b(Supp)s(ort)29 b(for)h(IEEE)g(Sp)s(ecial)g(V)-8 b(alues)68
+b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
+g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(20)136
+5552 y(4.11)49 b(When)31 b(the)f(Final)h(Size)g(of)g(the)f(FITS)g(HDU)h
+(is)f(Unkno)m(wn)k(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(21)136 5714 y(4.12)49
+b(Lo)s(cal)32 b(FITS)d(Con)m(v)m(en)m(tions)j(supp)s(orted)c(b)m(y)j
+(FITSIO)72 b(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(21)1912 5942 y(iii)p
+eop end
 %%Page: 4 4
-TeXDict begin 4 3 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.iv) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(iv)3311 b
-Fh(CONTENTS)345 555 y
-SDict begin H.S end
- 345 555 a Fj(4.12.1)61 b(Supp)s(ort)29
-b(for)h(Long)g(String)g(Keyw)m(ord)g(V)-8 b(alues.)2294
-555 y
-SDict begin 13.6 H.L end
- 2294 555 a 2294 555 a
-SDict begin [/Subtype /Link/Dest (subsection.4.12.1) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2294 555 a 62 w Fj(.)46 b(.)f(.)h(.)g(.)g
-(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(21)345 716 y
-SDict begin H.S end
- 345 716 a Fj(4.12.2)61 b(Arra)m(ys)31
-b(of)f(Fixed-Length)h(Strings)f(in)g(Binary)h(T)-8 b(ables)2569
-716 y
-SDict begin 13.6 H.L end
- 2569 716 a 2569 716 a
-SDict begin [/Subtype /Link/Dest (subsection.4.12.2) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2569 716 a 70 w Fj(.)46 b(.)f(.)h(.)g(.)f
-(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(22)345
-876 y
-SDict begin H.S end
- 345 876 a Fj(4.12.3)61 b(Keyw)m(ord)30 b(Units)h(Strings)1545
-876 y
-SDict begin 13.6 H.L end
- 1545 876 a 1545 876 a
-SDict begin [/Subtype /Link/Dest (subsection.4.12.3) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1545 876 a 33 w Fj(.)46 b(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(23)345 1037 y
-SDict begin H.S end
- 345
-1037 a Fj(4.12.4)61 b(HIERAR)m(CH)31 b(Con)m(v)m(en)m(tion)h(for)e
-(Extended)g(Keyw)m(ord)g(Names)2839 1037 y
-SDict begin 13.6 H.L end
- 2839 1037
-a 2839 1037 a
-SDict begin [/Subtype /Link/Dest (subsection.4.12.4) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2839 1037 a 83 w Fj(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
-h(.)g(.)f(.)85 b(23)136 1197 y
-SDict begin H.S end
- 136 1197 a Fj(4.13)49
-b(Optimizing)31 b(Co)s(de)f(for)g(Maxim)m(um)h(Pro)s(cessing)g(Sp)s
-(eed)2312 1197 y
-SDict begin 13.6 H.L end
- 2312 1197 a 2312 1197 a
-SDict begin [/Subtype /Link/Dest (section.4.13) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2312 1197 a
-44 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)f(.)85 b(24)345 1358 y
-SDict begin H.S end
- 345 1358 a Fj(4.13.1)61
-b(Bac)m(kground)31 b(Information:)41 b(Ho)m(w)31 b(CFITSIO)e(Manages)j
-(Data)g(I/O)3043 1358 y
-SDict begin 13.6 H.L end
- 3043 1358 a 3043 1358 a
-SDict begin [/Subtype /Link/Dest (subsection.4.13.1) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 3043
-1358 a 91 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(24)345 1518 y
-SDict begin H.S end
- 345 1518 a Fj(4.13.2)61 b(Optimization)32
-b(Strategies)1580 1518 y
-SDict begin 13.6 H.L end
- 1580 1518 a 1580 1518 a
-SDict begin [/Subtype /Link/Dest (subsection.4.13.2) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1580
-1518 a 69 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(25)0 1771 y
-SDict begin H.S end
- 0 1771 a Fi(5)119 b(Basic)36 b(In)m(terface)e(Routines)
-1327 1771 y
-SDict begin 13.6 H.L end
- 1327 1771 a 1327 1771 a
-SDict begin [/Subtype /Link/Dest (chapter.5) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 1327 1771 a 2468
-w Fi(29)136 1931 y
-SDict begin H.S end
- 136 1931 a Fj(5.1)94 b(FITSIO)30 b(Error)f(Status)h
-(Routines)1596 1931 y
-SDict begin 13.6 H.L end
- 1596 1931 a 1596 1931 a
-SDict begin [/Subtype /Link/Dest (section.5.1) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1596 1931
-a 53 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(29)136 2092 y
-SDict begin H.S end
- 136 2092 a Fj(5.2)94 b(File)32 b(I/O)e(Routines)1055
-2092 y
-SDict begin 13.6 H.L end
- 1055 2092 a 1055 2092 a
-SDict begin [/Subtype /Link/Dest (section.5.2) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1055 2092 a 28 w Fj(.)46
-b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
-g(.)f(.)85 b(30)136 2252 y
-SDict begin H.S end
- 136 2252 a Fj(5.3)94 b(Keyw)m(ord)31
-b(I/O)f(Routines)1259 2252 y
-SDict begin 13.6 H.L end
- 1259 2252 a 1259 2252 a
-SDict begin [/Subtype /Link/Dest (section.5.3) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
-
-1259 2252 a 36 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
-g(.)f(.)h(.)g(.)f(.)85 b(32)136 2412 y
-SDict begin H.S end
- 136 2412 a Fj(5.4)94
-b(Data)32 b(I/O)f(Routines)1101 2412 y
-SDict begin 13.6 H.L end
- 1101 2412 a 1101
-2412 a
-SDict begin [/Subtype /Link/Dest (section.5.4) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1101 2412 a 53 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
-g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(33)0 2665 y
-SDict begin H.S end
-
-0 2665 a Fi(6)119 b(Adv)-6 b(anced)36 b(In)m(terface)e(Subroutines)1672
-2665 y
-SDict begin 13.6 H.L end
- 1672 2665 a 1672 2665 a
-SDict begin [/Subtype /Link/Dest (chapter.6) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 1672 2665 a 2123 w Fi(35)136
-2826 y
-SDict begin H.S end
- 136 2826 a Fj(6.1)94 b(FITS)30 b(File)i(Op)s(en)d(and)g(Close)i
-(Subroutines:)1965 2826 y
-SDict begin 13.6 H.L end
- 1965 2826 a 1965 2826 a
-SDict begin [/Subtype /Link/Dest (section.6.1) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1965
-2826 a 37 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(35)136
-2986 y
-SDict begin H.S end
- 136 2986 a Fj(6.2)94 b(HDU-Lev)m(el)33 b(Op)s(erations)1288
-2986 y
-SDict begin 13.6 H.L end
- 1288 2986 a 1288 2986 a
-SDict begin [/Subtype /Link/Dest (section.6.2) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1288 2986 a 78 w Fj(.)46
-b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(38)136 3146 y
-SDict begin H.S end
- 136 3146 a Fj(6.3)94 b(De\014ne)31 b(or)f(Rede\014ne)g
-(the)h(structure)f(of)g(the)h(CHDU)2217 3146 y
-SDict begin 13.6 H.L end
- 2217 3146
-a 2217 3146 a
-SDict begin [/Subtype /Link/Dest (section.6.3) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2217 3146 a 68 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
-g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(41)136
-3307 y
-SDict begin H.S end
- 136 3307 a Fj(6.4)94 b(FITS)30 b(Header)h(I/O)f(Subroutines)1546
-3307 y
-SDict begin 13.6 H.L end
- 1546 3307 a 1546 3307 a
-SDict begin [/Subtype /Link/Dest (section.6.4) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1546 3307 a 32 w Fj(.)46
-b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(43)345 3467 y
-SDict begin H.S end
- 345 3467 a Fj(6.4.1)106 b(Header)31 b(Space)g(and)f(P)m
-(osition)h(Routines)2115 3467 y
-SDict begin 13.6 H.L end
- 2115 3467 a 2115 3467
-a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.1) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2115 3467 a 29 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
-f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(43)345
-3628 y
-SDict begin H.S end
- 345 3628 a Fj(6.4.2)106 b(Read)31 b(or)f(W)-8
-b(rite)32 b(Standard)d(Header)i(Routines)2320 3628 y
-SDict begin 13.6 H.L end
-
-2320 3628 a 2320 3628 a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.2) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2320 3628 a 36 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f
+TeXDict begin 4 3 bop 0 299 a Fj(iv)3311 b Fh(CONTENTS)345
+555 y Fj(4.12.1)61 b(Supp)s(ort)29 b(for)h(Long)g(String)g(Keyw)m(ord)g
+(V)-8 b(alues.)62 b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
+(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(21)345 716 y(4.12.2)61
+b(Arra)m(ys)31 b(of)f(Fixed-Length)h(Strings)f(in)g(Binary)h(T)-8
+b(ables)70 b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
+(.)f(.)85 b(22)345 876 y(4.12.3)61 b(Keyw)m(ord)30 b(Units)h(Strings)i
+(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
 (.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(43)345 3788 y
-SDict begin H.S end
- 345 3788 a Fj(6.4.3)106 b(W)-8 b(rite)32
-b(Keyw)m(ord)e(Subroutines)1774 3788 y
-SDict begin 13.6 H.L end
- 1774 3788 a 1774
-3788 a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.3) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1774 3788 a 87 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(45)345 3949 y
-SDict begin H.S end
- 345 3949 a Fj(6.4.4)106 b(Insert)30 b(Keyw)m(ord)g
-(Subroutines)1782 3949 y
-SDict begin 13.6 H.L end
- 1782 3949 a 1782 3949 a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.4) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1782
-3949 a 79 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(47)345 4109 y
-SDict begin H.S end
- 345 4109 a Fj(6.4.5)106 b(Read)31 b(Keyw)m(ord)f
-(Subroutines)1755 4109 y
-SDict begin 13.6 H.L end
- 1755 4109 a 1755 4109 a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.5) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1755
-4109 a 35 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
-(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(47)345 4270 y
-SDict begin H.S end
- 345 4270 a Fj(6.4.6)106 b(Mo)s(dify)30
-b(Keyw)m(ord)h(Subroutines)1834 4270 y
-SDict begin 13.6 H.L end
- 1834 4270 a 1834
-4270 a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.6) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1834 4270 a 27 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(49)345 4430 y
-SDict begin H.S end
- 345 4430 a Fj(6.4.7)106 b(Up)s(date)31
-b(Keyw)m(ord)f(Subroutines)1844 4430 y
-SDict begin 13.6 H.L end
- 1844 4430 a 1844
-4430 a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.7) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1844 4430 a 88 w Fj(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(50)345 4591 y
-SDict begin H.S end
- 345 4591 a Fj(6.4.8)106 b(Delete)33 b(Keyw)m(ord)d
-(Subroutines)1803 4591 y
-SDict begin 13.6 H.L end
- 1803 4591 a 1803 4591 a
-SDict begin [/Subtype /Link/Dest (subsection.6.4.8) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1803
-4591 a 58 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(51)136 4751 y
-SDict begin H.S end
- 136 4751 a Fj(6.5)94 b(Data)32 b(Scaling)g(and)d
-(Unde\014ned)g(Pixel)i(P)m(arameters)2204 4751 y
-SDict begin 13.6 H.L end
- 2204
-4751 a 2204 4751 a
-SDict begin [/Subtype /Link/Dest (section.6.5) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2204 4751 a 81 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(51)136 4912 y
-SDict begin H.S end
- 136 4912 a Fj(6.6)94 b(FITS)30 b(Primary)g(Arra)m(y)h
-(or)f(IMA)m(GE)h(Extension)g(I/O)f(Subroutines)2763 4912
-y
-SDict begin 13.6 H.L end
- 2763 4912 a 2763 4912 a
-SDict begin [/Subtype /Link/Dest (section.6.6) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2763 4912 a 88 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)
-f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(52)136 5072 y
-SDict begin H.S end
- 136 5072
-a Fj(6.7)94 b(FITS)30 b(ASCI)s(I)f(and)h(Binary)g(T)-8
-b(able)31 b(Data)h(I/O)e(Subroutines)2470 5072 y
-SDict begin 13.6 H.L end
- 2470
-5072 a 2470 5072 a
-SDict begin [/Subtype /Link/Dest (section.6.7) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2470 5072 a 27 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f
-(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(55)345
-5232 y
-SDict begin H.S end
- 345 5232 a Fj(6.7.1)106 b(Column)30 b(Information)g(Subroutines)
-1981 5232 y
-SDict begin 13.6 H.L end
- 1981 5232 a 1981 5232 a
-SDict begin [/Subtype /Link/Dest (subsection.6.7.1) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1981 5232 a 92 w
-Fj(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
-(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(55)345 5393 y
-SDict begin H.S end
- 345
-5393 a Fj(6.7.2)106 b(Lo)m(w-Lev)m(el)33 b(T)-8 b(able)31
-b(Access)g(Subroutines)2113 5393 y
-SDict begin 13.6 H.L end
- 2113 5393 a 2113 5393
-a
-SDict begin [/Subtype /Link/Dest (subsection.6.7.2) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2113 5393 a 31 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
-f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(58)345
-5553 y
-SDict begin H.S end
- 345 5553 a Fj(6.7.3)106 b(Edit)31 b(Ro)m(ws)f(or)h(Columns)1572
-5553 y
-SDict begin 13.6 H.L end
- 1572 5553 a 1572 5553 a
-SDict begin [/Subtype /Link/Dest (subsection.6.7.3) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1572 5553 a 77 w Fj(.)46
+b(23)345 1037 y(4.12.4)61 b(HIERAR)m(CH)31 b(Con)m(v)m(en)m(tion)h(for)
+e(Extended)g(Keyw)m(ord)g(Names)83 b(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f
+(.)h(.)g(.)f(.)85 b(23)136 1197 y(4.13)49 b(Optimizing)31
+b(Co)s(de)f(for)g(Maxim)m(um)h(Pro)s(cessing)g(Sp)s(eed)44
+b(.)i(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)f(.)85 b(24)345 1358 y(4.13.1)61 b(Bac)m(kground)31
+b(Information:)41 b(Ho)m(w)31 b(CFITSIO)e(Manages)j(Data)g(I/O)91
+b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(24)345 1518
+y(4.13.2)61 b(Optimization)32 b(Strategies)69 b(.)46
 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(59)345
-5714 y
-SDict begin H.S end
- 345 5714 a Fj(6.7.4)106 b(Read)31 b(and)f(W)-8
-b(rite)31 b(Column)f(Data)i(Routines)2249 5714 y
-SDict begin 13.6 H.L end
- 2249
-5714 a 2249 5714 a
-SDict begin [/Subtype /Link/Dest (subsection.6.7.4) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2249 5714 a 36 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(60)p eop end
-%%Page: 5 5
-TeXDict begin 5 4 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.v) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(CONTENTS)3334
-b Fj(v)136 555 y
-SDict begin H.S end
- 136 555 a Fj(6.8)94 b(Ro)m(w)31 b(Selection)h(and)e
-(Calculator)i(Routines)1937 555 y
-SDict begin 13.6 H.L end
- 1937 555 a 1937 555
-a
-SDict begin [/Subtype /Link/Dest (section.6.8) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1937 555 a 65 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(64)136 717 y
-SDict begin H.S end
- 136 717 a Fj(6.9)94 b(Celestial)33 b(Co)s(ordinate)d
-(System)g(Subroutines)2004 717 y
-SDict begin 13.6 H.L end
- 2004 717 a 2004 717
-a
-SDict begin [/Subtype /Link/Dest (section.6.9) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2004 717 a 69 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(65)136
-879 y
-SDict begin H.S end
- 136 879 a Fj(6.10)49 b(File)32 b(Chec)m(ksum)e(Subroutines)1462
-879 y
-SDict begin 13.6 H.L end
- 1462 879 a 1462 879 a
-SDict begin [/Subtype /Link/Dest (section.6.10) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1462 879 a 46 w Fj(.)45 b(.)h(.)g(.)f(.)h
+(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(25)0
+1771 y Fi(5)119 b(Basic)36 b(In)m(terface)e(Routines)2504
+b(29)136 1931 y Fj(5.1)94 b(FITSIO)30 b(Error)f(Status)h(Routines)84
+b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
+b(29)136 2092 y(5.2)94 b(File)32 b(I/O)e(Routines)e(.)46
+b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
 (.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
-g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(67)136 1041
-y
-SDict begin H.S end
- 136 1041 a Fj(6.11)80 b(Date)32 b(and)d(Time)i(Utilit)m(y)h(Routines)
-1682 1041 y
-SDict begin 13.6 H.L end
- 1682 1041 a 1682 1041 a
-SDict begin [/Subtype /Link/Dest (section.6.11) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1682 1041 a 38 w
-Fj(.)45 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(68)136 1204 y
-SDict begin H.S end
- 136 1204 a Fj(6.12)49 b(General)32 b(Utilit)m(y)g
-(Subroutines)1476 1204 y
-SDict begin 13.6 H.L end
- 1476 1204 a 1476 1204 a
-SDict begin [/Subtype /Link/Dest (section.6.12) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1476
-1204 a 32 w Fj(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-f(.)85 b(69)0 1464 y
-SDict begin H.S end
- 0 1464 a Fi(7)119 b(The)35 b(CFITSIO)e(Iterator)g
-(F)-9 b(unction)1677 1464 y
-SDict begin 13.6 H.L end
- 1677 1464 a 1677 1464 a
-SDict begin [/Subtype /Link/Dest (chapter.7) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 1677
-1464 a 2118 w Fi(77)0 1725 y
-SDict begin H.S end
- 0 1725 a Fi(8)119 b(Extended)35
-b(File)f(Name)h(Syn)m(tax)1500 1725 y
-SDict begin 13.6 H.L end
- 1500 1725 a 1500
-1725 a
-SDict begin [/Subtype /Link/Dest (chapter.8) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 1500 1725 a 2295 w Fi(79)136 1887 y
-SDict begin H.S end
- 136 1887 a
-Fj(8.1)94 b(Ov)m(erview)716 1887 y
-SDict begin 13.6 H.L end
- 716 1887 a 716 1887
-a
-SDict begin [/Subtype /Link/Dest (section.8.1) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 716 1887 a 84 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
+g(.)f(.)85 b(30)136 2252 y(5.3)94 b(Keyw)m(ord)31 b(I/O)f(Routines)36
+b(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
+f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f
+(.)85 b(32)136 2412 y(5.4)94 b(Data)32 b(I/O)f(Routines)53
+b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)f(.)85 b(33)0 2665 y Fi(6)119 b(Adv)-6 b(anced)36
+b(In)m(terface)e(Subroutines)2159 b(35)136 2826 y Fj(6.1)94
+b(FITS)30 b(File)i(Op)s(en)d(and)g(Close)i(Subroutines:)76
+b(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(35)136 2986 y(6.2)94
+b(HDU-Lev)m(el)33 b(Op)s(erations)108 b(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
+g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(38)136 3146
+y(6.3)94 b(De\014ne)31 b(or)f(Rede\014ne)g(the)h(structure)f(of)g(the)h
+(CHDU)99 b(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(41)136 3307 y(6.4)94
+b(FITS)30 b(Header)h(I/O)f(Subroutines)i(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)f(.)85 b(43)345 3467 y(6.4.1)106
+b(Header)31 b(Space)g(and)f(P)m(osition)h(Routines)60
+b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)f(.)85 b(43)345 3628 y(6.4.2)106
+b(Read)31 b(or)f(W)-8 b(rite)32 b(Standard)d(Header)i(Routines)67
+b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)f(.)85 b(43)345 3788 y(6.4.3)106 b(W)-8 b(rite)32
+b(Keyw)m(ord)e(Subroutines)116 b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f
+(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)
+85 b(45)345 3949 y(6.4.4)106 b(Insert)30 b(Keyw)m(ord)g(Subroutines)108
+b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(47)345 4109
+y(6.4.5)106 b(Read)31 b(Keyw)m(ord)f(Subroutines)64 b(.)46
+b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(47)345 4270
+y(6.4.6)106 b(Mo)s(dify)30 b(Keyw)m(ord)h(Subroutines)55
+b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(49)345 4430
+y(6.4.7)106 b(Up)s(date)31 b(Keyw)m(ord)f(Subroutines)116
+b(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
+g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(50)345 4591
+y(6.4.8)106 b(Delete)33 b(Keyw)m(ord)d(Subroutines)87
+b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(51)136 4751
+y(6.5)94 b(Data)32 b(Scaling)g(and)d(Unde\014ned)g(Pixel)i(P)m
+(arameters)113 b(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
+(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(51)136 4912 y(6.6)94
+b(FITS)30 b(Primary)g(Arra)m(y)h(or)f(IMA)m(GE)h(Extension)g(I/O)f
+(Subroutines)117 b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f
+(.)85 b(52)136 5072 y(6.7)94 b(FITS)30 b(ASCI)s(I)f(and)h(Binary)g(T)-8
+b(able)31 b(Data)h(I/O)e(Subroutines)d(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f
+(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(56)345
+5232 y(6.7.1)106 b(Column)30 b(Information)g(Subroutines)121
+b(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(56)345 5393 y(6.7.2)106
+b(Lo)m(w-Lev)m(el)33 b(T)-8 b(able)31 b(Access)g(Subroutines)60
+b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)f(.)85 b(58)345 5553 y(6.7.3)106
+b(Edit)31 b(Ro)m(ws)f(or)h(Columns)106 b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g
 (.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
-g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(79)136
-2049 y
-SDict begin H.S end
- 136 2049 a Fj(8.2)94 b(Filet)m(yp)s(e)668 2049
-y
-SDict begin 13.6 H.L end
- 668 2049 a 668 2049 a
-SDict begin [/Subtype /Link/Dest (section.8.2) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 668 2049 a 62 w Fj(.)45 b(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
-g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)f(.)85 b(82)345 2211 y
-SDict begin H.S end
- 345 2211 a Fj(8.2.1)106 b(Notes)32
-b(ab)s(out)e(HTTP)g(pro)m(xy)g(serv)m(ers)1968 2211 y
-SDict begin 13.6 H.L end
-
-1968 2211 a 1968 2211 a
-SDict begin [/Subtype /Link/Dest (subsection.8.2.1) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1968 2211 a 34 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g
+g(.)f(.)h(.)g(.)f(.)85 b(59)345 5714 y(6.7.4)106 b(Read)31
+b(and)f(W)-8 b(rite)31 b(Column)f(Data)i(Routines)66
+b(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
+f(.)h(.)g(.)f(.)85 b(60)p eop end
+%%Page: 5 5
+TeXDict begin 5 4 bop 0 299 a Fh(CONTENTS)3334 b Fj(v)136
+555 y(6.8)94 b(Ro)m(w)31 b(Selection)h(and)e(Calculator)i(Routines)95
+b(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(64)136 717 y(6.9)94
+b(Celestial)33 b(Co)s(ordinate)d(System)g(Subroutines)98
+b(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(65)136 879 y(6.10)49
+b(File)32 b(Chec)m(ksum)e(Subroutines)75 b(.)45 b(.)h(.)g(.)f(.)h(.)g
 (.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-f(.)85 b(82)345 2373 y
-SDict begin H.S end
- 345 2373 a Fj(8.2.2)106 b(Notes)32
-b(ab)s(out)e(the)h(stream)f(\014let)m(yp)s(e)h(driv)m(er)2161
-2373 y
-SDict begin 13.6 H.L end
- 2161 2373 a 2161 2373 a
-SDict begin [/Subtype /Link/Dest (subsection.8.2.2) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2161 2373 a 54 w Fj(.)45
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(67)136 1041 y(6.11)80
+b(Date)32 b(and)d(Time)i(Utilit)m(y)h(Routines)69 b(.)45
 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f
-(.)h(.)g(.)f(.)85 b(83)345 2536 y
-SDict begin H.S end
- 345 2536 a Fj(8.2.3)106
-b(Notes)32 b(ab)s(out)e(the)h(gsiftp)f(\014let)m(yp)s(e)1849
-2536 y
-SDict begin 13.6 H.L end
- 1849 2536 a 1849 2536 a
-SDict begin [/Subtype /Link/Dest (subsection.8.2.3) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1849 2536 a 83 w Fj(.)45
-b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
-(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(84)345 2698 y
-SDict begin H.S end
- 345
-2698 a Fj(8.2.4)106 b(Notes)32 b(ab)s(out)e(the)h(ro)s(ot)f(\014let)m
-(yp)s(e)1793 2698 y
-SDict begin 13.6 H.L end
- 1793 2698 a 1793 2698 a
-SDict begin [/Subtype /Link/Dest (subsection.8.2.4) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1793 2698
-a 68 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
-g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(84)345
-2860 y
-SDict begin H.S end
- 345 2860 a Fj(8.2.5)106 b(Notes)32 b(ab)s(out)e(the)h(shmem)e
-(\014let)m(yp)s(e:)1932 2860 y
-SDict begin 13.6 H.L end
- 1932 2860 a 1932 2860
-a
-SDict begin [/Subtype /Link/Dest (subsection.8.2.5) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1932 2860 a 70 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
-h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(86)136 3022 y
-SDict begin H.S end
- 136 3022 a Fj(8.3)94 b(Base)32 b(Filename)923
-3022 y
-SDict begin 13.6 H.L end
- 923 3022 a 923 3022 a
-SDict begin [/Subtype /Link/Dest (section.8.3) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 923 3022 a 90 w Fj(.)45
-b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
-h(.)g(.)f(.)85 b(86)136 3184 y
-SDict begin H.S end
- 136 3184 a Fj(8.4)94 b(Output)30
-b(File)h(Name)g(when)f(Op)s(ening)f(an)h(Existing)h(File)2346
-3184 y
-SDict begin 13.6 H.L end
- 2346 3184 a 2346 3184 a
-SDict begin [/Subtype /Link/Dest (section.8.4) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2346 3184 a 81 w Fj(.)45
-b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f
-(.)85 b(88)136 3346 y
-SDict begin H.S end
- 136 3346 a Fj(8.5)94 b(T)-8 b(emplate)32
-b(File)g(Name)f(when)e(Creating)i(a)g(New)f(File)2228
-3346 y
-SDict begin 13.6 H.L end
- 2228 3346 a 2228 3346 a
-SDict begin [/Subtype /Link/Dest (section.8.5) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2228 3346 a 57 w Fj(.)46
-b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)f(.)85 b(90)136 3508 y
-SDict begin H.S end
- 136 3508 a Fj(8.6)94 b(Image)32
-b(Tile-Compression)e(Sp)s(eci\014cation)1841 3508 y
-SDict begin 13.6 H.L end
- 1841
-3508 a 1841 3508 a
-SDict begin [/Subtype /Link/Dest (section.8.6) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1841 3508 a 91 w Fj(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-f(.)85 b(90)136 3670 y
-SDict begin H.S end
- 136 3670 a Fj(8.7)94 b(HDU)32
-b(Lo)s(cation)f(Sp)s(eci\014cation)1461 3670 y
-SDict begin 13.6 H.L end
- 1461 3670
-a 1461 3670 a
-SDict begin [/Subtype /Link/Dest (section.8.7) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1461 3670 a 47 w Fj(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)
-g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)f(.)85 b(90)136 3832 y
-SDict begin H.S end
- 136 3832 a
-Fj(8.8)94 b(Image)32 b(Section)903 3832 y
-SDict begin 13.6 H.L end
- 903 3832 a
-903 3832 a
-SDict begin [/Subtype /Link/Dest (section.8.8) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 903 3832 a 39 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
-h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(91)136 3994 y
-SDict begin H.S end
- 136 3994 a Fj(8.9)94 b(Image)32 b(T)-8
-b(ransform)29 b(Filters)1312 3994 y
-SDict begin 13.6 H.L end
- 1312 3994 a 1312
-3994 a
-SDict begin [/Subtype /Link/Dest (section.8.9) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1312 3994 a 54 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
-h(.)g(.)f(.)h(.)g(.)f(.)85 b(92)136 4156 y
-SDict begin H.S end
- 136 4156 a
-Fj(8.10)49 b(Column)30 b(and)g(Keyw)m(ord)g(Filtering)h(Sp)s
-(eci\014cation)2124 4156 y
-SDict begin 13.6 H.L end
- 2124 4156 a 2124 4156 a
-SDict begin [/Subtype /Link/Dest (section.8.10) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2124
-4156 a 91 w Fj(.)45 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(94)136 4318 y
-SDict begin H.S end
-
-136 4318 a Fj(8.11)49 b(Ro)m(w)31 b(Filtering)h(Sp)s(eci\014cation)1426
-4318 y
-SDict begin 13.6 H.L end
- 1426 4318 a 1426 4318 a
-SDict begin [/Subtype /Link/Dest (section.8.11) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1426 4318 a 82 w Fj(.)45
-b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(68)136
+1204 y(6.12)49 b(General)32 b(Utilit)m(y)g(Subroutines)61
+b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
+b(69)0 1464 y Fi(7)119 b(The)35 b(CFITSIO)e(Iterator)g(F)-9
+b(unction)2154 b(77)0 1725 y(8)119 b(Extended)35 b(File)f(Name)h(Syn)m
+(tax)2330 b(79)136 1887 y Fj(8.1)94 b(Ov)m(erview)84
+b(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
+(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(79)136 2049 y(8.2)94
+b(Filet)m(yp)s(e)62 b(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
 (.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85
-b(97)345 4481 y
-SDict begin H.S end
- 345 4481 a Fj(8.11.1)61 b(General)32
-b(Syn)m(tax)1251 4481 y
-SDict begin 13.6 H.L end
- 1251 4481 a 1251 4481 a
-SDict begin [/Subtype /Link/Dest (subsection.8.11.1) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1251
-4481 a 44 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
-(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
-f(.)h(.)g(.)f(.)85 b(97)345 4643 y
-SDict begin H.S end
- 345 4643 a Fj(8.11.2)61
-b(Bit)32 b(Masks)1040 4643 y
-SDict begin 13.6 H.L end
- 1040 4643 a 1040 4643 a
-SDict begin [/Subtype /Link/Dest (subsection.8.11.2) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
-
-1040 4643 a 43 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
-g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(100)345 4805 y
-SDict begin H.S end
- 345
-4805 a Fj(8.11.3)61 b(V)-8 b(ector)32 b(Columns)1274
-4805 y
-SDict begin 13.6 H.L end
- 1274 4805 a 1274 4805 a
-SDict begin [/Subtype /Link/Dest (subsection.8.11.3) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1274 4805 a 92 w Fj(.)46
-b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
-(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40
-b(101)345 4967 y
-SDict begin H.S end
- 345 4967 a Fj(8.11.4)61 b(Go)s(o)s(d)30
-b(Time)h(In)m(terv)-5 b(al)31 b(Filtering)1799 4967 y
-SDict begin 13.6 H.L end
-
-1799 4967 a 1799 4967 a
-SDict begin [/Subtype /Link/Dest (subsection.8.11.4) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1799 4967 a 62 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
-h(.)g(.)f(.)40 b(103)345 5129 y
-SDict begin H.S end
- 345 5129 a Fj(8.11.5)61
-b(Spatial)31 b(Region)h(Filtering)1590 5129 y
-SDict begin 13.6 H.L end
- 1590 5129
-a 1590 5129 a
-SDict begin [/Subtype /Link/Dest (subsection.8.11.5) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1590 5129 a 59 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+b(82)345 2211 y(8.2.1)106 b(Notes)32 b(ab)s(out)e(HTTP)g(pro)m(xy)g
+(serv)m(ers)k(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
+f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(82)345
+2373 y(8.2.2)106 b(Notes)32 b(ab)s(out)e(the)h(stream)f(\014let)m(yp)s
+(e)h(driv)m(er)54 b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(83)345 2536
+y(8.2.3)106 b(Notes)32 b(ab)s(out)e(the)h(gsiftp)f(\014let)m(yp)s(e)83
+b(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
+g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(84)345 2698
+y(8.2.4)106 b(Notes)32 b(ab)s(out)e(the)h(ro)s(ot)f(\014let)m(yp)s(e)68
+b(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(84)345 2860
+y(8.2.5)106 b(Notes)32 b(ab)s(out)e(the)h(shmem)e(\014let)m(yp)s(e:)70
+b(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(86)136 3022 y(8.3)94
+b(Base)32 b(Filename)90 b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
 f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f
-(.)h(.)g(.)f(.)40 b(103)345 5291 y
-SDict begin H.S end
- 345 5291 a Fj(8.11.6)61
-b(Example)31 b(Ro)m(w)g(Filters)1476 5291 y
-SDict begin 13.6 H.L end
- 1476 5291
-a 1476 5291 a
-SDict begin [/Subtype /Link/Dest (subsection.8.11.6) cvn/H /I/Border
-[0 0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1476 5291 a 32 w Fj(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)
+(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(86)136
+3184 y(8.4)94 b(Output)30 b(File)h(Name)g(when)f(Op)s(ening)f(an)h
+(Existing)h(File)81 b(.)45 b(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(88)136 3346 y(8.5)94
+b(T)-8 b(emplate)32 b(File)g(Name)f(when)e(Creating)i(a)g(New)f(File)57
+b(.)46 b(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
+f(.)h(.)g(.)f(.)85 b(90)136 3508 y(8.6)94 b(Image)32
+b(Tile-Compression)e(Sp)s(eci\014cation)91 b(.)45 b(.)h(.)g(.)g(.)f(.)h
+(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
+g(.)f(.)85 b(90)136 3670 y(8.7)94 b(HDU)32 b(Lo)s(cation)f(Sp)s
+(eci\014cation)47 b(.)e(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
+(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+f(.)85 b(90)136 3832 y(8.8)94 b(Image)32 b(Section)39
+b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)
 g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)f(.)40 b(106)136 5453 y
-SDict begin H.S end
- 136 5453 a
-Fj(8.12)80 b(Binning)30 b(or)g(Histogramming)i(Sp)s(eci\014cation)1971
-5453 y
-SDict begin 13.6 H.L end
- 1971 5453 a 1971 5453 a
-SDict begin [/Subtype /Link/Dest (section.8.12) cvn/H /I/Border [0
-0 1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1971 5453 a 31 w Fj(.)46
-b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(107)0 5714 y
-SDict begin H.S end
- 0 5714 a
-Fi(9)84 b(T)-9 b(emplate)35 b(Files)845 5714 y
-SDict begin 13.6 H.L end
- 845 5714
-a 845 5714 a
-SDict begin [/Subtype /Link/Dest (chapter.9) cvn/H /I/Border [0 0 1]BorderArrayPatch/Color
-[1 0 0] H.B /ANN pdfmark end
- 845 5714 a 2898 w Fi(111)p eop end
+(.)g(.)f(.)h(.)g(.)f(.)85 b(91)136 3994 y(8.9)94 b(Image)32
+b(T)-8 b(ransform)29 b(Filters)54 b(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g
+(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(92)136 4156 y(8.10)49
+b(Column)30 b(and)g(Keyw)m(ord)g(Filtering)h(Sp)s(eci\014cation)91
+b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
+g(.)f(.)h(.)g(.)f(.)85 b(94)136 4318 y(8.11)49 b(Ro)m(w)31
+b(Filtering)h(Sp)s(eci\014cation)82 b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)
+h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
+(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(97)345 4481 y(8.11.1)61
+b(General)32 b(Syn)m(tax)44 b(.)i(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f
+(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)f(.)85 b(97)345 4643 y(8.11.2)61
+b(Bit)32 b(Masks)43 b(.)j(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
+(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(100)345 4805 y(8.11.3)61
+b(V)-8 b(ector)32 b(Columns)92 b(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f
+(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)
+f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(101)345 4967 y(8.11.4)61
+b(Go)s(o)s(d)30 b(Time)h(In)m(terv)-5 b(al)31 b(Filtering)h(and)d
+(Calculation)37 b(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
+g(.)f(.)h(.)g(.)f(.)40 b(103)345 5129 y(8.11.5)61 b(Spatial)31
+b(Region)h(Filtering)59 b(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
+g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
+(.)f(.)40 b(105)345 5291 y(8.11.6)61 b(Example)31 b(Ro)m(w)g(Filters)h
+(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g
+(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40
+b(107)136 5453 y(8.12)80 b(Binning)30 b(or)g(Histogramming)i(Sp)s
+(eci\014cation)f(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
+(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(108)0
+5714 y Fi(9)84 b(T)-9 b(emplate)35 b(Files)2933 b(113)p
+eop end
 %%Page: 6 6
-TeXDict begin 6 5 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.vi) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(vi)3311 b
-Fh(CONTENTS)136 555 y
-SDict begin H.S end
- 136 555 a Fj(9.1)94 b(Detailed)33
-b(T)-8 b(emplate)31 b(Line)g(F)-8 b(ormat)1601 555 y
-SDict begin 13.6 H.L end
-
-1601 555 a 1601 555 a
-SDict begin [/Subtype /Link/Dest (section.9.1) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1601 555 a 48 w Fj(.)46 b(.)f(.)h(.)g(.)f(.)h(.)g
-(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)
-g(.)f(.)h(.)g(.)f(.)40 b(111)136 715 y
-SDict begin H.S end
- 136 715 a Fj(9.2)94
-b(Auto-indexing)31 b(of)g(Keyw)m(ords)1435 715 y
-SDict begin 13.6 H.L end
- 1435
-715 a 1435 715 a
-SDict begin [/Subtype /Link/Dest (section.9.2) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1435 715 a 73 w Fj(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
-h(.)g(.)f(.)h(.)g(.)f(.)40 b(112)136 876 y
-SDict begin H.S end
- 136 876 a
-Fj(9.3)94 b(T)-8 b(emplate)32 b(P)m(arser)f(Directiv)m(es)1421
-876 y
-SDict begin 13.6 H.L end
- 1421 876 a 1421 876 a
-SDict begin [/Subtype /Link/Dest (section.9.3) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1421 876 a 87 w Fj(.)45 b(.)h(.)g(.)f(.)h
-(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
-g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(113)136 1036
-y
-SDict begin H.S end
- 136 1036 a Fj(9.4)94 b(F)-8 b(ormal)32 b(T)-8 b(emplate)32
-b(Syn)m(tax)1332 1036 y
-SDict begin 13.6 H.L end
- 1332 1036 a 1332 1036 a
-SDict begin [/Subtype /Link/Dest (section.9.4) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1332
-1036 a 34 w Fj(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f
-(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)
-h(.)g(.)f(.)40 b(114)136 1196 y
-SDict begin H.S end
- 136 1196 a Fj(9.5)94
-b(Errors)596 1196 y
-SDict begin 13.6 H.L end
- 596 1196 a 596 1196 a
-SDict begin [/Subtype /Link/Dest (section.9.5) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 596 1196 a
-63 w Fj(.)46 b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
+TeXDict begin 6 5 bop 0 299 a Fj(vi)3311 b Fh(CONTENTS)136
+555 y Fj(9.1)94 b(Detailed)33 b(T)-8 b(emplate)31 b(Line)g(F)-8
+b(ormat)48 b(.)e(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40
+b(113)136 715 y(9.2)94 b(Auto-indexing)31 b(of)g(Keyw)m(ords)73
+b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40
+b(114)136 876 y(9.3)94 b(T)-8 b(emplate)32 b(P)m(arser)f(Directiv)m(es)
+87 b(.)45 b(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
+(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40
+b(115)136 1036 y(9.4)94 b(F)-8 b(ormal)32 b(T)-8 b(emplate)32
+b(Syn)m(tax)i(.)46 b(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)
+h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h
+(.)g(.)f(.)40 b(116)136 1196 y(9.5)94 b(Errors)63 b(.)46
+b(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g
+(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)
+g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(116)136 1356 y(9.6)94
+b(Examples)72 b(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g
 (.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)
-f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(114)136
-1356 y
-SDict begin H.S end
- 136 1356 a Fj(9.6)94 b(Examples)728 1356 y
-SDict begin 13.6 H.L end
- 728
-1356 a 728 1356 a
-SDict begin [/Subtype /Link/Dest (section.9.6) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 728 1356 a 72 w Fj(.)46 b(.)g(.)g(.)f(.)h(.)g(.)f(.)h
-(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)
-g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40
-b(114)0 1607 y
-SDict begin H.S end
- 0 1607 a Fi(10)67 b(Summary)36 b(of)f(all)f(FITSIO)g
-(User-In)m(terface)h(Subroutines)2563 1607 y
-SDict begin 13.6 H.L end
- 2563 1607
-a 2563 1607 a
-SDict begin [/Subtype /Link/Dest (chapter.10) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 2563 1607 a 1180 w Fi(117)0 1858 y
-SDict begin H.S end
- 0 1858
-a Fi(11)67 b(P)m(arameter)35 b(De\014nitions)1215 1858
-y
-SDict begin 13.6 H.L end
- 1215 1858 a 1215 1858 a
-SDict begin [/Subtype /Link/Dest (chapter.11) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1215 1858 a 2528 w Fi(125)0
-2109 y
-SDict begin H.S end
- 0 2109 a Fi(12)67 b(FITSIO)33 b(Error)i(Status)g(Co)s(des)1483
-2109 y
-SDict begin 13.6 H.L end
- 1483 2109 a 1483 2109 a
-SDict begin [/Subtype /Link/Dest (chapter.12) cvn/H /I/Border [0 0
-1]BorderArrayPatch/Color [1 0 0] H.B /ANN pdfmark end
- 1483 2109 a 2260 w Fi(131)p
-eop end
+f(.)h(.)g(.)g(.)f(.)h(.)g(.)f(.)h(.)g(.)f(.)40 b(116)0
+1607 y Fi(10)67 b(Summary)36 b(of)f(all)f(FITSIO)g(User-In)m(terface)h
+(Subroutines)1215 b(119)0 1858 y(11)67 b(P)m(arameter)35
+b(De\014nitions)2563 b(127)0 2109 y(12)67 b(FITSIO)33
+b(Error)i(Status)g(Co)s(des)2295 b(133)p eop end
 %%Page: 1 7
-TeXDict begin 1 6 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0 464
-a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.1) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(1)0 1687
+TeXDict begin 1 6 bop 0 1225 a Fg(Chapter)65 b(1)0 1687
 y Fm(In)-6 b(tro)6 b(duction)0 2180 y Fj(This)33 b(do)s(cumen)m(t)i
 (describ)s(es)e(the)h(F)-8 b(ortran-callable)38 b(subroutine)33
 b(in)m(terface)j(that)f(is)f(pro)m(vided)g(as)g(part)g(of)h(the)0
 2293 y(CFITSIO)f(library)h(\(whic)m(h)h(is)g(written)g(in)f(ANSI)g
 (C\).)h(This)f(is)h(a)g(companion)g(do)s(cumen)m(t)f(to)i(the)e
 (CFITSIO)0 2406 y(User's)k(Guide)f(whic)m(h)h(should)e(b)s(e)h
 (consulted)h(for)f(further)g(information)h(ab)s(out)f(the)h(underlying)
@@ -6531,34 +5226,22 @@
 (CFITSIO)f(source)i(co)s(de,)h(do)s(cumen)m(tation,)i(and)21
 b(example)j(programs)e(are)h(a)m(v)-5 b(ailable)0 4918
 y(on)30 b(the)h(W)-8 b(orld-Wide)32 b(W)-8 b(eb)31 b(or)f(via)h(anon)m
 (ymous)f(ftp)g(from:)382 5178 y Ff(http://heasarc.gsfc.nasa)o(.go)o
 (v/fi)o(tsio)382 5291 y(ftp://legacy.gsfc.nasa.g)o(ov/)o(soft)o(ware)o
 (/fi)o(tsio)o(/c)1927 5942 y Fj(1)p eop end
 %%Page: 2 8
-TeXDict begin 2 7 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.2) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(2)2452 b
-Fh(CHAPTER)30 b(1.)71 b(INTR)m(ODUCTION)0 555 y Fj(An)m(y)28
-b(questions,)g(bug)f(rep)s(orts,)h(or)f(suggested)i(enhancemen)m(ts)f
-(related)g(to)h(the)e(CFITSIO)f(pac)m(k)-5 b(age)30 b(should)d(b)s(e)0
-668 y(sen)m(t)k(to)g(the)g(FTOOLS)e(Help)h(Desk)h(at)g(the)g(HEASAR)m
-(C:)382 928 y Ff(http://heasarc.gsfc.nasa)o(.go)o(v/cg)o(i-bi)o(n/f)o
-(tool)o(shel)o(p)0 1188 y Fj(This)40 b(User's)i(Guide)f(assumes)g(that)
-h(readers)f(already)g(ha)m(v)m(e)i(a)f(general)g(understanding)d(of)j
+TeXDict begin 2 7 bop 0 299 a Fj(2)2452 b Fh(CHAPTER)30
+b(1.)71 b(INTR)m(ODUCTION)0 555 y Fj(An)m(y)28 b(questions,)g(bug)f
+(rep)s(orts,)h(or)f(suggested)i(enhancemen)m(ts)f(related)g(to)h(the)e
+(CFITSIO)f(pac)m(k)-5 b(age)30 b(should)d(b)s(e)0 668
+y(sen)m(t)k(to)g(the)g(FTOOLS)e(Help)h(Desk)h(at)g(the)g(HEASAR)m(C:)
+382 928 y Ff(http://heasarc.gsfc.nasa)o(.go)o(v/cg)o(i-bi)o(n/f)o(tool)
+o(shel)o(p)0 1188 y Fj(This)40 b(User's)i(Guide)f(assumes)g(that)h
+(readers)f(already)g(ha)m(v)m(e)i(a)f(general)g(understanding)d(of)j
 (the)f(de\014nition)0 1301 y(and)31 b(structure)g(of)h(FITS)e(format)i
 (\014les.)44 b(F)-8 b(urther)32 b(information)f(ab)s(out)h(FITS)f
 (formats)g(is)h(a)m(v)-5 b(ailable)34 b(from)d(the)0
 1413 y(FITS)37 b(Supp)s(ort)f(O\016ce)i(at)h Ff
 (http://fits.gsfc.nasa.g)o(ov)p Fj(.)57 b(In)37 b(particular,)j(the)e
 ('FITS)g(Standard')f(giv)m(es)0 1526 y(the)31 b(authoritativ)m(e)j
 (de\014nition)d(of)g(the)h(FITS)e(data)i(format.)43 b(Other)31
@@ -6577,50 +5260,23 @@
 b(of)g(programs)e(that)h(can)h(b)s(e)e(used)g(to)i(manipulate)0
 2251 y(and)f(analyze)i(FITS)d(format)i(\014les.)41 b(Fv)30
 b(and)g(FTOOLS)f(are)i(a)m(v)-5 b(ailable)32 b(from)e(their)h(resp)s
 (ectiv)m(e)g(W)-8 b(eb)31 b(sites)g(at:)382 2511 y Ff
 (http://fv.gsfc.nasa.gov)382 2624 y(http://heasarc.gsfc.nasa)o(.go)o
 (v/ft)o(ools)p eop end
 %%Page: 3 9
-TeXDict begin 3 8 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.3) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0 464
-a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.2) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(2)0 1687
-y Fm(Creating)77 b(FITSIO/CFITSIO)0 2071 y
-SDict begin H.S end
- 0 2071 a 0
-2071 a
-SDict begin 13.6 H.A end
- 0 2071 a 0 2071 a
-SDict begin [/View [/XYZ H.V]/Dest (section.2.1) cvn /DEST pdfmark
-end
- 0 2071 a 145 x Fe(2.1)135 b(Building)45
-b(the)h(Library)0 2467 y Fj(T)-8 b(o)43 b(use)g(the)g(FITSIO)f
-(subroutines)f(one)j(m)m(ust)e(\014rst)g(build)g(the)h(CFITSIO)f
-(library)-8 b(,)46 b(whic)m(h)d(requires)f(a)h(C)0 2580
-y(compiler.)73 b(gcc)43 b(is)e(ideal,)j(or)d(most)h(other)f(ANSI-C)g
-(compilers)g(will)h(also)g(w)m(ork.)73 b(The)40 b(CFITSIO)g(co)s(de)h
-(is)0 2692 y(con)m(tained)25 b(in)f(ab)s(out)f(40)i(C)f(source)g
-(\014les)f(\(*.c\))j(and)d(header)h(\014les)g(\(*.h\).)39
+TeXDict begin 3 8 bop 0 1225 a Fg(Chapter)65 b(2)0 1687
+y Fm(Creating)77 b(FITSIO/CFITSIO)0 2216 y Fe(2.1)135
+b(Building)45 b(the)h(Library)0 2467 y Fj(T)-8 b(o)43
+b(use)g(the)g(FITSIO)f(subroutines)f(one)j(m)m(ust)e(\014rst)g(build)g
+(the)h(CFITSIO)f(library)-8 b(,)46 b(whic)m(h)d(requires)f(a)h(C)0
+2580 y(compiler.)73 b(gcc)43 b(is)e(ideal,)j(or)d(most)h(other)f
+(ANSI-C)g(compilers)g(will)h(also)g(w)m(ork.)73 b(The)40
+b(CFITSIO)g(co)s(de)h(is)0 2692 y(con)m(tained)25 b(in)f(ab)s(out)f(40)
+i(C)f(source)g(\014les)f(\(*.c\))j(and)d(header)h(\014les)g(\(*.h\).)39
 b(On)23 b(V)-10 b(AX/VMS)25 b(systems)f(2)g(assem)m(bly-)0
 2805 y(co)s(de)31 b(\014les)f(\(vmsieeed.mar)h(and)f(vmsieeer.mar\))h
 (are)g(also)g(needed.)0 2965 y(The)45 b(F)-8 b(ortran)46
 b(in)m(terface)g(subroutines)e(to)i(the)f(C)g(CFITSIO)f(routines)h(are)
 g(lo)s(cated)i(in)e(the)g(f77)p 3538 2965 28 4 v 33 w(wrap1.c,)0
 3078 y(through)22 b(f77)p 459 3078 V 33 w(wrap4.c)h(\014les.)38
 b(These)22 b(are)h(relativ)m(ely)i(simple)d('wrapp)s(ers')f(that)i
@@ -6643,29 +5299,17 @@
 e(running)f(the)i(con\014gure)f(command.)47 b(The)0 4437
 y(curren)m(tly)30 b(recognized)i(compiler)f(names)f(are:)48
 4698 y Ff(g77Fortran)48 4811 y(IBMR2Fortran)48 4924 y(CLIPPERFortran)48
 5036 y(pgiFortran)48 5149 y(NAGf90Fortran)48 5262 y(f2cFortran)48
 5375 y(hpuxFortran)48 5488 y(apolloFortran)48 5601 y(sunFortran)48
 5714 y(CRAYFortran)1927 5942 y Fj(3)p eop end
 %%Page: 4 10
-TeXDict begin 4 9 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a -8
-191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.4) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(4)1896 b
-Fh(CHAPTER)30 b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)48
-555 y Ff(mipsFortran)48 668 y(DECFortran)48 781 y(vmsFortran)48
+TeXDict begin 4 9 bop 0 299 a Fj(4)1896 b Fh(CHAPTER)30
+b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)48 555
+y Ff(mipsFortran)48 668 y(DECFortran)48 781 y(vmsFortran)48
 894 y(CONVEXFortran)48 1007 y(PowerStationFortran)48
 1120 y(AbsoftUNIXFortran)48 1233 y(AbsoftProFortran)48
 1346 y(SXFortran)0 1609 y Fj(Alternativ)m(ely)-8 b(,)42
 b(one)c(ma)m(y)g(edit)g(the)f(CFLA)m(GS)h(line)f(in)h(the)f(Mak)m
 (e\014le)i(to)f(add)f(the)h('-DcompilerName')i(\015ag)0
 1722 y(after)31 b(running)e(the)h('./con\014gure')h(command.)0
 1882 y(The)f(CFITSIO)f(library)h(is)g(built)g(on)h(Unix)f(systems)g(b)m
@@ -6714,53 +5358,41 @@
 b(an)m(tages)33 b(of)d(using)g(a)h(shared)e(library)h(are:)143
 5488 y Ff(1.)95 b(Less)47 b(disk)f(space)h(if)g(you)g(build)f(more)h
 (than)f(1)i(program)143 5601 y(2.)95 b(Less)47 b(memory)f(if)h(more)g
 (than)f(one)h(copy)g(of)g(a)g(program)f(using)h(the)g(shared)334
 5714 y(library)f(is)h(running)f(at)h(the)g(same)g(time)f(since)h(the)g
 (system)f(is)h(smart)p eop end
 %%Page: 5 11
-TeXDict begin 5 10 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.5) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(2.1.)72
-b(BUILDING)31 b(THE)f(LIBRAR)-8 b(Y)2507 b Fj(5)334 555
-y Ff(enough)46 b(to)h(share)g(copies)f(of)h(the)g(shared)f(library)g
-(at)h(run)g(time.)143 668 y(3.)95 b(Possibly)46 b(easier)g(maintenance)
-e(since)j(a)g(new)g(version)f(of)h(the)g(shared)334 781
-y(library)f(can)h(be)g(installed)e(without)h(relinking)f(all)i(the)g
-(software)334 894 y(that)g(uses)f(it)i(\(as)e(long)h(as)g(the)g
-(subroutine)e(names)i(and)f(calling)334 1007 y(sequences)f(remain)h
-(unchanged\).)143 1120 y(4.)95 b(No)47 b(run-time)f(penalty.)0
-1534 y Fj(The)30 b(disadv)-5 b(an)m(tages)32 b(are:)143
-1949 y Ff(1.)47 b(More)g(hassle)f(at)h(runtime.)94 b(You)46
-b(have)h(to)g(either)f(build)h(the)g(programs)286 2062
-y(specially)f(or)h(have)f(LD_LIBRARY_PATH)e(set)j(right.)143
-2175 y(2.)g(There)g(may)g(be)g(a)g(slight)f(start)h(up)g(penalty,)e
-(depending)h(on)h(where)f(you)h(are)286 2288 y(reading)f(the)h(shared)f
-(library)g(and)h(the)g(program)f(from)g(and)h(if)g(your)g(CPU)g(is)286
-2401 y(either)f(really)h(slow)f(or)h(really)f(heavily)g(loaded.)0
-2815 y Fj(On)30 b(HP/UX)i(systems,)g(the)f(en)m(vironmen)m(t)h(v)-5
-b(ariable)32 b(CFLA)m(GS)f(should)f(b)s(e)h(set)g(to)h(-Ae)g(b)s(efore)
-f(running)e(con-)0 2928 y(\014gure)h(to)h(enable)g("extended)g(ANSI")f
-(features.)0 3088 y(It)j(ma)m(y)g(not)g(b)s(e)f(p)s(ossible)g(to)h
-(statically)i(link)e(programs)f(that)h(use)g(CFITSIO)e(on)h(some)h
-(platforms)g(\(namely)-8 b(,)0 3201 y(on)28 b(Solaris)h(2.6\))h(due)e
-(to)h(the)g(net)m(w)m(ork)g(driv)m(ers)f(\(whic)m(h)h(pro)m(vide)g(FTP)
-f(and)g(HTTP)g(access)h(to)h(FITS)d(\014les\).)41 b(It)0
-3314 y(is)33 b(p)s(ossible)f(to)i(mak)m(e)f(b)s(oth)g(a)g(dynamic)f
-(and)g(a)i(static)g(v)m(ersion)f(of)g(the)g(CFITSIO)e(library)-8
+TeXDict begin 5 10 bop 0 299 a Fh(2.1.)72 b(BUILDING)31
+b(THE)f(LIBRAR)-8 b(Y)2507 b Fj(5)334 555 y Ff(enough)46
+b(to)h(share)g(copies)f(of)h(the)g(shared)f(library)g(at)h(run)g(time.)
+143 668 y(3.)95 b(Possibly)46 b(easier)g(maintenance)e(since)j(a)g(new)
+g(version)f(of)h(the)g(shared)334 781 y(library)f(can)h(be)g(installed)
+e(without)h(relinking)f(all)i(the)g(software)334 894
+y(that)g(uses)f(it)i(\(as)e(long)h(as)g(the)g(subroutine)e(names)i(and)
+f(calling)334 1007 y(sequences)f(remain)h(unchanged\).)143
+1120 y(4.)95 b(No)47 b(run-time)f(penalty.)0 1534 y Fj(The)30
+b(disadv)-5 b(an)m(tages)32 b(are:)143 1949 y Ff(1.)47
+b(More)g(hassle)f(at)h(runtime.)94 b(You)46 b(have)h(to)g(either)f
+(build)h(the)g(programs)286 2062 y(specially)f(or)h(have)f
+(LD_LIBRARY_PATH)e(set)j(right.)143 2175 y(2.)g(There)g(may)g(be)g(a)g
+(slight)f(start)h(up)g(penalty,)e(depending)h(on)h(where)f(you)h(are)
+286 2288 y(reading)f(the)h(shared)f(library)g(and)h(the)g(program)f
+(from)g(and)h(if)g(your)g(CPU)g(is)286 2401 y(either)f(really)h(slow)f
+(or)h(really)f(heavily)g(loaded.)0 2815 y Fj(On)30 b(HP/UX)i(systems,)g
+(the)f(en)m(vironmen)m(t)h(v)-5 b(ariable)32 b(CFLA)m(GS)f(should)f(b)s
+(e)h(set)g(to)h(-Ae)g(b)s(efore)f(running)e(con-)0 2928
+y(\014gure)h(to)h(enable)g("extended)g(ANSI")f(features.)0
+3088 y(It)j(ma)m(y)g(not)g(b)s(e)f(p)s(ossible)g(to)h(statically)i
+(link)e(programs)f(that)h(use)g(CFITSIO)e(on)h(some)h(platforms)g
+(\(namely)-8 b(,)0 3201 y(on)28 b(Solaris)h(2.6\))h(due)e(to)h(the)g
+(net)m(w)m(ork)g(driv)m(ers)f(\(whic)m(h)h(pro)m(vide)g(FTP)f(and)g
+(HTTP)g(access)h(to)h(FITS)d(\014les\).)41 b(It)0 3314
+y(is)33 b(p)s(ossible)f(to)i(mak)m(e)f(b)s(oth)g(a)g(dynamic)f(and)g(a)
+i(static)g(v)m(ersion)f(of)g(the)g(CFITSIO)e(library)-8
 b(,)34 b(but)e(net)m(w)m(ork)i(\014le)0 3427 y(access)e(will)e(not)h(b)
 s(e)f(p)s(ossible)g(using)g(the)g(static)i(v)m(ersion.)0
 3587 y(On)c(V)-10 b(AX/VMS)31 b(and)d(ALPHA/VMS)i(systems)f(the)h(mak)m
 (e)p 2100 3587 28 4 v 34 w(g\015oat.com)h(command)e(\014le)g(ma)m(y)h
 (b)s(e)f(executed)h(to)0 3700 y(build)35 b(the)i(c\014tsio.olb)g(ob)5
 b(ject)37 b(library)f(using)g(the)g(default)h(G-\015oating)g(p)s(oin)m
 (t)g(option)f(for)g(double)g(v)-5 b(ariables.)0 3813
@@ -6802,494 +5434,336 @@
 5441 y(dll)j(library)-8 b(.)41 b(This)30 b(will)g(require,)h(ho)m(w)m
 (ev)m(er,)h(some)e(exp)s(ertise)h(in)f(mixed)g(language)i(programming.)
 0 5601 y(CFITSIO)f(should)g(b)s(e)g(compatible)j(with)d(most)i(curren)m
 (t)f(ANCI)g(C)f(and)h(C++)f(compilers:)44 b(Cra)m(y)33
 b(sup)s(ercom-)0 5714 y(puters)d(are)g(curren)m(tly)h(not)f(supp)s
 (orted.)p eop end
 %%Page: 6 12
-TeXDict begin 6 11 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.6) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(6)1896
-b Fh(CHAPTER)30 b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)0
-464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (section.2.2) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fe(2.2)135
-b(T)-11 b(esting)46 b(the)f(Library)0 805 y Fj(The)40
-b(CFITSIO)e(library)i(should)f(b)s(e)g(tested)i(b)m(y)f(building)f(and)
-g(running)g(the)h(testprog.c)h(program)f(that)h(is)0
+TeXDict begin 6 11 bop 0 299 a Fj(6)1896 b Fh(CHAPTER)30
+b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)0 555 y
+Fe(2.2)135 b(T)-11 b(esting)46 b(the)f(Library)0 805
+y Fj(The)40 b(CFITSIO)e(library)i(should)f(b)s(e)g(tested)i(b)m(y)f
+(building)f(and)g(running)g(the)h(testprog.c)h(program)f(that)h(is)0
 918 y(included)30 b(with)g(the)g(release.)42 b(On)30
-b(Unix)g(systems)g(t)m(yp)s(e:)191 1156 y Ff(\045)47
-b(make)g(testprog)191 1269 y(\045)g(testprog)f(>)h(testprog.lis)191
-1382 y(\045)g(diff)g(testprog.lis)d(testprog.out)191
-1495 y(\045)j(cmp)g(testprog.fit)e(testprog.std)0 1733
+b(Unix)g(systems)g(t)m(yp)s(e:)191 1154 y Ff(\045)47
+b(make)g(testprog)191 1267 y(\045)g(testprog)f(>)h(testprog.lis)191
+1380 y(\045)g(diff)g(testprog.lis)d(testprog.out)191
+1493 y(\045)j(cmp)g(testprog.fit)e(testprog.std)0 1729
 y Fj(On)30 b(VMS)g(systems,)g(\(assuming)h(cc)g(is)f(the)h(name)f(of)h
-(the)f(C)g(compiler)h(command\),)g(t)m(yp)s(e:)191 1970
-y Ff($)47 b(cc)h(testprog.c)191 2083 y($)f(link)g(testprog,)e
-(cfitsio/lib,)g(alpha$library:vaxcrtl/l)o(ib)191 2196
-y($)i(run)g(testprog)0 2434 y Fj(The)30 b(testprog)h(program)g(should)e
+(the)f(C)g(compiler)h(command\),)g(t)m(yp)s(e:)191 1965
+y Ff($)47 b(cc)h(testprog.c)191 2078 y($)f(link)g(testprog,)e
+(cfitsio/lib,)g(alpha$library:vaxcrtl/l)o(ib)191 2191
+y($)i(run)g(testprog)0 2427 y Fj(The)30 b(testprog)h(program)g(should)e
 (pro)s(duce)g(a)i(FITS)f(\014le)g(called)i(`testprog.\014t')g(that)f
-(is)f(iden)m(tical)j(to)e(the)f(`test-)0 2547 y(prog.std')25
+(is)f(iden)m(tical)j(to)e(the)f(`test-)0 2540 y(prog.std')25
 b(FITS)f(\014le)g(included)g(with)g(this)h(release.)40
 b(The)24 b(diagnostic)i(messages)g(\(whic)m(h)e(w)m(ere)h(pip)s(ed)f
-(to)h(the)g(\014le)0 2660 y(testprog.lis)h(in)e(the)h(Unix)f(example\))
+(to)h(the)g(\014le)0 2653 y(testprog.lis)h(in)e(the)h(Unix)f(example\))
 i(should)d(b)s(e)h(iden)m(tical)j(to)e(the)g(listing)g(con)m(tained)h
-(in)e(the)h(\014le)f(testprog.out.)0 2773 y(The)30 b('di\013)7
+(in)e(the)h(\014le)f(testprog.out.)0 2766 y(The)30 b('di\013)7
 b(')31 b(and)e('cmp')i(commands)f(sho)m(wn)g(ab)s(o)m(v)m(e)h(should)f
 (not)g(rep)s(ort)g(an)m(y)h(di\013erences)g(in)f(the)g(\014les.)41
-b(\(There)0 2886 y(ma)m(y)35 b(b)s(e)e(some)h(minor)g(formatting)g
+b(\(There)0 2879 y(ma)m(y)35 b(b)s(e)e(some)h(minor)g(formatting)g
 (di\013erences,)i(suc)m(h)d(as)i(the)f(presence)g(or)g(absence)g(of)g
-(leading)h(zeros,)h(or)e(3)0 2999 y(digit)d(exp)s(onen)m(ts)f(in)g(n)m
+(leading)h(zeros,)h(or)e(3)0 2992 y(digit)d(exp)s(onen)m(ts)f(in)g(n)m
 (um)m(b)s(ers,)g(whic)m(h)g(can)g(b)s(e)g(ignored\).)0
-3159 y(The)f(F)-8 b(ortran)31 b(wrapp)s(ers)d(in)h(CFITSIO)f(ma)m(y)j
+3152 y(The)f(F)-8 b(ortran)31 b(wrapp)s(ers)d(in)h(CFITSIO)f(ma)m(y)j
 (b)s(e)e(tested)h(with)g(the)g(testf77)h(program.)40
-b(On)29 b(Unix)h(systems)g(the)0 3272 y(fortran)g(compilation)i(and)e
-(link)g(command)g(ma)m(y)h(b)s(e)f(called)h('f77')h(or)e('g77',)j(dep)s
-(ending)c(on)h(the)g(system.)143 3509 y Ff(\045)48 b(f77)f(-o)g
-(testf77)f(testf77.f)f(-L.)i(-lcfitsio)e(-lnsl)h(-lsocket)48
-3622 y(or)143 3735 y(\045)i(f77)f(-f)g(-o)g(testf77)f(testf77.f)f(-L.)i
-(-lcfitsio)188 b(\(under)46 b(SUN)h(O/S\))48 3848 y(or)143
-3961 y(\045)h(f77)f(-o)g(testf77)f(testf77.f)f(-Wl,-L.)h(-lcfitsio)f
-(-lm)i(-lnsl)f(-lsocket)g(\(HP/UX\))48 4074 y(or)143
-4187 y(\045)i(g77)f(-o)g(testf77)f(-s)h(testf77.f)e(-lcfitsio)g
-(-lcc_dynamic)g(-lncurses)g(\(Mac)i(OS-X\))143 4413 y(\045)h(testf77)d
-(>)j(testf77.lis)143 4526 y(\045)g(diff)e(testf77.lis)f(testf77.out)143
-4638 y(\045)j(cmp)f(testf77.fit)d(testf77.std)0 4876
+b(On)29 b(Unix)h(systems)g(the)0 3265 y(F)-8 b(ortran)31
+b(compiler)g(is)f(t)m(ypically)j(called)e('gfortran'.)42
+b(-)143 3501 y Ff(\045)48 b(gfortran)d(-o)i(testf77)f(testf77.f)f(-L.)i
+(-lcfitsio)f(-lz)h(-lcurl)143 3614 y(\045)h(testf77)d(>)j(testf77.lis)
+143 3727 y(\045)g(diff)e(testf77.lis)f(testf77.out)143
+3840 y(\045)j(cmp)f(testf77.fit)d(testf77.std)0 4076
 y Fj(On)31 b(mac)m(hines)h(running)f(SUN)g(O/S,)h(F)-8
 b(ortran)33 b(programs)e(m)m(ust)h(b)s(e)f(compiled)h(with)g(the)g('-f)
-7 b(')32 b(option)h(to)f(force)0 4989 y(double)24 b(precision)g(v)-5
+7 b(')32 b(option)h(to)f(force)0 4189 y(double)24 b(precision)g(v)-5
 b(ariables)25 b(to)g(b)s(e)e(aligned)i(on)f(8-b)m(yte)i(b)s(oundaries)c
 (to)j(mak)m(e)g(the)g(fortran-declared)f(v)-5 b(ariables)0
-5102 y(compatible)34 b(with)e(C.)g(A)h(similar)g(compiler)g(option)g
+4301 y(compatible)34 b(with)e(C.)g(A)h(similar)g(compiler)g(option)g
 (ma)m(y)g(b)s(e)f(required)g(on)g(other)h(platforms.)48
-b(F)-8 b(ailing)34 b(to)f(use)0 5215 y(this)26 b(option)g(ma)m(y)g
+b(F)-8 b(ailing)34 b(to)f(use)0 4414 y(this)26 b(option)g(ma)m(y)g
 (cause)h(the)f(program)f(to)i(crash)e(on)h(FITSIO)f(routines)g(that)i
-(read)f(or)f(write)h(double)g(precision)0 5328 y(v)-5
-b(ariables.)0 5488 y(On)27 b(Windo)m(ws)h(platforms,)g(linking)g(F)-8
+(read)f(or)f(write)h(double)g(precision)0 4527 y(v)-5
+b(ariables.)0 4687 y(On)27 b(Windo)m(ws)h(platforms,)g(linking)g(F)-8
 b(ortran)28 b(programs)f(with)h(a)g(C)f(library)g(often)h(dep)s(ends)e
-(on)i(the)g(particular)0 5601 y(compilers)40 b(in)m(v)m(olv)m(ed.)71
+(on)i(the)g(particular)0 4800 y(compilers)40 b(in)m(v)m(olv)m(ed.)71
 b(Some)40 b(users)f(ha)m(v)m(e)i(found)d(the)i(follo)m(wing)i(commands)
-d(w)m(ork)h(when)f(using)g(the)h(In)m(tel)0 5714 y(F)-8
-b(ortran)31 b(compiler:)p eop end
+d(w)m(ork)h(when)f(using)g(the)h(In)m(tel)0 4913 y(F)-8
+b(ortran)31 b(compiler:)0 5149 y Ff(ifort)46 b(/libs.dll)g(cfitsio.lib)
+e(/MD)j(testf77.f)f(/Gm)0 5375 y(or)h(possibly,)0 5601
+y(ifort)f(/libs:dll)g(cfitsio.lib)e(/MD)j(/fpp)g
+(/extfpp:cfortran.h,fitsi)o(o.h)191 5714 y(/iface:cvf)e(testf77.f)p
+eop end
 %%Page: 7 13
-TeXDict begin 7 12 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.7) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(2.3.)72
-b(LINKING)30 b(PR)m(OGRAMS)h(WITH)f(FITSIO)2041 b Fj(7)0
-555 y Ff(ifort)46 b(/libs.dll)g(cfitsio.lib)e(/MD)j(testf77.f)f(/Gm)0
-781 y(or)h(possibly,)0 1007 y(ifort)f(/libs:dll)g(cfitsio.lib)e(/MD)j
-(/fpp)g(/extfpp:cfortran.h,fitsi)o(o.h)191 1120 y(/iface:cvf)e
-(testf77.f)0 1335 y Fj(Also)32 b(note)h(that)f(on)g(some)g(systems)f
-(the)h(output)g(listing)g(of)g(the)g(testf77)h(program)f(ma)m(y)g
-(di\013er)f(sligh)m(tly)i(from)0 1448 y(the)f(testf77.std)i(template)g
-(if)e(leading)h(zeros)g(are)g(not)g(prin)m(ted)e(b)m(y)i(default)f(b)s
-(efore)g(the)g(decimal)i(p)s(oin)m(t)e(when)0 1561 y(using)e(F)h
-(format.)0 1721 y(A)f(few)h(other)f(utilit)m(y)i(programs)e(are)h
-(included)e(with)h(CFITSIO:)191 1937 y Ff(speed)46 b(-)i(measures)d
-(the)i(maximum)f(throughput)f(\(in)i(MB)g(per)g(second\))668
-2050 y(for)g(writing)f(and)h(reading)f(FITS)g(files)h(with)f(CFITSIO)
-191 2275 y(listhead)f(-)j(lists)e(all)h(the)g(header)f(keywords)g(in)h
-(any)g(FITS)f(file)191 2501 y(fitscopy)f(-)j(copies)e(any)h(FITS)g
-(file)f(\(especially)f(useful)h(in)h(conjunction)811
-2614 y(with)g(the)g(CFITSIO's)e(extended)h(input)g(filename)g(syntax\))
-191 2840 y(cookbook)f(-)j(a)f(sample)f(program)g(that)h(performs)e
-(common)i(read)f(and)811 2953 y(write)h(operations)e(on)i(a)g(FITS)g
-(file.)191 3179 y(iter_a,)f(iter_b,)g(iter_c)g(-)h(examples)f(of)h(the)
-g(CFITSIO)f(iterator)f(routine)0 3394 y Fj(The)30 b(\014rst)f(4)i(of)g
-(these)g(utilit)m(y)g(programs)f(can)h(b)s(e)f(compiled)h(and)e(link)m
-(ed)i(b)m(y)f(t)m(yping)143 3610 y Ff(\045)95 b(make)47
-b(program_name)0 3760 y
-SDict begin H.S end
- 0 3760 a 0 3760 a
-SDict begin 13.6 H.A end
- 0 3760 a 0
-3760 a
-SDict begin [/View [/XYZ H.V]/Dest (section.2.3) cvn /DEST pdfmark
-end
- 0 3760 a 176 x Fe(2.3)135 b(Linking)45 b(Programs)h(with)f
-(FITSIO)0 4186 y Fj(When)31 b(linking)g(applications)i(soft)m(w)m(are)f
-(with)f(the)g(FITSIO)f(library)-8 b(,)32 b(sev)m(eral)h(system)e
-(libraries)g(usually)g(need)0 4299 y(to)26 b(b)s(e)f(sp)s(eci\014ed)g
-(on)g(the)h(link)g(comman)f(Unix)h(systems,)h(the)e(most)h(reliable)h
-(w)m(a)m(y)f(to)h(determine)e(what)h(libraries)0 4412
-y(are)32 b(required)f(is)g(to)i(t)m(yp)s(e)e('mak)m(e)i(testprog')g
-(and)e(see)h(what)f(libraries)h(the)g(con\014gure)f(script)h(has)f
-(added.)43 b(The)0 4525 y(t)m(ypical)25 b(libraries)f(that)g(ma)m(y)g
-(need)f(to)h(b)s(e)f(added)g(are)g(-lm)h(\(the)g(math)f(library\))h
-(and)f(-lnsl)g(and)g(-lso)s(c)m(k)m(et)j(\(needed)0 4638
-y(only)h(for)f(FTP)g(and)g(HTTP)g(\014le)h(access\).)41
-b(These)26 b(latter)i(2)f(libraries)g(are)g(not)g(needed)f(on)g(VMS)h
-(and)f(Windo)m(ws)0 4751 y(platforms,)31 b(b)s(ecause)f(FTP)g(\014le)h
-(access)g(is)g(not)f(curren)m(tly)h(supp)s(orted)d(on)i(those)h
-(platforms.)0 4911 y(Note)i(that)g(when)e(upgrading)g(to)i(a)f(new)m
-(er)g(v)m(ersion)g(of)g(CFITSIO)f(it)h(is)g(usually)g(necessary)g(to)h
-(recompile,)h(as)0 5024 y(w)m(ell)d(as)g(relink,)g(the)f(programs)g
-(that)h(use)f(CFITSIO,)f(b)s(ecause)i(the)f(de\014nitions)g(in)g
-(\014tsio.h)h(often)f(c)m(hange.)0 5172 y
-SDict begin H.S end
- 0 5172 a 0
-5172 a
-SDict begin 13.6 H.A end
- 0 5172 a 0 5172 a
-SDict begin [/View [/XYZ H.V]/Dest (section.2.4) cvn /DEST pdfmark
-end
- 0 5172 a 179 x Fe(2.4)135 b(Getting)46
-b(Started)g(with)f(FITSIO)0 5601 y Fj(In)32 b(order)h(to)h(e\013ectiv)m
-(ely)i(use)d(the)g(FITSIO)f(library)h(as)h(quic)m(kly)g(as)f(p)s
-(ossible,)h(it)g(is)f(recommended)g(that)g(new)0 5714
-y(users)d(follo)m(w)h(these)g(steps:)p eop end
-%%Page: 8 14
-TeXDict begin 8 13 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.8) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(8)1896
-b Fh(CHAPTER)30 b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)0
-555 y Fj(1.)62 b(Read)38 b(the)f(follo)m(wing)i(`FITS)e(Primer')g(c)m
+TeXDict begin 7 12 bop 0 299 a Fh(2.3.)72 b(LINKING)30
+b(PR)m(OGRAMS)h(WITH)f(FITSIO)2041 b Fj(7)0 555 y(Also)32
+b(note)h(that)f(on)g(some)g(systems)f(the)h(output)g(listing)g(of)g
+(the)g(testf77)h(program)f(ma)m(y)g(di\013er)f(sligh)m(tly)i(from)0
+668 y(the)f(testf77.std)i(template)g(if)e(leading)h(zeros)g(are)g(not)g
+(prin)m(ted)e(b)m(y)i(default)f(b)s(efore)g(the)g(decimal)i(p)s(oin)m
+(t)e(when)0 781 y(using)e(F)h(format.)0 941 y(A)f(few)h(other)f(utilit)
+m(y)i(programs)e(are)h(included)e(with)h(CFITSIO:)191
+1216 y Ff(speed)46 b(-)i(measures)d(the)i(maximum)f(throughput)f(\(in)i
+(MB)g(per)g(second\))668 1329 y(for)g(writing)f(and)h(reading)f(FITS)g
+(files)h(with)f(CFITSIO)191 1555 y(listhead)f(-)j(lists)e(all)h(the)g
+(header)f(keywords)g(in)h(any)g(FITS)f(file)191 1780
+y(fitscopy)f(-)j(copies)e(any)h(FITS)g(file)f(\(especially)f(useful)h
+(in)h(conjunction)811 1893 y(with)g(the)g(CFITSIO's)e(extended)h(input)
+g(filename)g(syntax\))191 2119 y(cookbook)f(-)j(a)f(sample)f(program)g
+(that)h(performs)e(common)i(read)f(and)811 2232 y(write)h(operations)e
+(on)i(a)g(FITS)g(file.)191 2458 y(iter_a,)f(iter_b,)g(iter_c)g(-)h
+(examples)f(of)h(the)g(CFITSIO)f(iterator)f(routine)0
+2733 y Fj(The)30 b(\014rst)f(4)i(of)g(these)g(utilit)m(y)g(programs)f
+(can)h(b)s(e)f(compiled)h(and)e(link)m(ed)i(b)m(y)f(t)m(yping)143
+3007 y Ff(\045)95 b(make)47 b(program_name)0 3359 y Fe(2.3)135
+b(Linking)45 b(Programs)h(with)f(FITSIO)0 3612 y Fj(When)31
+b(linking)g(applications)i(soft)m(w)m(are)f(with)f(the)g(FITSIO)f
+(library)-8 b(,)32 b(sev)m(eral)h(system)e(libraries)g(usually)g(need)0
+3725 y(to)26 b(b)s(e)f(sp)s(eci\014ed)g(on)g(the)h(link)g(comman)f
+(Unix)h(systems,)h(the)e(most)h(reliable)h(w)m(a)m(y)f(to)h(determine)e
+(what)h(libraries)0 3838 y(are)32 b(required)f(is)g(to)i(t)m(yp)s(e)e
+('mak)m(e)i(testprog')g(and)e(see)h(what)f(libraries)h(the)g
+(con\014gure)f(script)h(has)f(added.)43 b(The)0 3951
+y(t)m(ypical)25 b(libraries)f(that)g(ma)m(y)g(need)f(to)h(b)s(e)f
+(added)g(are)g(-lm)h(\(the)g(math)f(library\))h(and)f(-lnsl)g(and)g
+(-lso)s(c)m(k)m(et)j(\(needed)0 4064 y(only)h(for)f(FTP)g(and)g(HTTP)g
+(\014le)h(access\).)41 b(These)26 b(latter)i(2)f(libraries)g(are)g(not)
+g(needed)f(on)g(VMS)h(and)f(Windo)m(ws)0 4177 y(platforms,)31
+b(b)s(ecause)f(FTP)g(\014le)h(access)g(is)g(not)f(curren)m(tly)h(supp)s
+(orted)d(on)i(those)h(platforms.)0 4337 y(Note)i(that)g(when)e
+(upgrading)g(to)i(a)f(new)m(er)g(v)m(ersion)g(of)g(CFITSIO)f(it)h(is)g
+(usually)g(necessary)g(to)h(recompile,)h(as)0 4450 y(w)m(ell)d(as)g
+(relink,)g(the)f(programs)g(that)h(use)f(CFITSIO,)f(b)s(ecause)i(the)f
+(de\014nitions)g(in)g(\014tsio.h)h(often)f(c)m(hange.)0
+4801 y Fe(2.4)135 b(Getting)46 b(Started)g(with)f(FITSIO)0
+5055 y Fj(In)32 b(order)h(to)h(e\013ectiv)m(ely)i(use)d(the)g(FITSIO)f
+(library)h(as)h(quic)m(kly)g(as)f(p)s(ossible,)h(it)g(is)f(recommended)
+g(that)g(new)0 5168 y(users)d(follo)m(w)h(these)g(steps:)0
+5328 y(1.)62 b(Read)38 b(the)f(follo)m(wing)i(`FITS)e(Primer')g(c)m
 (hapter)h(for)g(a)f(brief)g(o)m(v)m(erview)i(of)f(the)g(structure)e(of)
-i(FITS)f(\014les.)0 668 y(This)25 b(is)h(esp)s(ecially)h(imp)s(ortan)m
+i(FITS)f(\014les.)0 5441 y(This)25 b(is)h(esp)s(ecially)h(imp)s(ortan)m
 (t)g(for)e(users)h(who)f(ha)m(v)m(e)i(not)g(previously)e(dealt)i(with)f
-(the)g(FITS)f(table)i(and)f(image)0 781 y(extensions.)0
-941 y(2.)41 b(W)-8 b(rite)32 b(a)f(simple)f(program)g(to)h(read)g(or)f
+(the)g(FITS)f(table)i(and)f(image)0 5554 y(extensions.)0
+5714 y(2.)41 b(W)-8 b(rite)32 b(a)f(simple)f(program)g(to)h(read)g(or)f
 (write)g(a)h(FITS)f(\014le)g(using)g(the)h(Basic)g(In)m(terface)h
-(routines.)0 1101 y(3.)41 b(Refer)28 b(to)i(the)f(co)s(okb)s(o)s(ok.f)g
-(program)f(that)i(is)f(included)f(with)g(this)h(release)h(for)e
-(examples)i(of)f(routines)f(that)0 1214 y(p)s(erform)h(v)-5
-b(arious)30 b(common)h(FITS)f(\014le)g(op)s(erations.)0
-1374 y(4.)52 b(Read)34 b(Chapters)g(4)g(and)f(5)i(to)g(b)s(ecome)f
-(familiar)h(with)e(the)i(con)m(v)m(en)m(tions)h(and)d(adv)-5
-b(anced)34 b(features)h(of)f(the)0 1487 y(FITSIO)29 b(in)m(terface.)0
-1647 y(5.)47 b(Scan)32 b(through)f(the)h(more)h(extensiv)m(e)g(set)g
+(routines.)p eop end
+%%Page: 8 14
+TeXDict begin 8 13 bop 0 299 a Fj(8)1896 b Fh(CHAPTER)30
+b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)0 555 y
+Fj(3.)41 b(Refer)28 b(to)i(the)f(co)s(okb)s(o)s(ok.f)g(program)f(that)i
+(is)f(included)f(with)g(this)h(release)h(for)e(examples)i(of)f
+(routines)f(that)0 668 y(p)s(erform)h(v)-5 b(arious)30
+b(common)h(FITS)f(\014le)g(op)s(erations.)0 828 y(4.)52
+b(Read)34 b(Chapters)g(4)g(and)f(5)i(to)g(b)s(ecome)f(familiar)h(with)e
+(the)i(con)m(v)m(en)m(tions)h(and)d(adv)-5 b(anced)34
+b(features)h(of)f(the)0 941 y(FITSIO)29 b(in)m(terface.)0
+1101 y(5.)47 b(Scan)32 b(through)f(the)h(more)h(extensiv)m(e)g(set)g
 (of)g(routines)f(that)g(are)h(pro)m(vided)f(in)g(the)g(`Adv)-5
-b(anced)32 b(In)m(terface'.)0 1760 y(These)22 b(routines)f(p)s(erform)g
+b(anced)32 b(In)m(terface'.)0 1214 y(These)22 b(routines)f(p)s(erform)g
 (more)h(sp)s(ecialized)h(functions)e(than)g(are)i(pro)m(vided)e(b)m(y)h
-(the)g(Basic)h(In)m(terface)g(routines.)0 1945 y
-SDict begin H.S end
- 0 1945
-a 0 1945 a
-SDict begin 13.6 H.A end
- 0 1945 a 0 1945 a
-SDict begin [/View [/XYZ H.V]/Dest (section.2.5) cvn /DEST pdfmark
-end
- 0 1945 a 179 x Fe(2.5)135
-b(Example)46 b(Program)0 2380 y Fj(The)32 b(follo)m(wing)i(listing)f
+(the)g(Basic)h(In)m(terface)g(routines.)0 1569 y Fe(2.5)135
+b(Example)46 b(Program)0 1823 y Fj(The)32 b(follo)m(wing)i(listing)f
 (sho)m(ws)f(an)g(example)i(of)e(ho)m(w)h(to)g(use)f(the)g(FITSIO)g
-(routines)g(in)g(a)h(F)-8 b(ortran)33 b(program.)0 2493
+(routines)g(in)g(a)h(F)-8 b(ortran)33 b(program.)0 1936
 y(Refer)38 b(to)h(the)g(co)s(okb)s(o)s(ok.f)f(program)g(that)h(is)f
 (included)f(with)h(the)h(FITSIO)e(distribution)g(for)h(examples)h(of)0
-2606 y(other)31 b(FITS)e(programs.)286 2891 y Ff(program)46
-b(writeimage)0 3117 y(C)238 b(Create)46 b(a)i(FITS)f(primary)e(array)i
-(containing)e(a)i(2-D)g(image)286 3343 y(integer)f
+2049 y(other)31 b(FITS)e(programs.)286 2327 y Ff(program)46
+b(writeimage)0 2552 y(C)238 b(Create)46 b(a)i(FITS)f(primary)e(array)i
+(containing)e(a)i(2-D)g(image)286 2778 y(integer)f
 (status,unit,blocksize,bit)o(pix,)o(nax)o(is,n)o(axes)o(\(2\))286
-3456 y(integer)g(i,j,group,fpixel,nelement)o(s,ar)o(ray)o(\(300)o(,200)
-o(\))286 3569 y(character)g(filename*80)286 3681 y(logical)g
-(simple,extend)286 3907 y(status=0)0 4020 y(C)238 b(Name)47
-b(of)g(the)g(FITS)g(file)f(to)i(be)f(created:)286 4133
-y(filename='ATESTFILE.FITS')0 4359 y(C)238 b(Get)47 b(an)g(unused)g
+2891 y(integer)g(i,j,group,fpixel,nelement)o(s,ar)o(ray)o(\(300)o(,200)
+o(\))286 3004 y(character)g(filename*80)286 3117 y(logical)g
+(simple,extend)286 3343 y(status=0)0 3456 y(C)238 b(Name)47
+b(of)g(the)g(FITS)g(file)f(to)i(be)f(created:)286 3569
+y(filename='ATESTFILE.FITS')0 3794 y(C)238 b(Get)47 b(an)g(unused)g
 (Logical)e(Unit)i(Number)f(to)h(use)g(to)g(create)f(the)h(FITS)g(file)
-286 4472 y(call)g(ftgiou\(unit,status\))0 4698 y(C)238
-b(create)46 b(the)h(new)g(empty)g(FITS)f(file)286 4811
-y(blocksize=1)286 4924 y(call)h(ftinit\(unit,filename,blo)o(cksi)o
-(ze,s)o(tat)o(us\))0 5149 y(C)238 b(initialize)45 b(parameters)g(about)
+286 3907 y(call)g(ftgiou\(unit,status\))0 4133 y(C)238
+b(create)46 b(the)h(new)g(empty)g(FITS)f(file)286 4246
+y(blocksize=1)286 4359 y(call)h(ftinit\(unit,filename,blo)o(cksi)o
+(ze,s)o(tat)o(us\))0 4585 y(C)238 b(initialize)45 b(parameters)g(about)
 i(the)g(FITS)f(image)h(\(300)f(x)i(200)f(16-bit)f(integers\))286
-5262 y(simple=.true.)286 5375 y(bitpix=16)286 5488 y(naxis=2)286
-5601 y(naxes\(1\)=300)286 5714 y(naxes\(2\)=200)p eop
-end
+4698 y(simple=.true.)286 4811 y(bitpix=16)286 4924 y(naxis=2)286
+5036 y(naxes\(1\)=300)286 5149 y(naxes\(2\)=200)286 5262
+y(extend=.true.)0 5488 y(C)238 b(write)47 b(the)g(required)e(header)h
+(keywords)286 5601 y(call)h(ftphpr\(unit,simple,bitpi)o(x,na)o(xis,)o
+(nax)o(es,0)o(,1,e)o(xte)o(nd,s)o(tatu)o(s\))p eop end
 %%Page: 9 15
-TeXDict begin 9 14 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.9) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(2.6.)72
-b(LEGAL)30 b(STUFF)2995 b Fj(9)286 555 y Ff(extend=.true.)0
-781 y(C)238 b(write)47 b(the)g(required)e(header)h(keywords)286
-894 y(call)h(ftphpr\(unit,simple,bitpi)o(x,na)o(xis,)o(nax)o(es,0)o
-(,1,e)o(xte)o(nd,s)o(tatu)o(s\))0 1120 y(C)238 b(initialize)45
+TeXDict begin 9 14 bop 0 299 a Fh(2.6.)72 b(LEGAL)30
+b(STUFF)2995 b Fj(9)0 555 y Ff(C)238 b(initialize)45
 b(the)i(values)f(in)i(the)e(image)h(with)f(a)i(linear)e(ramp)h
-(function)286 1233 y(do)h(j=1,naxes\(2\))477 1346 y(do)f
-(i=1,naxes\(1\))668 1458 y(array\(i,j\)=i+j)477 1571
-y(end)g(do)286 1684 y(end)g(do)0 1910 y(C)238 b(write)47
-b(the)g(array)f(to)h(the)g(FITS)g(file)286 2023 y(group=1)286
-2136 y(fpixel=1)286 2249 y(nelements=naxes\(1\)*naxes\(2)o(\))286
-2362 y(call)g(ftpprj\(unit,group,fpixel)o(,nel)o(emen)o(ts,)o(arra)o
-(y,st)o(atu)o(s\))0 2588 y(C)238 b(write)47 b(another)f(optional)f
-(keyword)h(to)h(the)g(header)286 2700 y(call)g
-(ftpkyj\(unit,'EXPOSURE',1)o(500,)o('Tot)o(al)41 b(Exposure)46
-b(Time',status\))0 2926 y(C)238 b(close)47 b(the)g(file)f(and)h(free)g
-(the)g(unit)f(number)286 3039 y(call)h(ftclos\(unit,)d(status\))286
-3152 y(call)j(ftfiou\(unit,)d(status\))286 3265 y(end)0
-3427 y
-SDict begin H.S end
- 0 3427 a 0 3427 a
-SDict begin 13.6 H.A end
- 0 3427 a 0 3427 a
-SDict begin [/View [/XYZ H.V]/Dest (section.2.6) cvn /DEST pdfmark
-end
- 0 3427 a 196
-x Fe(2.6)135 b(Legal)46 b(Stu\013)0 3878 y Fj(Cop)m(yrigh)m(t)37
-b(\(Unpublished{all)g(righ)m(ts)g(reserv)m(ed)g(under)e(the)i(cop)m
-(yrigh)m(t)h(la)m(ws)f(of)g(the)g(United)g(States\),)j(U.S.)0
-3991 y(Go)m(v)m(ernmen)m(t)30 b(as)g(represen)m(ted)e(b)m(y)h(the)g
-(Administrator)g(of)g(the)g(National)h(Aeronautics)g(and)e(Space)h
-(Adminis-)0 4104 y(tration.)42 b(No)31 b(cop)m(yrigh)m(t)g(is)g
-(claimed)g(in)f(the)h(United)f(States)h(under)e(Title)j(17,)f(U.S.)f
-(Co)s(de.)0 4264 y(P)m(ermission)g(to)g(freely)f(use,)h(cop)m(y)-8
+(function)286 668 y(do)h(j=1,naxes\(2\))477 781 y(do)f(i=1,naxes\(1\))
+668 894 y(array\(i,j\)=i+j)477 1007 y(end)g(do)286 1120
+y(end)g(do)0 1346 y(C)238 b(write)47 b(the)g(array)f(to)h(the)g(FITS)g
+(file)286 1458 y(group=1)286 1571 y(fpixel=1)286 1684
+y(nelements=naxes\(1\)*naxes\(2)o(\))286 1797 y(call)g
+(ftpprj\(unit,group,fpixel)o(,nel)o(emen)o(ts,)o(arra)o(y,st)o(atu)o
+(s\))0 2023 y(C)238 b(write)47 b(another)f(optional)f(keyword)h(to)h
+(the)g(header)286 2136 y(call)g(ftpkyj\(unit,'EXPOSURE',1)o(500,)o
+('Tot)o(al)41 b(Exposure)46 b(Time',status\))0 2362 y(C)238
+b(close)47 b(the)g(file)f(and)h(free)g(the)g(unit)f(number)286
+2475 y(call)h(ftclos\(unit,)d(status\))286 2588 y(call)j(ftfiou\(unit,)
+d(status\))286 2700 y(end)0 3059 y Fe(2.6)135 b(Legal)46
+b(Stu\013)0 3314 y Fj(Cop)m(yrigh)m(t)37 b(\(Unpublished{all)g(righ)m
+(ts)g(reserv)m(ed)g(under)e(the)i(cop)m(yrigh)m(t)h(la)m(ws)f(of)g(the)
+g(United)g(States\),)j(U.S.)0 3427 y(Go)m(v)m(ernmen)m(t)30
+b(as)g(represen)m(ted)e(b)m(y)h(the)g(Administrator)g(of)g(the)g
+(National)h(Aeronautics)g(and)e(Space)h(Adminis-)0 3540
+y(tration.)42 b(No)31 b(cop)m(yrigh)m(t)g(is)g(claimed)g(in)f(the)h
+(United)f(States)h(under)e(Title)j(17,)f(U.S.)f(Co)s(de.)0
+3700 y(P)m(ermission)g(to)g(freely)f(use,)h(cop)m(y)-8
 b(,)31 b(mo)s(dify)-8 b(,)29 b(and)g(distribute)g(this)g(soft)m(w)m
-(are)i(and)e(its)h(do)s(cumen)m(tation)g(without)0 4377
+(are)i(and)e(its)h(do)s(cumen)m(tation)g(without)0 3813
 y(fee)f(is)f(hereb)m(y)g(gran)m(ted,)i(pro)m(vided)e(that)h(this)f(cop)
 m(yrigh)m(t)i(notice)f(and)f(disclaimer)h(of)f(w)m(arran)m(t)m(y)i(app)
-s(ears)d(in)h(all)0 4490 y(copies.)0 4650 y(DISCLAIMER:)0
-4811 y(THE)33 b(SOFTW)-10 b(ARE)32 b(IS)g(PR)m(O)m(VIDED)i('AS)f(IS')g
+s(ears)d(in)h(all)0 3926 y(copies.)0 4086 y(DISCLAIMER:)0
+4246 y(THE)33 b(SOFTW)-10 b(ARE)32 b(IS)g(PR)m(O)m(VIDED)i('AS)f(IS')g
 (WITHOUT)f(ANY)i(W)-10 b(ARRANTY)33 b(OF)g(ANY)h(KIND,)f(EI-)0
-4924 y(THER)42 b(EXPRESSED,)f(IMPLIED,)i(OR)e(ST)-8 b(A)g(TUTOR)g(Y,)43
-b(INCLUDING,)f(BUT)h(NOT)e(LIMITED)h(TO,)0 5036 y(ANY)33
+4359 y(THER)42 b(EXPRESSED,)f(IMPLIED,)i(OR)e(ST)-8 b(A)g(TUTOR)g(Y,)43
+b(INCLUDING,)f(BUT)h(NOT)e(LIMITED)h(TO,)0 4472 y(ANY)33
 b(W)-10 b(ARRANTY)33 b(THA)-8 b(T)32 b(THE)g(SOFTW)-10
 b(ARE)32 b(WILL)g(CONF)m(ORM)g(TO)g(SPECIFICA)-8 b(TIONS,)30
-b(ANY)0 5149 y(IMPLIED)38 b(W)-10 b(ARRANTIES)37 b(OF)h(MER)m(CHANT)-8
+b(ANY)0 4585 y(IMPLIED)38 b(W)-10 b(ARRANTIES)37 b(OF)h(MER)m(CHANT)-8
 b(ABILITY,)38 b(FITNESS)f(F)m(OR)h(A)g(P)-8 b(AR)g(TICULAR)38
-b(PUR-)0 5262 y(POSE,)24 b(AND)i(FREEDOM)f(FR)m(OM)h(INFRINGEMENT,)g
+b(PUR-)0 4698 y(POSE,)24 b(AND)i(FREEDOM)f(FR)m(OM)h(INFRINGEMENT,)g
 (AND)f(ANY)h(W)-10 b(ARRANTY)25 b(THA)-8 b(T)25 b(THE)g(DOC-)0
-5375 y(UMENT)-8 b(A)g(TION)31 b(WILL)f(CONF)m(ORM)h(TO)e(THE)h(SOFTW)
+4811 y(UMENT)-8 b(A)g(TION)31 b(WILL)f(CONF)m(ORM)h(TO)e(THE)h(SOFTW)
 -10 b(ARE,)30 b(OR)g(ANY)h(W)-10 b(ARRANTY)31 b(THA)-8
-b(T)30 b(THE)0 5488 y(SOFTW)-10 b(ARE)31 b(WILL)h(BE)g(ERR)m(OR)g
+b(T)30 b(THE)0 4924 y(SOFTW)-10 b(ARE)31 b(WILL)h(BE)g(ERR)m(OR)g
 (FREE.)g(IN)g(NO)g(EVENT)f(SHALL)g(NASA)h(BE)g(LIABLE)g(F)m(OR)g(ANY)0
-5601 y(D)m(AMA)m(GES,)26 b(INCLUDING,)e(BUT)f(NOT)g(LIMITED)h(TO,)f
-(DIRECT,)g(INDIRECT,)g(SPECIAL)f(OR)h(CON-)0 5714 y(SEQUENTIAL)28
+5036 y(D)m(AMA)m(GES,)26 b(INCLUDING,)e(BUT)f(NOT)g(LIMITED)h(TO,)f
+(DIRECT,)g(INDIRECT,)g(SPECIAL)f(OR)h(CON-)0 5149 y(SEQUENTIAL)28
 b(D)m(AMA)m(GES,)k(ARISING)d(OUT)g(OF,)h(RESUL)-8 b(TING)29
-b(FR)m(OM,)h(OR)f(IN)h(ANY)g(W)-10 b(A)i(Y)30 b(CON-)p
-eop end
-%%Page: 10 16
-TeXDict begin 10 15 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.10) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(10)1851
-b Fh(CHAPTER)30 b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)0
-555 y Fj(NECTED)25 b(WITH)g(THIS)f(SOFTW)-10 b(ARE,)25
+b(FR)m(OM,)h(OR)f(IN)h(ANY)g(W)-10 b(A)i(Y)30 b(CON-)0
+5262 y(NECTED)25 b(WITH)g(THIS)f(SOFTW)-10 b(ARE,)25
 b(WHETHER)g(OR)g(NOT)g(BASED)g(UPON)g(W)-10 b(ARRANTY,)26
-b(CON-)0 668 y(TRA)m(CT,)d(TOR)-8 b(T)23 b(,)g(OR)g(OTHER)-10
+b(CON-)0 5375 y(TRA)m(CT,)d(TOR)-8 b(T)23 b(,)g(OR)g(OTHER)-10
 b(WISE,)22 b(WHETHER)i(OR)f(NOT)f(INJUR)-8 b(Y)24 b(W)-10
-b(AS)23 b(SUST)-8 b(AINED)23 b(BY)h(PER-)0 781 y(SONS)h(OR)i(PR)m(OPER)
--8 b(TY)26 b(OR)g(OTHER)-10 b(WISE,)26 b(AND)h(WHETHER)g(OR)f(NOT)g
-(LOSS)f(W)-10 b(AS)26 b(SUST)-8 b(AINED)0 894 y(FR)m(OM,)37
-b(OR)e(AR)m(OSE)h(OUT)f(OF)h(THE)g(RESUL)-8 b(TS)35 b(OF,)h(OR)f(USE)h
-(OF,)g(THE)g(SOFTW)-10 b(ARE)35 b(OR)g(SER-)0 1007 y(VICES)29
-b(PR)m(O)m(VIDED)j(HEREUNDER.")0 1254 y
-SDict begin H.S end
- 0 1254 a 0 1254
-a
-SDict begin 13.6 H.A end
- 0 1254 a 0 1254 a
-SDict begin [/View [/XYZ H.V]/Dest (section.2.7) cvn /DEST pdfmark
-end
- 0 1254 a 197 x Fe(2.7)135 b(Ac)l(kno)l(wledgmen)l
-(ts)0 1723 y Fj(The)29 b(dev)m(elopmen)m(t)h(of)g(man)m(y)f(of)h(the)f
-(p)s(o)m(w)m(erful)g(features)g(in)g(CFITSIO)f(w)m(as)i(made)f(p)s
-(ossible)g(through)f(collab-)0 1836 y(orations)35 b(with)f(man)m(y)h(p)
-s(eople)f(or)h(organizations)h(from)e(around)f(the)i(w)m(orld.)52
-b(The)34 b(follo)m(wing,)j(in)d(particular,)0 1949 y(ha)m(v)m(e)e(made)
-e(esp)s(ecially)i(signi\014can)m(t)f(con)m(tributions:)0
-2109 y(Programmers)25 b(from)h(the)f(In)m(tegral)i(Science)g(Data)g
-(Cen)m(ter,)g(Switzerland)f(\(namely)-8 b(,)28 b(Jurek)c(Bork)m(o)m
-(wski,)29 b(Bruce)0 2222 y(O'Neel,)34 b(and)e(Don)h(Jennings\),)f
-(designed)g(the)h(concept)g(for)f(the)h(plug-in)f(I/O)g(driv)m(ers)g
-(that)h(w)m(as)g(in)m(tro)s(duced)0 2335 y(with)i(CFITSIO)e(2.0.)56
-b(The)34 b(use)h(of)g(`driv)m(ers')g(greatly)h(simpli\014ed)f(the)g(lo)
-m(w-lev)m(el)j(I/O,)d(whic)m(h)f(in)h(turn)f(made)0 2448
-y(other)40 b(new)f(features)i(in)e(CFITSIO)f(\(e.g.,)45
-b(supp)s(ort)38 b(for)h(compressed)h(FITS)f(\014les)h(and)f(supp)s(ort)
-f(for)i(IRAF)0 2560 y(format)32 b(image)g(\014les\))g(m)m(uc)m(h)f
-(easier)i(to)f(implemen)m(t.)44 b(Jurek)31 b(Bork)m(o)m(wski)h(wrote)g
-(the)g(Shared)e(Memory)i(driv)m(er,)0 2673 y(and)23 b(Bruce)i(O'Neel)g
-(wrote)f(the)g(driv)m(ers)g(for)f(accessing)j(FITS)d(\014les)h(o)m(v)m
-(er)h(the)f(net)m(w)m(ork)h(using)e(the)i(FTP)-8 b(,)24
-b(HTTP)-8 b(,)0 2786 y(and)30 b(R)m(OOT)g(proto)s(cols.)0
-2946 y(The)45 b(ISDC)g(also)h(pro)m(vided)f(the)h(template)h(parsing)e
+b(AS)23 b(SUST)-8 b(AINED)23 b(BY)h(PER-)0 5488 y(SONS)h(OR)i(PR)m
+(OPER)-8 b(TY)26 b(OR)g(OTHER)-10 b(WISE,)26 b(AND)h(WHETHER)g(OR)f
+(NOT)g(LOSS)f(W)-10 b(AS)26 b(SUST)-8 b(AINED)0 5601
+y(FR)m(OM,)37 b(OR)e(AR)m(OSE)h(OUT)f(OF)h(THE)g(RESUL)-8
+b(TS)35 b(OF,)h(OR)f(USE)h(OF,)g(THE)g(SOFTW)-10 b(ARE)35
+b(OR)g(SER-)0 5714 y(VICES)29 b(PR)m(O)m(VIDED)j(HEREUNDER.")p
+eop end
+%%Page: 10 16
+TeXDict begin 10 15 bop 0 299 a Fj(10)1851 b Fh(CHAPTER)30
+b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)0 555 y
+Fe(2.7)135 b(Ac)l(kno)l(wledgmen)l(ts)0 904 y Fj(The)29
+b(dev)m(elopmen)m(t)h(of)g(man)m(y)f(of)h(the)f(p)s(o)m(w)m(erful)g
+(features)g(in)g(CFITSIO)f(w)m(as)i(made)f(p)s(ossible)g(through)f
+(collab-)0 1017 y(orations)35 b(with)f(man)m(y)h(p)s(eople)f(or)h
+(organizations)h(from)e(around)f(the)i(w)m(orld.)52 b(The)34
+b(follo)m(wing,)j(in)d(particular,)0 1129 y(ha)m(v)m(e)e(made)e(esp)s
+(ecially)i(signi\014can)m(t)f(con)m(tributions:)0 1290
+y(Programmers)25 b(from)h(the)f(In)m(tegral)i(Science)g(Data)g(Cen)m
+(ter,)g(Switzerland)f(\(namely)-8 b(,)28 b(Jurek)c(Bork)m(o)m(wski,)29
+b(Bruce)0 1403 y(O'Neel,)34 b(and)e(Don)h(Jennings\),)f(designed)g(the)
+h(concept)g(for)f(the)h(plug-in)f(I/O)g(driv)m(ers)g(that)h(w)m(as)g
+(in)m(tro)s(duced)0 1515 y(with)i(CFITSIO)e(2.0.)56 b(The)34
+b(use)h(of)g(`driv)m(ers')g(greatly)h(simpli\014ed)f(the)g(lo)m(w-lev)m
+(el)j(I/O,)d(whic)m(h)f(in)h(turn)f(made)0 1628 y(other)40
+b(new)f(features)i(in)e(CFITSIO)f(\(e.g.,)45 b(supp)s(ort)38
+b(for)h(compressed)h(FITS)f(\014les)h(and)f(supp)s(ort)f(for)i(IRAF)0
+1741 y(format)32 b(image)g(\014les\))g(m)m(uc)m(h)f(easier)i(to)f
+(implemen)m(t.)44 b(Jurek)31 b(Bork)m(o)m(wski)h(wrote)g(the)g(Shared)e
+(Memory)i(driv)m(er,)0 1854 y(and)23 b(Bruce)i(O'Neel)g(wrote)f(the)g
+(driv)m(ers)g(for)f(accessing)j(FITS)d(\014les)h(o)m(v)m(er)h(the)f
+(net)m(w)m(ork)h(using)e(the)i(FTP)-8 b(,)24 b(HTTP)-8
+b(,)0 1967 y(and)30 b(R)m(OOT)g(proto)s(cols.)0 2127
+y(The)45 b(ISDC)g(also)h(pro)m(vided)f(the)h(template)h(parsing)e
 (routines)g(\(written)h(b)m(y)f(Jurek)g(Bork)m(o)m(wski\))i(and)e(the)0
-3059 y(hierarc)m(hical)39 b(grouping)d(routines)h(\(written)h(b)m(y)f
+2240 y(hierarc)m(hical)39 b(grouping)d(routines)h(\(written)h(b)m(y)f
 (Don)h(Jennings\).)60 b(The)37 b(ISDC)f(D)m(AL)i(\(Data)h(Access)f(La)m
-(y)m(er\))0 3172 y(routines)30 b(are)h(la)m(y)m(ered)h(on)e(top)h(of)f
+(y)m(er\))0 2353 y(routines)30 b(are)h(la)m(y)m(ered)h(on)e(top)h(of)f
 (CFITSIO)f(and)h(mak)m(e)h(extensiv)m(e)h(use)e(of)h(these)g(features.)
-0 3332 y(Uw)m(e)25 b(Lammers)e(\(XMM/ESA/ESTEC,)h(The)g(Netherlands\))g
+0 2513 y(Uw)m(e)25 b(Lammers)e(\(XMM/ESA/ESTEC,)h(The)g(Netherlands\))g
 (designed)g(the)g(high-p)s(erformance)f(lexical)j(pars-)0
-3445 y(ing)42 b(algorithm)h(that)f(is)g(used)f(to)i(do)e(on-the-\015y)h
+2626 y(ing)42 b(algorithm)h(that)f(is)g(used)f(to)i(do)e(on-the-\015y)h
 (\014ltering)g(of)g(FITS)f(tables.)76 b(This)41 b(algorithm)i(essen)m
-(tially)0 3558 y(pre-compiles)36 b(the)g(user-supplied)e(selection)k
+(tially)0 2739 y(pre-compiles)36 b(the)g(user-supplied)e(selection)k
 (expression)d(in)m(to)i(a)f(form)g(that)g(can)g(b)s(e)f(rapidly)g(ev)-5
-b(aluated)37 b(for)0 3671 y(eac)m(h)31 b(ro)m(w.)40 b(P)m(eter)31
+b(aluated)37 b(for)0 2852 y(eac)m(h)31 b(ro)m(w.)40 b(P)m(eter)31
 b(Wilson)f(\(RSTX,)f(NASA/GSF)m(C\))i(then)e(wrote)h(the)g(parsing)f
-(routines)g(used)g(b)m(y)g(CFITSIO)0 3784 y(based)i(on)f(Lammers')h
+(routines)g(used)g(b)m(y)g(CFITSIO)0 2965 y(based)i(on)f(Lammers')h
 (design,)g(com)m(bined)g(with)g(other)g(tec)m(hniques)g(suc)m(h)g(as)g
-(the)g(CFITSIO)f(iterator)i(routine)0 3897 y(to)g(further)e(enhance)h
+(the)g(CFITSIO)f(iterator)i(routine)0 3078 y(to)g(further)e(enhance)h
 (the)h(data)g(pro)s(cessing)f(throughput.)42 b(This)31
 b(e\013ort)h(also)g(b)s(ene\014ted)e(from)h(a)h(m)m(uc)m(h)f(earlier)0
-4010 y(lexical)25 b(parsing)f(routine)f(that)h(w)m(as)g(dev)m(elop)s
+3191 y(lexical)25 b(parsing)f(routine)f(that)h(w)m(as)g(dev)m(elop)s
 (ed)g(b)m(y)g(Ken)m(t)g(Blac)m(kburn)f(\(NASA/GSF)m(C\).)i(More)g
-(recen)m(tly)-8 b(,)27 b(Craig)0 4123 y(Markw)m(ardt)i(\(NASA/GSF)m
+(recen)m(tly)-8 b(,)27 b(Craig)0 3304 y(Markw)m(ardt)i(\(NASA/GSF)m
 (C\))g(implemen)m(ted)g(additional)g(functions)f(\(median,)h(a)m(v)m
-(erage,)j(stddev\))c(and)g(other)0 4236 y(enhancemen)m(ts)j(to)g(the)g
-(lexical)h(parser.)0 4396 y(The)40 b(CFITSIO)g(iterator)i(function)e
+(erage,)j(stddev\))c(and)g(other)0 3416 y(enhancemen)m(ts)j(to)g(the)g
+(lexical)h(parser.)0 3577 y(The)40 b(CFITSIO)g(iterator)i(function)e
 (is)h(lo)s(osely)h(based)f(on)f(similar)i(ideas)f(dev)m(elop)s(ed)g
-(for)g(the)g(XMM)g(Data)0 4509 y(Access)31 b(La)m(y)m(er.)0
-4669 y(P)m(eter)25 b(Wilson)g(\(RSTX,)f(NASA/GSF)m(C\))h(wrote)g(the)f
+(for)g(the)g(XMM)g(Data)0 3690 y(Access)31 b(La)m(y)m(er.)0
+3850 y(P)m(eter)25 b(Wilson)g(\(RSTX,)f(NASA/GSF)m(C\))h(wrote)g(the)f
 (complete)i(set)e(of)h(F)-8 b(ortran-callable)27 b(wrapp)s(ers)22
-b(for)i(all)h(the)0 4782 y(CFITSIO)k(routines,)h(whic)m(h)g(in)g(turn)g
+b(for)i(all)h(the)0 3963 y(CFITSIO)k(routines,)h(whic)m(h)g(in)g(turn)g
 (rely)g(on)h(the)f(CF)m(OR)-8 b(TRAN)31 b(macro)g(dev)m(elop)s(ed)g(b)m
-(y)f(Burkhard)f(Buro)m(w.)0 4942 y(The)h(syn)m(tax)i(used)e(b)m(y)h
+(y)f(Burkhard)f(Buro)m(w.)0 4123 y(The)h(syn)m(tax)i(used)e(b)m(y)h
 (CFITSIO)f(for)g(\014ltering)i(or)f(binning)e(input)h(FITS)h(\014les)g
-(is)g(based)f(on)h(ideas)h(dev)m(elop)s(ed)0 5055 y(for)41
+(is)g(based)f(on)h(ideas)h(dev)m(elop)s(ed)0 4236 y(for)41
 b(the)g(AXAF)h(Science)g(Cen)m(ter)g(Data)h(Mo)s(del)e(b)m(y)g
 (Jonathan)g(McDo)m(w)m(ell,)47 b(An)m(tonella)c(F)-8
-b(ruscione,)45 b(Aneta)0 5168 y(Siemigino)m(wsk)-5 b(a)27
+b(ruscione,)45 b(Aneta)0 4349 y(Siemigino)m(wsk)-5 b(a)27
 b(and)e(Bill)i(Jo)m(y)m(e.)41 b(See)26 b(h)m
 (ttp://heasarc.gsfc.nasa.go)m(v/do)s(cs/journal/axa)q(f7.h)m(t)q(ml)32
-b(for)25 b(further)0 5281 y(description)30 b(of)h(the)g(AXAF)g(Data)h
-(Mo)s(del.)0 5441 y(The)j(\014le)g(decompression)g(co)s(de)g(w)m(ere)h
+b(for)25 b(further)0 4461 y(description)30 b(of)h(the)g(AXAF)g(Data)h
+(Mo)s(del.)0 4622 y(The)j(\014le)g(decompression)g(co)s(de)g(w)m(ere)h
 (tak)m(en)g(directly)g(from)e(the)i(gzip)f(\(GNU)h(zip\))g(program)f
-(dev)m(elop)s(ed)g(b)m(y)0 5554 y(Jean-loup)30 b(Gailly)i(and)e
-(others.)0 5714 y(Doug)h(Mink,)g(SA)m(O,)f(pro)m(vided)g(the)h
+(dev)m(elop)s(ed)g(b)m(y)0 4735 y(Jean-loup)30 b(Gailly)i(and)e
+(others.)0 4895 y(Doug)h(Mink,)g(SA)m(O,)f(pro)m(vided)g(the)h
 (routines)f(for)g(con)m(v)m(erting)i(IRAF)f(format)g(images)g(in)m(to)g
-(FITS)f(format.)p eop end
+(FITS)f(format.)0 5055 y(Martin)j(Reinec)m(k)m(e)i(\(Max)f(Planc)m(k)f
+(Institute,)h(Garc)m(hing\)\))g(pro)m(vided)f(the)g(mo)s(di\014cations)
+f(to)i(cfortran.h)e(that)0 5168 y(are)d(necessary)h(to)f(supp)s(ort)e
+(64-bit)k(in)m(teger)f(v)-5 b(alues)29 b(when)f(calling)i(C)f(routines)
+g(from)f(fortran)h(programs.)39 b(The)0 5281 y(cfortran.h)30
+b(macros)h(w)m(ere)g(originally)h(dev)m(elop)s(ed)e(b)m(y)h(Burkhard)e
+(Buro)m(w)h(\(CERN\).)0 5441 y(Julian)f(T)-8 b(a)m(ylor)31
+b(\(ESO,)e(Garc)m(hing\))i(pro)m(vided)e(the)g(fast)h(b)m(yte-sw)m
+(apping)g(algorithms)h(that)f(use)f(the)h(SSE2)f(and)0
+5554 y(SSSE3)g(mac)m(hine)i(instructions)f(a)m(v)-5 b(ailable)33
+b(on)d(x86)p 1784 5554 28 4 v 34 w(64)h(CPUs.)0 5714
+y(In)c(addition,)i(man)m(y)f(other)g(p)s(eople)g(ha)m(v)m(e)h(made)f(v)
+-5 b(aluable)29 b(con)m(tributions)f(to)h(the)f(dev)m(elopmen)m(t)h(of)
+f(CFITSIO.)p eop end
 %%Page: 11 17
-TeXDict begin 11 16 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.11) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(2.7.)72
-b(A)m(CKNO)m(WLEDGMENTS)2577 b Fj(11)0 555 y(Martin)33
-b(Reinec)m(k)m(e)i(\(Max)f(Planc)m(k)f(Institute,)h(Garc)m(hing\)\))g
-(pro)m(vided)f(the)g(mo)s(di\014cations)f(to)i(cfortran.h)e(that)0
-668 y(are)d(necessary)h(to)f(supp)s(ort)e(64-bit)k(in)m(teger)f(v)-5
-b(alues)29 b(when)f(calling)i(C)f(routines)g(from)f(fortran)h
-(programs.)39 b(The)0 781 y(cfortran.h)30 b(macros)h(w)m(ere)g
-(originally)h(dev)m(elop)s(ed)e(b)m(y)h(Burkhard)e(Buro)m(w)h
-(\(CERN\).)0 941 y(Julian)f(T)-8 b(a)m(ylor)31 b(\(ESO,)e(Garc)m
-(hing\))i(pro)m(vided)e(the)g(fast)h(b)m(yte-sw)m(apping)g(algorithms)h
-(that)f(use)f(the)h(SSE2)f(and)0 1054 y(SSSE3)g(mac)m(hine)i
-(instructions)f(a)m(v)-5 b(ailable)33 b(on)d(x86)p 1784
-1054 28 4 v 34 w(64)h(CPUs.)0 1214 y(In)c(addition,)i(man)m(y)f(other)g
-(p)s(eople)g(ha)m(v)m(e)h(made)f(v)-5 b(aluable)29 b(con)m(tributions)f
-(to)h(the)f(dev)m(elopmen)m(t)h(of)f(CFITSIO.)0 1327
-y(These)i(include)g(\(with)h(ap)s(ologies)h(to)f(others)f(that)h(ma)m
-(y)g(ha)m(v)m(e)h(inadv)m(erten)m(tly)g(b)s(een)d(omitted\):)0
-1487 y(Stev)m(e)g(Allen,)g(Carl)f(Ak)m(erlof,)h(Keith)f(Arnaud,)g
-(Morten)g(Krabb)s(e)e(Barfo)s(ed,)j(Ken)m(t)f(Blac)m(kburn,)h(G)f(Bo)s
-(dammer,)0 1600 y(Romk)m(e)h(Bon)m(tek)m(o)s(e,)i(Lucio)d(Chiapp)s
-(etti,)g(Keith)g(Costorf,)g(Robin)g(Corb)s(et,)g(John)e(Da)m(vis,)k
-(Ric)m(hard)e(Fink,)h(Ning)0 1713 y(Gan,)g(Emily)e(Greene,)i(Jo)s(e)f
-(Harrington,)h(Cheng)e(Ho,)i(Phil)e(Ho)s(dge,)i(Jim)f(Ingham,)g(Y)-8
-b(oshitak)j(a)29 b(Ishisaki,)f(Diab)0 1826 y(Jerius,)j(Mark)h(Levine,)g
-(T)-8 b(o)s(dd)30 b(Karak)-5 b(askian,)32 b(Edw)m(ard)f(King,)g(Scott)i
-(Ko)s(c)m(h,)e(Claire)h(Larkin,)f(Rob)h(Managan,)0 1939
-y(Eric)38 b(Mandel,)i(John)d(Matto)m(x,)43 b(Carsten)37
+TeXDict begin 11 16 bop 0 299 a Fh(2.7.)72 b(A)m(CKNO)m(WLEDGMENTS)2577
+b Fj(11)0 555 y(These)30 b(include)g(\(with)h(ap)s(ologies)h(to)f
+(others)f(that)h(ma)m(y)g(ha)m(v)m(e)h(inadv)m(erten)m(tly)g(b)s(een)d
+(omitted\):)0 715 y(Stev)m(e)g(Allen,)g(Carl)f(Ak)m(erlof,)h(Keith)f
+(Arnaud,)g(Morten)g(Krabb)s(e)e(Barfo)s(ed,)j(Ken)m(t)f(Blac)m(kburn,)h
+(G)f(Bo)s(dammer,)0 828 y(Romk)m(e)h(Bon)m(tek)m(o)s(e,)i(Lucio)d
+(Chiapp)s(etti,)g(Keith)g(Costorf,)g(Robin)g(Corb)s(et,)g(John)e(Da)m
+(vis,)k(Ric)m(hard)e(Fink,)h(Ning)0 941 y(Gan,)g(Emily)e(Greene,)i(Jo)s
+(e)f(Harrington,)h(Cheng)e(Ho,)i(Phil)e(Ho)s(dge,)i(Jim)f(Ingham,)g(Y)
+-8 b(oshitak)j(a)29 b(Ishisaki,)f(Diab)0 1054 y(Jerius,)j(Mark)h
+(Levine,)g(T)-8 b(o)s(dd)30 b(Karak)-5 b(askian,)32 b(Edw)m(ard)f
+(King,)g(Scott)i(Ko)s(c)m(h,)e(Claire)h(Larkin,)f(Rob)h(Managan,)0
+1167 y(Eric)38 b(Mandel,)i(John)d(Matto)m(x,)43 b(Carsten)37
 b(Mey)m(er,)42 b(Emi)37 b(Miy)m(ata,)43 b(Stefan)38 b(Mo)s(c)m(hnac)m
-(ki,)j(Mik)m(e)f(Noble,)g(Oliv)m(er)0 2052 y(Ob)s(erdorf,)c(Cliv)m(e)i
+(ki,)j(Mik)m(e)f(Noble,)g(Oliv)m(er)0 1280 y(Ob)s(erdorf,)c(Cliv)m(e)i
 (P)m(age,)i(Arvind)35 b(P)m(armar,)j(Je\013)f(P)m(edelt)m(y)-8
 b(,)40 b(Tim)c(P)m(earson,)j(Maren)e(Purv)m(es,)h(Scott)f(Randall,)0
-2165 y(Chris)d(Rogers,)j(Arnold)e(Rots,)i(Barry)f(Sc)m(hlesinger,)h
+1393 y(Chris)d(Rogers,)j(Arnold)e(Rots,)i(Barry)f(Sc)m(hlesinger,)h
 (Robin)e(Stebbins,)g(Andrew)f(Szymk)m(o)m(wiak,)k(Allyn)e(T)-8
-b(en-)0 2278 y(nan)m(t,)31 b(P)m(eter)g(T)-8 b(eub)s(en,)30
+b(en-)0 1506 y(nan)m(t,)31 b(P)m(eter)g(T)-8 b(eub)s(en,)30
 b(James)g(Theiler,)h(Doug)g(T)-8 b(o)s(dy)g(,)31 b(Shiro)e(Ueno,)j
 (Stev)m(e)f(W)-8 b(alton,)33 b(Arc)m(hie)e(W)-8 b(arno)s(c)m(k,)32
-b(Alan)0 2391 y(W)-8 b(atson,)32 b(Dan)f(Whipple,)f(Wim)h(Wimmers,)g(P)
+b(Alan)0 1619 y(W)-8 b(atson,)32 b(Dan)f(Whipple,)f(Wim)h(Wimmers,)g(P)
 m(eter)g(Y)-8 b(oung,)31 b(Jianjun)e(Xu,)h(and)g(Nelson)h(Zarate.)p
 eop end
 %%Page: 12 18
-TeXDict begin 12 17 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.12) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(12)1851
-b Fh(CHAPTER)30 b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)p
-eop end
+TeXDict begin 12 17 bop 0 299 a Fj(12)1851 b Fh(CHAPTER)30
+b(2.)111 b(CREA)-8 b(TING)31 b(FITSIO/CFITSIO)p eop end
 %%Page: 13 19
-TeXDict begin 13 18 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.13) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0
-464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.3) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(3)0
+TeXDict begin 13 18 bop 0 1225 a Fg(Chapter)65 b(3)0
 1687 y Fm(A)78 b(FITS)f(Primer)0 2180 y Fj(This)23 b(section)j(giv)m
 (es)f(a)g(brief)e(o)m(v)m(erview)j(of)e(the)h(structure)e(of)i(FITS)e
 (\014les.)38 b(Users)24 b(should)g(refer)f(to)i(the)g(do)s(cumen-)0
 2293 y(tation)33 b(a)m(v)-5 b(ailable)33 b(from)e(the)g(FITS)g(Supp)s
 (ort)e(O\016ce,)j(as)f(describ)s(ed)f(in)h(the)h(in)m(tro)s(duction,)f
 (for)g(more)h(detailed)0 2406 y(information)f(on)f(FITS)g(formats.)0
 2566 y(FITS)37 b(w)m(as)g(\014rst)g(dev)m(elop)s(ed)h(in)f(the)g(late)i
@@ -7334,48 +5808,36 @@
 y(Eac)m(h)i(Header)f(Unit)h(consists)g(of)f(an)m(y)g(n)m(um)m(b)s(er)f
 (of)i(80-c)m(haracter)i(k)m(eyw)m(ord)d(records)g(or)g(`card)h(images')
 g(whic)m(h)0 5332 y(ha)m(v)m(e)f(the)e(general)i(form:)95
 5601 y Ff(KEYNAME)46 b(=)i(value)e(/)i(comment)d(string)95
 5714 y(NULLKEY)h(=)334 b(/)48 b(comment:)d(This)i(keyword)f(has)g(no)i
 (value)1905 5942 y Fj(13)p eop end
 %%Page: 14 20
-TeXDict begin 14 19 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.14) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(14)2398
-b Fh(CHAPTER)30 b(3.)112 b(A)30 b(FITS)g(PRIMER)0 555
-y Fj(The)35 b(k)m(eyw)m(ord)i(names)f(ma)m(y)g(b)s(e)g(up)f(to)h(8)h(c)
-m(haracters)g(long)g(and)e(can)h(only)h(con)m(tain)g(upp)s(ercase)e
-(letters,)k(the)0 668 y(digits)25 b(0-9,)i(the)e(h)m(yphen,)g(and)f
-(the)h(underscore)e(c)m(haracter.)41 b(The)24 b(k)m(eyw)m(ord)h(name)g
-(is)f(\(usually\))h(follo)m(w)m(ed)i(b)m(y)d(an)0 781
-y(equals)29 b(sign)g(and)f(a)g(space)i(c)m(haracter)g(\(=)e(\))h(in)f
-(columns)h(9)g(-)f(10)i(of)f(the)f(record,)h(follo)m(w)m(ed)i(b)m(y)d
-(the)h(v)-5 b(alue)29 b(of)g(the)0 894 y(k)m(eyw)m(ord)34
-b(whic)m(h)g(ma)m(y)g(b)s(e)f(either)h(an)g(in)m(teger,)i(a)e
-(\015oating)g(p)s(oin)m(t)g(n)m(um)m(b)s(er,)g(a)g(c)m(haracter)h
-(string)e(\(enclosed)i(in)0 1007 y(single)28 b(quotes\),)i(or)e(a)g(b)s
-(o)s(olean)g(v)-5 b(alue)28 b(\(the)g(letter)h(T)f(or)f(F\).)i(A)f(k)m
-(eyw)m(ord)g(ma)m(y)h(also)f(ha)m(v)m(e)h(a)g(n)m(ull)e(or)h
-(unde\014ned)0 1120 y(v)-5 b(alue)31 b(if)f(there)h(is)f(no)g(sp)s
-(eci\014ed)g(v)-5 b(alue)31 b(string,)g(as)f(in)g(the)h(second)f
-(example.)0 1280 y(The)c(last)h(k)m(eyw)m(ord)g(in)g(the)f(header)h(is)
-f(alw)m(a)m(ys)i(the)f(`END')g(k)m(eyw)m(ord)g(whic)m(h)g(has)f(no)g(v)
--5 b(alue)27 b(or)g(commen)m(t)g(\014elds.)0 1393 y(There)k(are)g(man)m
-(y)g(rules)g(go)m(v)m(erning)h(the)g(exact)g(format)g(of)f(a)g(k)m(eyw)
-m(ord)h(record)f(\(see)h(the)f(FITS)f(Standard\))h(so)0
+TeXDict begin 14 19 bop 0 299 a Fj(14)2398 b Fh(CHAPTER)30
+b(3.)112 b(A)30 b(FITS)g(PRIMER)0 555 y Fj(The)35 b(k)m(eyw)m(ord)i
+(names)f(ma)m(y)g(b)s(e)g(up)f(to)h(8)h(c)m(haracters)g(long)g(and)e
+(can)h(only)h(con)m(tain)g(upp)s(ercase)e(letters,)k(the)0
+668 y(digits)25 b(0-9,)i(the)e(h)m(yphen,)g(and)f(the)h(underscore)e(c)
+m(haracter.)41 b(The)24 b(k)m(eyw)m(ord)h(name)g(is)f(\(usually\))h
+(follo)m(w)m(ed)i(b)m(y)d(an)0 781 y(equals)29 b(sign)g(and)f(a)g
+(space)i(c)m(haracter)g(\(=)e(\))h(in)f(columns)h(9)g(-)f(10)i(of)f
+(the)f(record,)h(follo)m(w)m(ed)i(b)m(y)d(the)h(v)-5
+b(alue)29 b(of)g(the)0 894 y(k)m(eyw)m(ord)34 b(whic)m(h)g(ma)m(y)g(b)s
+(e)f(either)h(an)g(in)m(teger,)i(a)e(\015oating)g(p)s(oin)m(t)g(n)m(um)
+m(b)s(er,)g(a)g(c)m(haracter)h(string)e(\(enclosed)i(in)0
+1007 y(single)28 b(quotes\),)i(or)e(a)g(b)s(o)s(olean)g(v)-5
+b(alue)28 b(\(the)g(letter)h(T)f(or)f(F\).)i(A)f(k)m(eyw)m(ord)g(ma)m
+(y)h(also)f(ha)m(v)m(e)h(a)g(n)m(ull)e(or)h(unde\014ned)0
+1120 y(v)-5 b(alue)31 b(if)f(there)h(is)f(no)g(sp)s(eci\014ed)g(v)-5
+b(alue)31 b(string,)g(as)f(in)g(the)h(second)f(example.)0
+1280 y(The)c(last)h(k)m(eyw)m(ord)g(in)g(the)f(header)h(is)f(alw)m(a)m
+(ys)i(the)f(`END')g(k)m(eyw)m(ord)g(whic)m(h)g(has)f(no)g(v)-5
+b(alue)27 b(or)g(commen)m(t)g(\014elds.)0 1393 y(There)k(are)g(man)m(y)
+g(rules)g(go)m(v)m(erning)h(the)g(exact)g(format)g(of)f(a)g(k)m(eyw)m
+(ord)h(record)f(\(see)h(the)f(FITS)f(Standard\))h(so)0
 1506 y(it)c(is)g(b)s(etter)g(to)h(rely)f(on)g(standard)f(in)m(terface)j
 (soft)m(w)m(are)f(lik)m(e)g(FITSIO)e(to)i(correctly)g(construct)f(or)g
 (to)h(parse)f(the)0 1619 y(k)m(eyw)m(ord)k(records)f(rather)g(than)g
 (try)h(to)g(deal)g(directly)g(with)f(the)g(ra)m(w)h(FITS)e(formats.)0
 1779 y(Eac)m(h)37 b(Header)g(Unit)f(b)s(egins)g(with)g(a)g(series)h(of)
 f(required)g(k)m(eyw)m(ords)g(whic)m(h)g(dep)s(end)f(on)h(the)g(t)m(yp)
 s(e)h(of)f(HDU.)0 1892 y(These)31 b(required)g(k)m(eyw)m(ords)h(sp)s
@@ -7421,46 +5883,19 @@
 (the)f(column)136 5106 y Fd(\017)46 b Fj(TUNITn)30 b({)g(the)h(ph)m
 (ysical)g(units)f(of)g(the)h(column)f(\(optional\))0
 5341 y(Users)k(should)f(refer)h(to)h(the)f(FITS)g(Supp)s(ort)e(O\016ce)
 i(at)h Ff(http://fits.gsfc.nasa.gov)27 b Fj(for)34 b(further)f(infor-)0
 5454 y(mation)e(ab)s(out)f(the)h(FITS)e(format)i(and)f(related)h(soft)m
 (w)m(are)h(pac)m(k)-5 b(ages.)p eop end
 %%Page: 15 21
-TeXDict begin 15 20 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.15) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0
-464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.4) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(4)0
+TeXDict begin 15 20 bop 0 1225 a Fg(Chapter)65 b(4)0
 1687 y Fm(FITSIO)76 b(Con)-6 b(v)g(en)g(tions)76 b(and)h(Guidelines)0
-2020 y
-SDict begin H.S end
- 0 2020 a 0 2020 a
-SDict begin 13.6 H.A end
- 0 2020 a 0 2020 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.1) cvn /DEST pdfmark
-end
- 0 2020 a 196
-x Fe(4.1)135 b(CFITSIO)44 b(Size)h(Limitations)0 2524
-y Fj(CFITSIO)31 b(places)i(few)g(restrictions)g(on)g(the)f(size)i(of)e
-(FITS)g(\014les)h(that)g(it)g(reads)f(or)h(writes.)47
+2216 y Fe(4.1)135 b(CFITSIO)44 b(Size)h(Limitations)0
+2524 y Fj(CFITSIO)31 b(places)i(few)g(restrictions)g(on)g(the)f(size)i
+(of)e(FITS)g(\014les)h(that)g(it)g(reads)f(or)h(writes.)47
 b(There)32 b(are)h(a)g(few)0 2636 y(limits,)e(ho)m(w)m(ev)m(er,)h(whic)
 m(h)e(ma)m(y)h(a\013ect)h(some)f(extreme)g(cases:)0 2797
 y(1.)43 b(The)31 b(maxim)m(um)g(n)m(um)m(b)s(er)f(of)h(FITS)f(\014les)h
 (that)h(ma)m(y)g(b)s(e)e(sim)m(ultaneously)i(op)s(ened)f(b)m(y)g
 (CFITSIO)e(is)i(set)h(b)m(y)0 2910 y(NMAXFILES,)e(as)f(de\014ned)f(in)h
 (\014tsio2.h.)41 b(The)29 b(curren)m(t)g(default)g(v)-5
 b(alue)30 b(is)f(1000,)j(but)c(this)h(ma)m(y)h(b)s(e)f(increased)0
@@ -7519,49 +5954,29 @@
 (\(NAXIS1)g(k)m(eyw)m(ord\),)g(the)f(n)m(um)m(b)s(er)f(of)h(ro)m(ws)g
 (in)f(a)h(table)h(\(NAXIS2)0 5601 y(k)m(eyw)m(ord\),)c(and)d(the)h
 (total)i(size)f(of)f(the)g(v)-5 b(ariable-length)28 b(arra)m(y)e(heap)g
 (in)g(binary)f(tables)i(\(PCOUNT)e(k)m(eyw)m(ord\))0
 5714 y(m)m(ust)30 b(b)s(e)g(less)h(than)f(this)g(limit.)1905
 5942 y(15)p eop end
 %%Page: 16 22
-TeXDict begin 16 21 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.16) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(16)1277
-b Fh(CHAPTER)29 b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
+TeXDict begin 16 21 bop 0 299 a Fj(16)1277 b Fh(CHAPTER)29
+b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
 555 y Fj(Curren)m(tly)-8 b(,)31 b(supp)s(ort)e(for)i(large)h(\014les)f
 (within)f(CFITSIO)f(has)i(b)s(een)f(tested)i(on)f(the)g(Lin)m(ux,)g
 (Solaris,)g(and)f(IBM)0 668 y(AIX)g(op)s(erating)h(systems.)0
-954 y
-SDict begin H.S end
- 0 954 a 0 954 a
-SDict begin 13.6 H.A end
- 0 954 a 0 954 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.2) cvn /DEST pdfmark
-end
- 0 954 a 179 x Fe(4.2)135
-b(Multiple)46 b(Access)e(to)i(the)f(Same)g(FITS)f(File)0
-1409 y Fj(CFITSIO)35 b(supp)s(orts)g(sim)m(ultaneous)i(read)f(and)g
-(write)h(access)g(to)h(m)m(ultiple)f(HDUs)g(in)f(the)h(same)g(FITS)f
-(\014le.)0 1522 y(Th)m(us,)43 b(one)e(can)h(op)s(en)e(the)h(same)h
-(FITS)e(\014le)h(t)m(wice)i(within)d(a)i(single)f(program)g(and)g(mo)m
-(v)m(e)h(to)g(2)f(di\013eren)m(t)0 1635 y(HDUs)30 b(in)f(the)h(\014le,)
-g(and)f(then)g(read)h(and)e(write)i(data)g(or)g(k)m(eyw)m(ords)g(to)g
-(the)g(2)f(extensions)i(just)d(as)i(if)g(one)f(w)m(ere)0
-1748 y(accessing)f(2)f(completely)h(separate)f(FITS)f(\014les.)39
-b(Since)27 b(in)f(general)h(it)g(is)g(not)g(p)s(ossible)f(to)h(ph)m
+1133 y Fe(4.2)135 b(Multiple)46 b(Access)e(to)i(the)f(Same)g(FITS)f
+(File)0 1409 y Fj(CFITSIO)35 b(supp)s(orts)g(sim)m(ultaneous)i(read)f
+(and)g(write)h(access)g(to)h(m)m(ultiple)f(HDUs)g(in)f(the)h(same)g
+(FITS)f(\014le.)0 1522 y(Th)m(us,)43 b(one)e(can)h(op)s(en)e(the)h
+(same)h(FITS)e(\014le)h(t)m(wice)i(within)d(a)i(single)f(program)g(and)
+g(mo)m(v)m(e)h(to)g(2)f(di\013eren)m(t)0 1635 y(HDUs)30
+b(in)f(the)h(\014le,)g(and)f(then)g(read)h(and)e(write)i(data)g(or)g(k)
+m(eyw)m(ords)g(to)g(the)g(2)f(extensions)i(just)d(as)i(if)g(one)f(w)m
+(ere)0 1748 y(accessing)f(2)f(completely)h(separate)f(FITS)f(\014les.)
+39 b(Since)27 b(in)f(general)h(it)g(is)g(not)g(p)s(ossible)f(to)h(ph)m
 (ysically)g(op)s(en)f(the)0 1861 y(same)36 b(\014le)g(t)m(wice)h(and)e
 (then)g(exp)s(ect)h(to)g(b)s(e)f(able)h(to)h(sim)m(ultaneously)f(\(or)g
 (in)f(alternating)i(succession\))g(write)0 1974 y(to)e(2)f(di\013eren)m
 (t)h(lo)s(cations)h(in)d(the)i(\014le,)g(CFITSIO)e(recognizes)j(when)d
 (the)h(\014le)g(to)h(b)s(e)f(op)s(ened)f(\(in)h(the)h(call)g(to)0
 2087 y(\014ts)p 127 2087 28 4 v 32 w(op)s(en)p 349 2087
 V 33 w(\014le\))29 b(has)f(already)h(b)s(een)f(op)s(ened)g(and)g
@@ -7585,107 +6000,71 @@
 (some)h(e\016ciency)g(p)s(enalties)g(in)f(doing)h(this)f(ho)m(w)m(ev)m
 (er,)0 2990 y(since)j(CFITSIO)f(has)h(to)h(\015ush)d(all)j(the)f(in)m
 (ternal)h(bu\013ers)e(related)i(to)g(one)f(\014le)g(b)s(efore)g(switc)m
 (hing)g(to)h(the)f(other,)0 3103 y(so)i(it)h(w)m(ould)f(still)h(b)s(e)f
 (pruden)m(t)f(to)i(minimize)g(the)f(n)m(um)m(b)s(er)f(of)i(times)f(one)
 h(switc)m(hes)g(bac)m(k)g(and)e(forth)h(b)s(et)m(w)m(een)0
 3216 y(doing)g(I/O)h(to)g(di\013eren)m(t)g(HDUs)g(in)f(the)g(same)h
-(\014le.)0 3506 y
-SDict begin H.S end
- 0 3506 a 0 3506 a
-SDict begin 13.6 H.A end
- 0 3506 a 0 3506 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.3) cvn /DEST pdfmark
-end
-
-0 3506 a 174 x Fe(4.3)135 b(Curren)l(t)46 b(Header)f(Data)h(Unit)g
+(\014le.)0 3680 y Fe(4.3)135 b(Curren)l(t)46 b(Header)f(Data)h(Unit)g
 (\(CHDU\))0 3957 y Fj(In)32 b(general,)j(a)f(FITS)e(\014le)i(can)f(con)
 m(tain)h(m)m(ultiple)g(Header)g(Data)h(Units,)f(also)g(called)g
 (extensions.)49 b(CFITSIO)0 4070 y(only)38 b(op)s(erates)h(within)f
 (one)g(HDU)h(at)g(an)m(y)g(giv)m(en)g(time,)i(and)d(the)g(curren)m(tly)
 g(selected)i(HDU)f(is)f(called)i(the)0 4183 y(Curren)m(t)f(Header)h
 (Data)h(Unit)f(\(CHDU\).)h(When)f(a)g(FITS)f(\014le)h(is)f(\014rst)g
 (created)i(or)f(op)s(ened)f(the)h(CHDU)g(is)0 4295 y(automatically)28
 b(de\014ned)23 b(to)j(b)s(e)e(the)h(\014rst)f(HDU)i(\(i.e.,)h(the)e
 (primary)f(arra)m(y\).)40 b(CFITSIO)23 b(routines)i(are)g(pro)m(vided)0
 4408 y(to)36 b(mo)m(v)m(e)h(to)g(and)e(op)s(en)g(an)m(y)h(other)g
 (existing)g(HDU)h(within)e(the)h(FITS)f(\014le)g(or)h(to)g(app)s(end)e
 (or)i(insert)f(a)h(new)0 4521 y(HDU)31 b(in)f(the)h(FITS)e(\014le)i
-(whic)m(h)f(then)g(b)s(ecomes)h(the)f(CHDU.)0 4789 y
-SDict begin H.S end
-
-0 4789 a 0 4789 a
-SDict begin 13.6 H.A end
- 0 4789 a 0 4789 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.4) cvn /DEST pdfmark
-end
- 0 4789 a 197 x Fe(4.4)135
-b(Subroutine)45 b(Names)0 5262 y Fj(All)26 b(FITSIO)f(subroutine)g
-(names)h(b)s(egin)f(with)h(the)g(letters)h('ft')f(to)h(distinguish)e
-(them)h(from)f(other)h(subroutines)0 5375 y(and)34 b(are)h(5)g(or)f(6)h
-(c)m(haracters)h(long.)54 b(Users)34 b(should)g(not)g(name)h(their)g(o)
-m(wn)f(subroutines)f(b)s(eginning)h(with)g('ft')0 5488
-y(to)e(a)m(v)m(oid)i(con\015icts.)45 b(\(The)32 b(SPP)f(in)m(terface)i
-(routines)e(all)i(b)s(egin)e(with)h('fs'\).)45 b(Subroutines)30
-b(whic)m(h)h(read)h(or)g(get)0 5601 y(information)e(from)g(the)h(FITS)e
-(\014le)h(ha)m(v)m(e)i(names)e(b)s(eginning)f(with)h('ftg...'.)43
-b(Subroutines)28 b(whic)m(h)i(write)g(or)h(put)0 5714
-y(information)g(in)m(to)g(the)g(FITS)e(\014le)i(ha)m(v)m(e)g(names)g(b)
-s(eginning)e(with)h('ftp...'.)p eop end
+(whic)m(h)f(then)g(b)s(ecomes)h(the)f(CHDU.)0 4986 y
+Fe(4.4)135 b(Subroutine)45 b(Names)0 5262 y Fj(All)26
+b(FITSIO)f(subroutine)g(names)h(b)s(egin)f(with)h(the)g(letters)h('ft')
+f(to)h(distinguish)e(them)h(from)f(other)h(subroutines)0
+5375 y(and)34 b(are)h(5)g(or)f(6)h(c)m(haracters)h(long.)54
+b(Users)34 b(should)g(not)g(name)h(their)g(o)m(wn)f(subroutines)f(b)s
+(eginning)h(with)g('ft')0 5488 y(to)e(a)m(v)m(oid)i(con\015icts.)45
+b(\(The)32 b(SPP)f(in)m(terface)i(routines)e(all)i(b)s(egin)e(with)h
+('fs'\).)45 b(Subroutines)30 b(whic)m(h)h(read)h(or)g(get)0
+5601 y(information)e(from)g(the)h(FITS)e(\014le)h(ha)m(v)m(e)i(names)e
+(b)s(eginning)f(with)h('ftg...'.)43 b(Subroutines)28
+b(whic)m(h)i(write)g(or)h(put)0 5714 y(information)g(in)m(to)g(the)g
+(FITS)e(\014le)i(ha)m(v)m(e)g(names)g(b)s(eginning)e(with)h('ftp...'.)p
+eop end
 %%Page: 17 23
-TeXDict begin 17 22 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.17) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(4.5.)72
-b(SUBR)m(OUTINE)30 b(F)-10 b(AMILIES)30 b(AND)h(D)m(A)-8
-b(T)g(A)g(TYPES)1697 b Fj(17)0 464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
-
-0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.5) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fe(4.5)135 b(Subroutine)45
-b(F)-11 b(amilies)46 b(and)f(Datat)l(yp)t(es)0 805 y
-Fj(Man)m(y)h(of)g(the)g(subroutines)e(come)j(in)e(families)h(whic)m(h)g
-(di\013er)f(only)h(in)f(the)h(datat)m(yp)s(e)g(of)g(the)f(asso)s
-(ciated)0 918 y(parameter\(s\))34 b(.)47 b(The)32 b(datat)m(yp)s(e)i
-(of)f(these)g(subroutines)e(is)i(indicated)g(b)m(y)g(the)g(last)g
-(letter)h(of)f(the)g(subroutine)0 1031 y(name)d(\(e.g.,)j('j')d(in)g
-('ftpkyj'\))h(as)f(follo)m(ws:)382 1284 y Ff(x)47 b(-)h(bit)382
-1397 y(b)f(-)h(character*1)c(\(unsigned)i(byte\))382
-1510 y(i)h(-)h(short)e(integer)g(\(I*2\))382 1623 y(j)h(-)h(integer)e
-(\(I*4,)g(32-bit)g(integer\))382 1735 y(k)h(-)h(long)e(long)h(integer)f
-(\(I*8,)g(64-bit)g(integer\))382 1848 y(e)h(-)h(real)e(exponential)f
-(floating)h(point)g(\(R*4\))382 1961 y(f)h(-)h(real)e(fixed-format)f
-(floating)g(point)i(\(R*4\))382 2074 y(d)g(-)h(double)e(precision)f
-(real)i(floating-point)d(\(R*8\))382 2187 y(g)j(-)h(double)e(precision)
-f(fixed-format)g(floating)g(point)h(\(R*8\))382 2300
-y(c)h(-)h(complex)e(reals)g(\(pairs)g(of)h(R*4)g(values\))382
-2413 y(m)g(-)h(double)e(precision)f(complex)h(\(pairs)g(of)h(R*8)g
-(values\))382 2526 y(l)g(-)h(logical)e(\(L*4\))382 2639
-y(s)h(-)h(character)d(string)0 2891 y Fj(When)23 b(dealing)h(with)f
-(the)g(FITS)g(b)m(yte)g(datat)m(yp)s(e,)j(it)e(is)f(imp)s(ortan)m(t)h
-(to)f(remem)m(b)s(er)g(that)h(the)f(ra)m(w)g(v)-5 b(alues)24
-b(\(b)s(efore)0 3004 y(an)m(y)h(scaling)g(b)m(y)f(the)h(BSCALE)e(and)h
-(BZER)m(O,)g(or)h(TSCALn)d(and)i(TZER)m(On)f(k)m(eyw)m(ord)i(v)-5
-b(alues\))25 b(in)f(b)m(yte)h(arra)m(ys)0 3117 y(\(BITPIX)37
-b(=)f(8\))h(or)f(b)m(yte)i(columns)e(\(TF)m(ORMn)h(=)f('B'\))h(are)g
-(in)m(terpreted)g(as)g(unsigned)e(b)m(ytes)i(with)g(v)-5
-b(alues)0 3230 y(ranging)40 b(from)f(0)i(to)f(255.)71
+TeXDict begin 17 22 bop 0 299 a Fh(4.5.)72 b(SUBR)m(OUTINE)30
+b(F)-10 b(AMILIES)30 b(AND)h(D)m(A)-8 b(T)g(A)g(TYPES)1697
+b Fj(17)0 555 y Fe(4.5)135 b(Subroutine)45 b(F)-11 b(amilies)46
+b(and)f(Datat)l(yp)t(es)0 805 y Fj(Man)m(y)h(of)g(the)g(subroutines)e
+(come)j(in)e(families)h(whic)m(h)g(di\013er)f(only)h(in)f(the)h(datat)m
+(yp)s(e)g(of)g(the)f(asso)s(ciated)0 918 y(parameter\(s\))34
+b(.)47 b(The)32 b(datat)m(yp)s(e)i(of)f(these)g(subroutines)e(is)i
+(indicated)g(b)m(y)g(the)g(last)g(letter)h(of)f(the)g(subroutine)0
+1031 y(name)d(\(e.g.,)j('j')d(in)g('ftpkyj'\))h(as)f(follo)m(ws:)382
+1284 y Ff(x)47 b(-)h(bit)382 1397 y(b)f(-)h(character*1)c(\(unsigned)i
+(byte\))382 1510 y(i)h(-)h(short)e(integer)g(\(I*2\))382
+1623 y(j)h(-)h(integer)e(\(I*4,)g(32-bit)g(integer\))382
+1735 y(k)h(-)h(long)e(long)h(integer)f(\(I*8,)g(64-bit)g(integer\))382
+1848 y(e)h(-)h(real)e(exponential)f(floating)h(point)g(\(R*4\))382
+1961 y(f)h(-)h(real)e(fixed-format)f(floating)g(point)i(\(R*4\))382
+2074 y(d)g(-)h(double)e(precision)f(real)i(floating-point)d(\(R*8\))382
+2187 y(g)j(-)h(double)e(precision)f(fixed-format)g(floating)g(point)h
+(\(R*8\))382 2300 y(c)h(-)h(complex)e(reals)g(\(pairs)g(of)h(R*4)g
+(values\))382 2413 y(m)g(-)h(double)e(precision)f(complex)h(\(pairs)g
+(of)h(R*8)g(values\))382 2526 y(l)g(-)h(logical)e(\(L*4\))382
+2639 y(s)h(-)h(character)d(string)0 2891 y Fj(When)23
+b(dealing)h(with)f(the)g(FITS)g(b)m(yte)g(datat)m(yp)s(e,)j(it)e(is)f
+(imp)s(ortan)m(t)h(to)f(remem)m(b)s(er)g(that)h(the)f(ra)m(w)g(v)-5
+b(alues)24 b(\(b)s(efore)0 3004 y(an)m(y)h(scaling)g(b)m(y)f(the)h
+(BSCALE)e(and)h(BZER)m(O,)g(or)h(TSCALn)d(and)i(TZER)m(On)f(k)m(eyw)m
+(ord)i(v)-5 b(alues\))25 b(in)f(b)m(yte)h(arra)m(ys)0
+3117 y(\(BITPIX)37 b(=)f(8\))h(or)f(b)m(yte)i(columns)e(\(TF)m(ORMn)h
+(=)f('B'\))h(are)g(in)m(terpreted)g(as)g(unsigned)e(b)m(ytes)i(with)g
+(v)-5 b(alues)0 3230 y(ranging)40 b(from)f(0)i(to)f(255.)71
 b(Some)40 b(F)-8 b(ortran)40 b(compilers)h(supp)s(ort)d(a)i
 (non-standard)f(b)m(yte)h(datat)m(yp)s(e)h(suc)m(h)f(as)0
 3343 y(INTEGER*1,)34 b(LOGICAL*1,)g(or)f(BYTE,)g(whic)m(h)f(can)h
 (sometimes)h(b)s(e)e(used)g(instead)h(of)g(CHARA)m(CTER*1)0
 3456 y(v)-5 b(ariables.)39 b(Man)m(y)23 b(mac)m(hines)g(p)s(ermit)g
 (passing)f(a)h(n)m(umeric)g(datat)m(yp)s(e)g(\(suc)m(h)g(as)g
 (INTEGER*1\))h(to)f(the)g(FITSIO)0 3569 y(subroutines)41
@@ -7709,72 +6088,44 @@
 b(datat)m(yp)s(e.)76 b(If)41 b(a)i(particular)0 4567
 y(F)-8 b(ortran)35 b(compiler)g(do)s(es)f(not)h(directly)g(supp)s(ort)e
 (this)i(datat)m(yp)s(e,)h(then)f(one)f(ma)m(y)h(instead)g(pass)f(an)h
 (arra)m(y)g(of)0 4680 y(pairs)d(of)h(double)f(precision)h(v)-5
 b(alues)32 b(to)i(these)f(subroutines.)45 b(The)33 b(\014rst)e(v)-5
 b(alue)33 b(in)f(eac)m(h)i(pair)e(is)h(the)g(real)g(part,)0
 4792 y(and)d(the)g(second)h(is)f(the)h(imaginary)g(part.)0
-4946 y
-SDict begin H.S end
- 0 4946 a 0 4946 a
-SDict begin 13.6 H.A end
- 0 4946 a 0 4946 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.6) cvn /DEST pdfmark
-end
- 0 4946 a 179
-x Fe(4.6)135 b(Implicit)46 b(Data)g(T)l(yp)t(e)f(Con)l(v)l(ersion)0
-5375 y Fj(The)22 b(FITSIO)g(routines)h(that)h(read)e(and)h(write)g(n)m
-(umerical)g(data)h(can)f(p)s(erform)f(implicit)i(data)f(t)m(yp)s(e)g
+5125 y Fe(4.6)135 b(Implicit)46 b(Data)g(T)l(yp)t(e)f(Con)l(v)l(ersion)
+0 5375 y Fj(The)22 b(FITSIO)g(routines)h(that)h(read)e(and)h(write)g(n)
+m(umerical)g(data)h(can)f(p)s(erform)f(implicit)i(data)f(t)m(yp)s(e)g
 (con)m(v)m(ersion.)0 5488 y(This)i(means)g(that)h(the)g(data)g(t)m(yp)s
 (e)g(of)g(the)g(v)-5 b(ariable)26 b(or)g(arra)m(y)g(in)f(the)h(program)
 f(do)s(es)g(not)h(need)g(to)g(b)s(e)f(the)h(same)0 5601
 y(as)i(the)f(data)h(t)m(yp)s(e)g(of)f(the)h(v)-5 b(alue)28
 b(in)f(the)g(FITS)g(\014le.)40 b(Data)28 b(t)m(yp)s(e)g(con)m(v)m
 (ersion)h(is)e(supp)s(orted)f(for)h(n)m(umerical)h(and)0
 5714 y(string)33 b(data)h(t)m(yp)s(es)f(\(if)h(the)g(string)f(con)m
 (tains)h(a)g(v)-5 b(alid)33 b(n)m(um)m(b)s(er)f(enclosed)i(in)f
 (quotes\))h(when)f(reading)g(a)h(FITS)p eop end
 %%Page: 18 24
-TeXDict begin 18 23 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.18) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(18)1277
-b Fh(CHAPTER)29 b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
+TeXDict begin 18 23 bop 0 299 a Fj(18)1277 b Fh(CHAPTER)29
+b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
 555 y Fj(header)g(k)m(eyw)m(ord)g(v)-5 b(alue)31 b(and)g(for)f(n)m
 (umeric)h(v)-5 b(alues)31 b(when)f(reading)h(or)g(writing)g(v)-5
 b(alues)31 b(in)f(the)h(primary)f(arra)m(y)0 668 y(or)40
 b(a)h(table)h(column.)70 b(CFITSIO)39 b(returns)h(status)g(=)h(NUM)p
 2185 668 28 4 v 33 w(O)m(VERFLO)m(W)g(if)g(the)f(con)m(v)m(erted)i
 (data)f(v)-5 b(alue)0 781 y(exceeds)33 b(the)g(range)g(of)g(the)f
 (output)g(data)i(t)m(yp)s(e.)47 b(Implicit)33 b(data)g(t)m(yp)s(e)g
 (con)m(v)m(ersion)h(is)e(not)h(supp)s(orted)d(within)0
 894 y(binary)g(tables)h(for)f(string,)g(logical,)k(complex,)d(or)f
 (double)g(complex)h(data)g(t)m(yp)s(es.)0 1054 y(In)g(addition,)h(an)m
 (y)f(table)h(column)f(ma)m(y)h(b)s(e)f(read)g(as)h(if)f(it)h(con)m
 (tained)g(string)f(v)-5 b(alues.)44 b(In)31 b(the)g(case)i(of)e(n)m
 (umeric)0 1167 y(columns)f(the)h(returned)e(string)h(will)h(b)s(e)f
 (formatted)h(using)e(the)i(TDISPn)e(displa)m(y)i(format)f(if)h(it)g
-(exists.)0 1317 y
-SDict begin H.S end
- 0 1317 a 0 1317 a
-SDict begin 13.6 H.A end
- 0 1317 a 0 1317 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.7) cvn /DEST pdfmark
-end
-
-0 1317 a 179 x Fe(4.7)135 b(Data)46 b(Scaling)0 1746
+(exists.)0 1496 y Fe(4.7)135 b(Data)46 b(Scaling)0 1746
 y Fj(When)38 b(reading)f(n)m(umerical)i(data)f(v)-5 b(alues)38
 b(in)f(the)h(primary)f(arra)m(y)h(or)g(a)g(table)h(column,)h(the)d(v)-5
 b(alues)38 b(will)h(b)s(e)0 1859 y(scaled)f(automatically)j(b)m(y)c
 (the)h(BSCALE)f(and)g(BZER)m(O)h(\(or)g(TSCALn)d(and)i(TZER)m(On\))g
 (header)g(k)m(eyw)m(ord)0 1972 y(v)-5 b(alues)33 b(if)f(they)g(are)h
 (presen)m(t)g(in)f(the)g(header.)47 b(The)31 b(scaled)j(data)f(that)g
 (is)f(returned)f(to)i(the)g(reading)f(program)0 2085
@@ -7811,66 +6162,45 @@
 (\014le)h(will)0 3949 y(ha)m(v)m(e)430 4179 y Ff(FITS)46
 b(value)h(=)g(\(\(input)f(value\))g(-)h(BZERO\))f(/)i(BSCALE)0
 4410 y Fj(\(a)39 b(corresp)s(onding)d(form)m(ula)i(using)g(TSCALn)e
 (and)h(TZER)m(On)g(is)h(used)f(when)f(writing)i(to)h(table)g
 (columns\).)0 4523 y(Rounding)19 b(to)i(the)g(nearest)g(in)m(teger,)i
 (rather)e(than)f(truncation,)j(is)d(p)s(erformed)f(when)g(writing)h(in)
 m(teger)i(datat)m(yp)s(es)0 4636 y(to)31 b(the)g(FITS)e(\014le.)0
-4768 y
-SDict begin H.S end
- 0 4768 a 0 4768 a
-SDict begin 13.6 H.A end
- 0 4768 a 0 4768 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.8) cvn /DEST pdfmark
-end
- 0 4768 a 197
-x Fe(4.8)135 b(Error)46 b(Status)f(V)-11 b(alues)45 b(and)g(the)g
-(Error)g(Message)h(Stac)l(k)0 5215 y Fj(The)33 b(last)i(parameter)f(in)
-g(nearly)g(ev)m(ery)g(FITSIO)f(subroutine)g(is)h(the)g(error)f(status)h
-(v)-5 b(alue)35 b(whic)m(h)e(is)h(b)s(oth)f(an)0 5328
-y(input)j(and)f(an)i(output)f(parameter.)60 b(A)36 b(returned)f(p)s
-(ositiv)m(e)j(v)-5 b(alue)37 b(for)f(this)h(parameter)g(indicates)g(an)
-f(error)0 5441 y(w)m(as)31 b(detected.)42 b(A)30 b(listing)h(of)g(all)g
-(the)g(FITSIO)e(status)i(co)s(de)f(v)-5 b(alues)31 b(is)f(giv)m(en)i
-(at)f(the)f(end)g(of)h(this)f(do)s(cumen)m(t.)0 5601
-y(The)22 b(FITSIO)g(library)g(uses)h(an)f(`inherited)h(status')g(con)m
-(v)m(en)m(tion)i(for)e(the)g(status)g(parameter)g(whic)m(h)g(means)f
-(that)0 5714 y(if)i(a)h(subroutine)f(is)g(called)i(with)e(a)h(p)s
-(ositiv)m(e)g(input)f(v)-5 b(alue)25 b(of)g(the)f(status)h(parameter,)h
-(then)f(the)f(subroutine)g(will)p eop end
+4965 y Fe(4.8)135 b(Error)46 b(Status)f(V)-11 b(alues)45
+b(and)g(the)g(Error)g(Message)h(Stac)l(k)0 5215 y Fj(The)33
+b(last)i(parameter)f(in)g(nearly)g(ev)m(ery)g(FITSIO)f(subroutine)g(is)
+h(the)g(error)f(status)h(v)-5 b(alue)35 b(whic)m(h)e(is)h(b)s(oth)f(an)
+0 5328 y(input)j(and)f(an)i(output)f(parameter.)60 b(A)36
+b(returned)f(p)s(ositiv)m(e)j(v)-5 b(alue)37 b(for)f(this)h(parameter)g
+(indicates)g(an)f(error)0 5441 y(w)m(as)31 b(detected.)42
+b(A)30 b(listing)h(of)g(all)g(the)g(FITSIO)e(status)i(co)s(de)f(v)-5
+b(alues)31 b(is)f(giv)m(en)i(at)f(the)f(end)g(of)h(this)f(do)s(cumen)m
+(t.)0 5601 y(The)22 b(FITSIO)g(library)g(uses)h(an)f(`inherited)h
+(status')g(con)m(v)m(en)m(tion)i(for)e(the)g(status)g(parameter)g(whic)
+m(h)g(means)f(that)0 5714 y(if)i(a)h(subroutine)f(is)g(called)i(with)e
+(a)h(p)s(ositiv)m(e)g(input)f(v)-5 b(alue)25 b(of)g(the)f(status)h
+(parameter,)h(then)f(the)f(subroutine)g(will)p eop end
 %%Page: 19 25
-TeXDict begin 19 24 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.19) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(4.9.)72
-b(V)-10 b(ARIABLE-LENGTH)31 b(ARRA)-8 b(Y)31 b(F)-10
-b(A)m(CILITY)30 b(IN)h(BINAR)-8 b(Y)31 b(T)-8 b(ABLES)956
-b Fj(19)0 555 y(exit)26 b(immediately)f(without)g(c)m(hanging)h(the)e
-(v)-5 b(alue)25 b(of)g(the)g(status)g(parameter.)39 b(Th)m(us,)25
-b(if)g(one)f(passes)h(the)g(status)0 668 y(v)-5 b(alue)31
-b(returned)e(from)h(eac)m(h)i(FITSIO)d(routine)h(as)h(input)f(to)h(the)
-f(next)h(FITSIO)e(subroutine,)h(then)g(whenev)m(er)0
-781 y(an)39 b(error)g(is)h(detected)g(all)h(further)d(FITSIO)g(pro)s
-(cessing)h(will)h(cease.)69 b(This)39 b(con)m(v)m(en)m(tion)i(can)f
-(simplify)f(the)0 894 y(error)30 b(c)m(hec)m(king)j(in)d(application)i
-(programs)f(b)s(ecause)g(it)g(is)g(not)g(necessary)g(to)g(c)m(hec)m(k)i
-(the)e(v)-5 b(alue)31 b(of)g(the)g(status)0 1007 y(parameter)j(after)g
-(ev)m(ery)g(single)h(FITSIO)d(subroutine)g(call.)52 b(If)33
-b(a)h(program)f(con)m(tains)i(a)f(sequence)g(of)g(sev)m(eral)0
-1120 y(FITSIO)23 b(calls,)j(one)e(can)g(just)g(c)m(hec)m(k)h(the)f
-(status)g(v)-5 b(alue)24 b(after)h(the)f(last)g(call.)40
+TeXDict begin 19 24 bop 0 299 a Fh(4.9.)72 b(V)-10 b(ARIABLE-LENGTH)31
+b(ARRA)-8 b(Y)31 b(F)-10 b(A)m(CILITY)30 b(IN)h(BINAR)-8
+b(Y)31 b(T)-8 b(ABLES)956 b Fj(19)0 555 y(exit)26 b(immediately)f
+(without)g(c)m(hanging)h(the)e(v)-5 b(alue)25 b(of)g(the)g(status)g
+(parameter.)39 b(Th)m(us,)25 b(if)g(one)f(passes)h(the)g(status)0
+668 y(v)-5 b(alue)31 b(returned)e(from)h(eac)m(h)i(FITSIO)d(routine)h
+(as)h(input)f(to)h(the)f(next)h(FITSIO)e(subroutine,)h(then)g(whenev)m
+(er)0 781 y(an)39 b(error)g(is)h(detected)g(all)h(further)d(FITSIO)g
+(pro)s(cessing)h(will)h(cease.)69 b(This)39 b(con)m(v)m(en)m(tion)i
+(can)f(simplify)f(the)0 894 y(error)30 b(c)m(hec)m(king)j(in)d
+(application)i(programs)f(b)s(ecause)g(it)g(is)g(not)g(necessary)g(to)g
+(c)m(hec)m(k)i(the)e(v)-5 b(alue)31 b(of)g(the)g(status)0
+1007 y(parameter)j(after)g(ev)m(ery)g(single)h(FITSIO)d(subroutine)g
+(call.)52 b(If)33 b(a)h(program)f(con)m(tains)i(a)f(sequence)g(of)g
+(sev)m(eral)0 1120 y(FITSIO)23 b(calls,)j(one)e(can)g(just)g(c)m(hec)m
+(k)h(the)f(status)g(v)-5 b(alue)24 b(after)h(the)f(last)g(call.)40
 b(Since)24 b(the)g(returned)e(status)j(v)-5 b(alues)0
 1233 y(are)36 b(generally)h(distinctiv)m(e,)i(it)d(should)f(b)s(e)g(p)s
 (ossible)g(to)h(determine)g(whic)m(h)f(subroutine)g(originally)i
 (returned)0 1346 y(the)31 b(error)f(status.)0 1506 y(FITSIO)i(also)i
 (main)m(tains)f(an)g(in)m(ternal)h(stac)m(k)g(of)f(error)g(messages)h
 (\(80-c)m(haracter)i(maxim)m(um)d(length\))g(whic)m(h)0
 1619 y(in)j(man)m(y)g(cases)h(pro)m(vide)f(a)g(more)g(detailed)i
@@ -7881,23 +6211,15 @@
 b(a)h(program)g(detects)g(a)g(FITSIO)e(error.)44 b(T)-8
 b(o)32 b(do)f(this,)h(call)h(the)f(FTGMSG)g(routine)f(rep)s(eatedly)h
 (to)0 1957 y(get)h(the)g(successiv)m(e)g(messages)h(on)e(the)g(stac)m
 (k.)48 b(When)32 b(the)h(stac)m(k)g(is)g(empt)m(y)f(FTGMSG)h(will)g
 (return)e(a)h(blank)0 2070 y(string.)41 b(Note)31 b(that)g(this)f(is)g
 (a)g(`First)h(In)e({)i(First)f(Out')g(stac)m(k,)i(so)e(the)h(oldest)g
 (error)e(message)j(is)e(returned)f(\014rst)0 2183 y(b)m(y)h(ftgmsg.)0
-2378 y
-SDict begin H.S end
- 0 2378 a 0 2378 a
-SDict begin 13.6 H.A end
- 0 2378 a 0 2378 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.9) cvn /DEST pdfmark
-end
- 0 2378 a 179
-x Fe(4.9)135 b(V)-11 b(ariable-Length)46 b(Arra)l(y)f(F)-11
+2557 y Fe(4.9)135 b(V)-11 b(ariable-Length)46 b(Arra)l(y)f(F)-11
 b(acilit)l(y)46 b(in)f(Binary)g(T)-11 b(ables)0 2815
 y Fj(FITSIO)38 b(pro)m(vides)i(easy-to-use)h(supp)s(ort)d(for)h
 (reading)g(and)g(writing)h(data)g(in)f(v)-5 b(ariable)40
 b(length)g(\014elds)f(of)h(a)0 2928 y(binary)35 b(table.)56
 b(The)35 b(v)-5 b(ariable)36 b(length)f(columns)g(ha)m(v)m(e)i(TF)m
 (ORMn)e(k)m(eyw)m(ord)h(v)-5 b(alues)35 b(of)h(the)f(form)g
 (`1Pt\(len\)')0 3041 y(or)30 b(`1Qt\(len\)')h(where)f(`t')g(is)g(the)g
@@ -7948,28 +6270,16 @@
 5441 y(mo)m(v)m(ed.)0 5601 y(When)40 b(writing)h(to)g(a)g(v)-5
 b(ariable)41 b(length)g(\014eld,)i(the)e(en)m(tire)h(arra)m(y)f(of)f(v)
 -5 b(alues)41 b(for)f(a)h(giv)m(en)h(ro)m(w)f(of)f(the)h(table)0
 5714 y(m)m(ust)36 b(b)s(e)g(written)g(with)g(a)g(single)h(call)h(to)f
 (FTPCLx.)57 b(The)36 b(total)i(length)f(of)f(the)g(arra)m(y)h(is)f
 (calculated)i(from)p eop end
 %%Page: 20 26
-TeXDict begin 20 25 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.20) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(20)1277
-b Fh(CHAPTER)29 b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
+TeXDict begin 20 25 bop 0 299 a Fj(20)1277 b Fh(CHAPTER)29
+b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
 555 y Fj(\(NELEM+FELEM-1\).)44 b(One)30 b(cannot)i(app)s(end)d(more)i
 (elemen)m(ts)h(to)g(an)e(existing)i(\014eld)f(at)g(a)h(later)g(time;)g
 (an)m(y)0 668 y(attempt)j(to)f(do)g(so)g(will)g(simply)f(o)m(v)m
 (erwrite)j(all)e(the)g(data)h(whic)m(h)e(w)m(as)h(previously)g
 (written.)51 b(Note)35 b(also)f(that)0 781 y(the)g(new)g(data)g(will)h
 (b)s(e)e(written)h(to)h(a)f(new)g(area)g(of)g(the)h(heap)e(and)h(the)g
 (heap)g(space)g(used)f(b)m(y)h(the)g(previous)0 894 y(write)j(cannot)h
@@ -8018,31 +6328,23 @@
 (es)g(not)g(automatically)i(con)m(tin)m(ue)f(with)f(the)g(next)g(ro)m
 (w)g(of)g(the)0 3181 y(table)29 b(as)f(o)s(ccurs)g(when)f(reading)h(an)
 g(ordinary)g(\014xed)f(length)h(table)h(\014eld.)40 b(A)m(ttempts)29
 b(to)g(read)f(more)g(than)g(this)0 3294 y(will)k(cause)h(an)e(error)h
 (status)g(to)g(b)s(e)f(returned.)44 b(One)32 b(can)g(determine)g(the)g
 (n)m(um)m(b)s(er)e(of)i(elemen)m(ts)h(in)f(eac)m(h)h(ro)m(w)0
 3407 y(of)e(a)f(v)-5 b(ariable)31 b(column)g(with)f(the)g(FTGDES)h
-(subroutine.)0 3663 y
-SDict begin H.S end
- 0 3663 a 0 3663 a
-SDict begin 13.6 H.A end
- 0 3663 a 0 3663
-a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.10) cvn /DEST pdfmark
-end
- 0 3663 a 196 x Fe(4.10)136 b(Supp)t(ort)44 b(for)h(IEEE)g(Sp)t(ecial)
-h(V)-11 b(alues)0 4133 y Fj(The)26 b(ANSI/IEEE-754)h(\015oating-p)s
-(oin)m(t)h(n)m(um)m(b)s(er)d(standard)g(de\014nes)h(certain)h(sp)s
-(ecial)g(v)-5 b(alues)26 b(that)h(are)g(used)e(to)0 4246
-y(represen)m(t)j(suc)m(h)g(quan)m(tities)h(as)f(Not-a-Num)m(b)s(er)h
-(\(NaN\),)h(denormalized,)f(under\015o)m(w,)e(o)m(v)m(er\015o)m(w,)j
-(and)d(in\014nit)m(y)-8 b(.)0 4359 y(\(See)31 b(the)g(App)s(endix)d(in)
-j(the)f(FITS)g(standard)f(or)i(the)g(FITS)e(User's)i(Guide)f(for)g(a)h
-(list)g(of)g(these)g(v)-5 b(alues\).)41 b(The)0 4472
+(subroutine.)0 3859 y Fe(4.10)136 b(Supp)t(ort)44 b(for)h(IEEE)g(Sp)t
+(ecial)h(V)-11 b(alues)0 4133 y Fj(The)26 b(ANSI/IEEE-754)h
+(\015oating-p)s(oin)m(t)h(n)m(um)m(b)s(er)d(standard)g(de\014nes)h
+(certain)h(sp)s(ecial)g(v)-5 b(alues)26 b(that)h(are)g(used)e(to)0
+4246 y(represen)m(t)j(suc)m(h)g(quan)m(tities)h(as)f(Not-a-Num)m(b)s
+(er)h(\(NaN\),)h(denormalized,)f(under\015o)m(w,)e(o)m(v)m(er\015o)m
+(w,)j(and)d(in\014nit)m(y)-8 b(.)0 4359 y(\(See)31 b(the)g(App)s(endix)
+d(in)j(the)f(FITS)g(standard)f(or)i(the)g(FITS)e(User's)i(Guide)f(for)g
+(a)h(list)g(of)g(these)g(v)-5 b(alues\).)41 b(The)0 4472
 y(FITSIO)26 b(subroutines)h(that)h(read)f(\015oating)i(p)s(oin)m(t)e
 (data)i(in)e(FITS)g(\014les)g(recognize)j(these)e(IEEE)e(sp)s(ecial)j
 (v)-5 b(alues)0 4585 y(and)27 b(b)m(y)h(default)h(in)m(terpret)f(the)h
 (o)m(v)m(er\015o)m(w)g(and)f(in\014nit)m(y)f(v)-5 b(alues)29
 b(as)f(b)s(eing)g(equiv)-5 b(alen)m(t)29 b(to)g(a)g(NaN,)g(and)e(con)m
 (v)m(ert)0 4698 y(the)37 b(under\015o)m(w)e(and)i(denormalized)g(v)-5
 b(alues)37 b(in)m(to)h(zeros.)60 b(In)36 b(some)i(cases)f(programmers)g
@@ -8065,37 +6367,17 @@
 (compression)f(con)m(v)m(en)m(tion)j(that)e(is)f(discussed)g(in)g
 (section)h(5.6;)i(the)e(pixels)f(v)-5 b(alues)34 b(in)f(tile)0
 5601 y(compressed)d(images)i(are)f(represen)m(ted)g(b)m(y)g(scaled)g
 (in)m(tegers,)h(and)e(a)i(reserv)m(ed)e(in)m(teger)j(v)-5
 b(alue)31 b(\(not)g(a)g(NaN\))h(is)0 5714 y(used)e(to)h(represen)m(t)f
 (unde\014ned)e(pixels.)p eop end
 %%Page: 21 27
-TeXDict begin 21 26 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.21) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(4.11.)73
-b(WHEN)31 b(THE)f(FINAL)g(SIZE)f(OF)i(THE)f(FITS)f(HDU)i(IS)f(UNKNO)m
-(WN)978 b Fj(21)0 464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464
-a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.11) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fe(4.11)136 b(When)44 b(the)h(Final)h(Size)f(of)g(the)g
+TeXDict begin 21 26 bop 0 299 a Fh(4.11.)73 b(WHEN)31
+b(THE)f(FINAL)g(SIZE)f(OF)i(THE)f(FITS)f(HDU)i(IS)f(UNKNO)m(WN)978
+b Fj(21)0 555 y Fe(4.11)136 b(When)44 b(the)h(Final)h(Size)f(of)g(the)g
 (FITS)f(HDU)h(is)g(Unkno)l(wn)0 805 y Fj(It)27 b(is)h(not)f(required)f
 (to)i(kno)m(w)f(the)h(total)h(size)f(of)f(a)h(FITS)e(data)i(arra)m(y)g
 (or)f(table)h(b)s(efore)f(b)s(eginning)f(to)i(write)g(the)0
 918 y(data)k(to)f(the)g(FITS)f(\014le.)43 b(In)30 b(the)h(case)h(of)f
 (the)g(primary)f(arra)m(y)h(or)g(an)f(image)j(extension,)e(one)h
 (should)d(initially)0 1031 y(create)i(the)e(arra)m(y)h(with)e(the)i
 (size)g(of)f(the)g(highest)g(dimension)g(\(largest)i(NAXISn)d(k)m(eyw)m
@@ -8146,42 +6428,26 @@
 (hanging)h(the)f(v)-5 b(alue)33 b(directly)-8 b(.)47
 b(This)31 b(is)h(not)h(recommended,)f(ho)m(w)m(ev)m(er,)0
 3384 y(and)j(is)h(only)g(pro)m(vided)g(for)f(bac)m(kw)m(ard)h
 (compatibilit)m(y)i(with)e(soft)m(w)m(are)h(that)g(initially)g(creates)
 g(a)f(table)h(with)0 3497 y(a)d(large)h(n)m(um)m(b)s(er)e(of)h(ro)m
 (ws,)h(than)f(decreases)g(the)h(NAXIS2)f(v)-5 b(alue)34
 b(to)h(the)f(actual)h(smaller)g(v)-5 b(alue)34 b(just)f(b)s(efore)0
-3610 y(closing)e(the)g(table.)0 3762 y
-SDict begin H.S end
- 0 3762 a 0 3762
-a
-SDict begin 13.6 H.A end
- 0 3762 a 0 3762 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.12) cvn /DEST pdfmark
-end
- 0 3762 a 179 x Fe(4.12)136 b(Lo)t(cal)45
+3610 y(closing)e(the)g(table.)0 3941 y Fe(4.12)136 b(Lo)t(cal)45
 b(FITS)e(Con)l(v)l(en)l(tions)k(supp)t(orted)d(b)l(y)h(FITSIO)0
 4191 y Fj(CFITSIO)29 b(supp)s(orts)g(sev)m(eral)j(lo)s(cal)g(FITS)e
 (con)m(v)m(en)m(tions)i(whic)m(h)f(are)g(not)g(de\014ned)e(in)i(the)f
 (o\016cial)j(FITS)d(stan-)0 4304 y(dard)43 b(and)g(whic)m(h)g(are)h
 (not)g(necessarily)g(recognized)h(or)f(supp)s(orted)e(b)m(y)h(other)h
 (FITS)f(soft)m(w)m(are)i(pac)m(k)-5 b(ages.)0 4417 y(Programmers)36
 b(should)f(b)s(e)g(cautious)i(ab)s(out)e(using)h(these)g(features,)i
 (esp)s(ecially)f(if)f(the)g(FITS)f(\014les)h(that)h(are)0
 4530 y(pro)s(duced)31 b(are)i(exp)s(ected)g(to)g(b)s(e)f(pro)s(cessed)g
 (b)m(y)h(other)f(soft)m(w)m(are)i(systems)f(whic)m(h)f(do)h(not)f(use)h
-(the)f(CFITSIO)0 4642 y(in)m(terface.)0 4767 y
-SDict begin H.S end
- 0 4767
-a 0 4767 a
-SDict begin 13.6 H.A end
- 0 4767 a 0 4767 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.4.12.1) cvn /DEST pdfmark
-end
- 0 4767 a 163 x Fc(4.12.1)113
+(the)f(CFITSIO)0 4642 y(in)m(terface.)0 4930 y Fc(4.12.1)113
 b(Supp)s(ort)37 b(for)h(Long)g(String)f(Keyw)m(ord)h(V)-9
 b(alues.)0 5149 y Fj(The)23 b(length)i(of)f(a)g(standard)f(FITS)g
 (string)h(k)m(eyw)m(ord)g(is)g(limited)h(to)f(68)h(c)m(haracters)g(b)s
 (ecause)f(it)g(m)m(ust)g(\014t)g(en)m(tirely)0 5262 y(within)35
 b(a)h(single)h(FITS)e(header)h(k)m(eyw)m(ord)g(record.)57
 b(In)35 b(some)h(instances)g(it)h(is)e(necessary)i(to)f(enco)s(de)g
 (strings)0 5375 y(longer)27 b(than)f(this)g(limit,)i(so)e(FITSIO)f
@@ -8193,28 +6459,16 @@
 y(eac)m(h)c(substring)d(to)i(indicate)h(that)f(it)g(is)g(con)m(tin)m
 (ued)g(on)f(the)h(next)g(k)m(eyw)m(ord,)h(and)d(the)i(con)m(tin)m
 (uation)i(k)m(eyw)m(ords)0 5714 y(all)44 b(ha)m(v)m(e)h(the)f(name)f
 (CONTINUE)g(without)g(an)h(equal)g(sign)f(in)g(column)h(9.)80
 b(The)43 b(string)h(v)-5 b(alue)43 b(ma)m(y)i(b)s(e)p
 eop end
 %%Page: 22 28
-TeXDict begin 22 27 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.22) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(22)1277
-b Fh(CHAPTER)29 b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
+TeXDict begin 22 27 bop 0 299 a Fj(22)1277 b Fh(CHAPTER)29
+b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
 555 y Fj(con)m(tin)m(ued)e(in)f(this)h(w)m(a)m(y)g(o)m(v)m(er)h(as)e
 (man)m(y)h(additional)g(CONTINUE)f(k)m(eyw)m(ords)g(as)h(is)f
 (required.)40 b(The)27 b(follo)m(wing)0 668 y(lines)k(illustrate)g
 (this)f(con)m(tin)m(uation)j(con)m(v)m(en)m(tion)f(whic)m(h)e(is)h
 (used)e(in)h(the)h(v)-5 b(alue)31 b(of)f(the)h(STRKEY)e(k)m(eyw)m(ord:)
 0 920 y Ff(LONGSTRN=)45 b('OGIP)i(1.0')524 b(/)47 b(The)g(OGIP)g(Long)f
 (String)g(Convention)f(may)i(be)g(used.)0 1033 y(STRKEY)94
@@ -8258,23 +6512,15 @@
 (erten)m(tly)i(writing)f(k)m(eyw)m(ords)0 4029 y(using)38
 b(this)h(non-standard)e(con)m(v)m(en)m(tion)k(without)e(the)f(explicit)
 i(in)m(ten)m(t)g(of)f(the)g(programmer)f(or)h(user.)64
 b(The)0 4142 y(FTPKLS)28 b(subroutine)g(m)m(ust)h(b)s(e)g(called)h
 (instead)g(to)g(write)f(long)h(strings.)40 b(This)28
 b(routine)i(can)f(also)h(b)s(e)f(used)f(to)0 4255 y(write)j(ordinary)e
 (string)i(v)-5 b(alues)30 b(less)h(than)f(68)h(c)m(haracters)h(in)e
-(length.)0 4399 y
-SDict begin H.S end
- 0 4399 a 0 4399 a
-SDict begin 13.6 H.A end
- 0 4399 a 0 4399 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.4.12.2) cvn /DEST pdfmark
-end
-
-0 4399 a 145 x Fc(4.12.2)113 b(Arra)m(ys)37 b(of)g(Fixed-Length)j
+(length.)0 4544 y Fc(4.12.2)113 b(Arra)m(ys)37 b(of)g(Fixed-Length)j
 (Strings)e(in)f(Binary)h(T)-9 b(ables)0 4763 y Fj(CFITSIO)25
 b(supp)s(orts)g(2)i(w)m(a)m(ys)g(to)g(sp)s(ecify)f(that)i(a)f(c)m
 (haracter)h(column)e(in)g(a)h(binary)f(table)i(con)m(tains)f(an)g(arra)
 m(y)g(of)0 4876 y(\014xed-length)32 b(strings.)46 b(The)32
 b(\014rst)f(w)m(a)m(y)-8 b(,)34 b(whic)m(h)e(is)g(o\016cially)i(supp)s
 (orted)c(b)m(y)i(the)h(FITS)e(Standard)g(do)s(cumen)m(t,)0
 4989 y(uses)38 b(the)g(TDIMn)g(k)m(eyw)m(ord.)65 b(F)-8
@@ -8291,101 +6537,72 @@
 (string)f(within)h(the)g(v)m(ector.)59 b(F)-8 b(or)0
 5601 y(example,)47 b(TF)m(ORM1)d(=)f('120A10')j(w)m(ould)d(indicate)h
 (that)f(the)h(binary)e(table)i(column)f(is)g(120)h(c)m(haracters)0
 5714 y(wide)32 b(and)g(consists)h(of)g(12)g(10-c)m(haracter)i(length)e
 (strings.)47 b(This)31 b(con)m(v)m(en)m(tion)k(is)d(recognized)i(b)m(y)
 e(the)h(FITSIO)p eop end
 %%Page: 23 29
-TeXDict begin 23 28 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.23) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(4.12.)73
-b(LOCAL)29 b(FITS)h(CONVENTIONS)f(SUPPOR)-8 b(TED)29
-b(BY)i(FITSIO)1168 b Fj(23)0 555 y(subroutines)40 b(that)h(read)g(or)g
-(write)g(strings)f(in)h(binary)f(tables.)73 b(The)40
-b(Binary)h(T)-8 b(able)42 b(de\014nition)e(do)s(cumen)m(t)0
-668 y(sp)s(eci\014es)31 b(that)i(other)e(optional)i(c)m(haracters)g(ma)
-m(y)g(follo)m(w)g(the)e(datat)m(yp)s(e)i(co)s(de)f(in)f(the)h(TF)m(ORM)
-g(k)m(eyw)m(ord,)h(so)0 781 y(this)j(lo)s(cal)i(con)m(v)m(en)m(tion)h
-(is)e(in)f(compliance)i(with)e(the)h(FITS)f(standard,)h(although)g
-(other)g(FITS)f(readers)h(are)0 894 y(not)31 b(required)e(to)i
-(recognize)h(this)f(con)m(v)m(en)m(tion.)0 1037 y
-SDict begin H.S end
- 0 1037
-a 0 1037 a
-SDict begin 13.6 H.A end
- 0 1037 a 0 1037 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.4.12.3) cvn /DEST pdfmark
-end
- 0 1037 a 146 x Fc(4.12.3)113
-b(Keyw)m(ord)37 b(Units)h(Strings)0 1402 y Fj(One)f(de\014ciency)h(of)g
-(the)g(curren)m(t)g(FITS)f(Standard)f(is)i(that)h(it)f(do)s(es)f(not)h
-(de\014ne)f(a)i(sp)s(eci\014c)e(con)m(v)m(en)m(tion)j(for)0
-1515 y(recording)30 b(the)g(ph)m(ysical)h(units)f(of)g(a)g(k)m(eyw)m
-(ord)h(v)-5 b(alue.)41 b(The)30 b(TUNITn)f(k)m(eyw)m(ord)h(can)g(b)s(e)
-g(used)f(to)i(sp)s(ecify)f(the)0 1628 y(ph)m(ysical)36
-b(units)f(of)g(the)h(v)-5 b(alues)36 b(in)f(a)g(table)i(column,)f(but)f
-(there)g(is)h(no)f(analogous)i(con)m(v)m(en)m(tion)g(for)e(k)m(eyw)m
-(ord)0 1741 y(v)-5 b(alues.)42 b(The)30 b(commen)m(t)h(\014eld)g(of)f
-(the)h(k)m(eyw)m(ord)g(is)g(often)g(used)f(for)g(this)g(purp)s(ose,)g
-(but)f(the)i(units)f(are)h(usually)0 1854 y(not)g(sp)s(eci\014ed)e(in)h
-(a)h(w)m(ell)g(de\014ned)f(format)g(that)h(FITS)f(readers)g(can)h
-(easily)g(recognize)h(and)e(extract.)0 2014 y(T)-8 b(o)28
-b(solv)m(e)h(this)e(de\014ciency)-8 b(,)30 b(FITSIO)c(uses)h(a)h(lo)s
-(cal)h(con)m(v)m(en)m(tion)h(in)d(whic)m(h)g(the)h(k)m(eyw)m(ord)g
-(units)f(are)h(enclosed)g(in)0 2127 y(square)20 b(brac)m(k)m(ets)j(as)e
-(the)f(\014rst)g(tok)m(en)i(in)f(the)f(k)m(eyw)m(ord)i(commen)m(t)f
-(\014eld;)j(more)d(sp)s(eci\014cally)-8 b(,)24 b(the)d(op)s(ening)f
-(square)0 2240 y(brac)m(k)m(et)28 b(immediately)g(follo)m(ws)f(the)g
-(slash)f('/')h(commen)m(t)h(\014eld)e(delimiter)h(and)f(a)g(single)h
-(space)g(c)m(haracter.)41 b(The)0 2352 y(follo)m(wing)32
-b(examples)f(illustrate)g(k)m(eyw)m(ords)g(that)g(use)f(this)g(con)m(v)
-m(en)m(tion:)0 2602 y Ff(EXPOSURE=)713 b(1800.0)47 b(/)g([s])g(elapsed)
-f(exposure)f(time)0 2715 y(V_HELIO)h(=)763 b(16.23)47
-b(/)g([km)g(s**\(-1\)])e(heliocentric)g(velocity)0 2828
-y(LAMBDA)94 b(=)763 b(5400.)47 b(/)g([angstrom])e(central)h(wavelength)
-0 2941 y(FLUX)190 b(=)47 b(4.9033487787637465E-30)42
-b(/)47 b([J/cm**2/s])e(average)h(flux)0 3191 y Fj(In)28
-b(general,)h(the)g(units)e(named)h(in)g(the)h(IA)m(U\(1988\))i(St)m
-(yle)e(Guide)f(are)h(recommended,)f(with)g(the)h(main)f(excep-)0
-3304 y(tion)j(that)g(the)f(preferred)g(unit)f(for)i(angle)g(is)f('deg')
-i(for)e(degrees.)0 3464 y(The)24 b(FTPUNT)g(and)g(FTGUNT)h(subroutines)
-f(in)g(FITSIO)f(write)i(and)f(read,)i(resp)s(ectiv)m(ely)-8
-b(,)28 b(the)c(k)m(eyw)m(ord)h(unit)0 3577 y(strings)30
-b(in)g(an)h(existing)g(k)m(eyw)m(ord.)0 3720 y
-SDict begin H.S end
- 0 3720
-a 0 3720 a
-SDict begin 13.6 H.A end
- 0 3720 a 0 3720 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.4.12.4) cvn /DEST pdfmark
-end
- 0 3720 a 146 x Fc(4.12.4)113
-b(HIERAR)m(CH)34 b(Con)m(v)m(en)m(tion)k(for)f(Extended)h(Keyw)m(ord)f
-(Names)0 4085 y Fj(CFITSIO)k(supp)s(orts)g(the)i(HIERAR)m(CH)g(k)m(eyw)
-m(ord)g(con)m(v)m(en)m(tion)i(whic)m(h)e(allo)m(ws)h(k)m(eyw)m(ord)f
-(names)g(that)h(are)0 4198 y(longer)35 b(than)f(8)h(c)m(haracters.)54
-b(This)34 b(con)m(v)m(en)m(tion)i(w)m(as)f(dev)m(elop)s(ed)g(at)g(the)g
-(Europ)s(ean)e(Southern)g(Observ)-5 b(atory)0 4311 y(\(ESO\))34
-b(and)g(allo)m(ws)h(c)m(haracters)h(consisting)f(of)f(digits)h(0-9,)i
-(upp)s(er)32 b(case)j(letters)h(A-Z,)e(the)h(dash)e('-')i(and)f(the)0
-4424 y(underscore)j(')p 493 4424 28 4 v 33 w('.)63 b(The)37
-b(comp)s(onen)m(ts)h(of)g(hierarc)m(hical)h(k)m(eyw)m(ords)f(are)g
-(separated)g(b)m(y)g(a)g(single)g(ASCI)s(I)e(space)0
-4537 y(c)m(harater.)42 b(F)-8 b(or)31 b(instance:)0 4787
-y Ff(HIERARCH)46 b(ESO)g(INS)h(FOCU)g(POS)g(=)g(-0.00002500)e(/)j
+TeXDict begin 23 28 bop 0 299 a Fh(4.12.)73 b(LOCAL)29
+b(FITS)h(CONVENTIONS)f(SUPPOR)-8 b(TED)29 b(BY)i(FITSIO)1168
+b Fj(23)0 555 y(subroutines)40 b(that)h(read)g(or)g(write)g(strings)f
+(in)h(binary)f(tables.)73 b(The)40 b(Binary)h(T)-8 b(able)42
+b(de\014nition)e(do)s(cumen)m(t)0 668 y(sp)s(eci\014es)31
+b(that)i(other)e(optional)i(c)m(haracters)g(ma)m(y)g(follo)m(w)g(the)e
+(datat)m(yp)s(e)i(co)s(de)f(in)f(the)h(TF)m(ORM)g(k)m(eyw)m(ord,)h(so)0
+781 y(this)j(lo)s(cal)i(con)m(v)m(en)m(tion)h(is)e(in)f(compliance)i
+(with)e(the)h(FITS)f(standard,)h(although)g(other)g(FITS)f(readers)h
+(are)0 894 y(not)31 b(required)e(to)i(recognize)h(this)f(con)m(v)m(en)m
+(tion.)0 1183 y Fc(4.12.3)113 b(Keyw)m(ord)37 b(Units)h(Strings)0
+1402 y Fj(One)f(de\014ciency)h(of)g(the)g(curren)m(t)g(FITS)f(Standard)
+f(is)i(that)h(it)f(do)s(es)f(not)h(de\014ne)f(a)i(sp)s(eci\014c)e(con)m
+(v)m(en)m(tion)j(for)0 1515 y(recording)30 b(the)g(ph)m(ysical)h(units)
+f(of)g(a)g(k)m(eyw)m(ord)h(v)-5 b(alue.)41 b(The)30 b(TUNITn)f(k)m(eyw)
+m(ord)h(can)g(b)s(e)g(used)f(to)i(sp)s(ecify)f(the)0
+1628 y(ph)m(ysical)36 b(units)f(of)g(the)h(v)-5 b(alues)36
+b(in)f(a)g(table)i(column,)f(but)f(there)g(is)h(no)f(analogous)i(con)m
+(v)m(en)m(tion)g(for)e(k)m(eyw)m(ord)0 1741 y(v)-5 b(alues.)42
+b(The)30 b(commen)m(t)h(\014eld)g(of)f(the)h(k)m(eyw)m(ord)g(is)g
+(often)g(used)f(for)g(this)g(purp)s(ose,)g(but)f(the)i(units)f(are)h
+(usually)0 1854 y(not)g(sp)s(eci\014ed)e(in)h(a)h(w)m(ell)g(de\014ned)f
+(format)g(that)h(FITS)f(readers)g(can)h(easily)g(recognize)h(and)e
+(extract.)0 2014 y(T)-8 b(o)28 b(solv)m(e)h(this)e(de\014ciency)-8
+b(,)30 b(FITSIO)c(uses)h(a)h(lo)s(cal)h(con)m(v)m(en)m(tion)h(in)d
+(whic)m(h)g(the)h(k)m(eyw)m(ord)g(units)f(are)h(enclosed)g(in)0
+2127 y(square)20 b(brac)m(k)m(ets)j(as)e(the)f(\014rst)g(tok)m(en)i(in)
+f(the)f(k)m(eyw)m(ord)i(commen)m(t)f(\014eld;)j(more)d(sp)s
+(eci\014cally)-8 b(,)24 b(the)d(op)s(ening)f(square)0
+2240 y(brac)m(k)m(et)28 b(immediately)g(follo)m(ws)f(the)g(slash)f('/')
+h(commen)m(t)h(\014eld)e(delimiter)h(and)f(a)g(single)h(space)g(c)m
+(haracter.)41 b(The)0 2352 y(follo)m(wing)32 b(examples)f(illustrate)g
+(k)m(eyw)m(ords)g(that)g(use)f(this)g(con)m(v)m(en)m(tion:)0
+2602 y Ff(EXPOSURE=)713 b(1800.0)47 b(/)g([s])g(elapsed)f(exposure)f
+(time)0 2715 y(V_HELIO)h(=)763 b(16.23)47 b(/)g([km)g(s**\(-1\)])e
+(heliocentric)g(velocity)0 2828 y(LAMBDA)94 b(=)763 b(5400.)47
+b(/)g([angstrom])e(central)h(wavelength)0 2941 y(FLUX)190
+b(=)47 b(4.9033487787637465E-30)42 b(/)47 b([J/cm**2/s])e(average)h
+(flux)0 3191 y Fj(In)28 b(general,)h(the)g(units)e(named)h(in)g(the)h
+(IA)m(U\(1988\))i(St)m(yle)e(Guide)f(are)h(recommended,)f(with)g(the)h
+(main)f(excep-)0 3304 y(tion)j(that)g(the)f(preferred)g(unit)f(for)i
+(angle)g(is)f('deg')i(for)e(degrees.)0 3464 y(The)24
+b(FTPUNT)g(and)g(FTGUNT)h(subroutines)f(in)g(FITSIO)f(write)i(and)f
+(read,)i(resp)s(ectiv)m(ely)-8 b(,)28 b(the)c(k)m(eyw)m(ord)h(unit)0
+3577 y(strings)30 b(in)g(an)h(existing)g(k)m(eyw)m(ord.)0
+3866 y Fc(4.12.4)113 b(HIERAR)m(CH)34 b(Con)m(v)m(en)m(tion)k(for)f
+(Extended)h(Keyw)m(ord)f(Names)0 4085 y Fj(CFITSIO)k(supp)s(orts)g(the)
+i(HIERAR)m(CH)g(k)m(eyw)m(ord)g(con)m(v)m(en)m(tion)i(whic)m(h)e(allo)m
+(ws)h(k)m(eyw)m(ord)f(names)g(that)h(are)0 4198 y(longer)35
+b(than)f(8)h(c)m(haracters.)54 b(This)34 b(con)m(v)m(en)m(tion)i(w)m
+(as)f(dev)m(elop)s(ed)g(at)g(the)g(Europ)s(ean)e(Southern)g(Observ)-5
+b(atory)0 4311 y(\(ESO\))34 b(and)g(allo)m(ws)h(c)m(haracters)h
+(consisting)f(of)f(digits)h(0-9,)i(upp)s(er)32 b(case)j(letters)h(A-Z,)
+e(the)h(dash)e('-')i(and)f(the)0 4424 y(underscore)j(')p
+493 4424 28 4 v 33 w('.)63 b(The)37 b(comp)s(onen)m(ts)h(of)g(hierarc)m
+(hical)h(k)m(eyw)m(ords)f(are)g(separated)g(b)m(y)g(a)g(single)g(ASCI)s
+(I)e(space)0 4537 y(c)m(harater.)42 b(F)-8 b(or)31 b(instance:)0
+4787 y Ff(HIERARCH)46 b(ESO)g(INS)h(FOCU)g(POS)g(=)g(-0.00002500)e(/)j
 (Focus)e(position)0 5036 y Fj(Basically)-8 b(,)42 b(this)c(con)m(v)m
 (en)m(tion)h(uses)f(the)f(FITS)g(k)m(eyw)m(ord)h('HIERAR)m(CH')g(to)h
 (indicate)f(that)g(this)g(con)m(v)m(en)m(tion)0 5149
 y(is)j(b)s(eing)f(used,)j(then)d(the)h(actual)h(k)m(eyw)m(ord)f(name)g
 (\()p Ff('ESO)47 b(INS)g(FOCU)g(POS')39 b Fj(in)i(this)f(example\))i(b)
 s(egins)e(in)0 5262 y(column)h(10.)74 b(The)41 b(equals)g(sign)g(marks)
 g(the)g(end)g(of)g(the)h(k)m(eyw)m(ord)f(name)g(and)g(is)g(follo)m(w)m
@@ -8396,28 +6613,16 @@
 (v/registry/hierarc)m(h)p 2323 5488 V 38 w(k)m(eyw)m(ord.h)m(tml)g(and)
 f(in)g(Section)g(4.4)i(of)e(the)0 5601 y(ESO)40 b(Data)i(In)m(terface)g
 (Con)m(trol)g(Do)s(cumen)m(t)g(that)f(is)g(link)m(ed)g(to)h(from)e(h)m
 (ttp://arc)m(hiv)m(e.eso.org/cms/to)t(ols-)0 5714 y(do)s(cumen)m
 (tation/eso-data-in)m(terface-con)m(t)q(rol.h)m(tml.)p
 eop end
 %%Page: 24 30
-TeXDict begin 24 29 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.24) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(24)1277
-b Fh(CHAPTER)29 b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
+TeXDict begin 24 29 bop 0 299 a Fj(24)1277 b Fh(CHAPTER)29
+b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
 555 y Fj(This)h(con)m(v)m(en)m(tion)i(allo)m(ws)g(a)f(broader)f(range)h
 (of)g(k)m(eyw)m(ord)f(names)h(than)f(is)h(allo)m(w)m(ed)h(b)m(y)e(the)h
 (FITS)f(Standard.)0 668 y(Here)f(are)g(more)f(examples)h(of)g(suc)m(h)f
 (k)m(eyw)m(ords:)0 941 y Ff(HIERARCH)46 b(LONGKEYWORD)e(=)k(47.5)e(/)i
 (Keyword)e(has)h(>)g(8)g(characters)0 1054 y(HIERARCH)f(LONG-KEY_WORD2)
 d(=)48 b(52.3)f(/)g(Long)g(keyword)e(with)i(hyphen,)f(underscore)f(and)
 i(digit)0 1167 y(HIERARCH)f(EARTH)g(IS)h(A)h(STAR)e(=)i(F)f(/)h
@@ -8447,23 +6652,15 @@
 b(CFITSIO)27 b(returns)g(an)h(error)h(if)f(there)h(is)f(not)h(enough)f
 (ro)s(om)h(for)f(b)s(oth)g(the)0 2569 y(k)m(eyw)m(ord)k(name)f(and)f
 (the)i(k)m(eyw)m(ord)f(v)-5 b(alue)32 b(on)f(the)h(80-c)m(haracter)h
 (card,)f(except)g(for)f(string-v)-5 b(alued)32 b(k)m(eyw)m(ords)0
 2682 y(whic)m(h)f(are)h(simply)e(truncated)i(so)f(that)h(the)f(closing)
 i(quote)f(c)m(haracter)h(falls)e(in)g(column)g(80.)45
 b(A)31 b(space)h(is)f(also)0 2795 y(required)f(on)g(either)h(side)f(of)
-h(the)f(equal)h(sign.)0 2965 y
-SDict begin H.S end
- 0 2965 a 0 2965 a
-SDict begin 13.6 H.A end
- 0 2965
-a 0 2965 a
-SDict begin [/View [/XYZ H.V]/Dest (section.4.13) cvn /DEST pdfmark
-end
- 0 2965 a 179 x Fe(4.13)136 b(Optimizing)45
+h(the)f(equal)h(sign.)0 3144 y Fe(4.13)136 b(Optimizing)45
 b(Co)t(de)g(for)h(Maxim)l(um)f(Pro)t(cessing)g(Sp)t(eed)0
 3397 y Fj(CFITSIO)22 b(has)h(b)s(een)f(carefully)i(designed)f(to)h
 (obtain)g(the)f(highest)h(p)s(ossible)e(sp)s(eed)h(when)f(reading)h
 (and)g(writing)0 3510 y(FITS)33 b(\014les.)51 b(In)33
 b(order)h(to)g(ac)m(hiev)m(e)i(the)e(b)s(est)g(p)s(erformance,)g(ho)m
 (w)m(ev)m(er,)i(application)g(programmers)d(m)m(ust)h(b)s(e)0
 3623 y(careful)24 b(to)h(call)g(the)f(CFITSIO)f(routines)g
@@ -8482,23 +6679,15 @@
 (and)f(reading)g(bac)m(k)i(a)0 4348 y(test)31 b(FITS)f(image,)i(a)f
 (binary)e(table,)j(and)d(an)i(ASCI)s(I)e(table.)0 4508
 y(The)k(follo)m(wing)h(2)g(sections)g(pro)m(vide)g(some)f(bac)m
 (kground)g(on)h(ho)m(w)f(CFITSIO)f(in)m(ternally)i(manages)g(the)f
 (data)0 4621 y(I/O)g(and)g(describ)s(es)f(some)i(strategies)h(that)f
 (ma)m(y)g(b)s(e)e(used)h(to)h(optimize)g(the)g(pro)s(cessing)f(sp)s
 (eed)f(of)h(soft)m(w)m(are)0 4734 y(that)e(uses)f(CFITSIO.)0
-4877 y
-SDict begin H.S end
- 0 4877 a 0 4877 a
-SDict begin 13.6 H.A end
- 0 4877 a 0 4877 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.4.13.1) cvn /DEST pdfmark
-end
- 0 4877 a 163
-x Fc(4.13.1)113 b(Bac)m(kground)38 b(Information:)50
+5040 y Fc(4.13.1)113 b(Bac)m(kground)38 b(Information:)50
 b(Ho)m(w)37 b(CFITSIO)h(Manages)h(Data)f(I/O)0 5262 y
 Fj(Man)m(y)22 b(CFITSIO)e(op)s(erations)i(in)m(v)m(olv)m(e)i
 (transferring)d(only)h(a)g(small)g(n)m(um)m(b)s(er)f(of)h(b)m(ytes)g
 (to)g(or)g(from)f(the)h(FITS)f(\014le)0 5375 y(\(e.g,)31
 b(reading)e(a)g(k)m(eyw)m(ord,)h(or)f(writing)g(a)g(ro)m(w)g(in)f(a)h
 (table\);)i(it)f(w)m(ould)e(b)s(e)g(v)m(ery)i(ine\016cien)m(t)g(to)f
 (ph)m(ysically)h(read)0 5488 y(or)i(write)h(suc)m(h)f(small)g(blo)s(c)m
@@ -8506,28 +6695,16 @@
 (therefore)f(CFITSIO)f(main)m(tains)0 5601 y(a)38 b(set)g(of)g(in)m
 (ternal)h(Input{Output)c(\(IO\))j(bu\013ers)f(in)g(RAM)h(memory)g(that)
 g(eac)m(h)h(con)m(tain)g(one)f(FITS)f(blo)s(c)m(k)0 5714
 y(\(2880)27 b(b)m(ytes\))f(of)f(data.)40 b(Whenev)m(er)25
 b(CFITSIO)f(needs)g(to)i(access)g(data)g(in)f(the)g(FITS)f(\014le,)j
 (it)e(\014rst)f(transfers)h(the)p eop end
 %%Page: 25 31
-TeXDict begin 25 30 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.25) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(4.13.)73
-b(OPTIMIZING)29 b(CODE)h(F)m(OR)h(MAXIMUM)g(PR)m(OCESSING)f(SPEED)971
+TeXDict begin 25 30 bop 0 299 a Fh(4.13.)73 b(OPTIMIZING)29
+b(CODE)h(F)m(OR)h(MAXIMUM)g(PR)m(OCESSING)f(SPEED)971
 b Fj(25)0 555 y(FITS)30 b(blo)s(c)m(k)h(con)m(taining)h(those)f(b)m
 (ytes)g(in)m(to)g(one)g(of)f(the)h(IO)f(bu\013ers)f(in)h(memory)-8
 b(.)42 b(The)30 b(next)g(time)h(CFITSIO)0 668 y(needs)36
 b(to)g(access)i(b)m(ytes)e(in)g(the)g(same)h(blo)s(c)m(k)f(it)h(can)f
 (then)g(go)h(to)f(the)h(fast)f(IO)f(bu\013er)g(rather)h(than)g(using)g
 (a)0 781 y(m)m(uc)m(h)c(slo)m(w)m(er)i(system)e(disk)g(access)h
 (routine.)46 b(The)32 b(n)m(um)m(b)s(er)f(of)h(a)m(v)-5
@@ -8582,23 +6759,15 @@
 b(all)f(the)f(needed)g(information)h(in)f(that)h(blo)s(c)m(k)g(b)s
 (efore)f(it)h(gets)g(\015ushed)d(out)j(of)g(the)f(IO)g(bu\013er.)60
 b(It)38 b(is)0 3520 y(imp)s(ortan)m(t)31 b(to)h(a)m(v)m(oid)g(the)f
 (situation)h(where)f(the)g(same)g(FITS)f(blo)s(c)m(k)i(is)f(b)s(eing)f
 (read)h(then)g(\015ushed)e(from)h(a)h(IO)0 3633 y(bu\013er)e(m)m
 (ultiple)i(times.)0 3793 y(The)f(follo)m(wing)i(section)f(giv)m(es)h
 (more)e(sp)s(eci\014c)h(suggestions)g(for)f(optimizing)i(the)e(use)g
-(of)h(CFITSIO.)0 4040 y
-SDict begin H.S end
- 0 4040 a 0 4040 a
-SDict begin 13.6 H.A end
- 0 4040 a 0
-4040 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.4.13.2) cvn /DEST pdfmark
-end
- 0 4040 a 145 x Fc(4.13.2)113 b(Optimization)38
+(of)h(CFITSIO.)0 4185 y Fc(4.13.2)113 b(Optimization)38
 b(Strategies)0 4425 y Fj(1.)43 b(Because)32 b(the)f(data)g(in)g(FITS)f
 (\014les)h(is)g(alw)m(a)m(ys)h(stored)f(in)g("big-endian")h(b)m(yte)f
 (order,)g(where)f(the)h(\014rst)f(b)m(yte)0 4538 y(of)g(n)m(umeric)h(v)
 -5 b(alues)30 b(con)m(tains)i(the)e(most)h(signi\014can)m(t)g(bits)f
 (and)g(the)g(last)i(b)m(yte)e(con)m(tains)i(the)e(least)i(signi\014can)
 m(t)0 4650 y(bits,)e(CFITSIO)f(m)m(ust)h(sw)m(ap)g(the)g(order)f(of)h
 (the)h(b)m(ytes)f(when)f(reading)h(or)g(writing)g(FITS)g(\014les)g
@@ -8619,28 +6788,16 @@
 (on)g(lin)m(ux\))g(when)e(compiling)j(the)0 5601 y(sw)m(appro)s(c.c)30
 b(source)g(\014le,)g(whic)m(h)g(will)g(allo)m(w)i(the)e(compiler)g(to)h
 (generate)h(co)s(de)e(using)f(the)h(SSSE3)f(instruction)0
 5714 y(set.)41 b(A)28 b(con)m(v)m(enien)m(t)i(w)m(a)m(y)f(to)g(do)g
 (this)f(is)g(to)h(con\014gure)f(the)g(CFITSIO)f(library)h(with)g(the)g
 (follo)m(wing)i(command:)p eop end
 %%Page: 26 32
-TeXDict begin 26 31 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.26) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(26)1277
-b Fh(CHAPTER)29 b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)95
+TeXDict begin 26 31 bop 0 299 a Fj(26)1277 b Fh(CHAPTER)29
+b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)95
 555 y Ff(>)96 b(./configure)44 b(--enable-ssse3)0 819
 y Fj(Note,)37 b(ho)m(w)m(ev)m(er,)h(that)d(a)g(binary)f(executable)j
 (\014le)e(that)g(is)g(created)h(using)e(these)h(faster)g(functions)g
 (will)g(only)0 932 y(run)c(on)h(mac)m(hines)g(that)h(supp)s(ort)d(the)i
 (SSSE3)f(mac)m(hine)i(instructions.)45 b(It)33 b(will)f(crash)g(on)g
 (mac)m(hines)g(that)h(do)0 1045 y(not)e(supp)s(ort)d(them.)0
 1205 y(F)-8 b(or)36 b(faster)f(2-b)m(yte)i(sw)m(aps)e(on)g(virtually)g
@@ -8724,28 +6881,16 @@
 (FITS)g(\014les)g(that)h(are)g(op)s(en)f(at)h(the)g(same)g(time)g
 (\(since)g(one)g(I/O)f(bu\013er)f(is)i(alw)m(a)m(ys)h(reserv)m(ed)0
 5714 y(for)k(eac)m(h)h(op)s(en)f(FITS)f(\014le\).)53
 b(F)-8 b(ortunately)g(,)37 b(a)e(FITSIO)e(routine)h(is)h(a)m(v)-5
 b(ailable)36 b(that)f(will)f(return)g(the)g(optimal)p
 eop end
 %%Page: 27 33
-TeXDict begin 27 32 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.27) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(4.13.)73
-b(OPTIMIZING)29 b(CODE)h(F)m(OR)h(MAXIMUM)g(PR)m(OCESSING)f(SPEED)971
+TeXDict begin 27 32 bop 0 299 a Fh(4.13.)73 b(OPTIMIZING)29
+b(CODE)h(F)m(OR)h(MAXIMUM)g(PR)m(OCESSING)f(SPEED)971
 b Fj(27)0 555 y(n)m(um)m(b)s(er)32 b(of)i(ro)m(ws)g(for)g(a)g(giv)m(en)
 g(table:)49 b(call)35 b(ftgrsz\(unit,)g(nro)m(ws,)f(status\).)52
 b(It)34 b(is)g(not)g(critical)h(to)g(use)e(exactly)0
 668 y(the)f(v)-5 b(alue)32 b(of)f(nro)m(ws)g(returned)g(b)m(y)g(this)g
 (routine,)h(as)g(long)g(as)g(one)g(do)s(es)f(not)h(exceed)g(it.)45
 b(Using)32 b(a)g(v)m(ery)f(small)0 781 y(v)-5 b(alue)32
 b(ho)m(w)m(ev)m(er)i(can)e(also)h(lead)f(to)h(p)s(o)s(or)e(p)s
@@ -8836,28 +6981,16 @@
 (transfer)f(the)h(ra)m(w)g(b)m(ytes)h(instead)0 5562
 y(of)h(reading)g(then)g(writing)g(eac)m(h)h(column)e(of)i(the)f(table.)
 40 b(The)25 b(FITSIO)g(subroutines)g(FTGTBS)g(and)h(FTPTBS)0
 5675 y(\(for)i(ASCI)s(I)f(tables\),)j(and)d(FTGTBB)i(and)e(FTPTBB)i
 (\(for)f(binary)f(tables\))i(will)g(p)s(erform)d(lo)m(w-lev)m(el)31
 b(reads)d(or)p eop end
 %%Page: 28 34
-TeXDict begin 28 33 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.28) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(28)1277
-b Fh(CHAPTER)29 b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
+TeXDict begin 28 33 bop 0 299 a Fj(28)1277 b Fh(CHAPTER)29
+b(4.)72 b(FITSIO)29 b(CONVENTIONS)g(AND)i(GUIDELINES)0
 555 y Fj(writes)j(of)h(an)m(y)f(con)m(tiguous)i(range)f(of)f(b)m(ytes)h
 (in)f(a)h(table)g(extension.)53 b(These)34 b(routines)g(can)h(b)s(e)e
 (used)h(to)h(read)0 668 y(or)29 b(write)g(a)g(whole)g(ro)m(w)f(\(or)i
 (m)m(ultiple)f(ro)m(ws\))g(of)g(a)g(table)h(with)e(a)h(single)g
 (subroutine)f(call.)41 b(These)29 b(routines)g(are)0
 781 y(fast)38 b(b)s(ecause)f(they)h(b)m(ypass)f(all)h(the)g(usual)f
 (data)h(scaling,)j(error)c(c)m(hec)m(king)i(and)e(mac)m(hine)h(dep)s
@@ -8898,34 +7031,15 @@
 b(on)e(the)f(system)h(can)g(all)g(ha)m(v)m(e)h(a)f(signi\014can)m(t)g
 (impact)h(on)e(o)m(v)m(erall)j(I/O)d(e\016ciency)-8 b(.)0
 2795 y(F)g(or)36 b(critical)h(applications,)g(a)f(system)f
 (administrator)g(should)f(review)h(the)h(prop)s(osed)d(system)j(hardw)m
 (are)e(to)0 2908 y(iden)m(tify)d(an)m(y)g(p)s(oten)m(tial)g(I/O)g(b)s
 (ottlenec)m(ks.)p eop end
 %%Page: 29 35
-TeXDict begin 29 34 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.29) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0
-464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.5) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(5)0
+TeXDict begin 29 34 bop 0 1225 a Fg(Chapter)65 b(5)0
 1687 y Fm(Basic)77 b(In)-6 b(terface)77 b(Routines)0
 2180 y Fj(This)27 b(section)h(de\014nes)f(a)h(basic)g(set)g(of)g
 (subroutines)e(that)i(can)g(b)s(e)f(used)g(to)h(p)s(erform)e(the)i
 (most)g(common)g(t)m(yp)s(es)0 2293 y(of)d(read)g(and)f(write)h(op)s
 (erations)g(on)g(FITS)f(\014les.)39 b(New)25 b(users)f(should)g(start)h
 (with)g(these)g(subroutines)f(and)g(then,)0 2406 y(as)33
 b(needed,)h(explore)f(the)h(more)f(adv)-5 b(ance)33 b(routines)g
@@ -8937,111 +7051,86 @@
 (of)g(eac)m(h)i(routine.)44 b(This)30 b(sym)m(b)s(ol)i(is)f(not)h
 (actually)h(part)e(of)h(the)f(calling)i(sequence.)45
 b(Note)32 b(that)0 2904 y(the)f(status)h(parameter)g(is)f(b)s(oth)g(an)
 g(input)f(and)h(an)g(output)g(parameter)h(and)e(m)m(ust)h(b)s(e)g
 (initialized)i(=)e(0)h(prior)0 3017 y(to)f(calling)h(the)f(FITSIO)e
 (subroutines.)0 3177 y(Refer)h(to)i(Chapter)d(9)i(for)f(the)h
 (de\014nition)f(of)g(all)i(the)e(parameters)h(used)e(b)m(y)i(these)g
-(in)m(terface)g(routines.)0 3346 y
-SDict begin H.S end
- 0 3346 a 0 3346 a
-SDict begin 13.6 H.A end
-
-0 3346 a 0 3346 a
-SDict begin [/View [/XYZ H.V]/Dest (section.5.1) cvn /DEST pdfmark
-end
- 0 3346 a 179 x Fe(5.1)135 b(FITSIO)44
-b(Error)h(Status)h(Routines)0 3773 y Fi(1)81 b Fj(Return)24
+(in)m(terface)g(routines.)0 3511 y Fe(5.1)135 b(FITSIO)44
+b(Error)h(Status)h(Routines)0 3751 y Fi(1)81 b Fj(Return)24
 b(the)i(curren)m(t)f(v)m(ersion)h(n)m(um)m(b)s(er)e(of)i(the)f
 (\014tsio)h(library)-8 b(.)39 b(The)25 b(v)m(ersion)h(n)m(um)m(b)s(er)e
-(will)i(b)s(e)e(incremen)m(ted)227 3886 y(with)30 b(eac)m(h)i(new)e
-(release)h(of)g(CFITSIO.)382 4157 y Ff(FTVERS\()46 b(>)h(version\))0
-4429 y Fi(2)81 b Fj(Return)45 b(the)i(descriptiv)m(e)g(text)g(string)g
-(corresp)s(onding)e(to)i(a)g(FITSIO)e(error)h(status)h(co)s(de.)89
-b(The)46 b(30-)227 4541 y(c)m(haracter)32 b(length)f(string)f(con)m
+(will)i(b)s(e)e(incremen)m(ted)227 3864 y(with)32 b(eac)m(h)i(new)e
+(release)i(of)f(CFITSIO.)e(The)h(3)h(\014elds)f(of)g(the)h(v)m(ersion)g
+(string)f(M.xx.yy)i(are)e(con)m(v)m(erted)227 3976 y(to)f(a)g(\015oat)g
+(as:)41 b(M)31 b(+)f(.01*xx)i(+)e(.0001*yy)-8 b(.)382
+4234 y Ff(FTVERS\()46 b(>)h(version\))0 4491 y Fi(2)81
+b Fj(Return)45 b(the)i(descriptiv)m(e)g(text)g(string)g(corresp)s
+(onding)e(to)i(a)g(FITSIO)e(error)h(status)h(co)s(de.)89
+b(The)46 b(30-)227 4604 y(c)m(haracter)32 b(length)f(string)f(con)m
 (tains)i(a)f(brief)f(description)g(of)g(the)h(cause)g(of)f(the)h
-(error.)382 4813 y Ff(FTGERR\(status,)44 b(>)j(errtext\))0
-5084 y Fi(3)81 b Fj(Return)40 b(the)h(top)g(\(oldest\))h(80-c)m
+(error.)382 4861 y Ff(FTGERR\(status,)44 b(>)j(errtext\))0
+5118 y Fi(3)81 b Fj(Return)40 b(the)h(top)g(\(oldest\))h(80-c)m
 (haracter)i(error)c(message)i(from)f(the)g(in)m(ternal)g(FITSIO)f(stac)
-m(k)i(of)f(error)227 5197 y(messages)29 b(and)f(shift)g(an)m(y)g
+m(k)i(of)f(error)227 5231 y(messages)29 b(and)f(shift)g(an)m(y)g
 (remaining)g(messages)h(on)f(the)g(stac)m(k)i(up)d(one)h(lev)m(el.)42
-b(An)m(y)28 b(FITSIO)f(error)h(will)227 5310 y(generate)h(one)e(or)g
+b(An)m(y)28 b(FITSIO)f(error)h(will)227 5344 y(generate)h(one)e(or)g
 (more)h(messages)g(on)f(the)g(stac)m(k.)41 b(Call)28
 b(this)f(routine)g(rep)s(eatedly)g(to)h(get)h(eac)m(h)f(message)227
-5422 y(in)i(sequence.)41 b(The)30 b(error)g(stac)m(k)i(is)f(empt)m(y)f
-(when)g(a)g(blank)g(string)h(is)f(returned.)382 5694
+5457 y(in)i(sequence.)41 b(The)30 b(error)g(stac)m(k)i(is)f(empt)m(y)f
+(when)g(a)g(blank)g(string)h(is)f(returned.)382 5714
 y Ff(FTGMSG\()46 b(>)h(errmsg\))1905 5942 y Fj(29)p eop
 end
 %%Page: 30 36
-TeXDict begin 30 35 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.30) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(30)1747
-b Fh(CHAPTER)30 b(5.)111 b(BASIC)30 b(INTERF)-10 b(A)m(CE)30
-b(R)m(OUTINES)0 555 y Fi(4)81 b Fj(The)33 b(FTPMRK)h(routine)g(puts)g
-(an)g(in)m(visible)h(mark)m(er)f(on)g(the)h(CFITSIO)d(error)i(stac)m
-(k.)54 b(The)33 b(FTCMRK)227 668 y(routine)41 b(can)g(then)g(b)s(e)f
-(used)g(to)h(delete)h(an)m(y)f(more)g(recen)m(t)h(error)e(messages)i
-(on)f(the)g(stac)m(k,)k(bac)m(k)c(to)227 781 y(the)32
-b(p)s(osition)f(of)g(the)g(mark)m(er.)43 b(This)31 b(preserv)m(es)g(an)
-m(y)g(older)h(error)e(messages)i(on)f(the)h(stac)m(k.)44
-b(FTCMSG)227 894 y(simply)23 b(clears)g(the)g(en)m(tire)h(error)e
-(message)i(stac)m(k.)40 b(These)23 b(routines)f(are)h(called)h(without)
-f(an)m(y)g(argumen)m(ts.)382 1152 y Ff(FTPMRK)382 1265
-y(FTCMRK)382 1378 y(FTCMSG)0 1637 y Fi(5)81 b Fj(Prin)m(t)30
-b(out)h(the)g(error)f(message)i(corresp)s(onding)e(to)h(the)g(input)f
-(status)h(v)-5 b(alue)31 b(and)f(all)i(the)f(error)f(messages)227
-1750 y(on)g(the)h(FITSIO)e(stac)m(k)i(to)g(the)g(sp)s(eci\014ed)e
-(\014le)i(stream)f(\(stream)h(can)g(b)s(e)e(either)i(the)f(string)g
-('STDOUT')227 1863 y(or)h('STDERR'\).)f(If)g(the)h(input)e(status)i(v)
--5 b(alue)31 b(=)f(0)h(then)f(this)g(routine)g(do)s(es)g(nothing.)334
+TeXDict begin 30 35 bop 0 299 a Fj(30)1747 b Fh(CHAPTER)30
+b(5.)111 b(BASIC)30 b(INTERF)-10 b(A)m(CE)30 b(R)m(OUTINES)0
+555 y Fi(4)81 b Fj(The)33 b(FTPMRK)h(routine)g(puts)g(an)g(in)m
+(visible)h(mark)m(er)f(on)g(the)h(CFITSIO)d(error)i(stac)m(k.)54
+b(The)33 b(FTCMRK)227 668 y(routine)41 b(can)g(then)g(b)s(e)f(used)g
+(to)h(delete)h(an)m(y)f(more)g(recen)m(t)h(error)e(messages)i(on)f(the)
+g(stac)m(k,)k(bac)m(k)c(to)227 781 y(the)32 b(p)s(osition)f(of)g(the)g
+(mark)m(er.)43 b(This)31 b(preserv)m(es)g(an)m(y)g(older)h(error)e
+(messages)i(on)f(the)h(stac)m(k.)44 b(FTCMSG)227 894
+y(simply)23 b(clears)g(the)g(en)m(tire)h(error)e(message)i(stac)m(k.)40
+b(These)23 b(routines)f(are)h(called)h(without)f(an)m(y)g(argumen)m
+(ts.)382 1152 y Ff(FTPMRK)382 1265 y(FTCMRK)382 1378
+y(FTCMSG)0 1637 y Fi(5)81 b Fj(Prin)m(t)30 b(out)h(the)g(error)f
+(message)i(corresp)s(onding)e(to)h(the)g(input)f(status)h(v)-5
+b(alue)31 b(and)f(all)i(the)f(error)f(messages)227 1750
+y(on)g(the)h(FITSIO)e(stac)m(k)i(to)g(the)g(sp)s(eci\014ed)e(\014le)i
+(stream)f(\(stream)h(can)g(b)s(e)e(either)i(the)f(string)g('STDOUT')227
+1863 y(or)h('STDERR'\).)f(If)g(the)h(input)e(status)i(v)-5
+b(alue)31 b(=)f(0)h(then)f(this)g(routine)g(do)s(es)g(nothing.)334
 2121 y Ff(FTRPRT)46 b(\(stream,)g(>)h(status\))0 2380
 y Fi(6)81 b Fj(W)-8 b(rite)39 b(an)f(80-c)m(haracter)j(message)e(to)g
 (the)f(FITSIO)f(error)h(stac)m(k.)65 b(Application)39
 b(programs)f(should)f(not)227 2493 y(normally)31 b(write)f(to)i(the)e
 (stac)m(k,)i(but)e(there)g(ma)m(y)h(b)s(e)f(some)h(situations)g(where)f
 (this)g(is)h(desirable.)382 2751 y Ff(FTPMSG\(errmsg\))0
-2908 y
-SDict begin H.S end
- 0 2908 a 0 2908 a
-SDict begin 13.6 H.A end
- 0 2908 a 0 2908 a
-SDict begin [/View [/XYZ H.V]/Dest (section.5.2) cvn /DEST pdfmark
-end
- 0 2908 a 177
-x Fe(5.2)135 b(File)46 b(I/O)f(Routines)0 3325 y Fi(1)81
-b Fj(Op)s(en)34 b(an)h(existing)i(FITS)d(\014le)i(with)f(readonly)h(or)
-f(readwrite)h(access.)58 b(This)34 b(routine)i(alw)m(a)m(ys)h(op)s(ens)
-e(the)227 3438 y(primary)30 b(arra)m(y)i(\(the)f(\014rst)f(HDU\))i(of)f
-(the)h(\014le,)f(and)f(do)s(es)h(not)g(mo)m(v)m(e)h(to)g(a)f(follo)m
-(wing)i(extension,)f(if)f(one)227 3551 y(w)m(as)c(sp)s(eci\014ed)f(as)g
-(part)h(of)f(the)h(\014lename.)39 b(Use)27 b(the)g(FTNOPN)f(routine)g
-(to)h(automatically)j(mo)m(v)m(e)e(to)f(the)227 3664
-y(extension.)44 b(This)31 b(routine)g(will)h(also)g(op)s(en)f(IRAF)g
-(images)i(\(.imh)e(format)h(\014les\))g(and)e(ra)m(w)i(binary)e(data)
-227 3776 y(arra)m(ys)e(with)f(READONL)-8 b(Y)28 b(access)h(b)m(y)e
-(\014rst)g(con)m(v)m(erting)i(them)e(on)g(the)h(\015y)f(in)m(to)h
-(virtual)g(FITS)f(images.)227 3889 y(See)43 b(the)g(`Extended)f(File)i
-(Name)f(Syn)m(tax')g(c)m(hapter)g(for)f(more)h(details.)78
-b(The)42 b(FTDK)m(OPN)h(routine)227 4002 y(simply)37
-b(op)s(ens)g(the)h(sp)s(eci\014ed)f(\014le)h(without)f(trying)h(to)g
-(in)m(terpret)g(the)g(\014lename)g(using)f(the)h(extended)227
-4115 y(\014lename)31 b(syn)m(tax.)382 4374 y Ff
-(FTOPEN\(unit,filename,rwm)o(ode)o(,)42 b(>)47 b(blocksize,status\))382
-4487 y(FTDKOPN\(unit,filename,rw)o(mod)o(e,)42 b(>)47
-b(blocksize,status\))0 4745 y Fi(2)81 b Fj(Op)s(en)24
+3085 y Fe(5.2)135 b(File)46 b(I/O)f(Routines)0 3325 y
+Fi(1)81 b Fj(Op)s(en)34 b(an)h(existing)i(FITS)d(\014le)i(with)f
+(readonly)h(or)f(readwrite)h(access.)58 b(This)34 b(routine)i(alw)m(a)m
+(ys)h(op)s(ens)e(the)227 3438 y(primary)30 b(arra)m(y)i(\(the)f
+(\014rst)f(HDU\))i(of)f(the)h(\014le,)f(and)f(do)s(es)h(not)g(mo)m(v)m
+(e)h(to)g(a)f(follo)m(wing)i(extension,)f(if)f(one)227
+3551 y(w)m(as)c(sp)s(eci\014ed)f(as)g(part)h(of)f(the)h(\014lename.)39
+b(Use)27 b(the)g(FTNOPN)f(routine)g(to)h(automatically)j(mo)m(v)m(e)e
+(to)f(the)227 3664 y(extension.)44 b(This)31 b(routine)g(will)h(also)g
+(op)s(en)f(IRAF)g(images)i(\(.imh)e(format)h(\014les\))g(and)e(ra)m(w)i
+(binary)e(data)227 3776 y(arra)m(ys)e(with)f(READONL)-8
+b(Y)28 b(access)h(b)m(y)e(\014rst)g(con)m(v)m(erting)i(them)e(on)g(the)
+h(\015y)f(in)m(to)h(virtual)g(FITS)f(images.)227 3889
+y(See)43 b(the)g(`Extended)f(File)i(Name)f(Syn)m(tax')g(c)m(hapter)g
+(for)f(more)h(details.)78 b(The)42 b(FTDK)m(OPN)h(routine)227
+4002 y(simply)37 b(op)s(ens)g(the)h(sp)s(eci\014ed)f(\014le)h(without)f
+(trying)h(to)g(in)m(terpret)g(the)g(\014lename)g(using)f(the)h
+(extended)227 4115 y(\014lename)31 b(syn)m(tax.)382 4374
+y Ff(FTOPEN\(unit,filename,rwm)o(ode)o(,)42 b(>)47 b
+(blocksize,status\))382 4487 y(FTDKOPN\(unit,filename,rw)o(mod)o(e,)42
+b(>)47 b(blocksize,status\))0 4745 y Fi(2)81 b Fj(Op)s(en)24
 b(an)i(existing)h(FITS)e(\014le)h(with)f(readonly)h(or)g(readwrite)g
 (access)h(and)f(mo)m(v)m(e)h(to)f(a)h(follo)m(wing)g(extension,)227
 4858 y(if)38 b(one)g(w)m(as)g(sp)s(eci\014ed)g(as)g(part)f(of)h(the)h
 (\014lename.)63 b(\(e.g.,)42 b('\014lename.\014ts+2')c(or)g
 ('\014lename.\014ts[2]')i(will)227 4971 y(mo)m(v)m(e)e(to)g(the)e(3rd)g
 (HDU)i(in)e(the)h(\014le\).)60 b(Note)37 b(that)h(this)e(routine)h
 (di\013ers)f(from)g(FTOPEN)g(in)g(that)h(it)227 5084
@@ -9050,32 +7139,20 @@
 b(>)47 b(status\))0 5601 y Fi(3)81 b Fj(Op)s(en)31 b(an)h(existing)h
 (FITS)f(\014le)g(with)g(readonly)h(or)f(readwrite)h(access)g(and)f
 (then)g(mo)m(v)m(e)i(to)f(the)g(\014rst)e(HDU)227 5714
 y(con)m(taining)c(signi\014can)m(t)g(data,)g(if)e(a\))i(an)e(HDU)h
 (name)g(or)f(n)m(um)m(b)s(er)f(to)i(op)s(en)f(w)m(as)h(not)g
 (explicitly)h(sp)s(eci\014ed)p eop end
 %%Page: 31 37
-TeXDict begin 31 36 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.31) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(5.2.)72
-b(FILE)30 b(I/O)h(R)m(OUTINES)2693 b Fj(31)227 555 y(as)31
-b(part)g(of)g(the)g(\014lename,)h(and)e(b\))h(if)g(the)g(FITS)f(\014le)
-h(con)m(tains)h(a)g(n)m(ull)e(primary)g(arra)m(y)i(\(i.e.,)h(NAXIS)d(=)
-227 668 y(0\).)41 b(In)26 b(this)i(case,)h(it)f(will)g(lo)s(ok)g(for)f
-(the)h(\014rst)e(IMA)m(GE)j(HDU)f(with)f(NAXIS)g(>)h(0,)g(or)g(the)f
+TeXDict begin 31 36 bop 0 299 a Fh(5.2.)72 b(FILE)30
+b(I/O)h(R)m(OUTINES)2693 b Fj(31)227 555 y(as)31 b(part)g(of)g(the)g
+(\014lename,)h(and)e(b\))h(if)g(the)g(FITS)f(\014le)h(con)m(tains)h(a)g
+(n)m(ull)e(primary)g(arra)m(y)i(\(i.e.,)h(NAXIS)d(=)227
+668 y(0\).)41 b(In)26 b(this)i(case,)h(it)f(will)g(lo)s(ok)g(for)f(the)
+h(\014rst)e(IMA)m(GE)j(HDU)f(with)f(NAXIS)g(>)h(0,)g(or)g(the)f
 (\014rst)g(table)h(that)227 781 y(do)s(es)g(not)g(con)m(tain)g(the)g
 (strings)g(`GTI')g(\(Go)s(o)s(d)f(Time)h(In)m(terv)-5
 b(al\))29 b(or)f(`OBST)-8 b(ABLE')28 b(in)f(the)h(EXTNAME)227
 894 y(k)m(eyw)m(ord)37 b(v)-5 b(alue.)61 b(FTTOPN)36
 b(is)g(similar,)j(except)f(it)f(will)g(mo)m(v)m(e)i(to)e(the)g(\014rst)
 f(signi\014can)m(t)i(table)f(HDU)227 1007 y(\(skipping)26
 b(o)m(v)m(er)g(an)m(y)g(image)h(HDUs\))g(in)e(the)h(\014le)g(if)f(a)h
@@ -9131,129 +7208,89 @@
 (the)f(new)g(extension.)40 b(If)25 b(there)h(are)g(no)g(other)f(follo)m
 (wing)227 5601 y(extensions)32 b(then)f(the)h(new)f(table)h(extension)g
 (will)g(simply)f(b)s(e)g(app)s(ended)f(to)i(the)f(end)g(of)h(the)f
 (\014le.)44 b(The)227 5714 y(new)33 b(extension)h(will)f(b)s(ecome)h
 (the)f(CHDU.)h(The)f(FTIT)-8 b(ABLL)33 b(routine)g(is)g(iden)m(tical)i
 (to)f(the)g(FTIT)-8 b(AB)p eop end
 %%Page: 32 38
-TeXDict begin 32 37 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.32) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(32)1747
-b Fh(CHAPTER)30 b(5.)111 b(BASIC)30 b(INTERF)-10 b(A)m(CE)30
-b(R)m(OUTINES)227 555 y Fj(routine)36 b(except)g(that)g(the)f(2nd)g
-(and)g(3rd)g(parameters)g(\(that)i(giv)m(e)g(the)e(size)h(of)g(the)f
-(table\))i(are)f(64-bit)227 668 y(in)m(tegers)43 b(rather)f(than)f
-(32-bit)i(in)m(tegers.)76 b(Under)41 b(normal)g(circumstances,)46
-b(the)c(nro)m(ws)f(and)g(nro)m(wsll)227 781 y(paramen)m(ters)f(should)e
-(ha)m(v)m(e)j(a)f(v)-5 b(alue)40 b(of)f(0;)45 b(CFITSIO)38
-b(will)h(automatically)k(up)s(date)38 b(the)i(n)m(um)m(b)s(er)e(of)227
-894 y(ro)m(ws)31 b(as)f(data)h(is)g(written)f(to)h(the)g(table.)382
-1158 y Ff(FTITAB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o(ype)o(,tbc)o
-(ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42 b(>)716
-1271 y(status\))382 1384 y(FTITABLL\(unit,rowlenll,n)o(row)o(sll,)o
-(tfie)o(lds)o(,tty)o(pe,t)o(bco)o(l,tf)o(orm,)o(tun)o(it,e)o(xtna)o
-(me,)f(>)716 1497 y(status\))0 1761 y Fi(9)81 b Fj(Insert)26
-b(a)h(new)g(binary)f(table)h(extension)h(immediately)g(follo)m(wing)h
-(the)e(CHDU.)g(An)m(y)g(follo)m(wing)h(extensions)227
-1874 y(will)39 b(b)s(e)f(shifted)g(do)m(wn)g(to)h(mak)m(e)g(ro)s(om)g
-(for)f(the)g(new)g(extension.)66 b(If)38 b(there)h(are)f(no)h(other)f
-(follo)m(wing)227 1987 y(extensions)f(then)g(the)f(new)g(bin)m(table)h
-(extension)h(will)f(simply)f(b)s(e)g(app)s(ended)e(to)k(the)e(end)g(of)
-h(the)g(\014le.)227 2100 y(The)23 b(new)g(extension)h(will)f(b)s(ecome)
-h(the)f(CHDU.)h(The)f(FTIBINLL)g(routine)g(is)g(iden)m(tical)i(to)f
-(the)g(FTIBIN)227 2213 y(routine)30 b(except)i(that)e(the)h(2nd)e
-(parameter)i(\(that)g(giv)m(es)g(the)g(length)f(of)h(the)f(table\))h
-(is)g(a)f(64-bit)i(in)m(teger)227 2325 y(rather)24 b(than)g(a)g(32-bit)
-h(in)m(teger.)40 b(Under)23 b(normal)h(circumstances,)i(the)e(nro)m(ws)
-f(and)h(nro)m(wsll)g(paramen)m(ters)227 2438 y(should)31
-b(ha)m(v)m(e)i(a)f(v)-5 b(alue)32 b(of)f(0;)i(CFITSIO)d(will)i
-(automatically)j(up)s(date)30 b(the)i(n)m(um)m(b)s(er)e(of)i(ro)m(ws)g
-(as)g(data)g(is)227 2551 y(written)f(to)g(the)f(table.)382
-2815 y Ff(FTIBIN\(unit,nrows,tfield)o(s,t)o(type)o(,tfo)o(rm,)o(tuni)o
-(t,ex)o(tna)o(me,v)o(arid)o(at)41 b(>)48 b(status\))382
-2928 y(FTIBINLL\(unit,nrowsll,tf)o(iel)o(ds,t)o(type)o(,tf)o(orm,)o
-(tuni)o(t,e)o(xtna)o(me,v)o(ari)o(dat)41 b(>)48 b(status\))0
-3183 y
-SDict begin H.S end
- 0 3183 a 0 3183 a
-SDict begin 13.6 H.A end
- 0 3183 a 0 3183 a
-SDict begin [/View [/XYZ H.V]/Dest (section.5.3) cvn /DEST pdfmark
-end
- 0 3183 a 197
-x Fe(5.3)135 b(Keyw)l(ord)46 b(I/O)f(Routines)0 3624
-y Fi(1)81 b Fj(Put)30 b(\(app)s(end\))f(an)h(80-c)m(haracter)j(record)e
-(in)m(to)g(the)g(CHU.)382 3888 y Ff(FTPREC\(unit,card,)43
-b(>)k(status\))0 4152 y Fi(2)81 b Fj(Put)28 b(\(app)s(end\))g(a)h(new)g
+TeXDict begin 32 37 bop 0 299 a Fj(32)1747 b Fh(CHAPTER)30
+b(5.)111 b(BASIC)30 b(INTERF)-10 b(A)m(CE)30 b(R)m(OUTINES)227
+555 y Fj(routine)36 b(except)g(that)g(the)f(2nd)g(and)g(3rd)g
+(parameters)g(\(that)i(giv)m(e)g(the)e(size)h(of)g(the)f(table\))i(are)
+f(64-bit)227 668 y(in)m(tegers)43 b(rather)f(than)f(32-bit)i(in)m
+(tegers.)76 b(Under)41 b(normal)g(circumstances,)46 b(the)c(nro)m(ws)f
+(and)g(nro)m(wsll)227 781 y(paramen)m(ters)f(should)e(ha)m(v)m(e)j(a)f
+(v)-5 b(alue)40 b(of)f(0;)45 b(CFITSIO)38 b(will)h(automatically)k(up)s
+(date)38 b(the)i(n)m(um)m(b)s(er)e(of)227 894 y(ro)m(ws)31
+b(as)f(data)h(is)g(written)f(to)h(the)g(table.)382 1160
+y Ff(FTITAB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o(ype)o(,tbc)o(ol,t)
+o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42 b(>)716 1273
+y(status\))382 1386 y(FTITABLL\(unit,rowlenll,n)o(row)o(sll,)o(tfie)o
+(lds)o(,tty)o(pe,t)o(bco)o(l,tf)o(orm,)o(tun)o(it,e)o(xtna)o(me,)f(>)
+716 1499 y(status\))0 1765 y Fi(9)81 b Fj(Insert)26 b(a)h(new)g(binary)
+f(table)h(extension)h(immediately)g(follo)m(wing)h(the)e(CHDU.)g(An)m
+(y)g(follo)m(wing)h(extensions)227 1878 y(will)39 b(b)s(e)f(shifted)g
+(do)m(wn)g(to)h(mak)m(e)g(ro)s(om)g(for)f(the)g(new)g(extension.)66
+b(If)38 b(there)h(are)f(no)h(other)f(follo)m(wing)227
+1991 y(extensions)f(then)g(the)f(new)g(bin)m(table)h(extension)h(will)f
+(simply)f(b)s(e)g(app)s(ended)e(to)k(the)e(end)g(of)h(the)g(\014le.)227
+2104 y(The)23 b(new)g(extension)h(will)f(b)s(ecome)h(the)f(CHDU.)h(The)
+f(FTIBINLL)g(routine)g(is)g(iden)m(tical)i(to)f(the)g(FTIBIN)227
+2217 y(routine)30 b(except)i(that)e(the)h(2nd)e(parameter)i(\(that)g
+(giv)m(es)g(the)g(length)f(of)h(the)f(table\))h(is)g(a)f(64-bit)i(in)m
+(teger)227 2329 y(rather)24 b(than)g(a)g(32-bit)h(in)m(teger.)40
+b(Under)23 b(normal)h(circumstances,)i(the)e(nro)m(ws)f(and)h(nro)m
+(wsll)g(paramen)m(ters)227 2442 y(should)31 b(ha)m(v)m(e)i(a)f(v)-5
+b(alue)32 b(of)f(0;)i(CFITSIO)d(will)i(automatically)j(up)s(date)30
+b(the)i(n)m(um)m(b)s(er)e(of)i(ro)m(ws)g(as)g(data)g(is)227
+2555 y(written)f(to)g(the)f(table.)382 2821 y Ff
+(FTIBIN\(unit,nrows,tfield)o(s,t)o(type)o(,tfo)o(rm,)o(tuni)o(t,ex)o
+(tna)o(me,v)o(arid)o(at)41 b(>)48 b(status\))382 2934
+y(FTIBINLL\(unit,nrowsll,tf)o(iel)o(ds,t)o(type)o(,tf)o(orm,)o(tuni)o
+(t,e)o(xtna)o(me,v)o(ari)o(dat)41 b(>)48 b(status\))0
+3388 y Fe(5.3)135 b(Keyw)l(ord)46 b(I/O)f(Routines)0
+3633 y Fi(1)81 b Fj(Put)30 b(\(app)s(end\))f(an)h(80-c)m(haracter)j
+(record)e(in)m(to)g(the)g(CHU.)382 3899 y Ff(FTPREC\(unit,card,)43
+b(>)k(status\))0 4165 y Fi(2)81 b Fj(Put)28 b(\(app)s(end\))g(a)h(new)g
 (k)m(eyw)m(ord)g(of)g(the)g(appropriate)g(datat)m(yp)s(e)h(in)m(to)g
-(the)f(CHU.)g(The)f(E)h(and)f(D)i(v)m(ersions)227 4265
+(the)f(CHU.)g(The)f(E)h(and)f(D)i(v)m(ersions)227 4278
 y(of)24 b(this)f(routine)g(ha)m(v)m(e)h(the)g(added)e(feature)i(that)g
 (if)f(the)g('decimals')i(parameter)f(is)f(negativ)m(e,)k(then)c(the)g
-('G')227 4378 y(displa)m(y)30 b(format)g(rather)f(then)g(the)h('E')f
+('G')227 4391 y(displa)m(y)30 b(format)g(rather)f(then)g(the)h('E')f
 (format)h(will)g(b)s(e)f(used)f(when)h(constructing)h(the)f(k)m(eyw)m
-(ord)h(v)-5 b(alue,)227 4490 y(taking)27 b(the)g(absolute)g(v)-5
+(ord)h(v)-5 b(alue,)227 4504 y(taking)27 b(the)g(absolute)g(v)-5
 b(alue)26 b(of)h('decimals')g(for)f(the)h(precision.)39
 b(This)26 b(will)g(suppress)e(trailing)k(zeros,)g(and)227
-4603 y(will)37 b(use)g(a)g(\014xed)f(format)h(rather)g(than)f(an)h(exp)
+4617 y(will)37 b(use)g(a)g(\014xed)f(format)h(rather)g(than)f(an)h(exp)
 s(onen)m(tial)g(format,)i(dep)s(ending)c(on)i(the)g(magnitude)g(of)227
-4716 y(the)31 b(v)-5 b(alue.)382 4980 y Ff(FTPKY[JKLS]\(unit,keyword)o
+4730 y(the)31 b(v)-5 b(alue.)382 4996 y Ff(FTPKY[JKLS]\(unit,keyword)o
 (,ke)o(yval)o(,com)o(men)o(t,)42 b(>)47 b(status\))382
-5093 y(FTPKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o(ima)o(ls,c)o
-(omme)o(nt,)41 b(>)48 b(status\))0 5357 y Fi(3)81 b Fj(Get)37
+5109 y(FTPKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o(ima)o(ls,c)o
+(omme)o(nt,)41 b(>)48 b(status\))0 5375 y Fi(3)81 b Fj(Get)37
 b(the)f(n)m(th)f(80-c)m(haracter)k(header)d(record)g(from)f(the)h(CHU.)
 h(The)e(\014rst)g(k)m(eyw)m(ord)i(in)e(the)h(header)g(is)g(at)227
-5470 y(k)m(ey)p 365 5470 28 4 v 34 w(no)42 b(=)f(1;)49
-b(if)42 b(k)m(ey)p 996 5470 V 34 w(no)g(=)f(0)i(then)e(this)h
+5488 y(k)m(ey)p 365 5488 28 4 v 34 w(no)42 b(=)f(1;)49
+b(if)42 b(k)m(ey)p 996 5488 V 34 w(no)g(=)f(0)i(then)e(this)h
 (subroutine)f(simple)h(mo)m(v)m(es)i(the)e(in)m(ternal)h(p)s(oin)m(ter)
-f(to)h(the)227 5583 y(b)s(eginning)35 b(of)h(the)g(header)f(so)h(that)g
+f(to)h(the)227 5601 y(b)s(eginning)35 b(of)h(the)g(header)f(so)h(that)g
 (subsequen)m(t)f(k)m(eyw)m(ord)h(op)s(erations)g(will)g(start)g(at)g
-(the)g(top)g(of)g(the)227 5696 y(header;)31 b(it)g(also)g(returns)e(a)i
+(the)g(top)g(of)g(the)227 5714 y(header;)31 b(it)g(also)g(returns)e(a)i
 (blank)f(card)g(v)-5 b(alue)31 b(in)f(this)g(case.)p
 eop end
 %%Page: 33 39
-TeXDict begin 33 38 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.33) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(5.4.)72
-b(D)m(A)-8 b(T)g(A)32 b(I/O)f(R)m(OUTINES)2650 b Fj(33)382
-555 y Ff(FTGREC\(unit,key_no,)42 b(>)48 b(card,status\))0
-804 y Fi(4)81 b Fj(Get)31 b(a)g(k)m(eyw)m(ord)g(v)-5
-b(alue)30 b(\(with)h(the)f(appropriate)h(datat)m(yp)s(e\))g(and)f
-(commen)m(t)i(from)e(the)g(CHU)382 1052 y Ff(FTGKY[EDJKLS]\(unit,keywo)
-o(rd,)41 b(>)48 b(keyval,comment,status\))0 1301 y Fi(5)81
-b Fj(Delete)32 b(an)e(existing)i(k)m(eyw)m(ord)f(record.)382
-1550 y Ff(FTDKEY\(unit,keyword,)42 b(>)48 b(status\))0
-1705 y
-SDict begin H.S end
- 0 1705 a 0 1705 a
-SDict begin 13.6 H.A end
- 0 1705 a 0 1705 a
-SDict begin [/View [/XYZ H.V]/Dest (section.5.4) cvn /DEST pdfmark
-end
- 0 1705 a 176
-x Fe(5.4)135 b(Data)46 b(I/O)g(Routines)0 2132 y Fj(The)32
+TeXDict begin 33 38 bop 0 299 a Fh(5.4.)72 b(D)m(A)-8
+b(T)g(A)32 b(I/O)f(R)m(OUTINES)2650 b Fj(33)382 555 y
+Ff(FTGREC\(unit,key_no,)42 b(>)48 b(card,status\))0 804
+y Fi(4)81 b Fj(Get)31 b(a)g(k)m(eyw)m(ord)g(v)-5 b(alue)30
+b(\(with)h(the)f(appropriate)h(datat)m(yp)s(e\))g(and)f(commen)m(t)i
+(from)e(the)g(CHU)382 1052 y Ff(FTGKY[EDJKLS]\(unit,keywo)o(rd,)41
+b(>)48 b(keyval,comment,status\))0 1301 y Fi(5)81 b Fj(Delete)32
+b(an)e(existing)i(k)m(eyw)m(ord)f(record.)382 1550 y
+Ff(FTDKEY\(unit,keyword,)42 b(>)48 b(status\))0 1881
+y Fe(5.4)135 b(Data)46 b(I/O)g(Routines)0 2132 y Fj(The)32
 b(follo)m(wing)i(routines)e(read)h(or)f(write)h(data)g(v)-5
 b(alues)33 b(in)f(the)h(curren)m(t)f(HDU)i(of)e(the)h(FITS)f(\014le.)47
 b(Automatic)0 2245 y(datat)m(yp)s(e)28 b(con)m(v)m(ersion)h(will)e(b)s
 (e)g(attempted)h(for)g(n)m(umerical)f(datat)m(yp)s(es)i(if)e(the)g(sp)s
 (eci\014ed)g(datat)m(yp)s(e)h(is)f(di\013eren)m(t)0 2357
 y(from)j(the)g(actual)i(datat)m(yp)s(e)g(of)e(the)h(FITS)e(arra)m(y)i
 (or)f(table)i(column.)0 2606 y Fi(1)81 b Fj(W)-8 b(rite)31
@@ -9298,34 +7335,22 @@
 (ord,)j(if)227 5488 y(it)d(exists,)h(otherwise)f(b)m(y)f(the)g(datat)m
 (yp)s(e)h(of)f(the)h(column.)57 b(The)36 b(length)g(of)h(the)f
 (returned)f(strings)h(can)227 5601 y(b)s(e)29 b(determined)f(with)h
 (the)g(ftgcdw)g(routine.)40 b(The)28 b(follo)m(wing)j(TDISPn)c(displa)m
 (y)j(formats)f(are)g(curren)m(tly)227 5714 y(supp)s(orted:)p
 eop end
 %%Page: 34 40
-TeXDict begin 34 39 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.34) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(34)1747
-b Fh(CHAPTER)30 b(5.)111 b(BASIC)30 b(INTERF)-10 b(A)m(CE)30
-b(R)m(OUTINES)418 555 y Ff(Iw.m)142 b(Integer)418 668
-y(Ow.m)g(Octal)47 b(integer)418 781 y(Zw.m)142 b(Hexadecimal)45
-b(integer)418 894 y(Fw.d)142 b(Fixed)47 b(floating)e(point)418
-1007 y(Ew.d)142 b(Exponential)45 b(floating)h(point)418
-1120 y(Dw.d)142 b(Exponential)45 b(floating)h(point)418
-1233 y(Gw.d)142 b(General;)46 b(uses)g(Fw.d)h(if)g(significance)e(not)i
+TeXDict begin 34 39 bop 0 299 a Fj(34)1747 b Fh(CHAPTER)30
+b(5.)111 b(BASIC)30 b(INTERF)-10 b(A)m(CE)30 b(R)m(OUTINES)418
+555 y Ff(Iw.m)142 b(Integer)418 668 y(Ow.m)g(Octal)47
+b(integer)418 781 y(Zw.m)142 b(Hexadecimal)45 b(integer)418
+894 y(Fw.d)142 b(Fixed)47 b(floating)e(point)418 1007
+y(Ew.d)142 b(Exponential)45 b(floating)h(point)418 1120
+y(Dw.d)142 b(Exponential)45 b(floating)h(point)418 1233
+y(Gw.d)142 b(General;)46 b(uses)g(Fw.d)h(if)g(significance)e(not)i
 (lost,)f(else)h(Ew.d)227 1483 y Fj(where)24 b(w)h(is)f(the)h(width)f
 (in)g(c)m(haracters)i(of)f(the)g(displa)m(y)m(ed)g(v)-5
 b(alues,)27 b(m)d(is)h(the)f(minim)m(um)g(n)m(um)m(b)s(er)g(of)g
 (digits)227 1595 y(displa)m(y)m(ed,)31 b(and)e(d)h(is)f(the)i(n)m(um)m
 (b)s(er)d(of)i(digits)g(to)h(the)f(righ)m(t)h(of)f(the)g(decimal.)41
 b(The)29 b(.m)h(\014eld)g(is)g(optional.)382 1855 y Ff
 (FTGCV[SBIJKEDCM]\(unit,co)o(lnu)o(m,fr)o(ow,f)o(ele)o(m,ne)o(leme)o
@@ -9334,56 +7359,29 @@
 (and)g(full)g(name)h(of)g(the)f(column)h(whose)f(name)h(matc)m(hes)h
 (the)f(input)227 2341 y(template)35 b(string.)48 b(See)33
 b(the)h(`Adv)-5 b(anced)33 b(In)m(terface)h(Routines')f(c)m(hapter)h
 (for)f(a)g(full)g(description)g(of)g(this)227 2454 y(routine.)382
 2714 y Ff(FTGCNN\(unit,casesen,colt)o(emp)o(late)o(,)42
 b(>)47 b(colname,colnum,status\))p eop end
 %%Page: 35 41
-TeXDict begin 35 40 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.35) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0
-464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.6) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(6)0
+TeXDict begin 35 40 bop 0 1225 a Fg(Chapter)65 b(6)0
 1687 y Fm(Adv)-13 b(anced)78 b(In)-6 b(terface)77 b(Subroutines)0
 2180 y Fj(This)31 b(c)m(hapter)h(de\014nes)f(all)h(the)g(a)m(v)-5
 b(ailable)34 b(subroutines)d(in)g(the)h(FITSIO)e(user)h(in)m(terface.)
 46 b(F)-8 b(or)33 b(completeness,)0 2293 y(the)43 b(basic)g
 (subroutines)e(describ)s(ed)g(in)i(the)f(previous)h(c)m(hapter)g(are)g
 (also)g(rep)s(eated)g(here.)77 b(A)43 b(righ)m(t)g(arro)m(w)0
 2406 y(sym)m(b)s(ol)29 b(is)f(used)g(here)h(to)g(separate)h(the)f
 (input)f(parameters)h(from)f(the)h(output)g(parameters)g(in)f(the)h
 (de\014nition)0 2518 y(of)k(eac)m(h)h(subroutine.)47
 b(This)32 b(sym)m(b)s(ol)h(is)g(not)g(actually)i(part)d(of)h(the)h
 (calling)g(sequence.)49 b(An)32 b(alphab)s(etical)i(list)0
 2631 y(and)c(de\014nition)g(of)g(all)i(the)e(parameters)h(is)f(giv)m
-(en)i(at)f(the)f(end)g(of)h(this)f(section.)0 2782 y
-SDict begin H.S end
-
-0 2782 a 0 2782 a
-SDict begin 13.6 H.A end
- 0 2782 a 0 2782 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.1) cvn /DEST pdfmark
-end
- 0 2782 a 179 x Fe(6.1)135
-b(FITS)44 b(File)i(Op)t(en)e(and)h(Close)h(Subroutines:)0
+(en)i(at)f(the)f(end)g(of)h(this)f(section.)0 2961 y
+Fe(6.1)135 b(FITS)44 b(File)i(Op)t(en)e(and)h(Close)h(Subroutines:)0
 3197 y Fi(1)81 b Fj(Op)s(en)30 b(an)i(existing)g(FITS)g(\014le)f(with)h
 (readonly)g(or)g(readwrite)g(access.)46 b(The)31 b(FTDK)m(OPN)i
 (routine)e(simply)227 3310 y(op)s(ens)h(the)g(sp)s(eci\014ed)g(\014le)h
 (without)f(trying)h(to)g(in)m(terpret)g(the)f(\014lename)h(using)f(the)
 g(extended)h(\014lename)227 3423 y(syn)m(tax.)41 b(FTDOPN)28
 b(op)s(ens)e(the)i(\014le)g(and)f(also)i(mo)m(v)m(es)g(to)g(the)f
 (\014rst)f(HDU)h(con)m(taining)h(signi\014can)m(t)g(data,)227
@@ -9411,42 +7409,29 @@
 b(>)47 b(status\))0 5601 y Fi(3)81 b Fj(Reop)s(en)38
 b(a)i(FITS)e(\014le)i(that)f(w)m(as)h(previously)f(op)s(ened)f(with)h
 (FTOPEN,)g(FTNOPN,)g(or)h(FTINIT.)e(The)227 5714 y(newunit)f(n)m(um)m
 (b)s(er)f(ma)m(y)j(then)e(b)s(e)g(treated)i(as)f(a)g(separate)g
 (\014le,)i(and)d(one)h(ma)m(y)h(sim)m(ultaneously)f(read)1905
 5942 y(35)p eop end
 %%Page: 36 42
-TeXDict begin 36 41 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.36) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(36)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)227 555 y Fj(or)36 b(write)g(to)g(2)g
-(\(or)g(more\))g(di\013eren)m(t)g(extensions)g(in)f(the)h(same)g
-(\014le.)56 b(The)35 b(FTOPEN)g(and)g(FTNOPN)227 668
-y(routines)f(\(ab)s(o)m(v)m(e\))h(automatically)h(detects)f(cases)g
-(where)e(a)g(previously)h(op)s(ened)e(\014le)i(is)g(b)s(eing)f(op)s
-(ened)227 781 y(again,)c(and)e(then)g(in)m(ternally)h(call)g(FTREOPEN,)
-f(so)h(programs)e(should)h(rarely)g(need)g(to)h(explicitly)h(call)227
-894 y(this)i(routine.)334 1136 y Ff(FTREOPEN\(unit,)44
-b(>)j(newunit,)f(status\))0 1377 y Fi(4)81 b Fj(Op)s(en)24
-b(and)g(initialize)k(a)e(new)f(empt)m(y)g(FITS)g(\014le.)39
-b(The)25 b(FTDKINIT)g(routine)g(simply)g(creates)i(the)f(sp)s
-(eci\014ed)227 1490 y(\014le)31 b(without)f(trying)h(to)g(in)m(terpret)
-f(the)h(\014lename)g(using)e(the)i(extended)f(\014lename)h(syn)m(tax.)
-334 1732 y Ff(FTINIT\(unit,filename,bloc)o(ksi)o(ze,)41
+TeXDict begin 36 41 bop 0 299 a Fj(36)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)227 555 y Fj(or)36 b(write)g(to)g(2)g(\(or)g(more\))g
+(di\013eren)m(t)g(extensions)g(in)f(the)h(same)g(\014le.)56
+b(The)35 b(FTOPEN)g(and)g(FTNOPN)227 668 y(routines)f(\(ab)s(o)m(v)m
+(e\))h(automatically)h(detects)f(cases)g(where)e(a)g(previously)h(op)s
+(ened)e(\014le)i(is)g(b)s(eing)f(op)s(ened)227 781 y(again,)c(and)e
+(then)g(in)m(ternally)h(call)g(FTREOPEN,)f(so)h(programs)e(should)h
+(rarely)g(need)g(to)h(explicitly)h(call)227 894 y(this)i(routine.)334
+1136 y Ff(FTREOPEN\(unit,)44 b(>)j(newunit,)f(status\))0
+1377 y Fi(4)81 b Fj(Op)s(en)24 b(and)g(initialize)k(a)e(new)f(empt)m(y)
+g(FITS)g(\014le.)39 b(The)25 b(FTDKINIT)g(routine)g(simply)g(creates)i
+(the)f(sp)s(eci\014ed)227 1490 y(\014le)31 b(without)f(trying)h(to)g
+(in)m(terpret)f(the)h(\014lename)g(using)e(the)i(extended)f(\014lename)
+h(syn)m(tax.)334 1732 y Ff(FTINIT\(unit,filename,bloc)o(ksi)o(ze,)41
 b(>)48 b(status\))334 1845 y(FTDKINIT\(unit,filename,bl)o(ock)o(size)o
 (,)42 b(>)47 b(status\))0 2087 y Fi(5)81 b Fj(Create)24
 b(a)g(new)f(FITS)g(\014le,)i(using)e(a)h(template)h(\014le)e(to)i
 (de\014ne)d(its)i(initial)h(size)g(and)e(structure.)37
 b(The)24 b(template)227 2199 y(ma)m(y)39 b(b)s(e)f(another)h(FITS)e
 (HDU)i(or)g(an)f(ASCI)s(I)f(template)j(\014le.)64 b(If)38
 b(the)h(input)e(template)j(\014le)e(name)h(is)227 2312
@@ -9489,209 +7474,163 @@
 (range)g(50)227 5488 y(-)42 b(99)g(if)f(this)g(routine)g(is)g(also)h
 (to)g(b)s(e)f(used)f(in)h(the)g(same)h(program.)73 b(This)40
 b(routine)h(is)g(pro)m(vided)g(for)227 5601 y(con)m(v)m(enience)34
 b(only)-8 b(,)32 b(and)e(it)i(is)f(not)h(required)e(that)i(the)f(unit)g
 (n)m(um)m(b)s(ers)f(used)g(b)m(y)h(FITSIO)f(b)s(e)h(allo)s(cated)227
 5714 y(b)m(y)g(this)f(routine.)p eop end
 %%Page: 37 43
-TeXDict begin 37 42 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.37) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.1.)72
-b(FITS)30 b(FILE)g(OPEN)g(AND)h(CLOSE)e(SUBR)m(OUTINES:)1561
-b Fj(37)382 555 y Ff(FTGIOU\()46 b(>)h(iounit,)f(status\))0
-807 y Fi(10)g Fj(F)-8 b(ree)34 b(\(deallo)s(cate\))i(an)d(I/O)g(unit)f
+TeXDict begin 37 42 bop 0 299 a Fh(6.1.)72 b(FITS)30
+b(FILE)g(OPEN)g(AND)h(CLOSE)e(SUBR)m(OUTINES:)1561 b
+Fj(37)382 555 y Ff(FTGIOU\()46 b(>)h(iounit,)f(status\))0
+809 y Fi(10)g Fj(F)-8 b(ree)34 b(\(deallo)s(cate\))i(an)d(I/O)g(unit)f
 (n)m(um)m(b)s(er)g(whic)m(h)g(w)m(as)h(previously)g(allo)s(cated)i
-(with)e(FTGIOU.)g(All)g(pre-)227 919 y(viously)28 b(allo)s(cated)i
+(with)e(FTGIOU.)g(All)g(pre-)227 922 y(viously)28 b(allo)s(cated)i
 (unit)d(n)m(um)m(b)s(ers)f(ma)m(y)i(b)s(e)f(deallo)s(cated)j(at)e(once)
-h(b)m(y)e(calling)i(FTFIOU)f(with)f(iounit)h(=)227 1032
-y(-1.)382 1284 y Ff(FTFIOU\(iounit,)44 b(>)j(status\))0
-1535 y Fi(11)f Fj(Return)30 b(the)h(F)-8 b(ortran)31
+h(b)m(y)e(calling)i(FTFIOU)f(with)f(iounit)h(=)227 1034
+y(-1.)382 1288 y Ff(FTFIOU\(iounit,)44 b(>)j(status\))0
+1541 y Fi(11)f Fj(Return)30 b(the)h(F)-8 b(ortran)31
 b(unit)g(n)m(um)m(b)s(er)e(that)i(corresp)s(onds)f(to)h(the)g(C)g
 (\014ts\014le)f(p)s(oin)m(ter)h(v)-5 b(alue,)32 b(or)e(vice)i(v)m
-(ersa.)227 1648 y(These)37 b(2)h(C)f(routines)g(ma)m(y)g(b)s(e)g
+(ersa.)227 1654 y(These)37 b(2)h(C)f(routines)g(ma)m(y)g(b)s(e)g
 (useful)f(in)h(mixed)g(language)i(programs)e(where)f(b)s(oth)h(C)g(and)
-f(F)-8 b(ortran)227 1761 y(subroutines)25 b(need)g(to)i(access)g(the)f
+f(F)-8 b(ortran)227 1767 y(subroutines)25 b(need)g(to)i(access)g(the)f
 (same)g(\014le.)40 b(F)-8 b(or)26 b(example,)i(if)e(a)g(FITS)f(\014le)h
-(is)g(op)s(ened)f(with)g(unit)g(12)i(b)m(y)227 1874 y(a)k(F)-8
+(is)g(op)s(ened)f(with)g(unit)g(12)i(b)m(y)227 1880 y(a)k(F)-8
 b(ortran)31 b(subroutine,)f(then)g(a)h(C)f(routine)h(within)f(the)g
 (same)h(program)g(could)f(get)i(the)e(\014t\014le)h(p)s(oin)m(ter)227
-1987 y(v)-5 b(alue)39 b(to)f(access)h(the)f(same)h(\014le)f(b)m(y)f
+1993 y(v)-5 b(alue)39 b(to)f(access)h(the)f(same)h(\014le)f(b)m(y)f
 (calling)j('fptr)d(=)h(CUnit2FITS\(12\)'.)64 b(These)38
-b(routines)g(return)f(a)227 2100 y(v)-5 b(alue)31 b(of)g(zero)g(if)f
-(an)g(error)g(o)s(ccurs.)286 2351 y Ff(int)334 b(CFITS2Unit\(fitsfile)
-42 b(*ptr\);)286 2464 y(fitsfile*)k(CUnit2FITS\(int)e(unit\);)0
-2715 y Fi(11)i Fj(P)m(arse)32 b(the)g(input)e(\014lename)i(and)f
+b(routines)g(return)f(a)227 2106 y(v)-5 b(alue)31 b(of)g(zero)g(if)f
+(an)g(error)g(o)s(ccurs.)286 2359 y Ff(int)334 b(CFITS2Unit\(fitsfile)
+42 b(*ptr\);)286 2472 y(fitsfile*)k(CUnit2FITS\(int)e(unit\);)0
+2726 y Fi(11)i Fj(P)m(arse)32 b(the)g(input)e(\014lename)i(and)f
 (return)f(the)i(HDU)g(n)m(um)m(b)s(er)e(that)i(w)m(ould)f(b)s(e)g(mo)m
-(v)m(ed)i(to)f(if)f(the)h(\014le)f(w)m(ere)227 2828 y(op)s(ened)i(with)
+(v)m(ed)i(to)f(if)f(the)h(\014le)f(w)m(ere)227 2838 y(op)s(ened)i(with)
 g(FTNOPN.)g(The)f(returned)g(HDU)i(n)m(um)m(b)s(er)e(b)s(egins)h(with)g
 (1)g(for)g(the)g(primary)g(arra)m(y)-8 b(,)35 b(so)227
-2941 y(for)d(example,)g(if)g(the)g(input)f(\014lename)g(=)h(`m)m
+2951 y(for)d(example,)g(if)g(the)g(input)f(\014lename)g(=)h(`m)m
 (y\014le.\014ts[2]')h(then)e(hdun)m(um)e(=)j(3)g(will)g(b)s(e)f
-(returned.)43 b(FIT-)227 3054 y(SIO)35 b(do)s(es)h(not)g(op)s(en)g(the)
+(returned.)43 b(FIT-)227 3064 y(SIO)35 b(do)s(es)h(not)g(op)s(en)g(the)
 g(\014le)g(to)h(c)m(hec)m(k)h(if)e(the)g(extension)h(actually)h(exists)
-e(if)h(an)e(extension)i(n)m(um)m(b)s(er)227 3167 y(is)43
+e(if)h(an)e(extension)i(n)m(um)m(b)s(er)227 3177 y(is)43
 b(sp)s(eci\014ed.)75 b(If)42 b(an)g(extension)h(*name*)g(is)f(included)
 g(in)g(the)g(\014le)g(name)h(sp)s(eci\014cation)g(\(e.g.)77
-b(`m)m(y-)227 3280 y(\014le.\014ts[EVENTS]')30 b(then)f(this)h(routine)
+b(`m)m(y-)227 3290 y(\014le.\014ts[EVENTS]')30 b(then)f(this)h(routine)
 g(will)g(ha)m(v)m(e)h(to)f(op)s(en)f(the)h(FITS)f(\014le)h(and)f(lo)s
-(ok)h(for)g(the)g(p)s(osition)227 3393 y(of)38 b(the)h(named)e
+(ok)h(for)g(the)g(p)s(osition)227 3403 y(of)38 b(the)h(named)e
 (extension,)k(then)d(close)h(\014le)f(again.)64 b(This)38
 b(is)g(not)g(p)s(ossible)f(if)h(the)g(\014le)g(is)g(b)s(eing)g(read)227
-3506 y(from)e(the)g(stdin)f(stream,)j(and)d(an)h(error)f(will)h(b)s(e)g
+3516 y(from)e(the)g(stdin)f(stream,)j(and)d(an)h(error)f(will)h(b)s(e)g
 (returned)e(in)i(this)g(case.)58 b(If)35 b(the)h(\014lename)g(do)s(es)g
-(not)227 3619 y(sp)s(ecify)29 b(an)g(explicit)h(extension)g(\(e.g.)42
+(not)227 3629 y(sp)s(ecify)29 b(an)g(explicit)h(extension)g(\(e.g.)42
 b('m)m(y\014le.\014ts'\))30 b(then)f(hdun)m(um)e(=)h(-99)j(will)e(b)s
-(e)g(returned,)f(whic)m(h)h(is)227 3731 y(functionally)34
+(e)g(returned,)f(whic)m(h)h(is)227 3742 y(functionally)34
 b(equiv)-5 b(alen)m(t)35 b(to)g(hdun)m(um)c(=)i(1.)50
 b(This)33 b(routine)g(is)h(mainly)g(used)e(for)i(bac)m(kw)m(ard)g
-(compati-)227 3844 y(bilit)m(y)g(in)e(the)g(fto)s(ols)h(soft)m(w)m(are)
+(compati-)227 3855 y(bilit)m(y)g(in)e(the)g(fto)s(ols)h(soft)m(w)m(are)
 h(pac)m(k)-5 b(age)34 b(and)e(is)g(not)g(recommended)g(for)g(general)i
-(use.)46 b(It)32 b(is)h(generally)227 3957 y(b)s(etter)i(and)g(more)g
+(use.)46 b(It)32 b(is)h(generally)227 3968 y(b)s(etter)i(and)g(more)g
 (e\016cien)m(t)h(to)g(\014rst)e(op)s(en)g(the)h(FITS)f(\014le)h(with)g
-(FTNOPN,)g(then)g(use)f(FTGHDN)i(to)227 4070 y(determine)30
+(FTNOPN,)g(then)g(use)f(FTGHDN)i(to)227 4080 y(determine)30
 b(whic)m(h)g(HDU)g(in)f(the)h(\014le)g(has)g(b)s(een)f(op)s(ened,)g
 (rather)g(than)h(calling)h(FTEXTN)f(follo)m(w)m(ed)h(b)m(y)227
-4183 y(a)g(call)h(to)f(FTNOPN.)382 4434 y Ff(FTEXTN\(filename,)43
-b(>)48 b(nhdu,)e(status\))0 4686 y Fi(12)g Fj(Return)30
+4193 y(a)g(call)h(to)f(FTNOPN.)382 4447 y Ff(FTEXTN\(filename,)43
+b(>)48 b(nhdu,)e(status\))0 4700 y Fi(12)g Fj(Return)30
 b(the)g(name)h(of)f(the)h(op)s(ened)e(FITS)h(\014le.)382
-4937 y Ff(FTFLNM\(unit,)44 b(>)k(filename,)d(status\))0
-5188 y Fi(13)h Fj(Return)30 b(the)g(I/O)g(mo)s(de)g(of)h(the)g(op)s(en)
+4954 y Ff(FTFLNM\(unit,)44 b(>)k(filename,)d(status\))0
+5207 y Fi(13)h Fj(Return)30 b(the)g(I/O)g(mo)s(de)g(of)h(the)g(op)s(en)
 e(FITS)h(\014le)g(\(READONL)-8 b(Y)32 b(=)e(0,)h(READ)m(WRITE)g(=)f
-(1\).)382 5440 y Ff(FTFLMD\(unit,)44 b(>)k(iomode,)e(status\))0
-5691 y Fi(14)g Fj(Return)30 b(the)g(\014le)h(t)m(yp)s(e)f(of)h(the)f
+(1\).)382 5460 y Ff(FTFLMD\(unit,)44 b(>)k(iomode,)e(status\))0
+5714 y Fi(14)g Fj(Return)30 b(the)g(\014le)h(t)m(yp)s(e)f(of)h(the)f
 (op)s(ened)g(FITS)g(\014le)g(\(e.g.)42 b('\014le://',)32
 b('ftp://',)g(etc.\).)p eop end
 %%Page: 38 44
-TeXDict begin 38 43 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.38) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(38)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTURLT\(unit,)44
-b(>)k(urltype,)d(status\))0 819 y Fi(15)h Fj(P)m(arse)27
-b(the)f(input)f(\014lename)i(or)f(URL)g(in)m(to)h(its)g(comp)s(onen)m
-(t)f(parts:)39 b(the)26 b(\014le)g(t)m(yp)s(e)h(\(\014le://,)h(ftp://,)
-g(h)m(ttp://,)227 932 y(etc\),)34 b(the)e(base)g(input)e(\014le)i
-(name,)g(the)g(name)g(of)g(the)g(output)f(\014le)h(that)g(the)g(input)f
-(\014le)g(is)h(to)g(b)s(e)f(copied)227 1045 y(to)38 b(prior)e(to)h(op)s
-(ening,)h(the)f(HDU)g(or)f(extension)i(sp)s(eci\014cation,)h(the)e
-(\014ltering)f(sp)s(eci\014er,)i(the)f(binning)227 1157
-y(sp)s(eci\014er,)e(and)e(the)i(column)f(sp)s(eci\014er.)51
-b(Blank)34 b(strings)g(will)h(b)s(e)e(returned)g(for)h(an)m(y)g(comp)s
-(onen)m(ts)g(that)227 1270 y(are)d(not)g(presen)m(t)f(in)g(the)h(input)
-e(\014le)i(name.)334 1534 y Ff(FTIURL\(filename,)43 b(>)48
-b(filetype,)d(infile,)h(outfile,)g(extspec,)f(filter,)716
-1647 y(binspec,)g(colspec,)h(status\))0 1910 y Fi(16)g
-Fj(P)m(arse)e(the)g(input)f(\014le)h(name)f(and)g(return)g(the)h(ro)s
-(ot)g(\014le)f(name.)81 b(The)43 b(ro)s(ot)h(name)g(includes)f(the)h
-(\014le)227 2023 y(t)m(yp)s(e)35 b(if)g(sp)s(eci\014ed,)h(\(e.g.)56
-b('ftp://')37 b(or)e('h)m(ttp://'\))i(and)d(the)h(full)g(path)g(name,)h
-(to)g(the)f(exten)m(t)i(that)e(it)h(is)227 2136 y(sp)s(eci\014ed)26
-b(in)f(the)i(input)e(\014lename.)39 b(It)26 b(do)s(es)g(not)g(include)g
-(the)g(HDU)h(name)f(or)g(n)m(um)m(b)s(er,)g(or)g(an)m(y)h(\014ltering)
-227 2249 y(sp)s(eci\014cations.)334 2513 y Ff(FTRTNM\(filename,)43
-b(>)48 b(rootname,)d(status\))0 2776 y Fi(16)h Fj(T)-8
-b(est)36 b(if)g(the)g(input)f(\014le)h(or)f(a)i(compressed)e(v)m
-(ersion)h(of)g(the)g(\014le)g(\(with)g(a)g(.gz,)i(.Z,)e(.z,)i(or)e
-(.zip)g(extension\))227 2889 y(exists)j(on)f(disk.)63
+TeXDict begin 38 43 bop 0 299 a Fj(38)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTURLT\(unit,)44 b(>)k(urltype,)d
+(status\))0 821 y Fi(15)h Fj(P)m(arse)27 b(the)f(input)f(\014lename)i
+(or)f(URL)g(in)m(to)h(its)g(comp)s(onen)m(t)f(parts:)39
+b(the)26 b(\014le)g(t)m(yp)s(e)h(\(\014le://,)h(ftp://,)g(h)m(ttp://,)
+227 934 y(etc\),)34 b(the)e(base)g(input)e(\014le)i(name,)g(the)g(name)
+g(of)g(the)g(output)f(\014le)h(that)g(the)g(input)f(\014le)g(is)h(to)g
+(b)s(e)f(copied)227 1046 y(to)38 b(prior)e(to)h(op)s(ening,)h(the)f
+(HDU)g(or)f(extension)i(sp)s(eci\014cation,)h(the)e(\014ltering)f(sp)s
+(eci\014er,)i(the)f(binning)227 1159 y(sp)s(eci\014er,)e(and)e(the)i
+(column)f(sp)s(eci\014er.)51 b(Blank)34 b(strings)g(will)h(b)s(e)e
+(returned)g(for)h(an)m(y)g(comp)s(onen)m(ts)g(that)227
+1272 y(are)d(not)g(presen)m(t)f(in)g(the)h(input)e(\014le)i(name.)334
+1538 y Ff(FTIURL\(filename,)43 b(>)48 b(filetype,)d(infile,)h(outfile,)
+g(extspec,)f(filter,)716 1651 y(binspec,)g(colspec,)h(status\))0
+1916 y Fi(16)g Fj(P)m(arse)e(the)g(input)f(\014le)h(name)f(and)g
+(return)g(the)h(ro)s(ot)g(\014le)f(name.)81 b(The)43
+b(ro)s(ot)h(name)g(includes)f(the)h(\014le)227 2029 y(t)m(yp)s(e)35
+b(if)g(sp)s(eci\014ed,)h(\(e.g.)56 b('ftp://')37 b(or)e('h)m(ttp://'\))
+i(and)d(the)h(full)g(path)g(name,)h(to)g(the)f(exten)m(t)i(that)e(it)h
+(is)227 2142 y(sp)s(eci\014ed)26 b(in)f(the)i(input)e(\014lename.)39
+b(It)26 b(do)s(es)g(not)g(include)g(the)g(HDU)h(name)f(or)g(n)m(um)m(b)
+s(er,)g(or)g(an)m(y)h(\014ltering)227 2255 y(sp)s(eci\014cations.)334
+2520 y Ff(FTRTNM\(filename,)43 b(>)48 b(rootname,)d(status\))0
+2786 y Fi(16)h Fj(T)-8 b(est)36 b(if)g(the)g(input)f(\014le)h(or)f(a)i
+(compressed)e(v)m(ersion)h(of)g(the)g(\014le)g(\(with)g(a)g(.gz,)i(.Z,)
+e(.z,)i(or)e(.zip)g(extension\))227 2899 y(exists)j(on)f(disk.)63
 b(The)37 b(returned)g(v)-5 b(alue)38 b(of)g(the)h('exists')g(parameter)
 f(will)g(ha)m(v)m(e)i(1)e(of)g(the)g(4)g(follo)m(wing)227
-3002 y(v)-5 b(alues:)370 3257 y Ff(2:)95 b(the)47 b(file)g(does)g(not)f
+3011 y(v)-5 b(alues:)370 3270 y Ff(2:)95 b(the)47 b(file)g(does)g(not)f
 (exist,)h(but)f(a)i(compressed)d(version)h(does)g(exist)370
-3370 y(1:)95 b(the)47 b(disk)g(file)g(does)f(exist)370
-3483 y(0:)95 b(neither)46 b(the)h(file)g(nor)g(a)g(compressed)e
-(version)h(of)h(the)g(file)g(exist)323 3596 y(-1:)94
+3383 y(1:)95 b(the)47 b(disk)g(file)g(does)f(exist)370
+3496 y(0:)95 b(neither)46 b(the)h(file)g(nor)g(a)g(compressed)e
+(version)h(of)h(the)g(file)g(exist)323 3609 y(-1:)94
 b(the)47 b(input)g(file)f(name)h(is)g(not)g(a)g(disk)g(file)g(\(could)f
-(be)h(a)g(ftp,)g(http,)561 3709 y(smem,)g(or)g(mem)g(file,)f(or)h(a)h
+(be)h(a)g(ftp,)g(http,)561 3722 y(smem,)g(or)g(mem)g(file,)f(or)h(a)h
 (file)e(piped)h(in)g(on)g(the)g(STDIN)f(stream\))286
-3973 y(FTEXIST\(filename,)d(>)48 b(exists,)e(status\);)0
-4127 y
-SDict begin H.S end
- 0 4127 a 0 4127 a
-SDict begin 13.6 H.A end
- 0 4127 a 0 4127 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.2) cvn /DEST pdfmark
-end
- 0 4127 a 184
-x Fe(6.2)135 b(HDU-Lev)l(el)47 b(Op)t(erations)0 4562
-y Fj(When)30 b(a)h(FITS)f(\014le)g(is)h(\014rst)e(op)s(ened)h(or)g
+3987 y(FTEXIST\(filename,)d(>)48 b(exists,)e(status\);)0
+4327 y Fe(6.2)135 b(HDU-Lev)l(el)47 b(Op)t(erations)0
+4579 y Fj(When)30 b(a)h(FITS)f(\014le)g(is)h(\014rst)e(op)s(ened)h(or)g
 (created,)i(the)f(in)m(ternal)g(bu\013ers)e(in)h(FITSIO)f
-(automatically)34 b(p)s(oin)m(t)c(to)0 4675 y(the)g(\014rst)g(HDU)h(in)
+(automatically)34 b(p)s(oin)m(t)c(to)0 4692 y(the)g(\014rst)g(HDU)h(in)
 f(the)g(\014le.)41 b(The)29 b(follo)m(wing)j(routines)e(ma)m(y)h(b)s(e)
 e(used)h(to)h(mo)m(v)m(e)g(to)g(another)f(HDU)h(in)f(the)h(\014le.)0
-4788 y(Note)j(that)f(the)g(HDU)g(n)m(um)m(b)s(ering)f(con)m(v)m(en)m
+4805 y(Note)j(that)f(the)g(HDU)g(n)m(um)m(b)s(ering)f(con)m(v)m(en)m
 (tion)i(used)e(in)g(FITSIO)g(denotes)h(the)f(primary)g(arra)m(y)h(as)g
-(the)g(\014rst)0 4901 y(HDU,)e(the)g(\014rst)f(extension)h(in)f(a)g
+(the)g(\014rst)0 4918 y(HDU,)e(the)g(\014rst)f(extension)h(in)f(a)g
 (FITS)g(\014le)g(is)h(the)f(second)h(HDU,)g(and)f(so)h(on.)0
-5164 y Fi(1)81 b Fj(Mo)m(v)m(e)32 b(to)f(a)g(sp)s(eci\014ed)f
+5183 y Fi(1)81 b Fj(Mo)m(v)m(e)32 b(to)f(a)g(sp)s(eci\014ed)f
 (\(absolute\))h(HDU)g(in)g(the)f(FITS)g(\014le)g(\(nhdu)f(=)h(1)h(for)f
-(the)g(FITS)g(primary)f(arra)m(y\))382 5428 y Ff(FTMAHD\(unit,nhdu,)43
-b(>)k(hdutype,status\))0 5691 y Fi(2)81 b Fj(Mo)m(v)m(e)32
+(the)g(FITS)g(primary)f(arra)m(y\))382 5448 y Ff(FTMAHD\(unit,nhdu,)43
+b(>)k(hdutype,status\))0 5714 y Fi(2)81 b Fj(Mo)m(v)m(e)32
 b(to)f(a)g(new)f(\(existing\))i(HDU)f(forw)m(ard)f(or)g(bac)m(kw)m
 (ards)h(relativ)m(e)h(to)f(the)g(CHDU)p eop end
 %%Page: 39 45
-TeXDict begin 39 44 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.39) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.2.)72
-b(HDU-LEVEL)31 b(OPERA)-8 b(TIONS)2414 b Fj(39)382 555
-y Ff(FTMRHD\(unit,nmove,)43 b(>)k(hdutype,status\))0
-797 y Fi(3)81 b Fj(Mo)m(v)m(e)22 b(to)f(the)f(\(\014rst\))h(HDU)g(whic)
-m(h)f(has)g(the)g(sp)s(eci\014ed)g(extension)h(t)m(yp)s(e)f(and)g
-(EXTNAME)g(\(or)h(HDUNAME\))227 910 y(and)34 b(EXTVER)g(k)m(eyw)m(ord)h
-(v)-5 b(alues.)53 b(The)34 b(hdut)m(yp)s(e)f(parameter)i(ma)m(y)g(ha)m
-(v)m(e)g(a)g(v)-5 b(alue)35 b(of)f(IMA)m(GE)p 3665 910
-28 4 v 34 w(HDU)227 1023 y(\(0\),)43 b(ASCI)s(I)p 669
-1023 V 31 w(TBL)c(\(1\),)j(BINAR)-8 b(Y)p 1468 1023 V
-34 w(TBL)39 b(\(2\),)j(or)d(ANY)p 2234 1023 V 34 w(HDU)g(\(-1\))i
-(where)d(ANY)p 3173 1023 V 34 w(HDU)h(means)g(that)227
-1136 y(only)30 b(the)g(extname)h(and)e(extv)m(er)i(v)-5
-b(alues)30 b(will)g(b)s(e)f(used)g(to)i(lo)s(cate)g(the)f(correct)h
-(extension.)42 b(If)29 b(the)h(input)227 1249 y(v)-5
-b(alue)27 b(of)f(extv)m(er)h(is)f(0)g(then)g(the)g(EXTVER)g(k)m(eyw)m
-(ord)g(is)g(ignored)g(and)g(the)g(\014rst)f(HDU)i(with)e(a)i(matc)m
-(hing)227 1361 y(EXTNAME)g(\(or)g(HDUNAME\))h(k)m(eyw)m(ord)f(will)g(b)
-s(e)f(found.)38 b(If)26 b(no)h(matc)m(hing)h(HDU)f(is)g(found)e(in)h
-(the)h(\014le)227 1474 y(then)i(the)g(curren)m(t)g(HDU)h(will)f(remain)
-g(unc)m(hanged)g(and)g(a)g(status)g(=)g(BAD)p 2884 1474
-V 34 w(HDU)p 3123 1474 V 33 w(NUM)h(\(301\))h(will)f(b)s(e)227
-1587 y(returned.)382 1829 y Ff(FTMNHD\(unit,)44 b(hdutype,)i(extname,)f
-(extver,)h(>)i(status\))0 2071 y Fi(4)81 b Fj(Get)31
-b(the)g(n)m(um)m(b)s(er)e(of)h(the)h(curren)m(t)f(HDU)h(in)f(the)h
-(FITS)e(\014le)i(\(primary)f(arra)m(y)g(=)g(1\))382 2312
-y Ff(FTGHDN\(unit,)44 b(>)k(nhdu\))0 2554 y Fi(5)81 b
-Fj(Return)39 b(the)i(t)m(yp)s(e)g(of)g(the)g(curren)m(t)f(HDU)i(in)e
+TeXDict begin 39 44 bop 0 299 a Fh(6.2.)72 b(HDU-LEVEL)31
+b(OPERA)-8 b(TIONS)2414 b Fj(39)382 555 y Ff(FTMRHD\(unit,nmove,)43
+b(>)k(hdutype,status\))0 797 y Fi(3)81 b Fj(Mo)m(v)m(e)22
+b(to)f(the)f(\(\014rst\))h(HDU)g(whic)m(h)f(has)g(the)g(sp)s(eci\014ed)
+g(extension)h(t)m(yp)s(e)f(and)g(EXTNAME)g(\(or)h(HDUNAME\))227
+910 y(and)34 b(EXTVER)g(k)m(eyw)m(ord)h(v)-5 b(alues.)53
+b(The)34 b(hdut)m(yp)s(e)f(parameter)i(ma)m(y)g(ha)m(v)m(e)g(a)g(v)-5
+b(alue)35 b(of)f(IMA)m(GE)p 3665 910 28 4 v 34 w(HDU)227
+1023 y(\(0\),)43 b(ASCI)s(I)p 669 1023 V 31 w(TBL)c(\(1\),)j(BINAR)-8
+b(Y)p 1468 1023 V 34 w(TBL)39 b(\(2\),)j(or)d(ANY)p 2234
+1023 V 34 w(HDU)g(\(-1\))i(where)d(ANY)p 3173 1023 V
+34 w(HDU)h(means)g(that)227 1136 y(only)30 b(the)g(extname)h(and)e
+(extv)m(er)i(v)-5 b(alues)30 b(will)g(b)s(e)f(used)g(to)i(lo)s(cate)g
+(the)f(correct)h(extension.)42 b(If)29 b(the)h(input)227
+1249 y(v)-5 b(alue)27 b(of)f(extv)m(er)h(is)f(0)g(then)g(the)g(EXTVER)g
+(k)m(eyw)m(ord)g(is)g(ignored)g(and)g(the)g(\014rst)f(HDU)i(with)e(a)i
+(matc)m(hing)227 1361 y(EXTNAME)g(\(or)g(HDUNAME\))h(k)m(eyw)m(ord)f
+(will)g(b)s(e)f(found.)38 b(If)26 b(no)h(matc)m(hing)h(HDU)f(is)g
+(found)e(in)h(the)h(\014le)227 1474 y(then)i(the)g(curren)m(t)g(HDU)h
+(will)f(remain)g(unc)m(hanged)g(and)g(a)g(status)g(=)g(BAD)p
+2884 1474 V 34 w(HDU)p 3123 1474 V 33 w(NUM)h(\(301\))h(will)f(b)s(e)
+227 1587 y(returned.)382 1829 y Ff(FTMNHD\(unit,)44 b(hdutype,)i
+(extname,)f(extver,)h(>)i(status\))0 2071 y Fi(4)81 b
+Fj(Get)31 b(the)g(n)m(um)m(b)s(er)e(of)h(the)h(curren)m(t)f(HDU)h(in)f
+(the)h(FITS)e(\014le)i(\(primary)f(arra)m(y)g(=)g(1\))382
+2312 y Ff(FTGHDN\(unit,)44 b(>)k(nhdu\))0 2554 y Fi(5)81
+b Fj(Return)39 b(the)i(t)m(yp)s(e)g(of)g(the)g(curren)m(t)f(HDU)i(in)e
 (the)h(FITS)f(\014le.)71 b(The)41 b(p)s(ossible)f(v)-5
 b(alues)41 b(for)f(hdut)m(yp)s(e)g(are)227 2667 y(IMA)m(GE)p
 546 2667 V 34 w(HDU)31 b(\(0\),)h(ASCI)s(I)p 1242 2667
 V 31 w(TBL)e(\(1\),)i(or)e(BINAR)-8 b(Y)p 2133 2667 V
 34 w(TBL)30 b(\(2\).)382 2909 y Ff(FTGHDT\(unit,)44 b(>)k(hdutype,)d
 (status\))0 3150 y Fi(6)81 b Fj(Return)29 b(the)i(total)h(n)m(um)m(b)s
 (er)d(of)i(HDUs)f(in)h(the)f(FITS)g(\014le.)41 b(The)29
@@ -9725,118 +7664,93 @@
 h(that)f(the)h(4th)227 5246 y(parameter)25 b(\(the)g(length)g(of)f(eac)
 m(h)h(axis\))g(is)g(an)f(arra)m(y)h(of)f(64-bit)i(in)m(tegers)f(rather)
 f(than)g(an)g(arra)m(y)h(of)g(32-bit)227 5359 y(in)m(tegers.)382
 5601 y Ff(FTIIMG\(unit,bitpix,naxis)o(,na)o(xes,)41 b(>)48
 b(status\))382 5714 y(FTIIMGLL\(unit,bitpix,nax)o(is,)o(naxe)o(sll,)41
 b(>)47 b(status\))p eop end
 %%Page: 40 46
-TeXDict begin 40 45 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.40) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(40)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fi(9)81 b Fj(Insert)30
-b(a)i(new)f(ASCI)s(I)f(T)-8 b(ABLE)31 b(extension)h(immediately)h
-(follo)m(wing)f(the)g(CHDU.)g(An)m(y)f(follo)m(wing)i(exten-)227
-668 y(sions)26 b(will)g(b)s(e)f(shifted)g(do)m(wn)g(to)h(mak)m(e)h(ro)s
-(om)e(for)h(the)f(new)g(extension.)40 b(If)25 b(there)h(are)g(no)g
-(other)f(follo)m(wing)227 781 y(extensions)32 b(then)f(the)h(new)f
-(table)h(extension)g(will)g(simply)f(b)s(e)g(app)s(ended)f(to)i(the)f
-(end)g(of)h(the)f(\014le.)44 b(The)227 894 y(new)33 b(extension)h(will)
-f(b)s(ecome)h(the)f(CHDU.)h(The)f(FTIT)-8 b(ABLL)33 b(routine)g(is)g
-(iden)m(tical)i(to)f(the)g(FTIT)-8 b(AB)227 1007 y(routine)36
-b(except)g(that)g(the)f(2nd)g(and)g(3rd)g(parameters)g(\(that)i(giv)m
-(e)g(the)e(size)h(of)g(the)f(table\))i(are)f(64-bit)227
-1120 y(in)m(tegers)c(rather)e(than)g(32-bit)i(in)m(tegers.)382
-1374 y Ff(FTITAB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o(ype)o(,tbc)o
-(ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42 b(>)716
-1487 y(status\))382 1600 y(FTITABLL\(unit,rowlenll,n)o(row)o(sll,)o
-(tfie)o(lds)o(,tty)o(pe,t)o(bco)o(l,tf)o(orm,)o(tun)o(it,e)o(xtna)o
-(me,)f(>)716 1713 y(status\))0 1968 y Fi(10)46 b Fj(Insert)25
-b(a)h(new)f(binary)f(table)j(extension)f(immediately)g(follo)m(wing)h
-(the)f(CHDU.)g(An)m(y)g(follo)m(wing)g(extensions)227
-2081 y(will)39 b(b)s(e)f(shifted)g(do)m(wn)g(to)h(mak)m(e)g(ro)s(om)g
+TeXDict begin 40 45 bop 0 299 a Fj(40)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fi(9)81 b Fj(Insert)30 b(a)i(new)f(ASCI)s(I)f
+(T)-8 b(ABLE)31 b(extension)h(immediately)h(follo)m(wing)f(the)g(CHDU.)
+g(An)m(y)f(follo)m(wing)i(exten-)227 668 y(sions)26 b(will)g(b)s(e)f
+(shifted)g(do)m(wn)g(to)h(mak)m(e)h(ro)s(om)e(for)h(the)f(new)g
+(extension.)40 b(If)25 b(there)h(are)g(no)g(other)f(follo)m(wing)227
+781 y(extensions)32 b(then)f(the)h(new)f(table)h(extension)g(will)g
+(simply)f(b)s(e)g(app)s(ended)f(to)i(the)f(end)g(of)h(the)f(\014le.)44
+b(The)227 894 y(new)33 b(extension)h(will)f(b)s(ecome)h(the)f(CHDU.)h
+(The)f(FTIT)-8 b(ABLL)33 b(routine)g(is)g(iden)m(tical)i(to)f(the)g
+(FTIT)-8 b(AB)227 1007 y(routine)36 b(except)g(that)g(the)f(2nd)g(and)g
+(3rd)g(parameters)g(\(that)i(giv)m(e)g(the)e(size)h(of)g(the)f(table\))
+i(are)f(64-bit)227 1120 y(in)m(tegers)c(rather)e(than)g(32-bit)i(in)m
+(tegers.)382 1377 y Ff(FTITAB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o
+(ype)o(,tbc)o(ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42
+b(>)716 1490 y(status\))382 1603 y(FTITABLL\(unit,rowlenll,n)o(row)o
+(sll,)o(tfie)o(lds)o(,tty)o(pe,t)o(bco)o(l,tf)o(orm,)o(tun)o(it,e)o
+(xtna)o(me,)f(>)716 1716 y(status\))0 1974 y Fi(10)46
+b Fj(Insert)25 b(a)h(new)f(binary)f(table)j(extension)f(immediately)g
+(follo)m(wing)h(the)f(CHDU.)g(An)m(y)g(follo)m(wing)g(extensions)227
+2087 y(will)39 b(b)s(e)f(shifted)g(do)m(wn)g(to)h(mak)m(e)g(ro)s(om)g
 (for)f(the)g(new)g(extension.)66 b(If)38 b(there)h(are)f(no)h(other)f
-(follo)m(wing)227 2194 y(extensions)f(then)g(the)f(new)g(bin)m(table)h
+(follo)m(wing)227 2199 y(extensions)f(then)g(the)f(new)g(bin)m(table)h
 (extension)h(will)f(simply)f(b)s(e)g(app)s(ended)e(to)k(the)e(end)g(of)
-h(the)g(\014le.)227 2307 y(The)23 b(new)g(extension)h(will)f(b)s(ecome)
+h(the)g(\014le.)227 2312 y(The)23 b(new)g(extension)h(will)f(b)s(ecome)
 h(the)f(CHDU.)h(The)f(FTIBINLL)g(routine)g(is)g(iden)m(tical)i(to)f
-(the)g(FTIBIN)227 2419 y(routine)30 b(except)i(that)e(the)h(2nd)e
+(the)g(FTIBIN)227 2425 y(routine)30 b(except)i(that)e(the)h(2nd)e
 (parameter)i(\(that)g(giv)m(es)g(the)g(length)f(of)h(the)f(table\))h
-(is)g(a)f(64-bit)i(in)m(teger)227 2532 y(rather)f(than)f(a)g(32-bit)i
-(in)m(teger.)382 2787 y Ff(FTIBIN\(unit,nrows,tfield)o(s,t)o(type)o
+(is)g(a)f(64-bit)i(in)m(teger)227 2538 y(rather)f(than)f(a)g(32-bit)i
+(in)m(teger.)382 2796 y Ff(FTIBIN\(unit,nrows,tfield)o(s,t)o(type)o
 (,tfo)o(rm,)o(tuni)o(t,ex)o(tna)o(me,v)o(arid)o(at)41
-b(>)48 b(status\))382 2900 y(FTIBINLL\(unit,nrowsll,tf)o(iel)o(ds,t)o
+b(>)48 b(status\))382 2909 y(FTIBINLL\(unit,nrowsll,tf)o(iel)o(ds,t)o
 (type)o(,tf)o(orm,)o(tuni)o(t,e)o(xtna)o(me,v)o(ari)o(dat)41
-b(>)48 b(status\))0 3267 y Fi(11)e Fj(Resize)26 b(an)e(image)i(b)m(y)e
+b(>)48 b(status\))0 3279 y Fi(11)e Fj(Resize)26 b(an)e(image)i(b)m(y)e
 (mo)s(di\014ng)f(the)i(size,)i(dimensions,)e(and/or)f(datat)m(yp)s(e)h
-(of)g(the)g(curren)m(t)f(primary)f(arra)m(y)227 3380
+(of)g(the)g(curren)m(t)f(primary)f(arra)m(y)227 3392
 y(or)29 b(image)i(extension.)40 b(If)29 b(the)g(new)g(image,)i(as)e(sp)
 s(eci\014ed)f(b)m(y)h(the)g(input)f(argumen)m(ts,)i(is)f(larger)h(than)
-f(the)227 3493 y(curren)m(t)34 b(existing)h(image)g(in)f(the)g(FITS)f
+f(the)227 3505 y(curren)m(t)34 b(existing)h(image)g(in)f(the)g(FITS)f
 (\014le)h(then)f(zero)i(\014ll)f(data)h(will)f(b)s(e)f(inserted)h(at)g
-(the)g(end)g(of)g(the)227 3606 y(curren)m(t)25 b(image)h(and)e(an)m(y)i
+(the)g(end)g(of)g(the)227 3618 y(curren)m(t)25 b(image)h(and)e(an)m(y)i
 (follo)m(wing)g(extensions)g(will)f(b)s(e)f(mo)m(v)m(ed)i(further)e
 (bac)m(k)h(in)g(the)g(\014le.)39 b(Similarly)-8 b(,)27
-b(if)227 3719 y(the)h(new)e(image)j(is)e(smaller)h(than)f(the)g(curren)
+b(if)227 3731 y(the)h(new)e(image)j(is)e(smaller)h(than)f(the)g(curren)
 m(t)g(image)h(then)f(an)m(y)h(follo)m(wing)h(extensions)e(will)h(b)s(e)
-e(shifted)227 3832 y(up)32 b(to)m(w)m(ards)i(the)g(b)s(eginning)e(of)h
+e(shifted)227 3844 y(up)32 b(to)m(w)m(ards)i(the)g(b)s(eginning)e(of)h
 (the)h(FITS)e(\014le)h(and)g(the)g(image)h(data)g(will)g(b)s(e)e
-(truncated)h(to)h(the)f(new)227 3945 y(size.)41 b(This)25
+(truncated)h(to)h(the)f(new)227 3957 y(size.)41 b(This)25
 b(routine)h(rewrites)h(the)f(BITPIX,)h(NAXIS,)f(and)g(NAXISn)g(k)m(eyw)
-m(ords)g(with)g(the)h(appropriate)227 4058 y(v)-5 b(alues)37
+m(ords)g(with)g(the)h(appropriate)227 4070 y(v)-5 b(alues)37
 b(for)f(new)h(image.)60 b(The)36 b(FTRSIMLL)g(routine)g(is)h(iden)m
-(tical)h(to)g(the)e(FTRSIM)g(routine)h(except)227 4171
+(tical)h(to)g(the)e(FTRSIM)g(routine)h(except)227 4183
 y(that)30 b(the)g(4th)g(parameter)g(\(the)g(length)g(of)f(eac)m(h)i
 (axis\))f(is)g(an)f(arra)m(y)h(of)g(64-bit)h(in)m(tegers)f(rather)g
-(than)f(an)227 4284 y(arra)m(y)i(of)g(32-bit)g(in)m(tegers.)382
-4538 y Ff(FTRSIM\(unit,bitpix,naxis)o(,na)o(xes,)o(stat)o(us\))382
-4651 y(FTRSIMLL\(unit,bitpix,nax)o(is,)o(naxe)o(sll,)o(sta)o(tus\))0
-4906 y Fi(12)46 b Fj(Delete)34 b(the)f(CHDU)g(in)f(the)g(FITS)f
+(than)f(an)227 4295 y(arra)m(y)i(of)g(32-bit)g(in)m(tegers.)382
+4553 y Ff(FTRSIM\(unit,bitpix,naxis)o(,na)o(xes,)o(stat)o(us\))382
+4666 y(FTRSIMLL\(unit,bitpix,nax)o(is,)o(naxe)o(sll,)o(sta)o(tus\))0
+4924 y Fi(12)46 b Fj(Delete)34 b(the)f(CHDU)g(in)f(the)g(FITS)f
 (\014le.)47 b(An)m(y)32 b(follo)m(wing)i(HDUs)f(will)g(b)s(e)e(shifted)
-h(forw)m(ard)g(in)g(the)g(\014le,)h(to)227 5019 y(\014ll)38
+h(forw)m(ard)g(in)g(the)g(\014le,)h(to)227 5036 y(\014ll)38
 b(in)f(the)g(gap)h(created)g(b)m(y)g(the)f(deleted)h(HDU.)h(In)d(the)i
 (case)g(of)g(deleting)g(the)g(primary)e(arra)m(y)i(\(the)227
-5132 y(\014rst)30 b(HDU)h(in)f(the)h(\014le\))g(then)f(the)h(curren)m
+5149 y(\014rst)30 b(HDU)h(in)f(the)h(\014le\))g(then)f(the)h(curren)m
 (t)f(primary)f(arra)m(y)i(will)g(b)s(e)f(replace)h(b)m(y)g(a)g(n)m(ull)
-f(primary)f(arra)m(y)227 5245 y(con)m(taining)k(the)f(minim)m(um)e(set)
+f(primary)f(arra)m(y)227 5262 y(con)m(taining)k(the)f(minim)m(um)e(set)
 i(of)g(required)e(k)m(eyw)m(ords)i(and)e(no)i(data.)44
-b(If)31 b(there)g(are)h(more)f(extensions)227 5357 y(in)f(the)g(\014le)
+b(If)31 b(there)g(are)h(more)f(extensions)227 5375 y(in)f(the)g(\014le)
 g(follo)m(wing)i(the)e(one)g(that)h(is)f(deleted,)h(then)f(the)g(the)g
 (CHDU)h(will)f(b)s(e)g(rede\014ned)e(to)j(p)s(oin)m(t)f(to)227
-5470 y(the)d(follo)m(wing)h(extension.)41 b(If)26 b(there)h(are)g(no)g
+5488 y(the)d(follo)m(wing)h(extension.)41 b(If)26 b(there)h(are)g(no)g
 (follo)m(wing)h(extensions)f(then)g(the)g(CHDU)g(will)g(b)s(e)f
-(rede\014ned)227 5583 y(to)35 b(p)s(oin)m(t)f(to)h(the)f(previous)f
+(rede\014ned)227 5601 y(to)35 b(p)s(oin)m(t)f(to)h(the)f(previous)f
 (HDU.)i(The)e(output)h(HDUTYPE)g(parameter)h(indicates)f(the)h(t)m(yp)s
-(e)f(of)g(the)227 5696 y(new)c(CHDU)h(after)g(the)f(previous)g(CHDU)h
+(e)f(of)g(the)227 5714 y(new)c(CHDU)h(after)g(the)f(previous)g(CHDU)h
 (has)f(b)s(een)g(deleted.)p eop end
 %%Page: 41 47
-TeXDict begin 41 46 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.41) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.3.)72
-b(DEFINE)31 b(OR)f(REDEFINE)h(THE)f(STR)m(UCTURE)f(OF)h(THE)g(CHDU)1042
+TeXDict begin 41 46 bop 0 299 a Fh(6.3.)72 b(DEFINE)31
+b(OR)f(REDEFINE)h(THE)f(STR)m(UCTURE)f(OF)h(THE)g(CHDU)1042
 b Fj(41)382 555 y Ff(FTDHDU\(unit,)44 b(>)k(hdutype,status\))0
 828 y Fi(13)e Fj(Cop)m(y)36 b(all)h(or)f(part)g(of)g(the)g(input)f
 (FITS)g(\014le)h(and)g(app)s(end)e(it)i(to)h(the)f(end)g(of)g(the)g
 (output)g(FITS)f(\014le.)57 b(If)227 941 y('previous')39
 b(\(an)g(in)m(teger)h(parameter\))g(is)f(not)g(equal)g(to)h(0,)h(then)e
 (an)m(y)g(HDUs)g(preceding)g(the)g(curren)m(t)227 1054
 y(HDU)f(in)e(the)h(input)e(\014le)i(will)g(b)s(e)f(copied)h(to)g(the)g
@@ -9881,576 +7795,437 @@
 (also)f(b)s(e)f(useful)f(in)i(certain)g(application)h(programs)e(whic)m
 (h)g(w)m(an)m(t)h(to)227 4386 y(cop)m(y)j(the)f(data)h(from)f(one)g
 (FITS)f(\014le)h(to)h(another)f(but)g(also)h(w)m(an)m(t)g(to)g(mo)s
 (dify)e(the)h(header)g(k)m(eyw)m(ords)g(in)227 4499 y(the)j(pro)s
 (cess.)44 b(all)33 b(the)f(required)f(header)g(k)m(eyw)m(ords)h(m)m
 (ust)g(b)s(e)f(written)h(to)g(the)g(OUNIT)f(CHDU)h(b)s(efore)227
 4612 y(calling)g(this)e(routine)382 4885 y Ff(FTCPDT\(iunit,ounit,)42
-b(>)48 b(status\))0 5051 y
-SDict begin H.S end
- 0 5051 a 0 5051 a
-SDict begin 13.6 H.A end
- 0 5051 a
-0 5051 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.3) cvn /DEST pdfmark
-end
- 0 5051 a 184 x Fe(6.3)135 b(De\014ne)45 b(or)g(Rede\014ne)h
+b(>)48 b(status\))0 5235 y Fe(6.3)135 b(De\014ne)45 b(or)g(Rede\014ne)h
 (the)f(structure)g(of)g(the)g(CHDU)0 5488 y Fj(It)32
 b(should)f(rarely)h(b)s(e)g(necessary)g(to)h(call)g(the)f(subroutines)f
 (in)g(this)h(section.)47 b(FITSIO)30 b(in)m(ternally)j(calls)g(these)0
 5601 y(routines)h(whenev)m(er)g(necessary)-8 b(,)36 b(so)e(an)m(y)g
 (calls)h(to)g(these)f(routines)g(b)m(y)g(application)h(programs)f(will)
 g(lik)m(ely)i(b)s(e)0 5714 y(redundan)m(t.)p eop end
 %%Page: 42 48
-TeXDict begin 42 47 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.42) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(42)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fi(1)81 b Fj(This)36
-b(routine)h(forces)h(FITSIO)e(to)i(scan)f(the)g(curren)m(t)g(header)g
-(k)m(eyw)m(ords)h(that)f(de\014ne)g(the)g(structure)g(of)227
-668 y(the)31 b(HDU)f(\(suc)m(h)g(as)h(the)f(NAXISn,)g(PCOUNT)f(and)g
-(GCOUNT)h(k)m(eyw)m(ords\))h(so)f(that)h(it)f(can)h(initialize)227
+TeXDict begin 42 47 bop 0 299 a Fj(42)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fi(1)81 b Fj(This)36 b(routine)h(forces)h
+(FITSIO)e(to)i(scan)f(the)g(curren)m(t)g(header)g(k)m(eyw)m(ords)h
+(that)f(de\014ne)g(the)g(structure)g(of)227 668 y(the)31
+b(HDU)f(\(suc)m(h)g(as)h(the)f(NAXISn,)g(PCOUNT)f(and)g(GCOUNT)h(k)m
+(eyw)m(ords\))h(so)f(that)h(it)f(can)h(initialize)227
 781 y(the)36 b(in)m(ternal)g(bu\013ers)e(that)i(describ)s(e)f(the)h
 (HDU)g(structure.)55 b(This)35 b(routine)h(ma)m(y)g(b)s(e)e(used)h
 (instead)h(of)227 894 y(the)j(more)g(complicated)i(calls)f(to)f(ftp)s
 (def,)h(ftadef)f(or)g(ftb)s(def.)65 b(This)38 b(routine)h(is)g(also)h
 (v)m(ery)f(useful)f(for)227 1007 y(reinitializing)e(the)e(structure)g
 (of)g(an)f(HDU,)i(if)f(the)g(n)m(um)m(b)s(er)e(of)i(ro)m(ws)g(in)g(a)g
 (table,)i(as)e(sp)s(eci\014ed)f(b)m(y)h(the)227 1120
 y(NAXIS2)d(k)m(eyw)m(ord,)g(has)f(b)s(een)g(mo)s(di\014ed)f(from)h(its)
-h(initial)g(v)-5 b(alue.)382 1361 y Ff(FTRDEF\(unit,)44
-b(>)k(status\))141 b(\(DEPRECATED\))0 1602 y Fi(2)81
+h(initial)g(v)-5 b(alue.)382 1363 y Ff(FTRDEF\(unit,)44
+b(>)k(status\))141 b(\(DEPRECATED\))0 1606 y Fi(2)81
 b Fj(De\014ne)27 b(the)g(structure)g(of)g(the)g(primary)f(arra)m(y)i
 (or)f(IMA)m(GE)h(extension.)40 b(When)27 b(writing)g(GR)m(OUP)m(ed)h
-(FITS)227 1715 y(\014les)43 b(that)h(b)m(y)e(con)m(v)m(en)m(tion)k(set)
+(FITS)227 1719 y(\014les)43 b(that)h(b)m(y)e(con)m(v)m(en)m(tion)k(set)
 d(the)g(NAXIS1)g(k)m(eyw)m(ord)h(equal)f(to)h(0,)i(ftp)s(def)c(m)m(ust)
-h(b)s(e)f(called)i(with)227 1828 y(naxes\(1\))27 b(=)e(1,)i(NOT)e(0,)i
+h(b)s(e)f(called)i(with)227 1832 y(naxes\(1\))27 b(=)e(1,)i(NOT)e(0,)i
 (otherwise)f(FITSIO)e(will)i(rep)s(ort)f(an)g(error)g(status=308)i
-(when)d(trying)i(to)g(write)227 1941 y(data)31 b(to)g(a)g(group.)40
+(when)d(trying)i(to)g(write)227 1945 y(data)31 b(to)g(a)g(group.)40
 b(Note:)i(it)31 b(is)g(usually)f(simpler)g(to)h(call)h(FTRDEF)e(rather)
-h(than)f(this)g(routine.)382 2182 y Ff(FTPDEF\(unit,bitpix,naxis)o(,na)
+h(than)f(this)g(routine.)382 2188 y Ff(FTPDEF\(unit,bitpix,naxis)o(,na)
 o(xes,)o(pcou)o(nt,)o(gcou)o(nt,)41 b(>)48 b(status\))93
-b(\(DEPRECATED\))0 2424 y Fi(3)81 b Fj(De\014ne)32 b(the)h(structure)f
+b(\(DEPRECATED\))0 2431 y Fi(3)81 b Fj(De\014ne)32 b(the)h(structure)f
 (of)g(an)h(ASCI)s(I)e(table)i(\(T)-8 b(ABLE\))33 b(extension.)48
 b(Note:)e(it)33 b(is)f(usually)g(simpler)g(to)i(call)227
-2537 y(FTRDEF)d(rather)f(than)h(this)f(routine.)382 2778
+2544 y(FTRDEF)d(rather)f(than)h(this)f(routine.)382 2787
 y Ff(FTADEF\(unit,rowlen,tfiel)o(ds,)o(tbco)o(l,tf)o(orm)o(,nro)o(ws)42
-b(>)47 b(status\))f(\(DEPRECATED\))0 3019 y Fi(4)81 b
+b(>)47 b(status\))f(\(DEPRECATED\))0 3030 y Fi(4)81 b
 Fj(De\014ne)35 b(the)h(structure)f(of)g(a)h(binary)f(table)h(\(BINT)-8
 b(ABLE\))37 b(extension.)56 b(Note:)d(it)36 b(is)f(usually)g(simpler)g
-(to)227 3132 y(call)d(FTRDEF)f(rather)f(than)g(this)g(routine.)382
-3373 y Ff(FTBDEF\(unit,tfields,tfor)o(m,v)o(arid)o(at,n)o(row)o(s)42
-b(>)47 b(status\))f(\(DEPRECATED\))0 3615 y Fi(5)81 b
+(to)227 3143 y(call)d(FTRDEF)f(rather)f(than)g(this)g(routine.)382
+3386 y Ff(FTBDEF\(unit,tfields,tfor)o(m,v)o(arid)o(at,n)o(row)o(s)42
+b(>)47 b(status\))f(\(DEPRECATED\))0 3630 y Fi(5)81 b
 Fj(De\014ne)34 b(the)g(size)h(of)f(the)g(Curren)m(t)f(Data)i(Unit,)h(o)
 m(v)m(erriding)e(the)g(length)h(of)f(the)g(data)h(unit)e(as)h
-(previously)227 3728 y(de\014ned)e(b)m(y)h(ftp)s(def,)g(ftadef,)i(or)e
+(previously)227 3742 y(de\014ned)e(b)m(y)h(ftp)s(def,)g(ftadef,)i(or)e
 (ftb)s(def.)48 b(This)33 b(is)g(useful)f(if)i(one)f(do)s(es)g(not)h
-(kno)m(w)f(the)g(total)i(size)f(of)g(the)227 3841 y(data)f(unit)f(un)m
+(kno)m(w)f(the)g(total)i(size)f(of)g(the)227 3855 y(data)f(unit)f(un)m
 (til)h(after)f(the)h(data)g(ha)m(v)m(e)g(b)s(een)f(written.)46
 b(The)32 b(size)h(\(in)f(b)m(ytes\))h(of)g(an)f(ASCI)s(I)f(or)h(Binary)
-227 3954 y(table)27 b(is)f(giv)m(en)g(b)m(y)g(NAXIS1)g(*)g(NAXIS2.)40
+227 3968 y(table)27 b(is)f(giv)m(en)g(b)m(y)g(NAXIS1)g(*)g(NAXIS2.)40
 b(\(Note)27 b(that)f(to)h(determine)f(the)f(v)-5 b(alue)27
-b(of)f(NAXIS1)f(it)i(is)f(often)227 4066 y(more)32 b(con)m(v)m(enien)m
+b(of)f(NAXIS1)f(it)i(is)f(often)227 4081 y(more)32 b(con)m(v)m(enien)m
 (t)h(to)f(read)f(the)g(v)-5 b(alue)32 b(of)f(the)h(NAXIS1)f(k)m(eyw)m
 (ord)h(from)e(the)i(output)e(\014le,)i(rather)f(than)227
-4179 y(computing)f(the)g(ro)m(w)g(length)h(directly)f(from)f(all)i(the)
+4194 y(computing)f(the)g(ro)m(w)g(length)h(directly)f(from)f(all)i(the)
 f(TF)m(ORM)h(k)m(eyw)m(ord)f(v)-5 b(alues\).)41 b(Note:)h(it)30
-b(is)g(usually)227 4292 y(simpler)g(to)h(call)h(FTRDEF)f(rather)f(than)
-g(this)g(routine.)382 4534 y Ff(FTDDEF\(unit,bytlen,)42
-b(>)48 b(status\))e(\(DEPRECATED\))0 4775 y Fi(6)81 b
+b(is)g(usually)227 4307 y(simpler)g(to)h(call)h(FTRDEF)f(rather)f(than)
+g(this)g(routine.)382 4550 y Ff(FTDDEF\(unit,bytlen,)42
+b(>)48 b(status\))e(\(DEPRECATED\))0 4793 y Fi(6)81 b
 Fj(De\014ne)22 b(the)g(zero)i(indexed)d(b)m(yte)i(o\013set)g(of)g(the)f
 ('heap')h(measured)e(from)h(the)h(start)g(of)f(the)g(binary)g(table)h
-(data.)227 4888 y(By)30 b(default)g(the)f(heap)h(is)f(assumed)g(to)h
+(data.)227 4906 y(By)30 b(default)g(the)f(heap)h(is)f(assumed)g(to)h
 (start)g(immediately)h(follo)m(wing)g(the)f(regular)f(table)i(data,)f
-(i.e.,)h(at)227 5001 y(lo)s(cation)38 b(NAXIS1)f(x)g(NAXIS2.)59
+(i.e.,)h(at)227 5019 y(lo)s(cation)38 b(NAXIS1)f(x)g(NAXIS2.)59
 b(This)36 b(routine)g(is)h(only)f(relev)-5 b(an)m(t)38
-b(for)e(binary)g(tables)h(whic)m(h)g(con)m(tain)227 5114
+b(for)e(binary)g(tables)h(whic)m(h)g(con)m(tain)227 5132
 y(v)-5 b(ariable)36 b(length)g(arra)m(y)f(columns)g(\(with)h(TF)m(ORMn)
 f(=)f('Pt'\).)57 b(This)34 b(subroutine)g(also)i(automatically)227
-5227 y(writes)23 b(the)g(v)-5 b(alue)23 b(of)g(theap)g(to)h(a)f(k)m
+5245 y(writes)23 b(the)g(v)-5 b(alue)23 b(of)g(theap)g(to)h(a)f(k)m
 (eyw)m(ord)g(in)g(the)g(extension)g(header.)38 b(This)22
-b(subroutine)g(m)m(ust)h(b)s(e)f(called)227 5339 y(after)27
+b(subroutine)g(m)m(ust)h(b)s(e)f(called)227 5358 y(after)27
 b(the)f(required)f(k)m(eyw)m(ords)i(ha)m(v)m(e)g(b)s(een)e(written)h
 (\(with)g(ftph)m(bn\))f(and)h(after)g(the)h(table)g(structure)e(has)227
-5452 y(b)s(een)30 b(de\014ned)f(\(with)h(ftb)s(def)7
+5471 y(b)s(een)30 b(de\014ned)f(\(with)h(ftb)s(def)7
 b(\))30 b(but)g(b)s(efore)g(an)m(y)g(data)h(is)g(written)f(to)h(the)g
-(table.)382 5694 y Ff(FTPTHP\(unit,theap,)43 b(>)k(status\))p
+(table.)382 5714 y Ff(FTPTHP\(unit,theap,)43 b(>)k(status\))p
 eop end
 %%Page: 43 49
-TeXDict begin 43 48 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.43) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.4.)72
-b(FITS)30 b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(43)0
-464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.4) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fe(6.4)135
-b(FITS)44 b(Header)i(I/O)f(Subroutines)0 675 y
-SDict begin H.S end
- 0 675
-a 0 675 a
-SDict begin 13.6 H.A end
- 0 675 a 0 675 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.1) cvn /DEST pdfmark
-end
- 0 675 a 134 x Fc(6.4.1)112
-b(Header)38 b(Space)h(and)f(P)m(osition)f(Routines)0
-1019 y Fi(1)81 b Fj(Reserv)m(e)37 b(space)g(in)f(the)h(CHU)f(for)h
+TeXDict begin 43 48 bop 0 299 a Fh(6.4.)72 b(FITS)30
+b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(43)0 555 y
+Fe(6.4)135 b(FITS)44 b(Header)i(I/O)f(Subroutines)0 810
+y Fc(6.4.1)112 b(Header)38 b(Space)h(and)f(P)m(osition)f(Routines)0
+1021 y Fi(1)81 b Fj(Reserv)m(e)37 b(space)g(in)f(the)h(CHU)f(for)h
 (MOREKEYS)e(more)i(header)f(k)m(eyw)m(ords.)59 b(This)36
-b(subroutine)f(ma)m(y)j(b)s(e)227 1132 y(called)e(to)g(reserv)m(e)g
+b(subroutine)f(ma)m(y)j(b)s(e)227 1134 y(called)e(to)g(reserv)m(e)g
 (space)f(for)g(k)m(eyw)m(ords)g(whic)m(h)g(are)g(to)h(b)s(e)e(written)h
-(at)g(a)h(later)g(time,)h(after)e(the)g(data)227 1245
+(at)g(a)h(later)g(time,)h(after)e(the)g(data)227 1247
 y(unit)h(or)g(subsequen)m(t)f(extensions)h(ha)m(v)m(e)h(b)s(een)e
 (written)h(to)h(the)f(FITS)f(\014le.)58 b(If)35 b(this)h(subroutine)f
-(is)h(not)227 1358 y(explicitly)29 b(called,)g(then)e(the)g(initial)i
+(is)h(not)227 1360 y(explicitly)29 b(called,)g(then)e(the)g(initial)i
 (size)e(of)h(the)f(FITS)f(header)h(will)h(b)s(e)e(limited)i(to)g(the)f
-(space)h(a)m(v)-5 b(ailable)227 1471 y(at)24 b(the)g(time)g(that)g(the)
+(space)h(a)m(v)-5 b(ailable)227 1473 y(at)24 b(the)g(time)g(that)g(the)
 g(\014rst)f(data)h(is)g(written)f(to)h(the)g(asso)s(ciated)h(data)f
 (unit.)38 b(FITSIO)22 b(has)i(the)f(abilit)m(y)i(to)227
-1584 y(dynamically)g(add)e(more)h(space)h(to)g(the)f(header)g(if)g
+1586 y(dynamically)g(add)e(more)h(space)h(to)g(the)f(header)g(if)g
 (needed,)h(ho)m(w)m(ev)m(er)g(it)g(is)f(more)g(e\016cien)m(t)h(to)g
-(preallo)s(cate)227 1697 y(the)31 b(required)e(space)i(if)g(the)f(size)
-h(is)g(kno)m(wn)f(in)g(adv)-5 b(ance.)382 1958 y Ff
-(FTHDEF\(unit,morekeys,)42 b(>)47 b(status\))0 2219 y
+(preallo)s(cate)227 1699 y(the)31 b(required)e(space)i(if)g(the)f(size)
+h(is)g(kno)m(wn)f(in)g(adv)-5 b(ance.)382 1962 y Ff
+(FTHDEF\(unit,morekeys,)42 b(>)47 b(status\))0 2226 y
 Fi(2)81 b Fj(Return)23 b(the)i(n)m(um)m(b)s(er)e(of)h(existing)i(k)m
 (eyw)m(ords)e(in)h(the)f(CHU)g(\(NOT)h(including)f(the)g(END)h(k)m(eyw)
-m(ord)g(whic)m(h)f(is)227 2332 y(not)g(considered)f(a)g(real)h(k)m(eyw)
+m(ord)g(whic)m(h)f(is)227 2339 y(not)g(considered)f(a)g(real)h(k)m(eyw)
 m(ord\))g(and)f(the)g(remaining)h(space)f(a)m(v)-5 b(ailable)26
-b(to)e(write)f(additional)i(k)m(eyw)m(ords)227 2445 y(in)39
+b(to)e(write)f(additional)i(k)m(eyw)m(ords)227 2452 y(in)39
 b(the)h(CHU.)f(\(returns)f(KEYSADD)i(=)f(-1)h(if)f(the)g(header)g(has)g
 (not)h(y)m(et)g(b)s(een)e(closed\).)69 b(Note)40 b(that)227
-2558 y(FITSIO)23 b(will)i(attempt)g(to)g(dynamically)g(add)e(space)i
+2564 y(FITSIO)23 b(will)i(attempt)g(to)g(dynamically)g(add)e(space)i
 (for)f(more)g(k)m(eyw)m(ords)h(if)f(required)f(when)g(app)s(ending)227
-2671 y(new)30 b(k)m(eyw)m(ords)h(to)g(a)g(header.)382
-2932 y Ff(FTGHSP\(iunit,)44 b(>)j(keysexist,keysadd,status\))0
-3194 y Fi(3)81 b Fj(Return)38 b(the)i(n)m(um)m(b)s(er)e(of)h(k)m(eyw)m
+2677 y(new)30 b(k)m(eyw)m(ords)h(to)g(a)g(header.)382
+2941 y Ff(FTGHSP\(iunit,)44 b(>)j(keysexist,keysadd,status\))0
+3204 y Fi(3)81 b Fj(Return)38 b(the)i(n)m(um)m(b)s(er)e(of)h(k)m(eyw)m
 (ords)h(in)f(the)g(header)g(and)g(the)g(curren)m(t)h(p)s(osition)f(in)g
-(the)g(header.)68 b(This)227 3307 y(returns)37 b(the)g(n)m(um)m(b)s(er)
+(the)g(header.)68 b(This)227 3317 y(returns)37 b(the)g(n)m(um)m(b)s(er)
 f(of)i(the)g(k)m(eyw)m(ord)g(record)f(that)h(will)g(b)s(e)f(read)g
-(next)h(\(or)g(one)g(greater)g(than)g(the)227 3420 y(p)s(osition)29
+(next)h(\(or)g(one)g(greater)g(than)g(the)227 3430 y(p)s(osition)29
 b(of)f(the)h(last)g(k)m(eyw)m(ord)g(that)g(w)m(as)f(read)g(or)h
 (written\).)40 b(A)29 b(v)-5 b(alue)28 b(of)h(1)g(is)f(returned)f(if)h
-(the)h(p)s(oin)m(ter)227 3533 y(is)i(p)s(ositioned)f(at)h(the)g(b)s
-(eginning)e(of)i(the)g(header.)382 3794 y Ff(FTGHPS\(iunit,)44
-b(>)j(keysexist,key_no,status\))0 3943 y
-SDict begin H.S end
- 0 3943 a 0 3943
-a
-SDict begin 13.6 H.A end
- 0 3943 a 0 3943 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.2) cvn /DEST pdfmark
-end
- 0 3943 a 143 x Fc(6.4.2)112 b(Read)38
-b(or)f(W)-9 b(rite)37 b(Standard)i(Header)e(Routines)0
-4306 y Fj(These)31 b(subroutines)e(pro)m(vide)i(a)g(simple)g(metho)s(d)
+(the)h(p)s(oin)m(ter)227 3543 y(is)i(p)s(ositioned)f(at)h(the)g(b)s
+(eginning)e(of)i(the)g(header.)382 3807 y Ff(FTGHPS\(iunit,)44
+b(>)j(keysexist,key_no,status\))0 4102 y Fc(6.4.2)112
+b(Read)38 b(or)f(W)-9 b(rite)37 b(Standard)i(Header)e(Routines)0
+4321 y Fj(These)31 b(subroutines)e(pro)m(vide)i(a)g(simple)g(metho)s(d)
 f(of)h(reading)g(or)g(writing)g(most)g(of)g(the)g(k)m(eyw)m(ord)g(v)-5
-b(alues)31 b(that)0 4419 y(are)d(normally)g(required)f(in)h(a)g(FITS)f
+b(alues)31 b(that)0 4434 y(are)d(normally)g(required)f(in)h(a)g(FITS)f
 (\014les.)40 b(These)27 b(subroutines)g(are)h(pro)m(vided)f(for)h(con)m
-(v)m(enience)h(only)f(and)g(are)0 4532 y(not)36 b(required)e(to)i(b)s
+(v)m(enience)h(only)f(and)g(are)0 4547 y(not)36 b(required)e(to)i(b)s
 (e)f(used.)55 b(If)35 b(preferred,)h(users)e(ma)m(y)i(call)h(the)f(lo)m
 (w)m(er-lev)m(el)i(subroutines)c(describ)s(ed)h(in)g(the)0
-4644 y(previous)30 b(section)i(to)g(individually)f(read)f(or)h(write)g
+4660 y(previous)30 b(section)i(to)g(individually)f(read)f(or)h(write)g
 (the)g(required)f(k)m(eyw)m(ords.)43 b(Note)32 b(that)g(in)e(most)i
-(cases,)g(the)0 4757 y(required)26 b(k)m(eyw)m(ords)h(suc)m(h)g(as)g
+(cases,)g(the)0 4773 y(required)26 b(k)m(eyw)m(ords)h(suc)m(h)g(as)g
 (NAXIS,)f(TFIELD,)h(TTYPEn,)g(etc,)i(whic)m(h)d(de\014ne)g(the)h
-(structure)f(of)h(the)g(HDU)0 4870 y(m)m(ust)j(b)s(e)g(written)g(to)i
+(structure)f(of)h(the)g(HDU)0 4886 y(m)m(ust)j(b)s(e)g(written)g(to)i
 (the)e(header)g(b)s(efore)g(an)m(y)h(data)g(can)g(b)s(e)e(written)i(to)
-g(the)g(image)g(or)g(table.)0 5132 y Fi(1)81 b Fj(Put)37
+g(the)g(image)g(or)g(table.)0 5149 y Fi(1)81 b Fj(Put)37
 b(the)i(primary)e(header)h(or)g(IMA)m(GE)h(extension)f(k)m(eyw)m(ords)h
 (in)m(to)g(the)f(CHU.)g(There)g(are)g(2)h(a)m(v)-5 b(ailable)227
-5245 y(routines:)39 b(The)27 b(simpler)f(FTPHPS)h(routine)g(is)g(equiv)
+5262 y(routines:)39 b(The)27 b(simpler)f(FTPHPS)h(routine)g(is)g(equiv)
 -5 b(alen)m(t)29 b(to)e(calling)i(ftphpr)c(with)i(the)g(default)h(v)-5
-b(alues)227 5357 y(of)35 b(SIMPLE)f(=)g(true,)i(p)s(coun)m(t)e(=)g(0,)i
+b(alues)227 5375 y(of)35 b(SIMPLE)f(=)g(true,)i(p)s(coun)m(t)e(=)g(0,)i
 (gcoun)m(t)g(=)e(1,)i(and)e(EXTEND)h(=)f(true.)53 b(PCOUNT,)34
-b(GCOUNT)227 5470 y(and)23 b(EXTEND)h(k)m(eyw)m(ords)g(are)h(not)f
+b(GCOUNT)227 5488 y(and)23 b(EXTEND)h(k)m(eyw)m(ords)g(are)h(not)f
 (required)f(in)g(the)h(primary)f(header)g(and)h(are)g(only)g(written)g
-(if)f(p)s(coun)m(t)227 5583 y(is)31 b(not)g(equal)h(to)g(zero,)g(gcoun)
+(if)f(p)s(coun)m(t)227 5601 y(is)31 b(not)g(equal)h(to)g(zero,)g(gcoun)
 m(t)g(is)f(not)g(equal)g(to)h(zero)g(or)f(one,)g(and)g(if)g(extend)g
-(is)g(TR)m(UE,)g(resp)s(ectiv)m(ely)-8 b(.)227 5696 y(When)30
+(is)g(TR)m(UE,)g(resp)s(ectiv)m(ely)-8 b(.)227 5714 y(When)30
 b(writing)h(to)g(an)f(IMA)m(GE)i(extension,)f(the)f(SIMPLE)g(and)g
 (EXTEND)g(parameters)h(are)g(ignored.)p eop end
 %%Page: 44 50
-TeXDict begin 44 49 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.44) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(44)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTPHPS\(unit,bitpix,naxis)o
-(,na)o(xes,)41 b(>)48 b(status\))382 781 y(FTPHPR\(unit,simple,bitpi)o
-(x,n)o(axis)o(,nax)o(es,)o(pcou)o(nt,g)o(cou)o(nt,e)o(xten)o(d,)41
+TeXDict begin 44 49 bop 0 299 a Fj(44)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTPHPS\(unit,bitpix,naxis)o(,na)o(xes,)41
+b(>)48 b(status\))382 781 y(FTPHPR\(unit,simple,bitpi)o(x,n)o(axis)o
+(,nax)o(es,)o(pcou)o(nt,g)o(cou)o(nt,e)o(xten)o(d,)41
 b(>)48 b(status\))0 1082 y Fi(2)81 b Fj(Get)44 b(primary)e(header)h(or)
 h(IMA)m(GE)g(extension)g(k)m(eyw)m(ords)g(from)f(the)g(CHU.)h(When)f
 (reading)g(from)g(an)227 1195 y(IMA)m(GE)32 b(extension)f(the)f(SIMPLE)
-g(and)f(EXTEND)i(parameters)g(are)f(ignored.)382 1495
+g(and)f(EXTEND)i(parameters)g(are)f(ignored.)382 1497
 y Ff(FTGHPR\(unit,maxdim,)42 b(>)48 b(simple,bitpix,naxis,naxe)o(s,p)o
-(coun)o(t,gc)o(oun)o(t,ex)o(tend)o(,)716 1608 y(status\))0
-1909 y Fi(3)81 b Fj(Put)34 b(the)h(ASCI)s(I)f(table)i(header)f(k)m(eyw)
+(coun)o(t,gc)o(oun)o(t,ex)o(tend)o(,)716 1610 y(status\))0
+1911 y Fi(3)81 b Fj(Put)34 b(the)h(ASCI)s(I)f(table)i(header)f(k)m(eyw)
 m(ords)g(in)m(to)h(the)f(CHU.)h(The)e(optional)i(TUNITn)e(and)h
-(EXTNAME)227 2021 y(k)m(eyw)m(ords)c(are)g(written)f(only)h(if)f(the)h
+(EXTNAME)227 2024 y(k)m(eyw)m(ords)c(are)g(written)f(only)h(if)f(the)h
 (input)e(string)h(v)-5 b(alues)31 b(are)g(not)f(blank.)382
-2322 y Ff(FTPHTB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o(ype)o(,tbc)o
+2325 y Ff(FTPHTB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o(ype)o(,tbc)o
 (ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42 b(>)716
-2435 y(status\))0 2736 y Fi(4)81 b Fj(Get)31 b(the)g(ASCI)s(I)d(table)k
-(header)e(k)m(eyw)m(ords)h(from)e(the)i(CHU)382 3036
+2438 y(status\))0 2739 y Fi(4)81 b Fj(Get)31 b(the)g(ASCI)s(I)d(table)k
+(header)e(k)m(eyw)m(ords)h(from)e(the)i(CHU)382 3041
 y Ff(FTGHTB\(unit,maxdim,)42 b(>)48 b(rowlen,nrows,tfields,tty)o(pe,)o
-(tbco)o(l,tf)o(orm)o(,tun)o(it,)716 3149 y(extname,status\))0
-3450 y Fi(5)81 b Fj(Put)34 b(the)h(binary)f(table)i(header)e(k)m(eyw)m
+(tbco)o(l,tf)o(orm)o(,tun)o(it,)716 3154 y(extname,status\))0
+3455 y Fi(5)81 b Fj(Put)34 b(the)h(binary)f(table)i(header)e(k)m(eyw)m
 (ords)i(in)m(to)f(the)g(CHU.)g(The)g(optional)h(TUNITn)e(and)g(EXTNAME)
-227 3563 y(k)m(eyw)m(ords)i(are)g(written)f(only)g(if)h(the)f(input)f
+227 3568 y(k)m(eyw)m(ords)i(are)g(written)f(only)g(if)h(the)f(input)f
 (string)i(v)-5 b(alues)35 b(are)h(not)f(blank.)55 b(The)35
-b(p)s(coun)m(t)g(parameter,)227 3675 y(whic)m(h)f(sp)s(eci\014es)g(the)
+b(p)s(coun)m(t)g(parameter,)227 3681 y(whic)m(h)f(sp)s(eci\014es)g(the)
 h(size)g(of)g(the)f(v)-5 b(ariable)35 b(length)g(arra)m(y)g(heap,)g
-(should)f(initially)h(=)f(0;)j(FITSIO)d(will)227 3788
+(should)f(initially)h(=)f(0;)j(FITSIO)d(will)227 3794
 y(automatically)27 b(up)s(date)c(the)h(PCOUNT)f(k)m(eyw)m(ord)h(v)-5
 b(alue)24 b(if)g(an)m(y)g(v)-5 b(ariable)25 b(length)f(arra)m(y)h(data)
-f(is)g(written)227 3901 y(to)31 b(the)e(heap.)41 b(The)29
+f(is)g(written)227 3907 y(to)31 b(the)e(heap.)41 b(The)29
 b(TF)m(ORM)g(k)m(eyw)m(ord)h(v)-5 b(alue)30 b(for)g(v)-5
 b(ariable)30 b(length)g(v)m(ector)h(columns)e(should)g(ha)m(v)m(e)i
-(the)227 4014 y(form)c('Pt\(len\)')j(or)d('1Pt\(len\)')j(where)d(`t')h
+(the)227 4019 y(form)c('Pt\(len\)')j(or)d('1Pt\(len\)')j(where)d(`t')h
 (is)g(the)g(data)g(t)m(yp)s(e)g(co)s(de)f(letter)i(\(A,I,J,E,D,)g
-(etc.\))42 b(and)27 b(`len')h(is)227 4127 y(an)g(in)m(teger)i(sp)s
+(etc.\))42 b(and)27 b(`len')h(is)227 4132 y(an)g(in)m(teger)i(sp)s
 (ecifying)e(the)g(maxim)m(um)g(length)g(of)h(the)f(v)m(ectors)h(in)f
 (that)h(column)f(\(len)g(m)m(ust)g(b)s(e)g(greater)227
-4240 y(than)j(or)h(equal)f(to)i(the)e(longest)i(v)m(ector)f(in)f(the)h
+4245 y(than)j(or)h(equal)f(to)i(the)e(longest)i(v)m(ector)f(in)f(the)h
 (column\).)44 b(If)30 b(`len')i(is)g(not)f(sp)s(eci\014ed)g(when)f(the)
-i(table)g(is)227 4353 y(created)27 b(\(e.g.,)i(the)d(input)f(TF)m(ORMn)
+i(table)g(is)227 4358 y(created)27 b(\(e.g.,)i(the)d(input)f(TF)m(ORMn)
 h(v)-5 b(alue)26 b(is)g(just)f('1Pt'\))j(then)d(FITSIO)g(will)h(scan)g
-(the)g(column)g(when)227 4466 y(the)k(table)g(is)f(\014rst)g(closed)h
+(the)g(column)g(when)227 4471 y(the)k(table)g(is)f(\014rst)g(closed)h
 (and)f(will)g(app)s(end)f(the)h(maxim)m(um)h(length)f(to)h(the)g(TF)m
-(ORM)f(k)m(eyw)m(ord)h(v)-5 b(alue.)227 4579 y(Note)28
+(ORM)f(k)m(eyw)m(ord)h(v)-5 b(alue.)227 4584 y(Note)28
 b(that)e(if)g(the)g(table)h(is)f(subsequen)m(tly)g(mo)s(di\014ed)f(to)i
 (increase)f(the)h(maxim)m(um)f(length)g(of)g(the)g(v)m(ectors)227
-4692 y(then)k(the)h(mo)s(difying)f(program)g(is)g(resp)s(onsible)g(for)
+4697 y(then)k(the)h(mo)s(difying)f(program)g(is)g(resp)s(onsible)g(for)
 g(also)h(up)s(dating)e(the)i(TF)m(ORM)g(k)m(eyw)m(ord)g(v)-5
-b(alue.)382 4992 y Ff(FTPHBN\(unit,nrows,tfield)o(s,t)o(type)o(,tfo)o
+b(alue.)382 4998 y Ff(FTPHBN\(unit,nrows,tfield)o(s,t)o(type)o(,tfo)o
 (rm,)o(tuni)o(t,ex)o(tna)o(me,v)o(arid)o(at,)41 b(>)48
-b(status\))0 5293 y Fi(6)81 b Fj(Get)31 b(the)g(binary)e(table)i
-(header)g(k)m(eyw)m(ords)f(from)g(the)h(CHU)382 5593
+b(status\))0 5300 y Fi(6)81 b Fj(Get)31 b(the)g(binary)e(table)i
+(header)g(k)m(eyw)m(ords)f(from)g(the)h(CHU)382 5601
 y Ff(FTGHBN\(unit,maxdim,)42 b(>)48 b(nrows,tfields,ttype,tfor)o(m,t)o
-(unit)o(,ext)o(nam)o(e,va)o(rida)o(t,)716 5706 y(status\))p
+(unit)o(,ext)o(nam)o(e,va)o(rida)o(t,)716 5714 y(status\))p
 eop end
 %%Page: 45 51
-TeXDict begin 45 50 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.45) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.4.)72
-b(FITS)30 b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(45)0
-464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.3) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fc(6.4.3)112
-b(W)-9 b(rite)37 b(Keyw)m(ord)g(Subroutines)0 764 y Fi(1)81
-b Fj(Put)30 b(\(app)s(end\))f(an)h(80-c)m(haracter)j(record)e(in)m(to)g
-(the)g(CHU.)382 1020 y Ff(FTPREC\(unit,card,)43 b(>)k(status\))0
-1276 y Fi(2)81 b Fj(Put)36 b(\(app)s(end\))g(a)i(COMMENT)f(k)m(eyw)m
-(ord)g(in)m(to)h(the)g(CHU.)f(Multiple)h(COMMENT)f(k)m(eyw)m(ords)g
-(will)h(b)s(e)227 1389 y(written)31 b(if)f(the)h(input)e(commen)m(t)i
-(string)g(is)f(longer)h(than)f(72)i(c)m(haracters.)382
-1645 y Ff(FTPCOM\(unit,comment,)42 b(>)48 b(status\))0
-1901 y Fi(3)81 b Fj(Put)24 b(\(app)s(end\))g(a)h(HISTOR)-8
+TeXDict begin 45 50 bop 0 299 a Fh(6.4.)72 b(FITS)30
+b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(45)0 555 y
+Fc(6.4.3)112 b(W)-9 b(rite)37 b(Keyw)m(ord)g(Subroutines)0
+764 y Fi(1)81 b Fj(Put)30 b(\(app)s(end\))f(an)h(80-c)m(haracter)j
+(record)e(in)m(to)g(the)g(CHU.)382 1022 y Ff(FTPREC\(unit,card,)43
+b(>)k(status\))0 1280 y Fi(2)81 b Fj(Put)36 b(\(app)s(end\))g(a)i
+(COMMENT)f(k)m(eyw)m(ord)g(in)m(to)h(the)g(CHU.)f(Multiple)h(COMMENT)f
+(k)m(eyw)m(ords)g(will)h(b)s(e)227 1393 y(written)31
+b(if)f(the)h(input)e(commen)m(t)i(string)g(is)f(longer)h(than)f(72)i(c)
+m(haracters.)382 1650 y Ff(FTPCOM\(unit,comment,)42 b(>)48
+b(status\))0 1908 y Fi(3)81 b Fj(Put)24 b(\(app)s(end\))g(a)h(HISTOR)-8
 b(Y)25 b(k)m(eyw)m(ord)g(in)m(to)h(the)f(CHU.)g(Multiple)h(HISTOR)-8
 b(Y)24 b(k)m(eyw)m(ords)h(will)h(b)s(e)e(written)227
-2014 y(if)31 b(the)f(input)g(history)g(string)g(is)h(longer)g(than)f
-(72)h(c)m(haracters.)382 2270 y Ff(FTPHIS\(unit,history,)42
-b(>)48 b(status\))0 2526 y Fi(4)81 b Fj(Put)36 b(\(app)s(end\))f(the)h
+2021 y(if)31 b(the)f(input)g(history)g(string)g(is)h(longer)g(than)f
+(72)h(c)m(haracters.)382 2279 y Ff(FTPHIS\(unit,history,)42
+b(>)48 b(status\))0 2537 y Fi(4)81 b Fj(Put)36 b(\(app)s(end\))f(the)h
 (D)m(A)-8 b(TE)38 b(k)m(eyw)m(ord)f(in)m(to)g(the)f(CHU.)h(The)f(k)m
 (eyw)m(ord)g(v)-5 b(alue)37 b(will)g(con)m(tain)h(the)e(curren)m(t)227
-2639 y(system)c(date)g(as)g(a)f(c)m(haracter)i(string)f(in)f
+2650 y(system)c(date)g(as)g(a)f(c)m(haracter)i(string)f(in)f
 ('dd/mm/yy')g(format.)44 b(If)31 b(a)h(D)m(A)-8 b(TE)32
-b(k)m(eyw)m(ord)g(already)g(exists)227 2752 y(in)j(the)g(header,)i
+b(k)m(eyw)m(ord)g(already)g(exists)227 2763 y(in)j(the)g(header,)i
 (then)d(this)h(subroutine)f(will)i(simply)e(up)s(date)h(the)g(k)m(eyw)m
-(ord)g(v)-5 b(alue)36 b(in-place)g(with)f(the)227 2865
-y(curren)m(t)30 b(date.)382 3121 y Ff(FTPDAT\(unit,)44
-b(>)k(status\))0 3377 y Fi(5)81 b Fj(Put)22 b(\(app)s(end\))f(a)i(new)f
+(ord)g(v)-5 b(alue)36 b(in-place)g(with)f(the)227 2876
+y(curren)m(t)30 b(date.)382 3134 y Ff(FTPDAT\(unit,)44
+b(>)k(status\))0 3392 y Fi(5)81 b Fj(Put)22 b(\(app)s(end\))f(a)i(new)f
 (k)m(eyw)m(ord)h(of)g(the)f(appropriate)h(datat)m(yp)s(e)g(in)m(to)h
-(the)e(CHU.)h(Note)h(that)f(FTPKYS)f(will)227 3490 y(only)33
+(the)e(CHU.)h(Note)h(that)f(FTPKYS)f(will)227 3504 y(only)33
 b(write)g(string)f(v)-5 b(alues)33 b(up)e(to)j(68)f(c)m(haracters)h(in)
 e(length;)i(longer)f(strings)g(will)f(b)s(e)g(truncated.)47
-b(The)227 3603 y(FTPKLS)27 b(routine)h(can)h(b)s(e)f(used)f(to)i(write)
+b(The)227 3617 y(FTPKLS)27 b(routine)h(can)h(b)s(e)f(used)f(to)i(write)
 f(longer)h(strings,)g(using)e(a)i(non-standard)e(FITS)h(con)m(v)m(en)m
-(tion.)227 3716 y(The)23 b(E)h(and)f(D)h(v)m(ersions)g(of)g(this)f
+(tion.)227 3730 y(The)23 b(E)h(and)f(D)h(v)m(ersions)g(of)g(this)f
 (routine)h(ha)m(v)m(e)h(the)f(added)f(feature)h(that)g(if)g(the)g
-('decimals')h(parameter)f(is)227 3829 y(negativ)m(e,)i(then)20
+('decimals')h(parameter)f(is)227 3843 y(negativ)m(e,)i(then)20
 b(the)i('G')g(displa)m(y)f(format)g(rather)g(then)g(the)g('E')h(format)
-f(will)h(b)s(e)e(used)g(when)g(constructing)227 3942
+f(will)h(b)s(e)e(used)g(when)g(constructing)227 3956
 y(the)25 b(k)m(eyw)m(ord)f(v)-5 b(alue,)26 b(taking)f(the)g(absolute)g
 (v)-5 b(alue)24 b(of)h('decimals')g(for)f(the)g(precision.)39
-b(This)23 b(will)i(suppress)227 4055 y(trailing)35 b(zeros,)h(and)d
+b(This)23 b(will)i(suppress)227 4069 y(trailing)35 b(zeros,)h(and)d
 (will)i(use)e(a)i(\014xed)e(format)h(rather)g(than)f(an)h(exp)s(onen)m
-(tial)h(format,)h(dep)s(ending)c(on)227 4168 y(the)f(magnitude)f(of)h
-(the)f(v)-5 b(alue.)382 4424 y Ff(FTPKY[JKLS]\(unit,keyword)o(,ke)o
-(yval)o(,com)o(men)o(t,)42 b(>)47 b(status\))382 4537
+(tial)h(format,)h(dep)s(ending)c(on)227 4182 y(the)f(magnitude)f(of)h
+(the)f(v)-5 b(alue.)382 4440 y Ff(FTPKY[JKLS]\(unit,keyword)o(,ke)o
+(yval)o(,com)o(men)o(t,)42 b(>)47 b(status\))382 4553
 y(FTPKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o(ima)o(ls,c)o(omme)o
-(nt,)41 b(>)48 b(status\))0 4793 y Fi(6)81 b Fj(Put)33
+(nt,)41 b(>)48 b(status\))0 4811 y Fi(6)81 b Fj(Put)33
 b(\(app)s(end\))h(a)g(string)g(v)-5 b(alued)34 b(k)m(eyw)m(ord)h(in)m
 (to)g(the)g(CHU)f(whic)m(h)g(ma)m(y)g(b)s(e)g(longer)h(than)e(68)i(c)m
-(haracters)227 4906 y(in)j(length.)64 b(This)37 b(uses)h(the)g(Long)g
+(haracters)227 4924 y(in)j(length.)64 b(This)37 b(uses)h(the)g(Long)g
 (String)g(Keyw)m(ord)g(con)m(v)m(en)m(tion)i(that)e(is)g(describ)s(ed)f
-(in)h(the)g("Usage)227 5019 y(Guidelines)33 b(and)e(Suggestions")j
+(in)h(the)g("Usage)227 5036 y(Guidelines)33 b(and)e(Suggestions")j
 (section)f(of)g(this)f(do)s(cumen)m(t.)46 b(Since)33
-b(this)f(uses)g(a)g(non-standard)g(FITS)227 5132 y(con)m(v)m(en)m(tion)
+b(this)f(uses)g(a)g(non-standard)g(FITS)227 5149 y(con)m(v)m(en)m(tion)
 38 b(to)d(enco)s(de)h(the)f(long)h(k)m(eyw)m(ord)f(string,)i(programs)d
 (whic)m(h)h(use)g(this)g(routine)g(should)f(also)227
-5245 y(call)e(the)e(FTPLSW)g(routine)h(to)g(add)e(some)i(COMMENT)f(k)m
+5262 y(call)e(the)e(FTPLSW)g(routine)h(to)g(add)e(some)i(COMMENT)f(k)m
 (eyw)m(ords)h(to)g(w)m(arn)f(users)f(of)i(the)f(FITS)g(\014le)227
-5357 y(that)36 b(this)f(con)m(v)m(en)m(tion)j(is)d(b)s(eing)g(used.)55
+5375 y(that)36 b(this)f(con)m(v)m(en)m(tion)j(is)d(b)s(eing)g(used.)55
 b(FTPLSW)35 b(also)h(writes)g(a)f(k)m(eyw)m(ord)h(called)h(LONGSTRN)d
-(to)227 5470 y(record)c(the)h(v)m(ersion)f(of)h(the)f(longstring)h(con)
+(to)227 5488 y(record)c(the)h(v)m(ersion)f(of)h(the)f(longstring)h(con)
 m(v)m(en)m(tion)h(that)f(has)f(b)s(een)g(used,)f(in)h(case)h(a)g(new)f
-(con)m(v)m(en)m(tion)227 5583 y(is)f(adopted)g(at)g(some)g(p)s(oin)m(t)
+(con)m(v)m(en)m(tion)227 5601 y(is)f(adopted)g(at)g(some)g(p)s(oin)m(t)
 f(in)h(the)f(future.)40 b(If)28 b(the)g(LONGSTRN)g(k)m(eyw)m(ord)h(is)g
-(already)g(presen)m(t)f(in)h(the)227 5696 y(header,)i(then)f(FTPLSW)g
+(already)g(presen)m(t)f(in)h(the)227 5714 y(header,)i(then)f(FTPLSW)g
 (will)g(simply)g(return)g(and)f(will)i(not)g(write)f(duplicate)h(k)m
 (eyw)m(ords.)p eop end
 %%Page: 46 52
-TeXDict begin 46 51 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.46) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(46)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTPKLS\(unit,keyword,keyv)o
-(al,)o(comm)o(ent,)41 b(>)47 b(status\))382 668 y(FTPLSW\(unit,)d(>)k
-(status\))0 889 y Fi(7)81 b Fj(Put)30 b(\(app)s(end\))g(a)h(new)f(k)m
-(eyw)m(ord)h(with)f(an)h(unde\014ned,)e(or)h(n)m(ull,)h(v)-5
-b(alue)31 b(in)m(to)h(the)f(CHU.)g(The)f(v)-5 b(alue)31
-b(string)227 1002 y(of)g(the)f(k)m(eyw)m(ord)h(is)g(left)g(blank)f(in)g
-(this)g(case.)382 1223 y Ff(FTPKYU\(unit,keyword,comm)o(ent)o(,)42
-b(>)47 b(status\))0 1445 y Fi(8)81 b Fj(Put)41 b(\(app)s(end\))g(a)i(n)
+TeXDict begin 46 51 bop 0 299 a Fj(46)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTPKLS\(unit,keyword,keyv)o(al,)o(comm)o
+(ent,)41 b(>)47 b(status\))382 668 y(FTPLSW\(unit,)d(>)k(status\))0
+891 y Fi(7)81 b Fj(Put)30 b(\(app)s(end\))g(a)h(new)f(k)m(eyw)m(ord)h
+(with)f(an)h(unde\014ned,)e(or)h(n)m(ull,)h(v)-5 b(alue)31
+b(in)m(to)h(the)f(CHU.)g(The)f(v)-5 b(alue)31 b(string)227
+1004 y(of)g(the)f(k)m(eyw)m(ord)h(is)g(left)g(blank)f(in)g(this)g
+(case.)382 1227 y Ff(FTPKYU\(unit,keyword,comm)o(ent)o(,)42
+b(>)47 b(status\))0 1450 y Fi(8)81 b Fj(Put)41 b(\(app)s(end\))g(a)i(n)
 m(um)m(b)s(ered)d(sequence)j(of)f(k)m(eyw)m(ords)g(in)m(to)h(the)g
-(CHU.)f(One)f(ma)m(y)i(app)s(end)d(the)j(same)227 1558
+(CHU.)f(One)f(ma)m(y)i(app)s(end)d(the)j(same)227 1563
 y(commen)m(t)37 b(to)g(ev)m(ery)g(k)m(eyw)m(ord)g(\(and)f(eliminate)h
 (the)g(need)f(to)h(ha)m(v)m(e)g(an)f(arra)m(y)h(of)f(iden)m(tical)i
-(commen)m(t)227 1670 y(strings,)g(one)e(for)g(eac)m(h)h(k)m(eyw)m
+(commen)m(t)227 1676 y(strings,)g(one)e(for)g(eac)m(h)h(k)m(eyw)m
 (ord\))g(b)m(y)f(including)g(the)g(amp)s(ersand)e(c)m(haracter)k(as)e
-(the)h(last)g(non-blank)227 1783 y(c)m(haracter)g(in)e(the)h
+(the)h(last)g(non-blank)227 1788 y(c)m(haracter)g(in)e(the)h
 (\(\014rst\))f(COMMENTS)f(string)h(parameter.)56 b(This)35
-b(same)g(string)h(will)f(then)g(b)s(e)g(used)227 1896
+b(same)g(string)h(will)f(then)g(b)s(e)g(used)227 1901
 y(for)30 b(the)g(commen)m(t)h(\014eld)f(in)f(all)i(the)f(k)m(eyw)m
 (ords.)41 b(\(Note)32 b(that)e(the)g(SPP)f(v)m(ersion)i(of)f(these)g
-(routines)g(only)227 2009 y(supp)s(orts)f(a)i(single)g(commen)m(t)g
-(string\).)382 2230 y Ff(FTPKN[JKLS]\(unit,keyroot)o(,st)o(artn)o(o,no)
+(routines)g(only)227 2014 y(supp)s(orts)f(a)i(single)g(commen)m(t)g
+(string\).)382 2237 y Ff(FTPKN[JKLS]\(unit,keyroot)o(,st)o(artn)o(o,no)
 o(_ke)o(ys,k)o(eyva)o(ls,)o(comm)o(ents)o(,)42 b(>)47
-b(status\))382 2343 y(FTPKN[EDFG]\(unit,keyroot)o(,st)o(artn)o(o,no)o
+b(status\))382 2350 y(FTPKN[EDFG]\(unit,keyroot)o(,st)o(artn)o(o,no)o
 (_ke)o(ys,k)o(eyva)o(ls,)o(deci)o(mals)o(,co)o(mmen)o(ts,)41
-b(>)907 2456 y(status\))0 2677 y Fi(9)81 b Fj(Cop)m(y)21
+b(>)907 2463 y(status\))0 2686 y Fi(9)81 b Fj(Cop)m(y)21
 b(an)h(indexed)f(k)m(eyw)m(ord)i(from)e(one)h(HDU)h(to)f(another,)i(mo)
 s(difying)e(the)g(index)f(n)m(um)m(b)s(er)f(of)i(the)g(k)m(eyw)m(ord)
-227 2790 y(name)37 b(in)f(the)g(pro)s(cess.)58 b(F)-8
+227 2799 y(name)37 b(in)f(the)g(pro)s(cess.)58 b(F)-8
 b(or)37 b(example,)i(this)d(routine)h(could)f(read)g(the)h(TLMIN3)f(k)m
-(eyw)m(ord)h(from)f(the)227 2903 y(input)28 b(HDU)h(\(b)m(y)f(giving)h
+(eyw)m(ord)h(from)f(the)227 2912 y(input)28 b(HDU)h(\(b)m(y)f(giving)h
 (k)m(eyro)s(ot)h(=)d("TLMIN")i(and)f(inn)m(um)f(=)h(3\))h(and)f(write)g
-(it)h(to)g(the)f(output)g(HDU)227 3016 y(with)36 b(the)g(k)m(eyw)m(ord)
+(it)h(to)g(the)f(output)g(HDU)227 3025 y(with)36 b(the)g(k)m(eyw)m(ord)
 h(name)f(TLMIN4)g(\(b)m(y)g(setting)i(outn)m(um)d(=)h(4\).)58
 b(If)36 b(the)g(input)f(k)m(eyw)m(ord)i(do)s(es)f(not)227
-3129 y(exist,)c(then)e(this)g(routine)g(simply)g(returns)f(without)i
-(indicating)g(an)f(error.)382 3350 y Ff(FTCPKY\(inunit,)44
+3137 y(exist,)c(then)e(this)g(routine)g(simply)g(returns)f(without)i
+(indicating)g(an)f(error.)382 3360 y Ff(FTCPKY\(inunit,)44
 b(outunit,)h(innum,)h(outnum,)g(keyroot,)g(>)h(status\))0
-3571 y Fi(10)f Fj(Put)33 b(\(app)s(end\))f(a)h('triple)h(precision')g
+3583 y Fi(10)f Fj(Put)33 b(\(app)s(end\))f(a)h('triple)h(precision')g
 (k)m(eyw)m(ord)f(in)m(to)h(the)g(CHU)f(in)g(F28.16)i(format.)49
-b(The)33 b(\015oating)h(p)s(oin)m(t)227 3684 y(k)m(eyw)m(ord)c(v)-5
+b(The)33 b(\015oating)h(p)s(oin)m(t)227 3696 y(k)m(eyw)m(ord)c(v)-5
 b(alue)30 b(is)f(constructed)h(b)m(y)f(concatenating)j(the)d(input)g
 (in)m(teger)i(v)-5 b(alue)29 b(with)g(the)h(input)e(double)227
-3797 y(precision)22 b(fraction)h(v)-5 b(alue)23 b(\(whic)m(h)f(m)m(ust)
+3809 y(precision)22 b(fraction)h(v)-5 b(alue)23 b(\(whic)m(h)f(m)m(ust)
 g(ha)m(v)m(e)h(a)f(v)-5 b(alue)23 b(b)s(et)m(w)m(een)g(0.0)g(and)e
-(1.0\).)40 b(The)21 b(FTGKYT)h(routine)227 3910 y(should)35
+(1.0\).)40 b(The)21 b(FTGKYT)h(routine)227 3922 y(should)35
 b(b)s(e)h(used)f(to)i(read)f(this)f(k)m(eyw)m(ord)i(v)-5
 b(alue,)38 b(b)s(ecause)e(the)g(other)h(k)m(eyw)m(ord)f(reading)g
-(subroutines)227 4023 y(will)31 b(not)g(preserv)m(e)f(the)h(full)f
-(precision)g(of)h(the)f(v)-5 b(alue.)382 4244 y Ff
+(subroutines)227 4035 y(will)31 b(not)g(preserv)m(e)f(the)h(full)f
+(precision)g(of)h(the)f(v)-5 b(alue.)382 4258 y Ff
 (FTPKYT\(unit,keyword,intv)o(al,)o(dblv)o(al,c)o(omm)o(ent,)41
-b(>)48 b(status\))0 4466 y Fi(11)e Fj(W)-8 b(rite)36
+b(>)48 b(status\))0 4481 y Fi(11)e Fj(W)-8 b(rite)36
 b(k)m(eyw)m(ords)g(to)f(the)h(CHDU)f(that)h(are)f(de\014ned)f(in)g(an)h
 (ASCI)s(I)f(template)i(\014le.)55 b(The)34 b(format)i(of)f(the)227
-4578 y(template)d(\014le)f(is)f(describ)s(ed)f(under)g(the)i(ftgthd)f
-(routine)g(b)s(elo)m(w.)382 4800 y Ff(FTPKTP\(unit,)44
-b(filename,)i(>)h(status\))0 5021 y Fi(12)f Fj(App)s(end)28
+4594 y(template)d(\014le)f(is)f(describ)s(ed)f(under)g(the)i(ftgthd)f
+(routine)g(b)s(elo)m(w.)382 4816 y Ff(FTPKTP\(unit,)44
+b(filename,)i(>)h(status\))0 5039 y Fi(12)f Fj(App)s(end)28
 b(the)i(ph)m(ysical)g(units)g(string)g(to)g(an)g(existing)h(k)m(eyw)m
 (ord.)41 b(This)29 b(routine)h(uses)f(a)h(lo)s(cal)i(con)m(v)m(en)m
-(tion,)227 5134 y(sho)m(wn)g(in)g(the)h(follo)m(wing)h(example,)g(in)e
+(tion,)227 5152 y(sho)m(wn)g(in)g(the)h(follo)m(wing)h(example,)g(in)e
 (whic)m(h)g(the)h(k)m(eyw)m(ord)g(units)f(are)h(enclosed)g(in)f(square)
-g(brac)m(k)m(ets)227 5247 y(in)e(the)h(b)s(eginning)f(of)g(the)h(k)m
-(eyw)m(ord)g(commen)m(t)g(\014eld.)239 5468 y Ff(VELOCITY=)809
-b(12.3)46 b(/)i([km/s])e(orbital)g(speed)382 5694 y
+g(brac)m(k)m(ets)227 5265 y(in)e(the)h(b)s(eginning)f(of)g(the)h(k)m
+(eyw)m(ord)g(commen)m(t)g(\014eld.)239 5488 y Ff(VELOCITY=)809
+b(12.3)46 b(/)i([km/s])e(orbital)g(speed)382 5714 y
 (FTPUNT\(unit,keyword,unit)o(s,)41 b(>)48 b(status\))p
 eop end
 %%Page: 47 53
-TeXDict begin 47 52 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.47) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.4.)72
-b(FITS)30 b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(47)0
-464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.4) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fc(6.4.4)112
-b(Insert)38 b(Keyw)m(ord)f(Subroutines)0 762 y Fi(1)81
-b Fj(Insert)26 b(a)h(new)f(k)m(eyw)m(ord)h(record)g(in)m(to)g(the)g
-(CHU)g(at)g(the)g(sp)s(eci\014ed)f(p)s(osition)h(\(i.e.,)i(immediately)
-f(preceding)227 875 y(the)34 b(\(k)m(eyno\)th)g(k)m(eyw)m(ord)g(in)f
-(the)h(header.\))49 b(This)33 b('insert)g(record')h(subroutine)e(is)h
-(somewhat)h(less)g(e\016-)227 988 y(cien)m(t)28 b(then)f(the)g('app)s
-(end)e(record')i(subroutine)f(\(FTPREC\))g(describ)s(ed)g(ab)s(o)m(v)m
-(e)i(b)s(ecause)f(the)g(remaining)227 1101 y(k)m(eyw)m(ords)k(in)f(the)
-h(header)f(ha)m(v)m(e)h(to)g(b)s(e)f(shifted)g(do)m(wn)g(one)h(slot.)
-382 1349 y Ff(FTIREC\(unit,key_no,card,)41 b(>)47 b(status\))0
-1598 y Fi(2)81 b Fj(Insert)36 b(a)h(new)f(k)m(eyw)m(ord)i(in)m(to)g
-(the)f(CHU.)g(The)f(new)g(k)m(eyw)m(ord)i(is)f(inserted)f(immediately)i
-(follo)m(wing)h(the)227 1711 y(last)27 b(k)m(eyw)m(ord)g(that)f(has)g
+TeXDict begin 47 52 bop 0 299 a Fh(6.4.)72 b(FITS)30
+b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(47)0 555 y
+Fc(6.4.4)112 b(Insert)38 b(Keyw)m(ord)f(Subroutines)0
+763 y Fi(1)81 b Fj(Insert)26 b(a)h(new)f(k)m(eyw)m(ord)h(record)g(in)m
+(to)g(the)g(CHU)g(at)g(the)g(sp)s(eci\014ed)f(p)s(osition)h(\(i.e.,)i
+(immediately)f(preceding)227 876 y(the)34 b(\(k)m(eyno\)th)g(k)m(eyw)m
+(ord)g(in)f(the)h(header.\))49 b(This)33 b('insert)g(record')h
+(subroutine)e(is)h(somewhat)h(less)g(e\016-)227 989 y(cien)m(t)28
+b(then)f(the)g('app)s(end)e(record')i(subroutine)f(\(FTPREC\))g
+(describ)s(ed)g(ab)s(o)m(v)m(e)i(b)s(ecause)f(the)g(remaining)227
+1101 y(k)m(eyw)m(ords)k(in)f(the)h(header)f(ha)m(v)m(e)h(to)g(b)s(e)f
+(shifted)g(do)m(wn)g(one)h(slot.)382 1353 y Ff
+(FTIREC\(unit,key_no,card,)41 b(>)47 b(status\))0 1604
+y Fi(2)81 b Fj(Insert)36 b(a)h(new)f(k)m(eyw)m(ord)i(in)m(to)g(the)f
+(CHU.)g(The)f(new)g(k)m(eyw)m(ord)i(is)f(inserted)f(immediately)i
+(follo)m(wing)h(the)227 1717 y(last)27 b(k)m(eyw)m(ord)g(that)f(has)g
 (b)s(een)g(read)g(from)f(the)h(header.)40 b(The)25 b(FTIKLS)g
-(subroutine)g(w)m(orks)h(the)g(same)h(as)227 1824 y(the)h(FTIKYS)e
+(subroutine)g(w)m(orks)h(the)g(same)h(as)227 1830 y(the)h(FTIKYS)e
 (subroutine,)h(except)i(it)f(also)g(supp)s(orts)e(long)i(string)f(v)-5
 b(alues)28 b(greater)g(than)f(68)h(c)m(haracters)227
-1937 y(in)36 b(length.)59 b(These)36 b('insert)g(k)m(eyw)m(ord')h
+1943 y(in)36 b(length.)59 b(These)36 b('insert)g(k)m(eyw)m(ord')h
 (subroutines)e(are)i(somewhat)g(less)f(e\016cien)m(t)i(then)e(the)g
-('app)s(end)227 2049 y(k)m(eyw)m(ord')30 b(subroutines)e(describ)s(ed)g
+('app)s(end)227 2056 y(k)m(eyw)m(ord')30 b(subroutines)e(describ)s(ed)g
 (ab)s(o)m(v)m(e)i(b)s(ecause)f(the)g(remaining)h(k)m(eyw)m(ords)f(in)g
-(the)g(header)g(ha)m(v)m(e)h(to)227 2162 y(b)s(e)g(shifted)g(do)m(wn)g
-(one)h(slot.)382 2411 y Ff(FTIKEY\(unit,)44 b(card,)j(>)g(status\))382
-2524 y(FTIKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o(men)o(t,)42
-b(>)47 b(status\))382 2637 y(FTIKLS\(unit,keyword,keyv)o(al,)o(comm)o
-(ent,)41 b(>)47 b(status\))382 2750 y(FTIKY[EDFG]\(unit,keyword)o(,ke)o
+(the)g(header)g(ha)m(v)m(e)h(to)227 2168 y(b)s(e)g(shifted)g(do)m(wn)g
+(one)h(slot.)382 2420 y Ff(FTIKEY\(unit,)44 b(card,)j(>)g(status\))382
+2533 y(FTIKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o(men)o(t,)42
+b(>)47 b(status\))382 2645 y(FTIKLS\(unit,keyword,keyv)o(al,)o(comm)o
+(ent,)41 b(>)47 b(status\))382 2758 y(FTIKY[EDFG]\(unit,keyword)o(,ke)o
 (yval)o(,dec)o(ima)o(ls,c)o(omme)o(nt,)41 b(>)48 b(status\))0
-2998 y Fi(3)81 b Fj(Insert)32 b(a)i(new)f(k)m(eyw)m(ord)h(with)f(an)h
+3010 y Fi(3)81 b Fj(Insert)32 b(a)i(new)f(k)m(eyw)m(ord)h(with)f(an)h
 (unde\014ned,)e(or)h(n)m(ull,)h(v)-5 b(alue)34 b(in)m(to)h(the)e(CHU.)h
-(The)f(v)-5 b(alue)34 b(string)f(of)h(the)227 3111 y(k)m(eyw)m(ord)d
-(is)g(left)g(blank)f(in)g(this)g(case.)382 3359 y Ff
+(The)f(v)-5 b(alue)34 b(string)f(of)h(the)227 3123 y(k)m(eyw)m(ord)d
+(is)g(left)g(blank)f(in)g(this)g(case.)382 3374 y Ff
 (FTIKYU\(unit,keyword,comm)o(ent)o(,)42 b(>)47 b(status\))0
-3505 y
-SDict begin H.S end
- 0 3505 a 0 3505 a
-SDict begin 13.6 H.A end
- 0 3505 a 0 3505 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.5) cvn /DEST pdfmark
-end
- 0 3505 a 143
-x Fc(6.4.5)112 b(Read)38 b(Keyw)m(ord)g(Subroutines)0
-3867 y Fj(These)29 b(routines)f(return)g(the)h(v)-5 b(alue)29
+3663 y Fc(6.4.5)112 b(Read)38 b(Keyw)m(ord)g(Subroutines)0
+3882 y Fj(These)29 b(routines)f(return)g(the)h(v)-5 b(alue)29
 b(of)g(the)g(sp)s(eci\014ed)f(k)m(eyw)m(ord\(s\).)41
 b(Wild)30 b(card)e(c)m(haracters)i(\(*,)h(?,)e(or)g(#\))f(ma)m(y)0
-3980 y(b)s(e)f(used)h(when)f(sp)s(ecifying)h(the)g(name)g(of)g(the)g(k)
+3995 y(b)s(e)f(used)h(when)f(sp)s(ecifying)h(the)g(name)g(of)g(the)g(k)
 m(eyw)m(ord)h(to)g(b)s(e)e(read:)39 b(a)29 b(')10 b(?')40
 b(will)28 b(matc)m(h)h(an)m(y)g(single)f(c)m(haracter)0
-4093 y(at)38 b(that)g(p)s(osition)f(in)g(the)h(k)m(eyw)m(ord)g(name)f
+4108 y(at)38 b(that)g(p)s(osition)f(in)g(the)h(k)m(eyw)m(ord)g(name)f
 (and)g(a)g('*')i(will)e(matc)m(h)h(an)m(y)g(length)g(\(including)f
-(zero\))h(string)g(of)0 4206 y(c)m(haracters.)65 b(The)37
+(zero\))h(string)g(of)0 4221 y(c)m(haracters.)65 b(The)37
 b('#')h(c)m(haracter)h(will)f(matc)m(h)h(an)m(y)f(consecutiv)m(e)i
 (string)e(of)g(decimal)h(digits)f(\(0)h(-)f(9\).)64 b(Note)0
-4319 y(that)30 b(when)f(a)g(wild)g(card)h(is)f(used)g(in)g(the)h(input)
+4334 y(that)30 b(when)f(a)g(wild)g(card)h(is)f(used)g(in)g(the)h(input)
 e(k)m(eyw)m(ord)i(name,)g(the)g(routine)f(will)h(only)g(searc)m(h)g
-(for)f(a)h(matc)m(h)0 4432 y(from)h(the)h(curren)m(t)g(header)g(p)s
+(for)f(a)h(matc)m(h)0 4446 y(from)h(the)h(curren)m(t)g(header)g(p)s
 (osition)g(to)g(the)h(end)e(of)h(the)g(header.)45 b(It)32
 b(will)g(not)g(resume)g(the)g(searc)m(h)g(from)g(the)0
-4545 y(top)i(of)h(the)f(header)g(bac)m(k)h(to)g(the)f(original)h
+4559 y(top)i(of)h(the)f(header)g(bac)m(k)h(to)g(the)f(original)h
 (header)f(p)s(osition)g(as)h(is)f(done)g(when)f(no)h(wildcards)f(are)i
-(included)0 4657 y(in)f(the)g(k)m(eyw)m(ord)h(name.)52
+(included)0 4672 y(in)f(the)g(k)m(eyw)m(ord)h(name.)52
 b(If)33 b(the)h(desired)g(k)m(eyw)m(ord)h(string)f(is)g(8-c)m
 (haracters)i(long)f(\(the)f(maxim)m(um)g(length)h(of)0
-4770 y(a)h(k)m(eyw)m(ord)g(name\))g(then)g(a)g('*')g(ma)m(y)h(b)s(e)e
+4785 y(a)h(k)m(eyw)m(ord)g(name\))g(then)g(a)g('*')g(ma)m(y)h(b)s(e)e
 (app)s(ended)f(as)h(the)h(nin)m(th)g(c)m(haracter)h(of)f(the)f(input)g
-(name)h(to)g(force)0 4883 y(the)31 b(k)m(eyw)m(ord)g(searc)m(h)h(to)f
+(name)h(to)g(force)0 4898 y(the)31 b(k)m(eyw)m(ord)g(searc)m(h)h(to)f
 (stop)g(at)g(the)g(end)f(of)h(the)g(header)g(\(e.g.,)i('COMMENT)d(*')i
-(will)f(searc)m(h)g(for)g(the)g(next)0 4996 y(COMMENT)37
+(will)f(searc)m(h)g(for)g(the)g(next)0 5011 y(COMMENT)37
 b(k)m(eyw)m(ord\).)64 b(The)37 b(\013grec)i(routine)f(ma)m(y)g(b)s(e)f
 (used)g(to)i(set)f(the)g(starting)g(p)s(osition)g(when)f(doing)0
-5109 y(wild)30 b(card)g(searc)m(hes.)0 5357 y Fi(1)81
+5124 y(wild)30 b(card)g(searc)m(hes.)0 5375 y Fi(1)81
 b Fj(Get)37 b(the)f(n)m(th)f(80-c)m(haracter)k(header)d(record)g(from)f
 (the)h(CHU.)h(The)e(\014rst)g(k)m(eyw)m(ord)i(in)e(the)h(header)g(is)g
-(at)227 5470 y(k)m(ey)p 365 5470 28 4 v 34 w(no)42 b(=)f(1;)49
-b(if)42 b(k)m(ey)p 996 5470 V 34 w(no)g(=)f(0)i(then)e(this)h
+(at)227 5488 y(k)m(ey)p 365 5488 28 4 v 34 w(no)42 b(=)f(1;)49
+b(if)42 b(k)m(ey)p 996 5488 V 34 w(no)g(=)f(0)i(then)e(this)h
 (subroutine)f(simple)h(mo)m(v)m(es)i(the)e(in)m(ternal)h(p)s(oin)m(ter)
-f(to)h(the)227 5583 y(b)s(eginning)35 b(of)h(the)g(header)f(so)h(that)g
+f(to)h(the)227 5601 y(b)s(eginning)35 b(of)h(the)g(header)f(so)h(that)g
 (subsequen)m(t)f(k)m(eyw)m(ord)h(op)s(erations)g(will)g(start)g(at)g
-(the)g(top)g(of)g(the)227 5696 y(header;)31 b(it)g(also)g(returns)e(a)i
+(the)g(top)g(of)g(the)227 5714 y(header;)31 b(it)g(also)g(returns)e(a)i
 (blank)f(card)g(v)-5 b(alue)31 b(in)f(this)g(case.)p
 eop end
 %%Page: 48 54
-TeXDict begin 48 53 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.48) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(48)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTGREC\(unit,key_no,)42
+TeXDict begin 48 53 bop 0 299 a Fj(48)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTGREC\(unit,key_no,)42
 b(>)48 b(card,status\))0 797 y Fi(2)81 b Fj(Get)31 b(the)g(name,)f(v)-5
 b(alue)31 b(\(as)g(a)g(string\),)g(and)f(commen)m(t)i(of)e(the)h(n)m
 (th)f(k)m(eyw)m(ord)h(in)f(CHU.)h(This)f(routine)g(also)227
 910 y(c)m(hec)m(ks)h(that)f(the)g(returned)e(k)m(eyw)m(ord)i(name)f
 (\(KEYW)m(ORD\))i(con)m(tains)g(only)e(legal)i(ASCI)s(I)d(c)m
 (haracters.)227 1023 y(Call)j(FTGREC)f(and)g(FTPSV)m(C)g(to)h(b)m
 (ypass)f(this)g(error)g(c)m(hec)m(k.)382 1264 y Ff
@@ -10511,102 +8286,70 @@
 (length)h(of)f(68)h(c)m(haracters,)k(ho)m(w)m(ev)m(er,)f(CONTINUE'd)39
 b(string)227 5359 y(k)m(eyw)m(ords)31 b(ma)m(y)g(b)s(e)f(arbitrarily)g
 (long.)334 5601 y Ff(FTGKSL\(unit,keyword,)42 b(>)48
 b(length,status\))334 5714 y(FTGSKY\(unit,keyword,first)o(cha)o(r,ma)o
 (xcha)o(r,>)41 b(keyval,length,comment,sta)o(tus\))p
 eop end
 %%Page: 49 55
-TeXDict begin 49 54 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.49) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.4.)72
-b(FITS)30 b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(49)0
-555 y Fi(8)81 b Fj(Get)24 b(a)g(sequence)g(of)g(n)m(um)m(b)s(ered)e(k)m
-(eyw)m(ord)i(v)-5 b(alues.)38 b(These)24 b(routines)f(do)g(not)h(supp)s
-(ort)e(wild)h(card)g(c)m(haracters)227 668 y(in)30 b(the)h(ro)s(ot)g
-(name.)382 929 y Ff(FTGKN[EDJKLS]\(unit,keyro)o(ot,)o(star)o(tno,)o
-(max)o(_key)o(s,)42 b(>)47 b(keyvals,nfound,status\))0
-1189 y Fi(9)81 b Fj(Get)27 b(the)f(v)-5 b(alue)26 b(of)h(a)f
-(\015oating)h(p)s(oin)m(t)f(k)m(eyw)m(ord,)i(returning)d(the)h(in)m
-(teger)h(and)f(fractional)h(parts)f(of)g(the)g(v)-5 b(alue)227
-1302 y(in)32 b(separate)g(subroutine)f(argumen)m(ts.)45
-b(This)31 b(subroutine)f(ma)m(y)j(b)s(e)e(used)g(to)h(read)g(an)m(y)g
-(k)m(eyw)m(ord)g(but)f(is)227 1415 y(esp)s(ecially)h(useful)d(for)i
-(reading)f(the)h('triple)g(precision')f(k)m(eyw)m(ords)h(written)g(b)m
-(y)f(FTPKYT.)382 1675 y Ff(FTGKYT\(unit,keyword,)42 b(>)48
-b(intval,dblval,comment,s)o(tat)o(us\))0 1936 y Fi(10)e
+TeXDict begin 49 54 bop 0 299 a Fh(6.4.)72 b(FITS)30
+b(HEADER)h(I/O)f(SUBR)m(OUTINES)2086 b Fj(49)0 555 y
+Fi(8)81 b Fj(Get)24 b(a)g(sequence)g(of)g(n)m(um)m(b)s(ered)e(k)m(eyw)m
+(ord)i(v)-5 b(alues.)38 b(These)24 b(routines)f(do)g(not)h(supp)s(ort)e
+(wild)h(card)g(c)m(haracters)227 668 y(in)30 b(the)h(ro)s(ot)g(name.)
+382 930 y Ff(FTGKN[EDJKLS]\(unit,keyro)o(ot,)o(star)o(tno,)o(max)o
+(_key)o(s,)42 b(>)47 b(keyvals,nfound,status\))0 1192
+y Fi(9)81 b Fj(Get)27 b(the)f(v)-5 b(alue)26 b(of)h(a)f(\015oating)h(p)
+s(oin)m(t)f(k)m(eyw)m(ord,)i(returning)d(the)h(in)m(teger)h(and)f
+(fractional)h(parts)f(of)g(the)g(v)-5 b(alue)227 1305
+y(in)32 b(separate)g(subroutine)f(argumen)m(ts.)45 b(This)31
+b(subroutine)f(ma)m(y)j(b)s(e)e(used)g(to)h(read)g(an)m(y)g(k)m(eyw)m
+(ord)g(but)f(is)227 1418 y(esp)s(ecially)h(useful)d(for)i(reading)f
+(the)h('triple)g(precision')f(k)m(eyw)m(ords)h(written)g(b)m(y)f
+(FTPKYT.)382 1680 y Ff(FTGKYT\(unit,keyword,)42 b(>)48
+b(intval,dblval,comment,s)o(tat)o(us\))0 1941 y Fi(10)e
 Fj(Get)c(the)e(ph)m(ysical)i(units)e(string)g(in)h(an)f(existing)i(k)m
 (eyw)m(ord.)72 b(This)40 b(routine)g(uses)h(a)g(lo)s(cal)h(con)m(v)m
-(en)m(tion,)227 2049 y(sho)m(wn)32 b(in)g(the)h(follo)m(wing)h
+(en)m(tion,)227 2054 y(sho)m(wn)32 b(in)g(the)h(follo)m(wing)h
 (example,)g(in)e(whic)m(h)g(the)h(k)m(eyw)m(ord)g(units)f(are)h
-(enclosed)g(in)f(square)g(brac)m(k)m(ets)227 2162 y(in)37
+(enclosed)g(in)f(square)g(brac)m(k)m(ets)227 2167 y(in)37
 b(the)h(b)s(eginning)e(of)i(the)f(k)m(eyw)m(ord)h(commen)m(t)g
 (\014eld.)61 b(A)38 b(blank)f(string)g(is)g(returned)f(if)i(no)f(units)
-g(are)227 2274 y(de\014ned)29 b(for)i(the)f(k)m(eyw)m(ord.)191
-2535 y Ff(VELOCITY=)809 b(12.3)46 b(/)i([km/s])e(orbital)g(speed)382
-2761 y(FTGUNT\(unit,keyword,)c(>)48 b(units,status\))0
-2909 y
-SDict begin H.S end
- 0 2909 a 0 2909 a
-SDict begin 13.6 H.A end
- 0 2909 a 0 2909 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.6) cvn /DEST pdfmark
-end
- 0 2909 a 143
-x Fc(6.4.6)112 b(Mo)s(dify)39 b(Keyw)m(ord)e(Subroutines)0
-3271 y Fj(Wild)32 b(card)f(c)m(haracters,)j(as)e(describ)s(ed)e(in)h
+g(are)227 2280 y(de\014ned)29 b(for)i(the)f(k)m(eyw)m(ord.)191
+2542 y Ff(VELOCITY=)809 b(12.3)46 b(/)i([km/s])e(orbital)g(speed)382
+2768 y(FTGUNT\(unit,keyword,)c(>)48 b(units,status\))0
+3061 y Fc(6.4.6)112 b(Mo)s(dify)39 b(Keyw)m(ord)e(Subroutines)0
+3280 y Fj(Wild)32 b(card)f(c)m(haracters,)j(as)e(describ)s(ed)e(in)h
 (the)h(Read)g(Keyw)m(ord)f(section,)i(ab)s(o)m(v)m(e,)g(ma)m(y)g(b)s(e)
-d(used)h(when)g(sp)s(eci-)0 3384 y(fying)f(the)h(name)f(of)h(the)f(k)m
-(eyw)m(ord)h(to)g(b)s(e)f(mo)s(di\014ed.)0 3645 y Fi(1)81
+d(used)h(when)g(sp)s(eci-)0 3393 y(fying)f(the)h(name)f(of)h(the)f(k)m
+(eyw)m(ord)h(to)g(b)s(e)f(mo)s(di\014ed.)0 3655 y Fi(1)81
 b Fj(Mo)s(dify)30 b(\(o)m(v)m(erwrite\))i(the)f(n)m(th)f(80-c)m
-(haracter)j(header)d(record)h(in)f(the)g(CHU)382 3905
+(haracter)j(header)d(record)h(in)f(the)g(CHU)382 3917
 y Ff(FTMREC\(unit,key_no,card,)41 b(>)47 b(status\))0
-4166 y Fi(2)81 b Fj(Mo)s(dify)37 b(\(o)m(v)m(erwrite\))j(the)e(80-c)m
+4179 y Fi(2)81 b Fj(Mo)s(dify)37 b(\(o)m(v)m(erwrite\))j(the)e(80-c)m
 (haracter)j(header)c(record)h(for)f(the)h(named)f(k)m(eyw)m(ord)h(in)g
-(the)g(CHU.)g(This)227 4278 y(can)31 b(b)s(e)f(used)f(to)i(o)m(v)m
+(the)g(CHU.)g(This)227 4292 y(can)31 b(b)s(e)f(used)f(to)i(o)m(v)m
 (erwrite)h(the)f(name)f(of)h(the)f(k)m(eyw)m(ord)h(as)g(w)m(ell)g(as)g
 (its)g(v)-5 b(alue)30 b(and)g(commen)m(t)i(\014elds.)382
-4539 y Ff(FTMCRD\(unit,keyword,card)o(,)42 b(>)47 b(status\))0
-4799 y Fi(3)81 b Fj(Mo)s(dify)33 b(\(o)m(v)m(erwrite\))k(the)d(name)g
+4554 y Ff(FTMCRD\(unit,keyword,card)o(,)42 b(>)47 b(status\))0
+4815 y Fi(3)81 b Fj(Mo)s(dify)33 b(\(o)m(v)m(erwrite\))k(the)d(name)g
 (of)h(an)f(existing)h(k)m(eyw)m(ord)f(in)g(the)h(CHU)f(preserving)f
-(the)i(curren)m(t)e(v)-5 b(alue)227 4912 y(and)30 b(commen)m(t)h
-(\014elds.)382 5173 y Ff(FTMNAM\(unit,oldkey,keywo)o(rd,)41
-b(>)48 b(status\))0 5433 y Fi(4)81 b Fj(Mo)s(dify)30
+(the)i(curren)m(t)e(v)-5 b(alue)227 4928 y(and)30 b(commen)m(t)h
+(\014elds.)382 5190 y Ff(FTMNAM\(unit,oldkey,keywo)o(rd,)41
+b(>)48 b(status\))0 5452 y Fi(4)81 b Fj(Mo)s(dify)30
 b(\(o)m(v)m(erwrite\))i(the)f(commen)m(t)g(\014eld)f(of)h(an)f
-(existing)h(k)m(eyw)m(ord)g(in)f(the)h(CHU)382 5694 y
+(existing)h(k)m(eyw)m(ord)g(in)f(the)h(CHU)382 5714 y
 Ff(FTMCOM\(unit,keyword,comm)o(ent)o(,)42 b(>)47 b(status\))p
 eop end
 %%Page: 50 56
-TeXDict begin 50 55 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.50) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(50)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fi(5)81 b Fj(Mo)s(dify)24
-b(the)h(v)-5 b(alue)25 b(and)f(commen)m(t)i(\014elds)e(of)h(an)f
-(existing)i(k)m(eyw)m(ord)f(in)f(the)h(CHU.)g(The)f(FTMKLS)g(subrou-)
-227 668 y(tine)35 b(w)m(orks)e(the)h(same)h(as)f(the)g(FTMKYS)f
+TeXDict begin 50 55 bop 0 299 a Fj(50)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fi(5)81 b Fj(Mo)s(dify)24 b(the)h(v)-5
+b(alue)25 b(and)f(commen)m(t)i(\014elds)e(of)h(an)f(existing)i(k)m(eyw)
+m(ord)f(in)f(the)h(CHU.)g(The)f(FTMKLS)g(subrou-)227
+668 y(tine)35 b(w)m(orks)e(the)h(same)h(as)f(the)g(FTMKYS)f
 (subroutine,)h(except)h(it)g(also)f(supp)s(orts)e(long)j(string)f(v)-5
 b(alues)227 781 y(greater)38 b(than)f(68)h(c)m(haracters)g(in)f
 (length.)60 b(Optionally)-8 b(,)40 b(one)d(ma)m(y)h(mo)s(dify)e(only)h
 (the)g(v)-5 b(alue)37 b(\014eld)g(and)227 894 y(lea)m(v)m(e)32
 b(the)d(commen)m(t)i(\014eld)e(unc)m(hanged)g(b)m(y)g(setting)h(the)g
 (input)e(COMMENT)h(parameter)h(equal)g(to)g(the)227 1007
 y(amp)s(ersand)f(c)m(haracter)k(\(&\).)42 b(The)30 b(E)g(and)g(D)h(v)m
@@ -10615,193 +8358,146 @@
 (e,)k(then)c(the)g('G')h(displa)m(y)f(format)h(rather)f(then)g(the)g
 ('E')h(format)227 1233 y(will)i(b)s(e)f(used)f(when)h(constructing)h
 (the)f(k)m(eyw)m(ord)h(v)-5 b(alue,)30 b(taking)f(the)g(absolute)g(v)-5
 b(alue)29 b(of)f('decimals')i(for)227 1346 y(the)37 b(precision.)60
 b(This)35 b(will)i(suppress)e(trailing)i(zeros,)i(and)d(will)h(use)g(a)
 g(\014xed)e(format)i(rather)g(than)f(an)227 1458 y(exp)s(onen)m(tial)c
 (format,)f(dep)s(ending)d(on)j(the)f(magnitude)h(of)f(the)h(v)-5
-b(alue.)382 1687 y Ff(FTMKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o
-(men)o(t,)42 b(>)47 b(status\))382 1800 y(FTMKLS\(unit,keyword,keyv)o
-(al,)o(comm)o(ent,)41 b(>)47 b(status\))382 1913 y
+b(alue.)382 1689 y Ff(FTMKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o
+(men)o(t,)42 b(>)47 b(status\))382 1802 y(FTMKLS\(unit,keyword,keyv)o
+(al,)o(comm)o(ent,)41 b(>)47 b(status\))382 1915 y
 (FTMKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o(ima)o(ls,c)o(omme)o
-(nt,)41 b(>)48 b(status\))0 2141 y Fi(6)81 b Fj(Mo)s(dify)22
+(nt,)41 b(>)48 b(status\))0 2146 y Fi(6)81 b Fj(Mo)s(dify)22
 b(the)g(v)-5 b(alue)23 b(of)f(an)g(existing)i(k)m(eyw)m(ord)e(to)h(b)s
 (e)f(unde\014ned,)g(or)g(n)m(ull.)38 b(The)22 b(v)-5
-b(alue)22 b(string)h(of)f(the)g(k)m(eyw)m(ord)227 2254
+b(alue)22 b(string)h(of)f(the)g(k)m(eyw)m(ord)227 2259
 y(is)30 b(set)h(to)g(blank.)40 b(Optionally)-8 b(,)31
 b(one)f(ma)m(y)h(lea)m(v)m(e)h(the)f(commen)m(t)g(\014eld)e(unc)m
-(hanged)h(b)m(y)g(setting)h(the)f(input)227 2367 y(COMMENT)g(parameter)
+(hanged)h(b)m(y)g(setting)h(the)f(input)227 2372 y(COMMENT)g(parameter)
 h(equal)g(to)g(the)g(amp)s(ersand)e(c)m(haracter)j(\(&\).)382
-2595 y Ff(FTMKYU\(unit,keyword,comm)o(ent)o(,)42 b(>)47
-b(status\))0 2737 y
-SDict begin H.S end
- 0 2737 a 0 2737 a
-SDict begin 13.6 H.A end
- 0 2737 a 0 2737
-a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.7) cvn /DEST pdfmark
-end
- 0 2737 a 144 x Fc(6.4.7)112 b(Up)s(date)39 b(Keyw)m(ord)e
-(Subroutines)0 3084 y Fi(1)81 b Fj(Up)s(date)36 b(an)g(80-c)m(haracter)
+2602 y Ff(FTMKYU\(unit,keyword,comm)o(ent)o(,)42 b(>)47
+b(status\))0 2888 y Fc(6.4.7)112 b(Up)s(date)39 b(Keyw)m(ord)e
+(Subroutines)0 3092 y Fi(1)81 b Fj(Up)s(date)36 b(an)g(80-c)m(haracter)
 j(record)d(in)g(the)h(CHU.)f(If)g(the)g(sp)s(eci\014ed)g(k)m(eyw)m(ord)
-h(already)f(exists)h(then)f(that)227 3197 y(header)j(record)f(will)h(b)
+h(already)f(exists)h(then)f(that)227 3205 y(header)j(record)f(will)h(b)
 s(e)f(replaced)i(with)e(the)h(input)f(CARD)g(string.)66
 b(If)38 b(it)i(do)s(es)e(not)h(exist)g(then)g(the)227
-3310 y(new)f(record)g(will)g(b)s(e)f(added)h(to)g(the)g(header.)64
+3318 y(new)f(record)g(will)g(b)s(e)f(added)h(to)g(the)g(header.)64
 b(The)37 b(FTUKLS)g(subroutine)g(w)m(orks)h(the)g(same)h(as)f(the)227
-3423 y(FTUKYS)28 b(subroutine,)g(except)i(it)f(also)h(supp)s(orts)c
+3431 y(FTUKYS)28 b(subroutine,)g(except)i(it)f(also)h(supp)s(orts)c
 (long)j(string)g(v)-5 b(alues)29 b(greater)h(than)e(68)h(c)m(haracters)
-h(in)227 3536 y(length.)382 3764 y Ff(FTUCRD\(unit,keyword,card)o(,)42
-b(>)47 b(status\))0 3993 y Fi(2)81 b Fj(Up)s(date)44
+h(in)227 3544 y(length.)382 3775 y Ff(FTUCRD\(unit,keyword,card)o(,)42
+b(>)47 b(status\))0 4006 y Fi(2)81 b Fj(Up)s(date)44
 b(the)i(v)-5 b(alue)45 b(and)g(commen)m(t)h(\014elds)e(of)h(a)h(k)m
 (eyw)m(ord)f(in)g(the)g(CHU.)h(The)e(sp)s(eci\014ed)g(k)m(eyw)m(ord)i
-(is)227 4106 y(mo)s(di\014ed)38 b(if)g(it)h(already)g(exists)g(\(b)m(y)
+(is)227 4118 y(mo)s(di\014ed)38 b(if)g(it)h(already)g(exists)g(\(b)m(y)
 g(calling)h(FTMKYx\))f(otherwise)f(a)h(new)f(k)m(eyw)m(ord)h(is)g
-(created)g(b)m(y)227 4218 y(calling)f(FTPKYx.)58 b(The)36
+(created)g(b)m(y)227 4231 y(calling)f(FTPKYx.)58 b(The)36
 b(E)g(and)f(D)i(v)m(ersions)f(of)h(this)f(routine)g(ha)m(v)m(e)h(the)g
-(added)e(feature)i(that)g(if)f(the)227 4331 y('decimals')c(parameter)g
+(added)e(feature)i(that)g(if)f(the)227 4344 y('decimals')c(parameter)g
 (is)f(negativ)m(e,)i(then)d(the)h('G')h(displa)m(y)f(format)g(rather)g
-(then)f(the)h('E')g(format)h(will)227 4444 y(b)s(e)41
+(then)f(the)h('E')g(format)h(will)227 4457 y(b)s(e)41
 b(used)f(when)h(constructing)h(the)f(k)m(eyw)m(ord)h(v)-5
 b(alue,)45 b(taking)d(the)f(absolute)h(v)-5 b(alue)42
-b(of)g('decimals')g(for)227 4557 y(the)37 b(precision.)60
+b(of)g('decimals')g(for)227 4570 y(the)37 b(precision.)60
 b(This)35 b(will)i(suppress)e(trailing)i(zeros,)i(and)d(will)h(use)g(a)
-g(\014xed)e(format)i(rather)g(than)f(an)227 4670 y(exp)s(onen)m(tial)c
+g(\014xed)e(format)i(rather)g(than)f(an)227 4683 y(exp)s(onen)m(tial)c
 (format,)f(dep)s(ending)d(on)j(the)f(magnitude)h(of)f(the)h(v)-5
-b(alue.)382 4898 y Ff(FTUKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o
-(men)o(t,)42 b(>)47 b(status\))382 5011 y(FTUKLS\(unit,keyword,keyv)o
-(al,)o(comm)o(ent,)41 b(>)47 b(status\))382 5124 y
+b(alue.)382 4914 y Ff(FTUKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o
+(men)o(t,)42 b(>)47 b(status\))382 5027 y(FTUKLS\(unit,keyword,keyv)o
+(al,)o(comm)o(ent,)41 b(>)47 b(status\))382 5140 y
 (FTUKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o(ima)o(ls,c)o(omme)o
-(nt,)41 b(>)48 b(status\))0 5352 y Fi(3)81 b Fj(Up)s(date)23
+(nt,)41 b(>)48 b(status\))0 5370 y Fi(3)81 b Fj(Up)s(date)23
 b(the)g(v)-5 b(alue)24 b(of)g(an)f(existing)i(k)m(eyw)m(ord)f(to)g(b)s
 (e)f(unde\014ned,)f(or)i(n)m(ull,)h(or)e(insert)h(a)f(new)g
-(unde\014ned-v)-5 b(alue)227 5465 y(k)m(eyw)m(ord)30
+(unde\014ned-v)-5 b(alue)227 5483 y(k)m(eyw)m(ord)30
 b(if)f(it)h(do)s(esn't)f(already)h(exist.)41 b(The)29
 b(v)-5 b(alue)30 b(string)f(of)g(the)h(k)m(eyw)m(ord)f(is)h(left)g
-(blank)f(in)f(this)i(case.)382 5694 y Ff(FTUKYU\(unit,keyword,comm)o
+(blank)f(in)f(this)i(case.)382 5714 y Ff(FTUKYU\(unit,keyword,comm)o
 (ent)o(,)42 b(>)47 b(status\))p eop end
 %%Page: 51 57
-TeXDict begin 51 56 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.51) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.5.)72
-b(D)m(A)-8 b(T)g(A)32 b(SCALING)e(AND)h(UNDEFINED)h(PIXEL)e(P)-8
-b(ARAMETERS)1083 b Fj(51)0 464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464
-a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.4.8) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fc(6.4.8)112 b(Delete)38 b(Keyw)m(ord)f
-(Subroutines)0 763 y Fi(1)81 b Fj(Delete)32 b(an)e(existing)h(k)m(eyw)m
-(ord)g(record.)40 b(The)30 b(space)h(previously)f(o)s(ccupied)g(b)m(y)g
-(the)g(k)m(eyw)m(ord)h(is)f(reclaimed)227 876 y(b)m(y)c(mo)m(ving)h
-(all)g(the)f(follo)m(wing)i(header)e(records)g(up)f(one)h(ro)m(w)h(in)e
-(the)i(header.)39 b(The)25 b(\014rst)h(routine)g(deletes)227
-989 y(a)34 b(k)m(eyw)m(ord)f(at)h(a)g(sp)s(eci\014ed)e(p)s(osition)h
-(in)g(the)g(header)g(\(the)h(\014rst)e(k)m(eyw)m(ord)i(is)f(at)h(p)s
-(osition)f(1\),)i(whereas)227 1102 y(the)d(second)g(routine)g(deletes)h
-(a)f(sp)s(eci\014cally)g(named)f(k)m(eyw)m(ord.)46 b(Wild)32
-b(card)f(c)m(haracters,)j(as)e(describ)s(ed)227 1215
-y(in)f(the)g(Read)g(Keyw)m(ord)f(section,)i(ab)s(o)m(v)m(e,)g(ma)m(y)g
-(b)s(e)e(used)g(when)f(sp)s(ecifying)i(the)g(name)g(of)g(the)f(k)m(eyw)
-m(ord)227 1328 y(to)h(b)s(e)f(deleted)h(\(b)s(e)f(careful!\).)382
-1582 y Ff(FTDREC\(unit,key_no,)42 b(>)48 b(status\))382
-1695 y(FTDKEY\(unit,keyword,)42 b(>)48 b(status\))0 1852
-y
-SDict begin H.S end
- 0 1852 a 0 1852 a
-SDict begin 13.6 H.A end
- 0 1852 a 0 1852 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.5) cvn /DEST pdfmark
-end
- 0 1852 a 176 x
-Fe(6.5)135 b(Data)46 b(Scaling)g(and)e(Unde\014ned)h(Pixel)h(P)l
-(arameters)0 2278 y Fj(These)24 b(subroutines)f(de\014ne)h(or)h(mo)s
+TeXDict begin 51 56 bop 0 299 a Fh(6.5.)72 b(D)m(A)-8
+b(T)g(A)32 b(SCALING)e(AND)h(UNDEFINED)h(PIXEL)e(P)-8
+b(ARAMETERS)1083 b Fj(51)0 555 y Fc(6.4.8)112 b(Delete)38
+b(Keyw)m(ord)f(Subroutines)0 764 y Fi(1)81 b Fj(Delete)32
+b(an)e(existing)h(k)m(eyw)m(ord)g(record.)40 b(The)30
+b(space)h(previously)f(o)s(ccupied)g(b)m(y)g(the)g(k)m(eyw)m(ord)h(is)f
+(reclaimed)227 877 y(b)m(y)c(mo)m(ving)h(all)g(the)f(follo)m(wing)i
+(header)e(records)g(up)f(one)h(ro)m(w)h(in)e(the)i(header.)39
+b(The)25 b(\014rst)h(routine)g(deletes)227 990 y(a)34
+b(k)m(eyw)m(ord)f(at)h(a)g(sp)s(eci\014ed)e(p)s(osition)h(in)g(the)g
+(header)g(\(the)h(\014rst)e(k)m(eyw)m(ord)i(is)f(at)h(p)s(osition)f
+(1\),)i(whereas)227 1103 y(the)d(second)g(routine)g(deletes)h(a)f(sp)s
+(eci\014cally)g(named)f(k)m(eyw)m(ord.)46 b(Wild)32 b(card)f(c)m
+(haracters,)j(as)e(describ)s(ed)227 1215 y(in)f(the)g(Read)g(Keyw)m
+(ord)f(section,)i(ab)s(o)m(v)m(e,)g(ma)m(y)g(b)s(e)e(used)g(when)f(sp)s
+(ecifying)i(the)g(name)g(of)g(the)f(k)m(eyw)m(ord)227
+1328 y(to)h(b)s(e)f(deleted)h(\(b)s(e)f(careful!\).)382
+1586 y Ff(FTDREC\(unit,key_no,)42 b(>)48 b(status\))382
+1699 y(FTDKEY\(unit,keyword,)42 b(>)48 b(status\))0 2032
+y Fe(6.5)135 b(Data)46 b(Scaling)g(and)e(Unde\014ned)h(Pixel)h(P)l
+(arameters)0 2282 y Fj(These)24 b(subroutines)f(de\014ne)h(or)h(mo)s
 (dify)e(the)i(in)m(ternal)g(parameters)g(used)f(b)m(y)g(FITSIO)g(to)h
-(either)g(scale)h(the)e(data)0 2391 y(or)33 b(to)i(represen)m(t)e
+(either)g(scale)h(the)e(data)0 2395 y(or)33 b(to)i(represen)m(t)e
 (unde\014ned)e(pixels.)50 b(Generally)35 b(FITSIO)d(will)i(scale)g(the)
 g(data)g(according)g(to)g(the)g(v)-5 b(alues)34 b(of)0
-2504 y(the)e(BSCALE)g(and)f(BZER)m(O)h(\(or)h(TSCALn)d(and)i(TZER)m
+2508 y(the)e(BSCALE)g(and)f(BZER)m(O)h(\(or)h(TSCALn)d(and)i(TZER)m
 (On\))f(k)m(eyw)m(ords,)i(ho)m(w)m(ev)m(er)h(these)e(subroutines)f(ma)m
-(y)0 2617 y(b)s(e)h(used)h(to)h(o)m(v)m(erride)g(the)f(k)m(eyw)m(ord)h
+(y)0 2621 y(b)s(e)h(used)h(to)h(o)m(v)m(erride)g(the)f(k)m(eyw)m(ord)h
 (v)-5 b(alues.)49 b(This)32 b(ma)m(y)i(b)s(e)f(useful)f(when)g(one)i(w)
-m(an)m(ts)f(to)h(read)f(or)g(write)h(the)0 2730 y(ra)m(w)c(unscaled)f
+m(an)m(ts)f(to)h(read)f(or)g(write)h(the)0 2734 y(ra)m(w)c(unscaled)f
 (v)-5 b(alues)29 b(in)h(the)f(FITS)g(\014le.)40 b(Similarly)-8
 b(,)31 b(FITSIO)d(generally)j(uses)e(the)g(v)-5 b(alue)30
-b(of)g(the)f(BLANK)h(or)0 2843 y(TNULLn)35 b(k)m(eyw)m(ord)h(to)g
+b(of)g(the)f(BLANK)h(or)0 2847 y(TNULLn)35 b(k)m(eyw)m(ord)h(to)g
 (signify)f(an)h(unde\014ned)d(pixel,)k(but)e(these)h(routines)g(ma)m(y)
-g(b)s(e)e(used)h(to)h(o)m(v)m(erride)h(this)0 2956 y(v)-5
+g(b)s(e)e(used)h(to)h(o)m(v)m(erride)h(this)0 2959 y(v)-5
 b(alue.)41 b(These)30 b(subroutines)f(do)i(not)f(create)i(or)f(mo)s
 (dify)e(the)i(corresp)s(onding)e(header)h(k)m(eyw)m(ord)h(v)-5
-b(alues.)0 3210 y Fi(1)81 b Fj(Reset)26 b(the)g(scaling)g(factors)g(in)
+b(alues.)0 3217 y Fi(1)81 b Fj(Reset)26 b(the)g(scaling)g(factors)g(in)
 f(the)h(primary)f(arra)m(y)h(or)f(image)i(extension;)h(do)s(es)d(not)g
-(c)m(hange)i(the)f(BSCALE)227 3323 y(and)i(BZER)m(O)g(k)m(eyw)m(ord)h
+(c)m(hange)i(the)f(BSCALE)227 3330 y(and)i(BZER)m(O)g(k)m(eyw)m(ord)h
 (v)-5 b(alues)28 b(and)g(only)g(a\013ects)i(the)e(automatic)j(scaling)e
-(p)s(erformed)e(when)g(the)h(data)227 3436 y(elemen)m(ts)f(are)f
+(p)s(erformed)e(when)g(the)h(data)227 3443 y(elemen)m(ts)f(are)f
 (written/read)g(to/from)g(the)g(FITS)f(\014le.)39 b(When)25
 b(reading)h(from)f(a)h(FITS)f(\014le)g(the)h(returned)227
-3549 y(data)i(v)-5 b(alue)28 b(=)f(\(the)h(v)-5 b(alue)28
+3556 y(data)i(v)-5 b(alue)28 b(=)f(\(the)h(v)-5 b(alue)28
 b(giv)m(en)h(in)e(the)g(FITS)g(arra)m(y\))h(*)g(BSCALE)f(+)g(BZER)m(O.)
-g(The)g(in)m(v)m(erse)i(form)m(ula)227 3662 y(is)34 b(used)f(when)g
+g(The)g(in)m(v)m(erse)i(form)m(ula)227 3668 y(is)34 b(used)f(when)g
 (writing)h(data)h(v)-5 b(alues)34 b(to)g(the)g(FITS)g(\014le.)51
 b(\(NOTE:)34 b(BSCALE)f(and)g(BZER)m(O)h(m)m(ust)g(b)s(e)227
-3775 y(declared)d(as)g(Double)g(Precision)g(v)-5 b(ariables\).)382
-4029 y Ff(FTPSCL\(unit,bscale,bzero)o(,)42 b(>)47 b(status\))0
-4284 y Fi(2)81 b Fj(Reset)39 b(the)f(scaling)i(parameters)e(for)h(a)f
+3781 y(declared)d(as)g(Double)g(Precision)g(v)-5 b(ariables\).)382
+4039 y Ff(FTPSCL\(unit,bscale,bzero)o(,)42 b(>)47 b(status\))0
+4296 y Fi(2)81 b Fj(Reset)39 b(the)f(scaling)i(parameters)e(for)h(a)f
 (table)h(column;)k(do)s(es)38 b(not)g(c)m(hange)i(the)e(TSCALn)f(or)h
-(TZER)m(On)227 4397 y(k)m(eyw)m(ord)29 b(v)-5 b(alues)29
+(TZER)m(On)227 4409 y(k)m(eyw)m(ord)29 b(v)-5 b(alues)29
 b(and)e(only)i(a\013ects)g(the)g(automatic)h(scaling)f(p)s(erformed)e
-(when)g(the)i(data)g(elemen)m(ts)h(are)227 4510 y(written/read)i
+(when)g(the)i(data)g(elemen)m(ts)h(are)227 4522 y(written/read)i
 (to/from)g(the)g(FITS)f(\014le.)44 b(When)31 b(reading)g(from)g(a)h
 (FITS)f(\014le)g(the)h(returned)e(data)i(v)-5 b(alue)227
-4623 y(=)40 b(\(the)h(v)-5 b(alue)40 b(giv)m(en)h(in)f(the)g(FITS)g
+4635 y(=)40 b(\(the)h(v)-5 b(alue)40 b(giv)m(en)h(in)f(the)g(FITS)g
 (arra)m(y\))g(*)h(TSCAL)e(+)g(TZER)m(O.)h(The)f(in)m(v)m(erse)i(form)m
-(ula)g(is)f(used)227 4736 y(when)33 b(writing)h(data)h(v)-5
+(ula)g(is)f(used)227 4748 y(when)33 b(writing)h(data)h(v)-5
 b(alues)35 b(to)f(the)h(FITS)e(\014le.)52 b(\(NOTE:)34
 b(TSCAL)f(and)g(TZER)m(O)g(m)m(ust)h(b)s(e)f(declared)227
-4848 y(as)e(Double)g(Precision)g(v)-5 b(ariables\).)382
-5103 y Ff(FTTSCL\(unit,colnum,tscal)o(,tz)o(ero,)41 b(>)48
-b(status\))0 5357 y Fi(3)81 b Fj(De\014ne)36 b(the)g(in)m(teger)i(v)-5
+4861 y(as)e(Double)g(Precision)g(v)-5 b(ariables\).)382
+5118 y Ff(FTTSCL\(unit,colnum,tscal)o(,tz)o(ero,)41 b(>)48
+b(status\))0 5375 y Fi(3)81 b Fj(De\014ne)36 b(the)g(in)m(teger)i(v)-5
 b(alue)36 b(to)h(b)s(e)e(used)h(to)h(signify)f(unde\014ned)e(pixels)i
-(in)g(the)g(primary)f(arra)m(y)i(or)f(image)227 5470
+(in)g(the)g(primary)f(arra)m(y)i(or)f(image)227 5488
 y(extension.)59 b(This)35 b(is)h(only)g(used)g(if)g(BITPIX)g(=)f(8,)j
 (16,)h(32.)59 b(or)36 b(64)h(This)e(do)s(es)h(not)g(create)i(or)e(c)m
-(hange)227 5583 y(the)27 b(v)-5 b(alue)28 b(of)f(the)g(BLANK)g(k)m(eyw)
+(hange)227 5601 y(the)27 b(v)-5 b(alue)28 b(of)f(the)g(BLANK)g(k)m(eyw)
 m(ord)h(in)e(the)i(header.)39 b(FTPNULLL)27 b(is)g(iden)m(tical)h(to)g
-(FTPNUL)f(except)227 5696 y(that)k(the)g(blank)f(v)-5
+(FTPNUL)f(except)227 5714 y(that)k(the)g(blank)f(v)-5
 b(alue)31 b(is)f(a)h(64-bit)g(in)m(teger)h(instead)f(of)f(a)h(32-bit)h
 (in)m(teger.)p eop end
 %%Page: 52 58
-TeXDict begin 52 57 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.52) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(52)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTPNUL\(unit,blank,)43
+TeXDict begin 52 57 bop 0 299 a Fj(52)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTPNUL\(unit,blank,)43
 b(>)k(status\))382 668 y(FTPNULLL\(unit,blankll,)42 b(>)47
 b(status\))0 919 y Fi(4)81 b Fj(De\014ne)36 b(the)g(string)g(to)g(b)s
 (e)f(used)g(to)i(signify)f(unde\014ned)e(pixels)i(in)f(a)h(column)g(in)
 g(an)f(ASCI)s(I)g(table.)58 b(This)227 1032 y(do)s(es)30
 b(not)h(create)h(or)e(c)m(hange)i(the)e(v)-5 b(alue)31
 b(of)g(the)f(TNULLn)g(k)m(eyw)m(ord.)382 1283 y Ff
 (FTSNUL\(unit,colnum,snull)41 b(>)47 b(status\))0 1534
@@ -10811,1052 +8507,884 @@
 ('I',)f('J',)f(or)h('K'\).)g(This)f(do)s(es)g(not)h(create)h(or)e(c)m
 (hange)i(the)e(v)-5 b(alue)42 b(of)g(the)227 1760 y(TNULLn)d(k)m(eyw)m
 (ord.)71 b(FTTNULLL)39 b(is)i(iden)m(tical)h(to)e(FTTNUL)g(except)h
 (that)g(the)f(tn)m(ull)h(v)-5 b(alue)40 b(is)h(a)227
 1872 y(64-bit)32 b(in)m(teger)g(instead)e(of)h(a)g(32-bit)g(in)m
 (teger.)382 2123 y Ff(FTTNUL\(unit,colnum,tnull)41 b(>)47
 b(status\))382 2236 y(FTTNULLL\(unit,colnum,tnu)o(lll)o(l)42
-b(>)47 b(status\))0 2385 y
-SDict begin H.S end
- 0 2385 a 0 2385 a
-SDict begin 13.6 H.A end
- 0 2385 a
-0 2385 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.6) cvn /DEST pdfmark
-end
- 0 2385 a 184 x Fe(6.6)135 b(FITS)44 b(Primary)h(Arra)l(y)g(or)
-g(IMA)l(GE)g(Extension)h(I/O)f(Subroutines)0 2819 y Fj(These)26
-b(subroutines)f(put)h(or)h(get)g(data)h(v)-5 b(alues)26
-b(in)h(the)f(primary)g(data)h(arra)m(y)g(\(i.e.,)i(the)e(\014rst)f(HDU)
-h(in)f(the)h(FITS)0 2932 y(\014le\))35 b(or)g(an)f(IMA)m(GE)i
-(extension.)54 b(The)34 b(data)i(arra)m(y)f(is)f(represen)m(ted)h(as)g
-(a)g(single)g(one-dimensional)h(arra)m(y)f(of)0 3045
-y(pixels)h(regardless)h(of)f(the)g(actual)h(dimensionalit)m(y)g(of)g
-(the)f(arra)m(y)-8 b(,)38 b(and)e(the)g(FPIXEL)g(parameter)g(giv)m(es)i
-(the)0 3158 y(p)s(osition)28 b(within)e(this)i(1-D)g(arra)m(y)g(of)g
-(the)g(\014rst)e(pixel)i(to)g(read)g(or)f(write.)40 b(Automatic)29
-b(data)f(t)m(yp)s(e)g(con)m(v)m(ersion)h(is)0 3270 y(p)s(erformed)g
-(for)i(n)m(umeric)g(data)g(\(except)i(for)d(complex)i(data)f(t)m(yp)s
-(es\))h(if)f(the)g(data)g(t)m(yp)s(e)g(of)g(the)g(primary)f(arra)m(y)0
-3383 y(\(de\014ned)e(b)m(y)g(the)h(BITPIX)f(k)m(eyw)m(ord\))h
-(di\013ers)g(from)f(the)g(data)i(t)m(yp)s(e)e(of)h(the)g(arra)m(y)g(in)
-f(the)h(calling)h(subroutine.)0 3496 y(The)41 b(data)i(v)-5
-b(alues)42 b(are)g(also)h(scaled)f(b)m(y)g(the)g(BSCALE)f(and)g(BZER)m
-(O)h(header)f(v)-5 b(alues)42 b(as)g(they)g(are)g(b)s(eing)0
-3609 y(written)32 b(or)g(read)g(from)g(the)g(FITS)g(arra)m(y)-8
-b(.)47 b(The)31 b(ftpscl)i(subroutine)e(MUST)g(b)s(e)h(called)h(to)g
-(de\014ne)e(the)i(scaling)0 3722 y(parameters)h(when)e(writing)i(data)g
-(to)g(the)g(FITS)f(arra)m(y)h(or)f(to)h(o)m(v)m(erride)h(the)f(default)
-f(scaling)i(v)-5 b(alue)34 b(giv)m(en)g(in)0 3835 y(the)d(header)f
-(when)f(reading)i(the)f(FITS)g(arra)m(y)-8 b(.)0 3995
-y(Tw)m(o)41 b(sets)f(of)h(subroutines)e(are)i(pro)m(vided)f(to)h(read)g
-(the)f(data)i(arra)m(y)f(whic)m(h)f(di\013er)g(in)g(the)h(w)m(a)m(y)g
-(unde\014ned)0 4108 y(pixels)35 b(are)h(handled.)55 b(The)35
-b(\014rst)f(set)i(of)g(routines)f(\(FTGPVx\))h(simply)f(return)f(an)h
-(arra)m(y)h(of)g(data)g(elemen)m(ts)0 4221 y(in)c(whic)m(h)g
-(unde\014ned)e(pixels)i(are)h(set)f(equal)h(to)g(a)g(v)-5
-b(alue)32 b(sp)s(eci\014ed)g(b)m(y)g(the)g(user)g(in)g(the)g('n)m(ullv)
--5 b(al')33 b(parameter.)0 4334 y(An)h(additional)i(feature)f(of)f
-(these)h(subroutines)f(is)g(that)i(if)e(the)h(user)f(sets)h(n)m(ullv)-5
-b(al)35 b(=)f(0,)i(then)f(no)f(c)m(hec)m(ks)i(for)0 4447
-y(unde\014ned)d(pixels)j(will)g(b)s(e)e(p)s(erformed,)i(th)m(us)f
-(increasing)h(the)g(sp)s(eed)e(of)i(the)g(program.)55
-b(The)35 b(second)h(set)g(of)0 4560 y(routines)31 b(\(FTGPFx\))i
-(returns)d(the)i(data)g(elemen)m(t)h(arra)m(y)f(and,)f(in)h(addition,)g
-(a)g(logical)i(arra)m(y)e(whic)m(h)f(de\014nes)0 4673
-y(whether)40 b(the)g(corresp)s(onding)f(data)i(pixel)g(is)f
-(unde\014ned.)69 b(The)39 b(latter)j(set)f(of)f(subroutines)f(ma)m(y)i
-(b)s(e)f(more)0 4785 y(con)m(v)m(enien)m(t)33 b(to)g(use)e(in)g(some)g
-(circumstances,)i(ho)m(w)m(ev)m(er,)g(it)f(requires)f(an)g(additional)h
-(arra)m(y)g(of)g(logical)i(v)-5 b(alues)0 4898 y(whic)m(h)36
-b(can)g(b)s(e)g(un)m(wieldy)f(when)h(w)m(orking)g(with)g(large)h(data)g
-(arra)m(ys.)58 b(Also)37 b(for)f(programmer)g(con)m(v)m(enience,)0
-5011 y(sets)j(of)g(subroutines)f(to)h(directly)h(read)e(or)h(write)g(2)
-g(and)g(3)g(dimensional)g(arra)m(ys)g(ha)m(v)m(e)h(b)s(een)e(pro)m
-(vided,)j(as)0 5124 y(w)m(ell)31 b(as)f(a)g(set)g(of)g(subroutines)e
-(to)i(read)g(or)g(write)f(an)m(y)h(con)m(tiguous)h(rectangular)g
-(subset)e(of)h(pixels)g(within)f(the)0 5237 y(n-dimensional)h(arra)m(y)
--8 b(.)0 5488 y Fi(1)81 b Fj(Get)39 b(the)g(data)h(t)m(yp)s(e)e(of)h
-(the)g(image)h(\(=)f(BITPIX)f(v)-5 b(alue\).)67 b(P)m(ossible)39
-b(returned)f(v)-5 b(alues)39 b(are:)58 b(8,)41 b(16,)h(32,)227
-5601 y(64,)36 b(-32,)h(or)d(-64)h(corresp)s(onding)e(to)h(unsigned)f(b)
-m(yte,)j(signed)e(2-b)m(yte)h(in)m(teger,)i(signed)d(4-b)m(yte)h(in)m
-(teger,)227 5714 y(signed)c(8-b)m(yte)g(in)m(teger,)h(real,)g(and)d
-(double.)p eop end
+b(>)47 b(status\))0 2569 y Fe(6.6)135 b(FITS)44 b(Primary)h(Arra)l(y)g
+(or)g(IMA)l(GE)g(Extension)h(I/O)f(Subroutines)0 2819
+y Fj(These)26 b(subroutines)f(put)h(or)h(get)g(data)h(v)-5
+b(alues)26 b(in)h(the)f(primary)g(data)h(arra)m(y)g(\(i.e.,)i(the)e
+(\014rst)f(HDU)h(in)f(the)h(FITS)0 2932 y(\014le\))35
+b(or)g(an)f(IMA)m(GE)i(extension.)54 b(The)34 b(data)i(arra)m(y)f(is)f
+(represen)m(ted)h(as)g(a)g(single)g(one-dimensional)h(arra)m(y)f(of)0
+3045 y(pixels)h(regardless)h(of)f(the)g(actual)h(dimensionalit)m(y)g
+(of)g(the)f(arra)m(y)-8 b(,)38 b(and)e(the)g(FPIXEL)g(parameter)g(giv)m
+(es)i(the)0 3158 y(p)s(osition)28 b(within)e(this)i(1-D)g(arra)m(y)g
+(of)g(the)g(\014rst)e(pixel)i(to)g(read)g(or)f(write.)40
+b(Automatic)29 b(data)f(t)m(yp)s(e)g(con)m(v)m(ersion)h(is)0
+3270 y(p)s(erformed)g(for)i(n)m(umeric)g(data)g(\(except)i(for)d
+(complex)i(data)f(t)m(yp)s(es\))h(if)f(the)g(data)g(t)m(yp)s(e)g(of)g
+(the)g(primary)f(arra)m(y)0 3383 y(\(de\014ned)e(b)m(y)g(the)h(BITPIX)f
+(k)m(eyw)m(ord\))h(di\013ers)g(from)f(the)g(data)i(t)m(yp)s(e)e(of)h
+(the)g(arra)m(y)g(in)f(the)h(calling)h(subroutine.)0
+3496 y(The)41 b(data)i(v)-5 b(alues)42 b(are)g(also)h(scaled)f(b)m(y)g
+(the)g(BSCALE)f(and)g(BZER)m(O)h(header)f(v)-5 b(alues)42
+b(as)g(they)g(are)g(b)s(eing)0 3609 y(written)32 b(or)g(read)g(from)g
+(the)g(FITS)g(arra)m(y)-8 b(.)47 b(The)31 b(ftpscl)i(subroutine)e(MUST)
+g(b)s(e)h(called)h(to)g(de\014ne)e(the)i(scaling)0 3722
+y(parameters)h(when)e(writing)i(data)g(to)g(the)g(FITS)f(arra)m(y)h(or)
+f(to)h(o)m(v)m(erride)h(the)f(default)f(scaling)i(v)-5
+b(alue)34 b(giv)m(en)g(in)0 3835 y(the)d(header)f(when)f(reading)i(the)
+f(FITS)g(arra)m(y)-8 b(.)0 3995 y(Tw)m(o)41 b(sets)f(of)h(subroutines)e
+(are)i(pro)m(vided)f(to)h(read)g(the)f(data)i(arra)m(y)f(whic)m(h)f
+(di\013er)g(in)g(the)h(w)m(a)m(y)g(unde\014ned)0 4108
+y(pixels)35 b(are)h(handled.)55 b(The)35 b(\014rst)f(set)i(of)g
+(routines)f(\(FTGPVx\))h(simply)f(return)f(an)h(arra)m(y)h(of)g(data)g
+(elemen)m(ts)0 4221 y(in)c(whic)m(h)g(unde\014ned)e(pixels)i(are)h(set)
+f(equal)h(to)g(a)g(v)-5 b(alue)32 b(sp)s(eci\014ed)g(b)m(y)g(the)g
+(user)g(in)g(the)g('n)m(ullv)-5 b(al')33 b(parameter.)0
+4334 y(An)h(additional)i(feature)f(of)f(these)h(subroutines)f(is)g
+(that)i(if)e(the)h(user)f(sets)h(n)m(ullv)-5 b(al)35
+b(=)f(0,)i(then)f(no)f(c)m(hec)m(ks)i(for)0 4447 y(unde\014ned)d
+(pixels)j(will)g(b)s(e)e(p)s(erformed,)i(th)m(us)f(increasing)h(the)g
+(sp)s(eed)e(of)i(the)g(program.)55 b(The)35 b(second)h(set)g(of)0
+4560 y(routines)31 b(\(FTGPFx\))i(returns)d(the)i(data)g(elemen)m(t)h
+(arra)m(y)f(and,)f(in)h(addition,)g(a)g(logical)i(arra)m(y)e(whic)m(h)f
+(de\014nes)0 4673 y(whether)40 b(the)g(corresp)s(onding)f(data)i(pixel)
+g(is)f(unde\014ned.)69 b(The)39 b(latter)j(set)f(of)f(subroutines)f(ma)
+m(y)i(b)s(e)f(more)0 4785 y(con)m(v)m(enien)m(t)33 b(to)g(use)e(in)g
+(some)g(circumstances,)i(ho)m(w)m(ev)m(er,)g(it)f(requires)f(an)g
+(additional)h(arra)m(y)g(of)g(logical)i(v)-5 b(alues)0
+4898 y(whic)m(h)36 b(can)g(b)s(e)g(un)m(wieldy)f(when)h(w)m(orking)g
+(with)g(large)h(data)g(arra)m(ys.)58 b(Also)37 b(for)f(programmer)g
+(con)m(v)m(enience,)0 5011 y(sets)j(of)g(subroutines)f(to)h(directly)h
+(read)e(or)h(write)g(2)g(and)g(3)g(dimensional)g(arra)m(ys)g(ha)m(v)m
+(e)h(b)s(een)e(pro)m(vided,)j(as)0 5124 y(w)m(ell)31
+b(as)f(a)g(set)g(of)g(subroutines)e(to)i(read)g(or)g(write)f(an)m(y)h
+(con)m(tiguous)h(rectangular)g(subset)e(of)h(pixels)g(within)f(the)0
+5237 y(n-dimensional)h(arra)m(y)-8 b(.)0 5488 y Fi(1)81
+b Fj(Get)39 b(the)g(data)h(t)m(yp)s(e)e(of)h(the)g(image)h(\(=)f
+(BITPIX)f(v)-5 b(alue\).)67 b(P)m(ossible)39 b(returned)f(v)-5
+b(alues)39 b(are:)58 b(8,)41 b(16,)h(32,)227 5601 y(64,)36
+b(-32,)h(or)d(-64)h(corresp)s(onding)e(to)h(unsigned)f(b)m(yte,)j
+(signed)e(2-b)m(yte)h(in)m(teger,)i(signed)d(4-b)m(yte)h(in)m(teger,)
+227 5714 y(signed)c(8-b)m(yte)g(in)m(teger,)h(real,)g(and)d(double.)p
+eop end
 %%Page: 53 59
-TeXDict begin 53 58 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.53) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.6.)72
-b(FITS)30 b(PRIMAR)-8 b(Y)31 b(ARRA)-8 b(Y)31 b(OR)f(IMA)m(GE)h
-(EXTENSION)e(I/O)i(SUBR)m(OUTINES)589 b Fj(53)227 555
-y(The)26 b(second)f(subroutine)g(is)h(similar)g(to)g(FTGIDT,)h(except)f
-(that)h(if)f(the)f(image)j(pixel)e(v)-5 b(alues)26 b(are)g(scaled,)227
-668 y(with)h(non-default)g(v)-5 b(alues)27 b(for)g(the)h(BZER)m(O)f
-(and)f(BSCALE)g(k)m(eyw)m(ords,)j(then)e(this)g(routine)g(will)g
-(return)227 781 y(the)32 b('equiv)-5 b(alen)m(t')33 b(data)e(t)m(yp)s
-(e)h(that)f(is)g(needed)g(to)h(store)g(the)f(scaled)h(v)-5
-b(alues.)43 b(F)-8 b(or)32 b(example,)g(if)f(BITPIX)227
-894 y(=)39 b(16)g(and)g(BSCALE)f(=)g(0.1)i(then)f(the)g(equiv)-5
+TeXDict begin 53 58 bop 0 299 a Fh(6.6.)72 b(FITS)30
+b(PRIMAR)-8 b(Y)31 b(ARRA)-8 b(Y)31 b(OR)f(IMA)m(GE)h(EXTENSION)e(I/O)i
+(SUBR)m(OUTINES)589 b Fj(53)227 555 y(The)26 b(second)f(subroutine)g
+(is)h(similar)g(to)g(FTGIDT,)h(except)f(that)h(if)f(the)f(image)j
+(pixel)e(v)-5 b(alues)26 b(are)g(scaled,)227 668 y(with)h(non-default)g
+(v)-5 b(alues)27 b(for)g(the)h(BZER)m(O)f(and)f(BSCALE)g(k)m(eyw)m
+(ords,)j(then)e(this)g(routine)g(will)g(return)227 781
+y(the)32 b('equiv)-5 b(alen)m(t')33 b(data)e(t)m(yp)s(e)h(that)f(is)g
+(needed)g(to)h(store)g(the)f(scaled)h(v)-5 b(alues.)43
+b(F)-8 b(or)32 b(example,)g(if)f(BITPIX)227 894 y(=)39
+b(16)g(and)g(BSCALE)f(=)g(0.1)i(then)f(the)g(equiv)-5
 b(alen)m(t)40 b(data)f(t)m(yp)s(e)g(is)g(\015oating)h(p)s(oin)m(t,)h
 (and)d(-32)i(will)g(b)s(e)227 1007 y(returned.)65 b(There)39
 b(are)g(2)g(sp)s(ecial)h(cases:)58 b(if)39 b(the)g(image)h(con)m(tains)
 g(unsigned)e(2-b)m(yte)i(in)m(teger)g(v)-5 b(alues,)227
 1120 y(with)40 b(BITPIX)g(=)f(16,)44 b(BSCALE)39 b(=)h(1,)j(and)c(BZER)
 m(O)h(=)g(32768,)45 b(then)39 b(this)h(routine)g(will)h(return)e(a)227
 1233 y(non-standard)26 b(v)-5 b(alue)27 b(of)g(20)h(for)f(the)g(bitpix)
 g(v)-5 b(alue.)40 b(Similarly)27 b(if)f(the)i(image)g(con)m(tains)g
 (unsigned)e(4-b)m(yte)227 1346 y(in)m(tegers,)32 b(then)e(bitpix)g
 (will)h(b)s(e)f(returned)f(with)h(a)h(v)-5 b(alue)31
-b(of)f(40.)382 1602 y Ff(FTGIDT\(unit,)44 b(>)k(bitpix,status\))382
-1715 y(FTGIET\(unit,)c(>)k(bitpix,status\))0 1971 y Fi(2)81
+b(of)f(40.)382 1609 y Ff(FTGIDT\(unit,)44 b(>)k(bitpix,status\))382
+1722 y(FTGIET\(unit,)c(>)k(bitpix,status\))0 1986 y Fi(2)81
 b Fj(Get)31 b(the)g(dimension)e(\(n)m(um)m(b)s(er)h(of)g(axes)h(=)f
-(NAXIS\))h(of)f(the)h(image)382 2227 y Ff(FTGIDM\(unit,)44
-b(>)k(naxis,status\))0 2484 y Fi(3)81 b Fj(Get)38 b(the)f(size)h(of)f
+(NAXIS\))h(of)f(the)h(image)382 2250 y Ff(FTGIDM\(unit,)44
+b(>)k(naxis,status\))0 2513 y Fi(3)81 b Fj(Get)38 b(the)f(size)h(of)f
 (all)h(the)f(dimensions)g(of)g(the)g(image.)62 b(The)37
 b(FTGISZLL)e(routine)i(returns)f(an)h(arra)m(y)h(of)227
-2597 y(64-bit)32 b(in)m(tegers)g(instead)e(of)h(32-bit)g(in)m(tegers.)
-382 2853 y Ff(FTGISZ\(unit,)44 b(maxdim,)i(>)i(naxes,status\))382
-2966 y(FTGISZLL\(unit,)c(maxdim,)i(>)h(naxesll,status\))0
-3222 y Fi(4)81 b Fj(Get)35 b(the)f(parameters)g(that)h(de\014ne)e(the)h
+2626 y(64-bit)32 b(in)m(tegers)g(instead)e(of)h(32-bit)g(in)m(tegers.)
+382 2890 y Ff(FTGISZ\(unit,)44 b(maxdim,)i(>)i(naxes,status\))382
+3003 y(FTGISZLL\(unit,)c(maxdim,)i(>)h(naxesll,status\))0
+3266 y Fi(4)81 b Fj(Get)35 b(the)f(parameters)g(that)h(de\014ne)e(the)h
 (t)m(yp)s(e)g(and)g(size)g(of)h(the)f(image.)53 b(This)33
-b(routine)h(simply)f(com)m(bines)227 3335 y(calls)40
+b(routine)h(simply)f(com)m(bines)227 3379 y(calls)40
 b(to)f(the)g(ab)s(o)m(v)m(e)h(3)f(routines.)65 b(The)38
 b(FTGIPRLL)g(routine)h(returns)e(an)i(arra)m(y)g(of)g(64-bit)h(in)m
-(tegers)227 3448 y(instead)31 b(of)f(32-bit)i(in)m(tegers.)382
-3704 y Ff(FTGIPR\(unit,)44 b(maxdim,)i(>)i(bitpix,)d(naxis,)h(naxes,)h
-(int)f(*status\))382 3817 y(FTGIPRLL\(unit,)e(maxdim,)i(>)h(bitpix,)f
-(naxis,)g(naxesll,)f(int)i(*status\))0 4073 y Fi(5)81
-b Fj(Put)30 b(elemen)m(ts)h(in)m(to)h(the)e(data)h(arra)m(y)382
-4330 y Ff(FTPPR[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o(eme)o(nts,)o
-(valu)o(es,)41 b(>)48 b(status\))0 4586 y Fi(6)81 b Fj(Put)30
-b(elemen)m(ts)i(in)m(to)f(the)g(data)g(arra)m(y)-8 b(,)32
-b(substituting)e(the)g(appropriate)h(FITS)f(n)m(ull)g(v)-5
-b(alue)31 b(for)f(all)i(elemen)m(ts)227 4699 y(whic)m(h)c(are)f(equal)i
-(to)f(the)f(v)-5 b(alue)28 b(of)g(NULL)-10 b(V)g(AL.)28
-b(F)-8 b(or)28 b(in)m(teger)h(FITS)e(arra)m(ys,)i(the)e(n)m(ull)h(v)-5
-b(alue)28 b(de\014ned)e(b)m(y)227 4812 y(the)k(previous)f(call)i(to)g
-(FTPNUL)e(will)h(b)s(e)f(substituted;)h(for)f(\015oating)i(p)s(oin)m(t)
-f(FITS)f(arra)m(ys)h(\(BITPIX)f(=)227 4925 y(-32)j(or)e(-64\))i(then)e
-(the)h(sp)s(ecial)g(IEEE)e(NaN)i(\(Not-a-Num)m(b)s(er\))h(v)-5
-b(alue)31 b(will)g(b)s(e)f(substituted.)382 5181 y Ff
-(FTPPN[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o(eme)o(nts,)o(valu)o
-(es,)o(null)o(val)41 b(>)48 b(status\))0 5437 y Fi(7)81
-b Fj(Set)30 b(data)h(arra)m(y)g(elemen)m(ts)h(as)e(unde\014ned)382
-5694 y Ff(FTPPRU\(unit,group,fpixel)o(,ne)o(leme)o(nts,)41
+(tegers)227 3492 y(instead)31 b(of)f(32-bit)i(in)m(tegers.)382
+3756 y Ff(FTGIPR\(unit,)44 b(maxdim,)i(>)i(bitpix,)d(naxis,)h(naxes,)h
+(int)f(*status\))382 3869 y(FTGIPRLL\(unit,)e(maxdim,)i(>)h(bitpix,)f
+(naxis,)g(naxesll,)f(int)i(*status\))0 4132 y Fi(5)81
+b Fj(Put)25 b(elemen)m(ts)j(in)m(to)f(the)f(data)h(arra)m(y)-8
+b(.)40 b(The)26 b(FTPPR[]LL)f(routines)h(accept)i(64-bit)f(in)m(tegers)
+h(for)d(fpixel)i(and)227 4245 y(nelemen)m(ts.)382 4509
+y Ff(FTPPR[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o(eme)o(nts,)o(valu)
+o(es,)41 b(>)48 b(status\))382 4622 y(FTPPR[BIJKED]LL\(unit,gro)o(up,)o
+(fpix)o(elll)o(,ne)o(leme)o(ntsl)o(l,v)o(alue)o(s,)42
+b(>)47 b(status\))0 4886 y Fi(6)81 b Fj(Put)30 b(elemen)m(ts)i(in)m(to)
+f(the)g(data)g(arra)m(y)-8 b(,)32 b(substituting)e(the)g(appropriate)h
+(FITS)f(n)m(ull)g(v)-5 b(alue)31 b(for)f(all)i(elemen)m(ts)227
+4999 y(whic)m(h)k(are)g(equal)g(to)g(the)g(v)-5 b(alue)37
+b(of)e(NULL)-10 b(V)g(AL.)36 b(F)-8 b(or)37 b(in)m(teger)g(FITS)e(arra)
+m(ys,)i(the)f(n)m(ull)g(v)-5 b(alue)36 b(de\014ned)227
+5111 y(b)m(y)28 b(the)g(previous)f(call)i(to)g(FTPNUL)f(will)g(b)s(e)f
+(substituted;)h(for)g(\015oating)h(p)s(oin)m(t)f(FITS)f(arra)m(ys)h
+(\(BITPIX)227 5224 y(=)38 b(-32)i(or)e(-64\))i(then)e(the)g(sp)s(ecial)
+h(IEEE)f(NaN)h(\(Not-a-Num)m(b)s(er\))h(v)-5 b(alue)38
+b(will)h(b)s(e)f(substituted.)63 b(The)227 5337 y(FTPPN[]LL)31
+b(routines)f(accept)i(64-bit)f(in)m(tegers)h(for)e(fpixel)h(and)e
+(nelemen)m(ts.)382 5601 y Ff(FTPPN[BIJKED]\(unit,group)o(,fp)o(ixel)o
+(,nel)o(eme)o(nts,)o(valu)o(es,)o(null)o(val)41 b(>)48
+b(status\))382 5714 y(FTPPN[BIJKED]LL\(unit,gro)o(up,)o(fpix)o(elll)o
+(,ne)o(leme)o(ntsl)o(l,v)o(alue)o(s,nu)o(llv)o(al)42
 b(>)47 b(status\))p eop end
 %%Page: 54 60
-TeXDict begin 54 59 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.54) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(54)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fi(8)81 b Fj(Get)36
-b(elemen)m(ts)g(from)f(the)g(data)h(arra)m(y)-8 b(.)55
-b(Unde\014ned)34 b(arra)m(y)h(elemen)m(ts)i(will)e(b)s(e)g(returned)f
-(with)g(a)i(v)-5 b(alue)35 b(=)227 668 y(n)m(ullv)-5
-b(al,)31 b(unless)f(n)m(ullv)-5 b(al)31 b(=)f(0)h(in)f(whic)m(h)g(case)
-h(no)g(c)m(hec)m(ks)g(for)g(unde\014ned)d(pixels)i(will)h(b)s(e)f(p)s
-(erformed.)382 914 y Ff(FTGPV[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o
-(eme)o(nts,)o(null)o(val)o(,)42 b(>)47 b(values,anyf,status\))0
-1160 y Fi(9)81 b Fj(Get)32 b(elemen)m(ts)g(and)f(n)m(ull\015ags)g(from)
+TeXDict begin 54 59 bop 0 299 a Fj(54)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fi(7)81 b Fj(Set)33 b(data)g(arra)m(y)h
+(elemen)m(ts)g(as)g(unde\014ned.)46 b(FTPPR)m(ULL)33
+b(accepts)h(64-bit)h(in)m(tegers)f(for)f(fpixel)g(and)f(nele-)227
+668 y(men)m(ts.)382 916 y Ff(FTPPRU\(unit,group,fpixel)o(,ne)o(leme)o
+(nts,)41 b(>)47 b(status\))382 1029 y(FTPPRULL\(unit,group,fpix)o(ell)o
+(l,ne)o(leme)o(nts)o(ll,)41 b(>)48 b(status\))0 1276
+y Fi(8)81 b Fj(Get)36 b(elemen)m(ts)g(from)f(the)g(data)h(arra)m(y)-8
+b(.)55 b(Unde\014ned)34 b(arra)m(y)h(elemen)m(ts)i(will)e(b)s(e)g
+(returned)f(with)g(a)i(v)-5 b(alue)35 b(=)227 1389 y(n)m(ullv)-5
+b(al,)41 b(unless)c(n)m(ullv)-5 b(al)39 b(=)f(0)g(in)g(whic)m(h)f(case)
+i(no)f(c)m(hec)m(ks)i(for)e(unde\014ned)d(pixels)j(will)h(b)s(e)e(p)s
+(erformed.)227 1502 y(FTGPV[]LL)31 b(accepts)h(64-bit)f(in)m(tegers)h
+(for)e(fpixel)h(and)e(nelemen)m(ts.)382 1749 y Ff
+(FTGPV[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o(eme)o(nts,)o(null)o
+(val)o(,)42 b(>)47 b(values,anyf,status\))382 1862 y
+(FTGPV[BIJKED]LL\(unit,gro)o(up,)o(fpix)o(elll)o(,ne)o(leme)o(ntsl)o
+(l,n)o(ullv)o(al,)41 b(>)48 b(values,anyf,status\))0
+2110 y Fi(9)81 b Fj(Get)32 b(elemen)m(ts)g(and)f(n)m(ull\015ags)g(from)
 g(data)h(arra)m(y)-8 b(.)44 b(An)m(y)32 b(unde\014ned)d(arra)m(y)i
-(elemen)m(ts)i(will)e(ha)m(v)m(e)i(the)e(corre-)227 1273
+(elemen)m(ts)i(will)e(ha)m(v)m(e)i(the)e(corre-)227 2223
 y(sp)s(onding)e(\015agv)-5 b(als)31 b(elemen)m(t)h(set)f(equal)g(to)g
-(.TR)m(UE.)382 1519 y Ff(FTGPF[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)
+(.TR)m(UE.)382 2470 y Ff(FTGPF[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)
 o(eme)o(nts,)41 b(>)48 b(values,flagvals,anyf,st)o(atu)o(s\))0
-1765 y Fi(10)e Fj(Put)30 b(v)-5 b(alues)31 b(in)m(to)g(group)f
-(parameters)382 2011 y Ff(FTPGP[BIJKED]\(unit,group)o(,fp)o(arm,)o
-(npar)o(m,v)o(alue)o(s,)42 b(>)47 b(status\))0 2257 y
+2718 y Fi(10)e Fj(Put)30 b(v)-5 b(alues)31 b(in)m(to)g(group)f
+(parameters)382 2965 y Ff(FTPGP[BIJKED]\(unit,group)o(,fp)o(arm,)o
+(npar)o(m,v)o(alue)o(s,)42 b(>)47 b(status\))0 3213 y
 Fi(11)f Fj(Get)31 b(v)-5 b(alues)31 b(from)f(group)g(parameters)382
-2503 y Ff(FTGGP[BIJKED]\(unit,group)o(,fp)o(arm,)o(npar)o(m,)41
-b(>)48 b(values,status\))0 2749 y Fj(The)32 b(follo)m(wing)h(4)g
+3460 y Ff(FTGGP[BIJKED]\(unit,group)o(,fp)o(arm,)o(npar)o(m,)41
+b(>)48 b(values,status\))0 3708 y Fj(The)32 b(follo)m(wing)h(4)g
 (subroutines)e(transfer)g(FITS)h(images)h(with)f(2)g(or)g(3)h
 (dimensions)e(to)i(or)f(from)g(a)h(data)f(arra)m(y)0
-2862 y(whic)m(h)h(has)g(b)s(een)g(declared)g(in)g(the)h(calling)h
+3821 y(whic)m(h)h(has)g(b)s(een)g(declared)g(in)g(the)h(calling)h
 (program.)49 b(The)33 b(dimensionalit)m(y)h(of)g(the)f(FITS)g(image)h
-(is)f(passed)0 2975 y(b)m(y)26 b(the)g(naxis1,)h(naxis2,)h(and)d
+(is)f(passed)0 3933 y(b)m(y)26 b(the)g(naxis1,)h(naxis2,)h(and)d
 (naxis3)i(parameters)f(and)f(the)h(declared)h(dimensions)e(of)h(the)g
-(program)g(arra)m(y)h(are)0 3088 y(passed)k(in)f(the)i(dim1)e(and)h
+(program)g(arra)m(y)h(are)0 4046 y(passed)k(in)f(the)i(dim1)e(and)h
 (dim2)g(parameters.)43 b(Note)32 b(that)g(the)f(program)g(arra)m(y)g
 (do)s(es)g(not)g(ha)m(v)m(e)i(to)e(ha)m(v)m(e)i(the)0
-3201 y(same)28 b(dimensions)f(as)h(the)g(FITS)e(arra)m(y)-8
+4159 y(same)28 b(dimensions)f(as)h(the)g(FITS)e(arra)m(y)-8
 b(,)30 b(but)d(m)m(ust)g(b)s(e)g(at)i(least)f(as)g(big.)40
 b(F)-8 b(or)29 b(example)f(if)f(a)h(FITS)f(image)i(with)0
-3314 y(NAXIS1)i(=)f(NAXIS2)h(=)f(400)i(is)e(read)h(in)m(to)g(a)g
+4272 y(NAXIS1)i(=)f(NAXIS2)h(=)f(400)i(is)e(read)h(in)m(to)g(a)g
 (program)f(arra)m(y)h(whic)m(h)f(is)h(dimensioned)f(as)g(512)i(x)f(512)
-g(pixels,)0 3427 y(then)d(the)g(image)i(will)e(just)g(\014ll)g(the)h
+g(pixels,)0 4385 y(then)d(the)g(image)i(will)e(just)g(\014ll)g(the)h
 (lo)m(w)m(er)g(left)g(corner)f(of)h(the)f(arra)m(y)h(with)f(pixels)g
-(in)g(the)h(range)f(1)h(-)f(400)i(in)e(the)0 3540 y(X)k(an)g(Y)h
+(in)g(the)h(range)f(1)h(-)f(400)i(in)e(the)0 4498 y(X)k(an)g(Y)h
 (directions.)47 b(This)31 b(has)h(the)h(e\013ect)g(of)g(taking)g(a)g
 (con)m(tiguous)g(set)g(of)f(pixel)h(v)-5 b(alue)33 b(in)e(the)i(FITS)e
-(arra)m(y)0 3653 y(and)k(writing)g(them)g(to)h(a)g(non-con)m(tiguous)g
+(arra)m(y)0 4611 y(and)k(writing)g(them)g(to)h(a)g(non-con)m(tiguous)g
 (arra)m(y)f(in)g(program)g(memory)g(\(i.e.,)j(there)e(are)f(no)m(w)h
-(some)f(blank)0 3766 y(pixels)c(around)e(the)h(edge)i(of)e(the)h(image)
-g(in)f(the)h(program)f(arra)m(y\).)0 4012 y Fi(11)46
+(some)f(blank)0 4724 y(pixels)c(around)e(the)h(edge)i(of)e(the)h(image)
+g(in)f(the)h(program)f(arra)m(y\).)0 4971 y Fi(11)46
 b Fj(Put)30 b(2-D)i(image)f(in)m(to)h(the)e(data)h(arra)m(y)382
-4258 y Ff(FTP2D[BIJKED]\(unit,group)o(,di)o(m1,n)o(axis)o(1,n)o(axis)o
-(2,im)o(age)o(,)42 b(>)47 b(status\))0 4504 y Fi(12)f
+5219 y Ff(FTP2D[BIJKED]\(unit,group)o(,di)o(m1,n)o(axis)o(1,n)o(axis)o
+(2,im)o(age)o(,)42 b(>)47 b(status\))0 5466 y Fi(12)f
 Fj(Put)30 b(3-D)i(cub)s(e)d(in)m(to)j(the)e(data)h(arra)m(y)382
-4750 y Ff(FTP3D[BIJKED]\(unit,group)o(,di)o(m1,d)o(im2,)o(nax)o(is1,)o
-(naxi)o(s2,)o(naxi)o(s3,c)o(ube)o(,)42 b(>)47 b(status\))0
-4996 y Fi(13)f Fj(Get)29 b(2-D)f(image)h(from)f(the)f(data)i(arra)m(y)
--8 b(.)41 b(Unde\014ned)26 b(pixels)h(in)h(the)g(arra)m(y)g(will)g(b)s
-(e)f(set)h(equal)g(to)h(the)e(v)-5 b(alue)227 5109 y(of)31
-b('n)m(ullv)-5 b(al',)31 b(unless)f(n)m(ullv)-5 b(al=0)31
-b(in)f(whic)m(h)g(case)i(no)e(testing)i(for)e(unde\014ned)e(pixels)i
-(will)h(b)s(e)f(p)s(erformed.)382 5355 y Ff(FTG2D[BIJKED]\(unit,group)o
-(,nu)o(llva)o(l,di)o(m1,)o(naxi)o(s1,n)o(axi)o(s2,)41
-b(>)48 b(image,anyf,status\))0 5601 y Fi(14)e Fj(Get)31
-b(3-D)h(cub)s(e)e(from)g(the)g(data)h(arra)m(y)-8 b(.)42
-b(Unde\014ned)29 b(pixels)i(in)f(the)g(arra)m(y)h(will)g(b)s(e)f(set)h
-(equal)g(to)g(the)f(v)-5 b(alue)227 5714 y(of)31 b('n)m(ullv)-5
-b(al',)31 b(unless)f(n)m(ullv)-5 b(al=0)31 b(in)f(whic)m(h)g(case)i(no)
-e(testing)i(for)e(unde\014ned)e(pixels)i(will)h(b)s(e)f(p)s(erformed.)p
+5714 y Ff(FTP3D[BIJKED]\(unit,group)o(,di)o(m1,d)o(im2,)o(nax)o(is1,)o
+(naxi)o(s2,)o(naxi)o(s3,c)o(ube)o(,)42 b(>)47 b(status\))p
 eop end
 %%Page: 55 61
-TeXDict begin 55 60 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.55) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.7.)72
-b(FITS)30 b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31
-b(D)m(A)-8 b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(55)382
-555 y Ff(FTG3D[BIJKED]\(unit,group)o(,nu)o(llva)o(l,di)o(m1,)o(dim2)o
-(,nax)o(is1)o(,nax)o(is2,)o(nax)o(is3,)41 b(>)1002 668
-y(cube,anyf,status\))0 933 y Fj(The)i(follo)m(wing)h(subroutines)e
-(transfer)h(a)h(rectangular)g(subset)e(of)i(the)f(pixels)g(in)g(a)h
-(FITS)e(N-dimensional)0 1045 y(image)31 b(to)g(or)f(from)f(an)h(arra)m
-(y)g(whic)m(h)g(has)g(b)s(een)f(declared)h(in)g(the)g(calling)i
-(program.)40 b(The)29 b(fpixels)h(and)f(lpixels)0 1158
-y(parameters)e(are)h(in)m(teger)g(arra)m(ys)g(whic)m(h)f(sp)s(ecify)f
-(the)i(starting)g(and)e(ending)h(pixels)g(in)g(eac)m(h)h(dimension)e
-(of)i(the)0 1271 y(FITS)36 b(image)i(that)f(are)g(to)h(b)s(e)e(read)g
-(or)h(written.)60 b(\(Note)38 b(that)g(these)f(are)g(the)g(starting)g
-(and)f(ending)h(pixels)0 1384 y(in)d(the)h(FITS)f(image,)k(not)d(in)f
-(the)h(declared)g(arra)m(y\).)55 b(The)34 b(arra)m(y)i(parameter)f(is)g
-(treated)g(simply)g(as)g(a)g(large)0 1497 y(one-dimensional)c(arra)m(y)
+TeXDict begin 55 60 bop 0 299 a Fh(6.6.)72 b(FITS)30
+b(PRIMAR)-8 b(Y)31 b(ARRA)-8 b(Y)31 b(OR)f(IMA)m(GE)h(EXTENSION)e(I/O)i
+(SUBR)m(OUTINES)589 b Fj(55)0 555 y Fi(13)46 b Fj(Get)29
+b(2-D)f(image)h(from)f(the)f(data)i(arra)m(y)-8 b(.)41
+b(Unde\014ned)26 b(pixels)h(in)h(the)g(arra)m(y)g(will)g(b)s(e)f(set)h
+(equal)g(to)h(the)e(v)-5 b(alue)227 668 y(of)31 b('n)m(ullv)-5
+b(al',)31 b(unless)f(n)m(ullv)-5 b(al=0)31 b(in)f(whic)m(h)g(case)i(no)
+e(testing)i(for)e(unde\014ned)e(pixels)i(will)h(b)s(e)f(p)s(erformed.)
+382 947 y Ff(FTG2D[BIJKED]\(unit,group)o(,nu)o(llva)o(l,di)o(m1,)o
+(naxi)o(s1,n)o(axi)o(s2,)41 b(>)48 b(image,anyf,status\))0
+1226 y Fi(14)e Fj(Get)31 b(3-D)h(cub)s(e)e(from)g(the)g(data)h(arra)m
+(y)-8 b(.)42 b(Unde\014ned)29 b(pixels)i(in)f(the)g(arra)m(y)h(will)g
+(b)s(e)f(set)h(equal)g(to)g(the)f(v)-5 b(alue)227 1339
+y(of)31 b('n)m(ullv)-5 b(al',)31 b(unless)f(n)m(ullv)-5
+b(al=0)31 b(in)f(whic)m(h)g(case)i(no)e(testing)i(for)e(unde\014ned)e
+(pixels)i(will)h(b)s(e)f(p)s(erformed.)382 1617 y Ff
+(FTG3D[BIJKED]\(unit,group)o(,nu)o(llva)o(l,di)o(m1,)o(dim2)o(,nax)o
+(is1)o(,nax)o(is2,)o(nax)o(is3,)41 b(>)1002 1730 y(cube,anyf,status\))0
+2009 y Fj(The)i(follo)m(wing)h(subroutines)e(transfer)h(a)h
+(rectangular)g(subset)e(of)i(the)f(pixels)g(in)g(a)h(FITS)e
+(N-dimensional)0 2122 y(image)31 b(to)g(or)f(from)f(an)h(arra)m(y)g
+(whic)m(h)g(has)g(b)s(een)f(declared)h(in)g(the)g(calling)i(program.)40
+b(The)29 b(fpixels)h(and)f(lpixels)0 2235 y(parameters)e(are)h(in)m
+(teger)g(arra)m(ys)g(whic)m(h)f(sp)s(ecify)f(the)i(starting)g(and)e
+(ending)h(pixels)g(in)g(eac)m(h)h(dimension)e(of)i(the)0
+2348 y(FITS)36 b(image)i(that)f(are)g(to)h(b)s(e)e(read)g(or)h
+(written.)60 b(\(Note)38 b(that)g(these)f(are)g(the)g(starting)g(and)f
+(ending)h(pixels)0 2461 y(in)d(the)h(FITS)f(image,)k(not)d(in)f(the)h
+(declared)g(arra)m(y\).)55 b(The)34 b(arra)m(y)i(parameter)f(is)g
+(treated)g(simply)g(as)g(a)g(large)0 2574 y(one-dimensional)c(arra)m(y)
 f(of)h(the)f(appropriate)g(datat)m(yp)s(e)h(con)m(taining)h(the)e
 (pixel)g(v)-5 b(alues;)31 b(The)e(pixel)i(v)-5 b(alues)30
-b(in)0 1610 y(the)c(FITS)f(arra)m(y)i(are)f(read/written)g(from/to)h
+b(in)0 2686 y(the)c(FITS)f(arra)m(y)i(are)f(read/written)g(from/to)h
 (this)f(program)f(arra)m(y)i(in)e(strict)i(sequence)f(without)g(an)m(y)
-h(gaps;)g(it)0 1723 y(is)i(up)e(to)j(the)f(calling)h(routine)f(to)g
+h(gaps;)g(it)0 2799 y(is)i(up)e(to)j(the)f(calling)h(routine)f(to)g
 (correctly)h(in)m(terpret)f(the)g(dimensionalit)m(y)h(of)f(this)g(arra)
-m(y)-8 b(.)41 b(The)28 b(t)m(w)m(o)i(families)0 1836
+m(y)-8 b(.)41 b(The)28 b(t)m(w)m(o)i(families)0 2912
 y(of)d(FITS)g(reading)g(routines)g(\(FTGSVx)g(and)g(FTGSFx)g
 (subroutines\))f(also)j(ha)m(v)m(e)f(an)f('incs')h(parameter)f(whic)m
-(h)0 1949 y(de\014nes)j(the)h(data)h(sampling)e(in)m(terv)-5
+(h)0 3025 y(de\014nes)j(the)h(data)h(sampling)e(in)m(terv)-5
 b(al)32 b(in)f(eac)m(h)h(dimension)e(of)h(the)g(FITS)f(arra)m(y)-8
 b(.)43 b(F)-8 b(or)32 b(example,)g(if)f(incs\(1\)=2)0
-2062 y(and)i(incs\(2\)=3)h(when)f(reading)g(a)h(2-dimensional)g(FITS)f
+3138 y(and)i(incs\(2\)=3)h(when)f(reading)g(a)h(2-dimensional)g(FITS)f
 (image,)i(then)e(only)h(ev)m(ery)g(other)f(pixel)h(in)f(the)h(\014rst)0
-2175 y(dimension)e(and)h(ev)m(ery)h(3rd)e(pixel)i(in)f(the)g(second)g
+3251 y(dimension)e(and)h(ev)m(ery)h(3rd)e(pixel)i(in)f(the)g(second)g
 (dimension)f(will)i(b)s(e)e(returned)g(in)h(the)g('arra)m(y')h
-(parameter.)0 2287 y([Note:)39 b(the)25 b(FTGSSx)f(family)i(of)e
+(parameter.)0 3364 y([Note:)39 b(the)25 b(FTGSSx)f(family)i(of)e
 (routines)h(whic)m(h)g(w)m(ere)g(presen)m(t)g(in)f(previous)g(v)m
-(ersions)h(of)g(FITSIO)f(ha)m(v)m(e)i(b)s(een)0 2400
+(ersions)h(of)g(FITSIO)f(ha)m(v)m(e)i(b)s(een)0 3477
 y(sup)s(erseded)i(b)m(y)j(the)f(more)h(general)g(FTGSVx)f(family)h(of)g
-(routines.])0 2665 y Fi(15)46 b Fj(Put)30 b(an)g(arbitrary)g(data)h
+(routines.])0 3756 y Fi(15)46 b Fj(Put)30 b(an)g(arbitrary)g(data)h
 (subsection)g(in)m(to)g(the)g(data)g(arra)m(y)-8 b(.)382
-2929 y Ff(FTPSS[BIJKED]\(unit,group)o(,na)o(xis,)o(naxe)o(s,f)o(pixe)o
+4034 y Ff(FTPSS[BIJKED]\(unit,group)o(,na)o(xis,)o(naxe)o(s,f)o(pixe)o
 (ls,l)o(pix)o(els,)o(arra)o(y,)41 b(>)48 b(status\))0
-3194 y Fi(16)e Fj(Get)30 b(an)e(arbitrary)g(data)i(subsection)e(from)g
+4313 y Fi(16)e Fj(Get)30 b(an)e(arbitrary)g(data)i(subsection)e(from)g
 (the)h(data)g(arra)m(y)-8 b(.)42 b(Unde\014ned)27 b(pixels)h(in)h(the)f
-(arra)m(y)i(will)e(b)s(e)g(set)227 3306 y(equal)k(to)h(the)e(v)-5
+(arra)m(y)i(will)e(b)s(e)g(set)227 4426 y(equal)k(to)h(the)e(v)-5
 b(alue)33 b(of)e('n)m(ullv)-5 b(al',)33 b(unless)e(n)m(ullv)-5
 b(al=0)33 b(in)e(whic)m(h)g(case)i(no)e(testing)i(for)e(unde\014ned)f
-(pixels)227 3419 y(will)h(b)s(e)f(p)s(erformed.)382 3684
+(pixels)227 4539 y(will)h(b)s(e)f(p)s(erformed.)382 4818
 y Ff(FTGSV[BIJKED]\(unit,group)o(,na)o(xis,)o(naxe)o(s,f)o(pixe)o(ls,l)
-o(pix)o(els,)o(incs)o(,nu)o(llva)o(l,)42 b(>)1002 3797
-y(array,anyf,status\))0 4061 y Fi(17)k Fj(Get)34 b(an)f(arbitrary)g
+o(pix)o(els,)o(incs)o(,nu)o(llva)o(l,)42 b(>)1002 4931
+y(array,anyf,status\))0 5209 y Fi(17)k Fj(Get)34 b(an)f(arbitrary)g
 (data)g(subsection)g(from)g(the)g(data)g(arra)m(y)-8
 b(.)50 b(An)m(y)33 b(Unde\014ned)e(pixels)i(in)g(the)g(arra)m(y)h(will)
-227 4174 y(ha)m(v)m(e)e(the)e(corresp)s(onding)g('\015agv)-5
+227 5322 y(ha)m(v)m(e)e(the)e(corresp)s(onding)g('\015agv)-5
 b(als')31 b(elemen)m(t)h(set)f(equal)g(to)g(.TR)m(UE.)382
-4438 y Ff(FTGSF[BIJKED]\(unit,group)o(,na)o(xis,)o(naxe)o(s,f)o(pixe)o
-(ls,l)o(pix)o(els,)o(incs)o(,)42 b(>)1002 4551 y
-(array,flagvals,anyf,statu)o(s\))0 4714 y
-SDict begin H.S end
- 0 4714 a 0
-4714 a
-SDict begin 13.6 H.A end
- 0 4714 a 0 4714 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.7) cvn /DEST pdfmark
-end
- 0 4714 a 176 x Fe(6.7)135 b(FITS)44
-b(ASCI)t(I)g(and)h(Binary)g(T)-11 b(able)45 b(Data)h(I/O)f(Subroutines)
-0 5011 y
-SDict begin H.S end
- 0 5011 a 0 5011 a
-SDict begin 13.6 H.A end
- 0 5011 a 0 5011 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.7.1) cvn /DEST pdfmark
-end
- 0 5011 a
-134 x Fc(6.7.1)112 b(Column)39 b(Information)f(Subroutines)0
-5357 y Fi(1)81 b Fj(Get)37 b(the)f(n)m(um)m(b)s(er)f(of)i(ro)m(ws)f(or)
+5601 y Ff(FTGSF[BIJKED]\(unit,group)o(,na)o(xis,)o(naxe)o(s,f)o(pixe)o
+(ls,l)o(pix)o(els,)o(incs)o(,)42 b(>)1002 5714 y
+(array,flagvals,anyf,statu)o(s\))p eop end
+%%Page: 56 62
+TeXDict begin 56 61 bop 0 299 a Fj(56)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fe(6.7)135 b(FITS)44 b(ASCI)t(I)g(and)h
+(Binary)g(T)-11 b(able)45 b(Data)h(I/O)f(Subroutines)0
+809 y Fc(6.7.1)112 b(Column)39 b(Information)f(Subroutines)0
+1017 y Fi(1)81 b Fj(Get)37 b(the)f(n)m(um)m(b)s(er)f(of)i(ro)m(ws)f(or)
 g(columns)g(in)g(the)h(curren)m(t)f(FITS)g(table.)59
 b(The)36 b(n)m(um)m(b)s(er)f(of)h(ro)m(ws)h(is)f(giv)m(en)227
-5470 y(b)m(y)f(the)h(NAXIS2)f(k)m(eyw)m(ord)h(and)f(the)g(n)m(um)m(b)s
+1129 y(b)m(y)f(the)h(NAXIS2)f(k)m(eyw)m(ord)h(and)f(the)g(n)m(um)m(b)s
 (er)f(of)h(columns)g(is)g(giv)m(en)h(b)m(y)g(the)f(TFIELDS)g(k)m(eyw)m
-(ord)g(in)227 5583 y(the)d(header)f(of)h(the)g(table.)45
+(ord)g(in)227 1242 y(the)d(header)f(of)h(the)g(table.)45
 b(The)31 b(FTGNR)-10 b(WLL)32 b(routine)g(is)f(iden)m(tical)i(to)g
-(FTGNR)-10 b(W)32 b(except)h(that)f(the)227 5696 y(n)m(um)m(b)s(er)d
+(FTGNR)-10 b(W)32 b(except)h(that)f(the)227 1355 y(n)m(um)m(b)s(er)d
 (of)i(ro)m(ws)f(is)h(returned)e(as)h(a)h(64-bit)h(in)m(teger)g(rather)e
-(than)g(a)h(32-bit)g(in)m(teger.)p eop end
-%%Page: 56 62
-TeXDict begin 56 61 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.56) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(56)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTGNRW\(unit,)44
-b(>)k(nrows,)e(status\))382 668 y(FTGNRWLL\(unit,)e(>)j(nrowsll,)f
-(status\))382 781 y(FTGNCL\(unit,)e(>)k(ncols,)e(status\))0
-1044 y Fi(2)81 b Fj(Get)25 b(the)f(table)i(column)e(n)m(um)m(b)s(er)f
+(than)g(a)h(32-bit)g(in)m(teger.)382 1608 y Ff(FTGNRW\(unit,)44
+b(>)k(nrows,)e(status\))382 1721 y(FTGNRWLL\(unit,)e(>)j(nrowsll,)f
+(status\))382 1834 y(FTGNCL\(unit,)e(>)k(ncols,)e(status\))0
+2087 y Fi(2)81 b Fj(Get)25 b(the)f(table)i(column)e(n)m(um)m(b)s(er)f
 (\(and)h(name\))h(of)f(the)h(column)f(whose)g(name)g(matc)m(hes)i(an)e
-(input)g(template)227 1157 y(name.)38 b(The)21 b(table)i(column)e
+(input)g(template)227 2200 y(name.)38 b(The)21 b(table)i(column)e
 (names)h(are)g(de\014ned)e(b)m(y)i(the)g(TTYPEn)e(k)m(eyw)m(ords)i(in)f
-(the)h(FITS)f(header.)37 b(If)22 b(a)227 1270 y(column)i(do)s(es)g(not)
+(the)h(FITS)f(header.)37 b(If)22 b(a)227 2313 y(column)i(do)s(es)g(not)
 g(ha)m(v)m(e)h(a)f(TTYPEn)f(k)m(eyw)m(ord,)j(then)d(these)h(routines)g
-(assume)g(that)g(the)h(name)e(consists)227 1383 y(of)i(all)h(blank)f(c)
+(assume)g(that)g(the)h(name)e(consists)227 2426 y(of)i(all)h(blank)f(c)
 m(haracters.)40 b(These)25 b(2)g(subroutines)e(p)s(erform)h(the)h(same)
-g(function)g(except)h(that)f(FTGCNO)227 1496 y(only)j(returns)e(the)h
+g(function)g(except)h(that)f(FTGCNO)227 2539 y(only)j(returns)e(the)h
 (n)m(um)m(b)s(er)f(of)h(the)g(matc)m(hing)i(column)e(whereas)g(FTGCNN)g
-(also)h(returns)e(the)i(name)f(of)227 1609 y(the)k(column.)40
+(also)h(returns)e(the)i(name)f(of)227 2652 y(the)k(column.)40
 b(If)30 b(CASESEN)f(=)h(.true.)41 b(then)30 b(the)h(column)f(name)g
-(matc)m(h)i(will)e(b)s(e)g(case-sensitiv)m(e.)227 1761
+(matc)m(h)i(will)e(b)s(e)g(case-sensitiv)m(e.)227 2801
 y(The)41 b(input)e(column)i(name)g(template)h(\(COL)-8
 b(TEMPLA)g(TE\))41 b(is)g(\(1\))g(either)h(the)f(exact)h(name)f(of)g
-(the)227 1874 y(column)36 b(to)i(b)s(e)d(searc)m(hed)i(for,)h(or)e
+(the)227 2914 y(column)36 b(to)i(b)s(e)d(searc)m(hed)i(for,)h(or)e
 (\(2\))i(it)f(ma)m(y)g(con)m(tain)g(wild)f(cards)g(c)m(haracters)i
-(\(*,)h(?,)f(or)e(#\),)i(or)f(\(3\))227 1987 y(it)d(ma)m(y)g(con)m
+(\(*,)h(?,)f(or)e(#\),)i(or)f(\(3\))227 3026 y(it)d(ma)m(y)g(con)m
 (tain)g(the)f(n)m(um)m(b)s(er)f(of)h(the)g(desired)g(column)g(\(where)g
 (the)g(n)m(um)m(b)s(er)f(is)h(expressed)f(as)h(ASCI)s(I)227
-2100 y(digits\).)41 b(The)28 b(\014rst)g(2)h(wild)f(cards)g(b)s(eha)m
+3139 y(digits\).)41 b(The)28 b(\014rst)g(2)h(wild)f(cards)g(b)s(eha)m
 (v)m(e)h(similarly)g(to)g(UNIX)g(\014lename)g(matc)m(hing:)40
-b(the)29 b('*')g(c)m(haracter)227 2213 y(matc)m(hes)e(an)m(y)g
+b(the)29 b('*')g(c)m(haracter)227 3252 y(matc)m(hes)e(an)m(y)g
 (sequence)f(of)h(c)m(haracters)g(\(including)f(zero)h(c)m(haracters\))h
 (and)d(the)i(')10 b(?')39 b(c)m(haracter)28 b(matc)m(hes)227
-2325 y(an)m(y)40 b(single)h(c)m(haracter.)71 b(The)39
+3365 y(an)m(y)40 b(single)h(c)m(haracter.)71 b(The)39
 b(#)h(wildcard)f(will)h(matc)m(h)h(an)m(y)f(consecutiv)m(e)i(string)e
-(of)g(decimal)g(digits)227 2438 y(\(0-9\).)45 b(As)31
+(of)g(decimal)g(digits)227 3478 y(\(0-9\).)45 b(As)31
 b(an)g(example,)h(the)f(template)h(strings)f('AB?DE',)h('AB*E',)h(and)d
-('AB*CDE')j(will)e(all)h(matc)m(h)227 2551 y(the)26 b(string)g
+('AB*CDE')j(will)e(all)h(matc)m(h)227 3591 y(the)26 b(string)g
 ('ABCDE'.)i(If)d(more)h(than)g(one)g(column)g(name)g(in)g(the)g(table)h
-(matc)m(hes)g(the)f(template)i(string,)227 2664 y(then)33
+(matc)m(hes)g(the)f(template)i(string,)227 3704 y(then)33
 b(the)h(\014rst)f(matc)m(h)h(is)f(returned)g(and)f(the)i(status)g(v)-5
 b(alue)34 b(will)f(b)s(e)g(set)h(to)g(237)h(as)f(a)f(w)m(arning)h(that)
-g(a)227 2777 y(unique)g(matc)m(h)i(w)m(as)f(not)g(found.)53
+g(a)227 3817 y(unique)g(matc)m(h)i(w)m(as)f(not)g(found.)53
 b(T)-8 b(o)35 b(\014nd)f(the)h(other)g(cases)g(that)h(matc)m(h)g(the)f
-(template,)i(simply)e(call)227 2890 y(the)27 b(subroutine)f(again)i
+(template,)i(simply)e(call)227 3930 y(the)27 b(subroutine)f(again)i
 (lea)m(ving)h(the)e(input)f(status)h(v)-5 b(alue)28 b(equal)f(to)h(237)
-g(and)f(the)g(next)g(matc)m(hing)h(name)227 3003 y(will)k(then)g(b)s(e)
+g(and)f(the)g(next)g(matc)m(hing)h(name)227 4043 y(will)k(then)g(b)s(e)
 f(returned.)43 b(Rep)s(eat)32 b(this)g(pro)s(cess)f(un)m(til)h(a)g
 (status)g(=)g(219)h(\(column)e(name)h(not)g(found\))f(is)227
-3116 y(returned.)40 b(If)30 b(these)h(subroutines)e(fail)i(to)g(matc)m
+4156 y(returned.)40 b(If)30 b(these)h(subroutines)e(fail)i(to)g(matc)m
 (h)g(the)g(template)h(to)f(an)m(y)g(of)f(the)h(columns)f(in)g(the)h
-(table,)227 3229 y(they)i(lastly)g(c)m(hec)m(k)h(if)f(the)f(template)i
+(table,)227 4268 y(they)i(lastly)g(c)m(hec)m(k)h(if)f(the)f(template)i
 (can)f(b)s(e)e(in)m(terpreted)i(as)g(a)g(simple)f(p)s(ositiv)m(e)h(in)m
-(teger)h(\(e.g.,)h('7',)f(or)227 3342 y('512'\))i(and)d(if)g(so,)i
+(teger)h(\(e.g.,)h('7',)f(or)227 4381 y('512'\))i(and)d(if)g(so,)i
 (they)f(return)e(that)j(column)e(n)m(um)m(b)s(er.)49
 b(If)33 b(no)g(matc)m(hes)i(are)f(found)e(then)h(a)h(status)g(=)227
-3455 y(219)e(error)e(is)g(returned.)227 3607 y(Note)h(that)e(the)h
+4494 y(219)e(error)e(is)g(returned.)227 4643 y(Note)h(that)e(the)h
 (FITS)e(Standard)g(recommends)g(that)i(only)f(letters,)i(digits,)f(and)
-f(the)g(underscore)f(c)m(har-)227 3719 y(acter)44 b(b)s(e)e(used)g(in)h
+f(the)g(underscore)f(c)m(har-)227 4756 y(acter)44 b(b)s(e)e(used)g(in)h
 (column)f(names)h(\(with)g(no)f(em)m(b)s(edded)g(spaces)h(in)g(the)g
-(name\).)78 b(T)-8 b(railing)43 b(blank)227 3832 y(c)m(haracters)32
-b(are)f(not)f(signi\014can)m(t.)382 4096 y Ff
+(name\).)78 b(T)-8 b(railing)43 b(blank)227 4869 y(c)m(haracters)32
+b(are)f(not)f(signi\014can)m(t.)382 5122 y Ff
 (FTGCNO\(unit,casesen,colt)o(emp)o(late)o(,)42 b(>)47
-b(colnum,status\))382 4209 y(FTGCNN\(unit,casesen,colt)o(emp)o(late)o
-(,)42 b(>)47 b(colname,colnum,status\))0 4472 y Fi(3)81
+b(colnum,status\))382 5235 y(FTGCNN\(unit,casesen,colt)o(emp)o(late)o
+(,)42 b(>)47 b(colname,colnum,status\))0 5488 y Fi(3)81
 b Fj(Get)39 b(the)g(datat)m(yp)s(e)h(of)e(a)h(column)g(in)f(an)g(ASCI)s
 (I)g(or)g(binary)g(table.)66 b(This)38 b(routine)h(returns)e(an)i(in)m
-(teger)227 4585 y(co)s(de)34 b(v)-5 b(alue)33 b(corresp)s(onding)f(to)i
+(teger)227 5601 y(co)s(de)34 b(v)-5 b(alue)33 b(corresp)s(onding)f(to)i
 (the)g(datat)m(yp)s(e)g(of)f(the)g(column.)49 b(\(See)34
-b(the)f(FTBNFM)i(and)d(FT)-8 b(ASFM)227 4698 y(subroutines)27
+b(the)f(FTBNFM)i(and)d(FT)-8 b(ASFM)227 5714 y(subroutines)27
 b(in)h(the)g(Utilities)j(section)e(of)f(this)g(do)s(cumen)m(t)g(for)g
 (a)h(list)g(of)f(the)h(co)s(de)f(v)-5 b(alues\).)41 b(The)27
-b(v)m(ector)227 4811 y(rep)s(eat)38 b(coun)m(t)g(\(whic)m(h)g(is)g(alw)
-m(a)m(y)h(1)f(for)g(ASCI)s(I)e(table)i(columns\))g(is)g(also)g
-(returned.)62 b(If)37 b(the)h(sp)s(eci\014ed)227 4924
-y(column)32 b(has)f(an)g(ASCI)s(I)f(c)m(haracter)j(datat)m(yp)s(e)g
-(\(co)s(de)f(=)f(16\))i(then)e(the)h(width)e(of)i(a)g(unit)f(string)h
-(in)f(the)227 5036 y(column)i(is)g(also)h(returned.)48
-b(Note)34 b(that)g(this)e(routine)h(supp)s(orts)f(the)h(lo)s(cal)h(con)
-m(v)m(en)m(tion)h(for)e(sp)s(ecifying)227 5149 y(arra)m(ys)f(of)f
-(strings)g(within)f(a)i(binary)e(table)i(c)m(haracter)g(column,)g
-(using)e(the)h(syn)m(tax)h(TF)m(ORM)f(=)g('rAw')227 5262
-y(where)f('r')g(is)h(the)f(total)i(n)m(um)m(b)s(er)d(of)i(c)m
+b(v)m(ector)p eop end
+%%Page: 57 63
+TeXDict begin 57 62 bop 0 299 a Fh(6.7.)72 b(FITS)30
+b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31 b(D)m(A)-8
+b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(57)227 555
+y(rep)s(eat)38 b(coun)m(t)g(\(whic)m(h)g(is)g(alw)m(a)m(y)h(1)f(for)g
+(ASCI)s(I)e(table)i(columns\))g(is)g(also)g(returned.)62
+b(If)37 b(the)h(sp)s(eci\014ed)227 668 y(column)32 b(has)f(an)g(ASCI)s
+(I)f(c)m(haracter)j(datat)m(yp)s(e)g(\(co)s(de)f(=)f(16\))i(then)e(the)
+h(width)e(of)i(a)g(unit)f(string)h(in)f(the)227 781 y(column)i(is)g
+(also)h(returned.)48 b(Note)34 b(that)g(this)e(routine)h(supp)s(orts)f
+(the)h(lo)s(cal)h(con)m(v)m(en)m(tion)h(for)e(sp)s(ecifying)227
+894 y(arra)m(ys)f(of)f(strings)g(within)f(a)i(binary)e(table)i(c)m
+(haracter)g(column,)g(using)e(the)h(syn)m(tax)h(TF)m(ORM)f(=)g('rAw')
+227 1007 y(where)f('r')g(is)h(the)f(total)i(n)m(um)m(b)s(er)d(of)i(c)m
 (haracters)g(\(=)g(the)f(width)g(of)g(the)g(column\))h(and)f('w')g(is)g
-(the)h(width)227 5375 y(of)39 b(a)f(unit)g(string)g(within)g(the)g
+(the)h(width)227 1120 y(of)39 b(a)f(unit)g(string)g(within)g(the)g
 (column.)64 b(Th)m(us)37 b(if)h(the)g(column)g(has)g(TF)m(ORM)h(=)f
-('60A12')i(then)e(this)227 5488 y(routine)29 b(will)g(return)f(dataco)s
+('60A12')i(then)e(this)227 1233 y(routine)29 b(will)g(return)f(dataco)s
 (de)i(=)e(16,)i(rep)s(eat)f(=)f(60,)j(and)d(width)g(=)g(12.)41
-b(\(The)29 b(TDIMn)f(k)m(eyw)m(ord)h(ma)m(y)227 5601
+b(\(The)29 b(TDIMn)f(k)m(eyw)m(ord)h(ma)m(y)227 1346
 y(also)35 b(b)s(e)e(used)g(to)h(sp)s(ecify)f(the)h(unit)f(string)h
 (length;)i(The)d(pair)g(of)h(k)m(eyw)m(ords)g(TF)m(ORMn)f(=)g('60A')j
-(and)227 5714 y(TDIMn)30 b(=)g('\(12,5\)')j(w)m(ould)e(ha)m(v)m(e)g
-(the)g(same)g(e\013ect)g(as)g(TF)m(ORMn)f(=)g('60A12'\).)p
-eop end
-%%Page: 57 63
-TeXDict begin 57 62 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.57) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.7.)72
-b(FITS)30 b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31
-b(D)m(A)-8 b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(57)227
-555 y(The)31 b(second)h(routine,)g(FTEQTY)f(is)g(similar)h(except)h
-(that)f(in)f(the)h(case)g(of)g(scaled)g(in)m(teger)h(columns)e(it)227
-668 y(returns)23 b(the)h('equiv)-5 b(alen)m(t')25 b(data)f(t)m(yp)s(e)g
-(that)h(is)e(needed)h(to)g(store)g(the)g(scaled)g(v)-5
-b(alues,)26 b(and)d(not)h(necessarily)227 781 y(the)38
+(and)227 1458 y(TDIMn)30 b(=)g('\(12,5\)')j(w)m(ould)e(ha)m(v)m(e)g
+(the)g(same)g(e\013ect)g(as)g(TF)m(ORMn)f(=)g('60A12'\).)227
+1604 y(The)h(second)h(routine,)g(FTEQTY)f(is)g(similar)h(except)h(that)
+f(in)f(the)h(case)g(of)g(scaled)g(in)m(teger)h(columns)e(it)227
+1717 y(returns)23 b(the)h('equiv)-5 b(alen)m(t')25 b(data)f(t)m(yp)s(e)
+g(that)h(is)e(needed)h(to)g(store)g(the)g(scaled)g(v)-5
+b(alues,)26 b(and)d(not)h(necessarily)227 1830 y(the)38
 b(ph)m(ysical)h(data)f(t)m(yp)s(e)g(of)g(the)g(unscaled)g(v)-5
 b(alues)38 b(as)g(stored)g(in)g(the)g(FITS)f(table.)64
-b(F)-8 b(or)38 b(example)h(if)227 894 y(a)c('1I')g(column)f(in)g(a)g
+b(F)-8 b(or)38 b(example)h(if)227 1943 y(a)c('1I')g(column)f(in)g(a)g
 (binary)g(table)h(has)f(TSCALn)f(=)g(1)i(and)f(TZER)m(On)f(=)g(32768,)
-38 b(then)c(this)g(column)227 1007 y(e\013ectiv)m(ely)27
+38 b(then)c(this)g(column)227 2056 y(e\013ectiv)m(ely)27
 b(con)m(tains)e(unsigned)e(short)g(in)m(teger)j(v)-5
 b(alues,)25 b(and)f(th)m(us)f(the)h(returned)f(v)-5 b(alue)24
-b(of)g(t)m(yp)s(eco)s(de)h(will)227 1120 y(b)s(e)32 b(the)h(co)s(de)g
+b(of)g(t)m(yp)s(eco)s(de)h(will)227 2169 y(b)s(e)32 b(the)h(co)s(de)g
 (for)g(an)f(unsigned)g(short)g(in)m(teger,)j(not)e(a)g(signed)g(short)f
 (in)m(teger.)49 b(Similarly)-8 b(,)34 b(if)f(a)g(column)227
-1233 y(has)d(TTYPEn)g(=)g('1I')h(and)f(TSCALn)e(=)i(0.12,)j(then)d(the)
+2281 y(has)d(TTYPEn)g(=)g('1I')h(and)f(TSCALn)e(=)i(0.12,)j(then)d(the)
 g(returned)g(t)m(yp)s(eco)s(de)g(will)h(b)s(e)f(the)h(co)s(de)f(for)h
-(a)227 1346 y('real')h(column.)382 1611 y Ff(FTGTCL\(unit,colnum,)42
-b(>)48 b(datacode,repeat,width,st)o(atu)o(s\))382 1724
+(a)227 2394 y('real')h(column.)382 2626 y Ff(FTGTCL\(unit,colnum,)42
+b(>)48 b(datacode,repeat,width,st)o(atu)o(s\))382 2739
 y(FTEQTY\(unit,colnum,)42 b(>)48 b(datacode,repeat,width,st)o(atu)o
-(s\))0 1989 y Fi(4)81 b Fj(Return)22 b(the)i(displa)m(y)g(width)f(of)g
+(s\))0 2970 y Fi(4)81 b Fj(Return)22 b(the)i(displa)m(y)g(width)f(of)g
 (a)h(column.)39 b(This)22 b(is)i(the)g(length)g(of)f(the)h(string)g
-(that)g(will)g(b)s(e)f(returned)f(when)227 2102 y(reading)33
+(that)g(will)g(b)s(e)f(returned)f(when)227 3083 y(reading)33
 b(the)g(column)g(as)g(a)g(formatted)g(string.)48 b(The)32
 b(displa)m(y)h(width)f(is)h(determined)g(b)m(y)f(the)h(TDISPn)227
-2215 y(k)m(eyw)m(ord,)e(if)g(presen)m(t,)f(otherwise)h(b)m(y)f(the)h
-(data)g(t)m(yp)s(e)g(of)f(the)h(column.)382 2480 y Ff(FTGCDW\(unit,)44
-b(colnum,)i(>)i(dispwidth,)d(status\))0 2745 y Fi(5)81
+3196 y(k)m(eyw)m(ord,)e(if)g(presen)m(t,)f(otherwise)h(b)m(y)f(the)h
+(data)g(t)m(yp)s(e)g(of)f(the)h(column.)382 3427 y Ff(FTGCDW\(unit,)44
+b(colnum,)i(>)i(dispwidth,)d(status\))0 3659 y Fi(5)81
 b Fj(Get)29 b(information)f(ab)s(out)g(an)g(existing)h(ASCI)s(I)e
 (table)i(column.)40 b(\(NOTE:)28 b(TSCAL)f(and)g(TZER)m(O)h(m)m(ust)g
-(b)s(e)227 2858 y(declared)j(as)g(Double)g(Precision)g(v)-5
+(b)s(e)227 3772 y(declared)j(as)g(Double)g(Precision)g(v)-5
 b(ariables\).)41 b(All)31 b(the)g(returned)e(parameters)i(are)f(scalar)
-i(quan)m(tities.)382 3123 y Ff(FTGACL\(unit,colnum,)42
-b(>)716 3236 y(ttype,tbcol,tunit,tform,)o(tsca)o(l,t)o(zero)o(,snu)o
-(ll,)o(tdis)o(p,st)o(atu)o(s\))0 3501 y Fi(6)81 b Fj(Get)29
+i(quan)m(tities.)382 4003 y Ff(FTGACL\(unit,colnum,)42
+b(>)716 4116 y(ttype,tbcol,tunit,tform,)o(tsca)o(l,t)o(zero)o(,snu)o
+(ll,)o(tdis)o(p,st)o(atu)o(s\))0 4348 y Fi(6)81 b Fj(Get)29
 b(information)f(ab)s(out)f(an)h(existing)h(binary)e(table)i(column.)40
 b(\(NOTE:)28 b(TSCAL)e(and)i(TZER)m(O)f(m)m(ust)h(b)s(e)227
-3614 y(declared)j(as)f(Double)g(Precision)h(v)-5 b(ariables\).)41
+4461 y(declared)j(as)f(Double)g(Precision)h(v)-5 b(ariables\).)41
 b(D)m(A)-8 b(T)g(A)g(TYPE)32 b(is)e(a)g(c)m(haracter)i(string)d(whic)m
-(h)h(returns)f(the)227 3727 y(datat)m(yp)s(e)35 b(of)g(the)f(column)g
+(h)h(returns)f(the)227 4574 y(datat)m(yp)s(e)35 b(of)g(the)f(column)g
 (as)g(de\014ned)f(b)m(y)h(the)g(TF)m(ORMn)g(k)m(eyw)m(ord)h(\(e.g.,)i
-('I',)e('J','E',)g('D',)g(etc.\).)54 b(In)227 3840 y(the)27
+('I',)e('J','E',)g('D',)g(etc.\).)54 b(In)227 4686 y(the)27
 b(case)g(of)g(an)f(ASCI)s(I)f(c)m(haracter)j(column,)f(D)m(A)-8
 b(T)g(A)g(TYPE)29 b(will)d(ha)m(v)m(e)i(a)f(v)-5 b(alue)27
-b(of)f(the)h(form)f('An')g(where)227 3953 y('n')34 b(is)g(an)g(in)m
+b(of)f(the)h(form)f('An')g(where)227 4799 y('n')34 b(is)g(an)g(in)m
 (teger)i(expressing)e(the)g(width)f(of)h(the)h(\014eld)e(in)h(c)m
 (haracters.)53 b(F)-8 b(or)35 b(example,)h(if)e(TF)m(ORM)g(=)227
-4066 y('160A8')39 b(then)e(FTGBCL)f(will)h(return)f(D)m(A)-8
+4912 y('160A8')39 b(then)e(FTGBCL)f(will)h(return)f(D)m(A)-8
 b(T)g(A)g(TYPE='A8')39 b(and)d(REPEA)-8 b(T=20.)60 b(All)37
-b(the)g(returned)227 4179 y(parameters)31 b(are)g(scalar)g(quan)m
-(tities.)382 4444 y Ff(FTGBCL\(unit,colnum,)42 b(>)716
-4557 y(ttype,tunit,datatype,rep)o(eat,)o(tsc)o(al,t)o(zero)o(,tn)o
-(ull,)o(tdis)o(p,s)o(tatu)o(s\))0 4822 y Fi(7)81 b Fj(Put)31
+b(the)g(returned)227 5025 y(parameters)31 b(are)g(scalar)g(quan)m
+(tities.)382 5257 y Ff(FTGBCL\(unit,colnum,)42 b(>)716
+5370 y(ttype,tunit,datatype,rep)o(eat,)o(tsc)o(al,t)o(zero)o(,tn)o
+(ull,)o(tdis)o(p,s)o(tatu)o(s\))0 5601 y Fi(7)81 b Fj(Put)31
 b(\(app)s(end\))g(a)i(TDIMn)f(k)m(eyw)m(ord)g(whose)g(v)-5
 b(alue)33 b(has)f(the)g(form)g('\(l,m,n...\)')47 b(where)32
-b(l,)h(m,)f(n...)46 b(are)33 b(the)227 4935 y(dimensions)d(of)g(a)h(m)m
-(ultidimensional)g(arra)m(y)g(column)f(in)g(a)h(binary)f(table.)382
-5200 y Ff(FTPTDM\(unit,colnum,naxis)o(,na)o(xes,)41 b(>)48
-b(status\))0 5465 y Fi(8)81 b Fj(Return)29 b(the)h(n)m(um)m(b)s(er)e
-(of)i(and)g(size)g(of)g(the)g(dimensions)g(of)g(a)g(table)h(column.)40
-b(Normally)31 b(this)f(information)227 5578 y(is)h(giv)m(en)h(b)m(y)f
-(the)g(TDIMn)f(k)m(eyw)m(ord,)i(but)e(if)h(this)g(k)m(eyw)m(ord)g(is)g
-(not)g(presen)m(t)g(then)g(this)f(routine)h(returns)227
-5691 y(NAXIS)f(=)g(1)h(and)f(NAXES\(1\))h(equal)g(to)g(the)g(rep)s(eat)
-g(coun)m(t)g(in)f(the)g(TF)m(ORM)h(k)m(eyw)m(ord.)p eop
-end
+b(l,)h(m,)f(n...)46 b(are)33 b(the)227 5714 y(dimensions)d(of)g(a)h(m)m
+(ultidimensional)g(arra)m(y)g(column)f(in)g(a)h(binary)f(table.)p
+eop end
 %%Page: 58 64
-TeXDict begin 58 63 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.58) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(58)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTGTDM\(unit,colnum,maxdi)o
-(m,)41 b(>)48 b(naxis,naxes,status\))0 808 y Fi(9)81
-b Fj(Deco)s(de)33 b(the)g(input)f(TDIMn)h(k)m(eyw)m(ord)g(string)f
-(\(e.g.)50 b('\(100,200\)'\))37 b(and)32 b(return)g(the)h(n)m(um)m(b)s
-(er)e(of)i(and)f(size)227 921 y(of)c(the)g(dimensions)f(of)h(a)g
-(binary)f(table)h(column.)40 b(If)27 b(the)h(input)f(tdimstr)g(c)m
-(haracter)i(string)f(is)g(n)m(ull,)g(then)227 1034 y(this)d(routine)f
-(returns)f(naxis)h(=)h(1)f(and)g(naxes[0])i(equal)e(to)i(the)e(rep)s
-(eat)h(coun)m(t)g(in)f(the)g(TF)m(ORM)h(k)m(eyw)m(ord.)227
-1147 y(This)30 b(routine)g(is)h(called)g(b)m(y)f(FTGTDM.)382
-1400 y Ff(FTDTDM\(unit,tdimstr,coln)o(um,)o(maxd)o(im,)41
-b(>)48 b(naxis,naxes,)c(status\))0 1654 y Fi(10)i Fj(Return)32
-b(the)h(optimal)h(n)m(um)m(b)s(er)e(of)h(ro)m(ws)g(to)h(read)f(or)g
-(write)g(at)h(one)f(time)h(for)e(maxim)m(um)h(I/O)g(e\016ciency)-8
-b(.)227 1767 y(Refer)31 b(to)g(the)g(\\Optimizing)g(Co)s(de")f(section)
-i(in)e(Chapter)g(5)g(for)h(more)f(discussion)g(on)g(ho)m(w)h(to)g(use)f
-(this)227 1879 y(routine.)382 2133 y Ff(FTGRSZ\(unit,)44
-b(>)k(nrows,status\))0 2271 y
-SDict begin H.S end
- 0 2271 a 0 2271 a
-SDict begin 13.6 H.A end
- 0 2271
-a 0 2271 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.7.2) cvn /DEST pdfmark
-end
- 0 2271 a 151 x Fc(6.7.2)112 b(Lo)m(w-Lev)m(el)39
-b(T)-9 b(able)38 b(Access)f(Subroutines)0 2641 y Fj(The)d(follo)m(wing)
-h(subroutines)e(pro)m(vide)i(lo)m(w-lev)m(el)i(access)e(to)g(the)g
-(data)g(in)f(ASCI)s(I)e(or)i(binary)g(tables)h(and)f(are)0
-2754 y(mainly)29 b(useful)f(as)i(an)f(e\016cien)m(t)h(w)m(a)m(y)g(to)g
-(cop)m(y)g(all)g(or)f(part)g(of)g(a)g(table)h(from)f(one)g(lo)s(cation)
-i(to)f(another.)40 b(These)0 2867 y(routines)24 b(simply)g(read)g(or)h
-(write)f(the)h(sp)s(eci\014ed)e(n)m(um)m(b)s(er)g(of)i(consecutiv)m(e)h
-(b)m(ytes)f(in)f(an)g(ASCI)s(I)f(or)h(binary)g(table,)0
-2980 y(without)37 b(regard)g(for)f(column)h(b)s(oundaries)e(or)i(the)g
-(ro)m(w)g(length)h(in)e(the)h(table.)61 b(The)37 b(\014rst)f(t)m(w)m(o)
-i(subroutines)0 3093 y(read)29 b(or)h(write)g(consecutiv)m(e)h(b)m
-(ytes)f(in)f(a)h(table)g(to)h(or)e(from)g(a)h(c)m(haracter)h(string)e
-(v)-5 b(ariable,)31 b(while)f(the)f(last)i(t)m(w)m(o)0
-3206 y(subroutines)f(read)i(or)g(write)g(consecutiv)m(e)h(b)m(ytes)g
-(to)f(or)g(from)f(a)h(v)-5 b(ariable)33 b(declared)f(as)g(a)g(n)m
-(umeric)f(data)i(t)m(yp)s(e)0 3319 y(\(e.g.,)40 b(INTEGER,)d
-(INTEGER*2,)i(REAL,)d(DOUBLE)h(PRECISION\).)f(These)g(routines)h(do)f
-(not)h(p)s(erform)0 3432 y(an)m(y)c(mac)m(hine)g(dep)s(enden)m(t)f
-(data)i(con)m(v)m(ersion)g(or)e(b)m(yte)i(sw)m(apping,)f(except)h(that)
-f(con)m(v)m(ersion)h(to/from)f(ASCI)s(I)0 3544 y(format)d(is)g(p)s
-(erformed)e(b)m(y)h(the)h(FTGTBS)f(and)g(FTPTBS)g(routines)h(on)f(mac)m
-(hines)h(whic)m(h)g(do)f(not)h(use)f(ASCI)s(I)0 3657
-y(c)m(haracter)j(co)s(des)e(in)g(the)h(in)m(ternal)g(data)g(represen)m
-(tations)h(\(e.g.,)g(on)e(IBM)h(mainframe)f(computers\).)0
-3911 y Fi(1)81 b Fj(Read)26 b(a)h(consecutiv)m(e)h(string)f(of)f(c)m
-(haracters)i(from)e(an)g(ASCI)s(I)f(table)i(in)m(to)h(a)e(c)m(haracter)
-i(v)-5 b(ariable)28 b(\(spanning)227 4024 y(columns)k(and)g(m)m
-(ultiple)h(ro)m(ws)f(if)g(necessary\))h(This)f(routine)g(should)f(not)i
-(b)s(e)e(used)h(with)g(binary)f(tables)227 4136 y(b)s(ecause)g(of)f
-(complications)i(related)g(to)f(passing)f(string)g(v)-5
-b(ariables)31 b(b)s(et)m(w)m(een)g(C)f(and)g(F)-8 b(ortran.)382
-4390 y Ff(FTGTBS\(unit,frow,startch)o(ar,)o(ncha)o(rs,)41
-b(>)48 b(string,status\))0 4643 y Fi(2)81 b Fj(W)-8 b(rite)31
+TeXDict begin 58 63 bop 0 299 a Fj(58)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTPTDM\(unit,colnum,naxis)o(,na)o(xes,)41
+b(>)48 b(status\))0 820 y Fi(8)81 b Fj(Return)29 b(the)h(n)m(um)m(b)s
+(er)e(of)i(and)g(size)g(of)g(the)g(dimensions)g(of)g(a)g(table)h
+(column.)40 b(Normally)31 b(this)f(information)227 933
+y(is)h(giv)m(en)h(b)m(y)f(the)g(TDIMn)f(k)m(eyw)m(ord,)i(but)e(if)h
+(this)g(k)m(eyw)m(ord)g(is)g(not)g(presen)m(t)g(then)g(this)f(routine)h
+(returns)227 1046 y(NAXIS)f(=)g(1)h(and)f(NAXES\(1\))h(equal)g(to)g
+(the)g(rep)s(eat)g(coun)m(t)g(in)f(the)g(TF)m(ORM)h(k)m(eyw)m(ord.)382
+1311 y Ff(FTGTDM\(unit,colnum,maxdi)o(m,)41 b(>)48 b
+(naxis,naxes,status\))0 1576 y Fi(9)81 b Fj(Deco)s(de)33
+b(the)g(input)f(TDIMn)h(k)m(eyw)m(ord)g(string)f(\(e.g.)50
+b('\(100,200\)'\))37 b(and)32 b(return)g(the)h(n)m(um)m(b)s(er)e(of)i
+(and)f(size)227 1689 y(of)c(the)g(dimensions)f(of)h(a)g(binary)f(table)
+h(column.)40 b(If)27 b(the)h(input)f(tdimstr)g(c)m(haracter)i(string)f
+(is)g(n)m(ull,)g(then)227 1801 y(this)d(routine)f(returns)f(naxis)h(=)h
+(1)f(and)g(naxes[0])i(equal)e(to)i(the)e(rep)s(eat)h(coun)m(t)g(in)f
+(the)g(TF)m(ORM)h(k)m(eyw)m(ord.)227 1914 y(This)30 b(routine)g(is)h
+(called)g(b)m(y)f(FTGTDM.)382 2179 y Ff(FTDTDM\(unit,tdimstr,coln)o
+(um,)o(maxd)o(im,)41 b(>)48 b(naxis,naxes,)c(status\))0
+2444 y Fi(10)i Fj(Return)32 b(the)h(optimal)h(n)m(um)m(b)s(er)e(of)h
+(ro)m(ws)g(to)h(read)f(or)g(write)g(at)h(one)f(time)h(for)e(maxim)m(um)
+h(I/O)g(e\016ciency)-8 b(.)227 2557 y(Refer)31 b(to)g(the)g
+(\\Optimizing)g(Co)s(de")f(section)i(in)e(Chapter)g(5)g(for)h(more)f
+(discussion)g(on)g(ho)m(w)h(to)g(use)f(this)227 2670
+y(routine.)382 2935 y Ff(FTGRSZ\(unit,)44 b(>)k(nrows,status\))0
+3231 y Fc(6.7.2)112 b(Lo)m(w-Lev)m(el)39 b(T)-9 b(able)38
+b(Access)f(Subroutines)0 3451 y Fj(The)d(follo)m(wing)h(subroutines)e
+(pro)m(vide)i(lo)m(w-lev)m(el)i(access)e(to)g(the)g(data)g(in)f(ASCI)s
+(I)e(or)i(binary)g(tables)h(and)f(are)0 3564 y(mainly)29
+b(useful)f(as)i(an)f(e\016cien)m(t)h(w)m(a)m(y)g(to)g(cop)m(y)g(all)g
+(or)f(part)g(of)g(a)g(table)h(from)f(one)g(lo)s(cation)i(to)f(another.)
+40 b(These)0 3677 y(routines)24 b(simply)g(read)g(or)h(write)f(the)h
+(sp)s(eci\014ed)e(n)m(um)m(b)s(er)g(of)i(consecutiv)m(e)h(b)m(ytes)f
+(in)f(an)g(ASCI)s(I)f(or)h(binary)g(table,)0 3790 y(without)37
+b(regard)g(for)f(column)h(b)s(oundaries)e(or)i(the)g(ro)m(w)g(length)h
+(in)e(the)h(table.)61 b(The)37 b(\014rst)f(t)m(w)m(o)i(subroutines)0
+3903 y(read)29 b(or)h(write)g(consecutiv)m(e)h(b)m(ytes)f(in)f(a)h
+(table)g(to)h(or)e(from)g(a)h(c)m(haracter)h(string)e(v)-5
+b(ariable,)31 b(while)f(the)f(last)i(t)m(w)m(o)0 4016
+y(subroutines)f(read)i(or)g(write)g(consecutiv)m(e)h(b)m(ytes)g(to)f
+(or)g(from)f(a)h(v)-5 b(ariable)33 b(declared)f(as)g(a)g(n)m(umeric)f
+(data)i(t)m(yp)s(e)0 4129 y(\(e.g.,)40 b(INTEGER,)d(INTEGER*2,)i(REAL,)
+d(DOUBLE)h(PRECISION\).)f(These)g(routines)h(do)f(not)h(p)s(erform)0
+4242 y(an)m(y)c(mac)m(hine)g(dep)s(enden)m(t)f(data)i(con)m(v)m(ersion)
+g(or)e(b)m(yte)i(sw)m(apping,)f(except)h(that)f(con)m(v)m(ersion)h
+(to/from)f(ASCI)s(I)0 4355 y(format)d(is)g(p)s(erformed)e(b)m(y)h(the)h
+(FTGTBS)f(and)g(FTPTBS)g(routines)h(on)f(mac)m(hines)h(whic)m(h)g(do)f
+(not)h(use)f(ASCI)s(I)0 4468 y(c)m(haracter)j(co)s(des)e(in)g(the)h(in)
+m(ternal)g(data)g(represen)m(tations)h(\(e.g.,)g(on)e(IBM)h(mainframe)f
+(computers\).)0 4733 y Fi(1)81 b Fj(Read)26 b(a)h(consecutiv)m(e)h
+(string)f(of)f(c)m(haracters)i(from)e(an)g(ASCI)s(I)f(table)i(in)m(to)h
+(a)e(c)m(haracter)i(v)-5 b(ariable)28 b(\(spanning)227
+4845 y(columns)k(and)g(m)m(ultiple)h(ro)m(ws)f(if)g(necessary\))h(This)
+f(routine)g(should)f(not)i(b)s(e)e(used)h(with)g(binary)f(tables)227
+4958 y(b)s(ecause)g(of)f(complications)i(related)g(to)f(passing)f
+(string)g(v)-5 b(ariables)31 b(b)s(et)m(w)m(een)g(C)f(and)g(F)-8
+b(ortran.)382 5223 y Ff(FTGTBS\(unit,frow,startch)o(ar,)o(ncha)o(rs,)41
+b(>)48 b(string,status\))0 5488 y Fi(2)81 b Fj(W)-8 b(rite)31
 b(a)g(consecutiv)m(e)h(string)e(of)h(c)m(haracters)g(to)g(an)f(ASCI)s
 (I)f(table)i(from)f(a)h(c)m(haracter)h(v)-5 b(ariable)31
-b(\(spanning)227 4756 y(columns)h(and)g(m)m(ultiple)h(ro)m(ws)f(if)g
+b(\(spanning)227 5601 y(columns)h(and)g(m)m(ultiple)h(ro)m(ws)f(if)g
 (necessary\))h(This)f(routine)g(should)f(not)i(b)s(e)e(used)h(with)g
-(binary)f(tables)227 4869 y(b)s(ecause)g(of)f(complications)i(related)g
+(binary)f(tables)227 5714 y(b)s(ecause)g(of)f(complications)i(related)g
 (to)f(passing)f(string)g(v)-5 b(ariables)31 b(b)s(et)m(w)m(een)g(C)f
-(and)g(F)-8 b(ortran.)382 5122 y Ff(FTPTBS\(unit,frow,startch)o(ar,)o
-(ncha)o(rs,s)o(tri)o(ng,)41 b(>)48 b(status\))0 5375
-y Fi(3)81 b Fj(Read)27 b(a)h(consecutiv)m(e)i(arra)m(y)e(of)g(b)m(ytes)
-g(from)f(an)g(ASCI)s(I)f(or)i(binary)e(table)j(in)m(to)f(a)g(n)m
-(umeric)g(v)-5 b(ariable)28 b(\(span-)227 5488 y(ning)k(columns)f(and)h
-(m)m(ultiple)g(ro)m(ws)g(if)g(necessary\).)46 b(The)32
-b(arra)m(y)g(parameter)g(ma)m(y)h(b)s(e)e(declared)h(as)h(an)m(y)227
-5601 y(n)m(umerical)i(datat)m(yp)s(e)g(as)g(long)g(as)g(the)f(arra)m(y)
-h(is)f(at)h(least)h('nc)m(hars')f(b)m(ytes)f(long,)j(e.g.,)f(if)f(nc)m
-(hars)f(=)g(17,)227 5714 y(then)c(declare)i(the)e(arra)m(y)h(as)g
-(INTEGER*4)g(ARRA)-8 b(Y\(5\).)p eop end
+(and)g(F)-8 b(ortran.)p eop end
 %%Page: 59 65
-TeXDict begin 59 64 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.59) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.7.)72
-b(FITS)30 b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31
-b(D)m(A)-8 b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(59)382
-555 y Ff(FTGTBB\(unit,frow,startch)o(ar,)o(ncha)o(rs,)41
-b(>)48 b(array,status\))0 813 y Fi(4)81 b Fj(W)-8 b(rite)32
+TeXDict begin 59 64 bop 0 299 a Fh(6.7.)72 b(FITS)30
+b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31 b(D)m(A)-8
+b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(59)382 555
+y Ff(FTPTBS\(unit,frow,startch)o(ar,)o(ncha)o(rs,s)o(tri)o(ng,)41
+b(>)48 b(status\))0 797 y Fi(3)81 b Fj(Read)27 b(a)h(consecutiv)m(e)i
+(arra)m(y)e(of)g(b)m(ytes)g(from)f(an)g(ASCI)s(I)f(or)i(binary)e(table)
+j(in)m(to)f(a)g(n)m(umeric)g(v)-5 b(ariable)28 b(\(span-)227
+910 y(ning)k(columns)f(and)h(m)m(ultiple)g(ro)m(ws)g(if)g(necessary\).)
+46 b(The)32 b(arra)m(y)g(parameter)g(ma)m(y)h(b)s(e)e(declared)h(as)h
+(an)m(y)227 1023 y(n)m(umerical)i(datat)m(yp)s(e)g(as)g(long)g(as)g
+(the)f(arra)m(y)h(is)f(at)h(least)h('nc)m(hars')f(b)m(ytes)f(long,)j
+(e.g.,)f(if)f(nc)m(hars)f(=)g(17,)227 1136 y(then)c(declare)i(the)e
+(arra)m(y)h(as)g(INTEGER*4)g(ARRA)-8 b(Y\(5\).)382 1379
+y Ff(FTGTBB\(unit,frow,startch)o(ar,)o(ncha)o(rs,)41
+b(>)48 b(array,status\))0 1621 y Fi(4)81 b Fj(W)-8 b(rite)32
 b(a)f(consecutiv)m(e)i(arra)m(y)f(of)f(b)m(ytes)g(to)h(an)e(ASCI)s(I)g
 (or)h(binary)f(table)i(from)e(a)i(n)m(umeric)e(v)-5 b(ariable)32
-b(\(span-)227 926 y(ning)j(columns)f(and)g(m)m(ultiple)h(ro)m(ws)g(if)f
-(necessary\))i(The)e(arra)m(y)h(parameter)g(ma)m(y)h(b)s(e)e(declared)h
-(as)g(an)m(y)227 1039 y(n)m(umerical)g(datat)m(yp)s(e)g(as)g(long)g(as)
-g(the)f(arra)m(y)h(is)f(at)h(least)h('nc)m(hars')f(b)m(ytes)f(long,)j
-(e.g.,)f(if)f(nc)m(hars)f(=)g(17,)227 1152 y(then)c(declare)i(the)e
-(arra)m(y)h(as)g(INTEGER*4)g(ARRA)-8 b(Y\(5\).)382 1410
-y Ff(FTPTBB\(unit,frow,startch)o(ar,)o(ncha)o(rs,a)o(rra)o(y,)42
-b(>)47 b(status\))0 1557 y
-SDict begin H.S end
- 0 1557 a 0 1557 a
-SDict begin 13.6 H.A end
- 0 1557 a
-0 1557 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.7.3) cvn /DEST pdfmark
-end
- 0 1557 a 143 x Fc(6.7.3)112 b(Edit)37 b(Ro)m(ws)g(or)h
-(Columns)0 1909 y Fi(1)81 b Fj(Insert)26 b(blank)h(ro)m(ws)h(in)m(to)g
+b(\(span-)227 1734 y(ning)j(columns)f(and)g(m)m(ultiple)h(ro)m(ws)g(if)
+f(necessary\))i(The)e(arra)m(y)h(parameter)g(ma)m(y)h(b)s(e)e(declared)
+h(as)g(an)m(y)227 1847 y(n)m(umerical)g(datat)m(yp)s(e)g(as)g(long)g
+(as)g(the)f(arra)m(y)h(is)f(at)h(least)h('nc)m(hars')f(b)m(ytes)f
+(long,)j(e.g.,)f(if)f(nc)m(hars)f(=)g(17,)227 1960 y(then)c(declare)i
+(the)e(arra)m(y)h(as)g(INTEGER*4)g(ARRA)-8 b(Y\(5\).)382
+2202 y Ff(FTPTBB\(unit,frow,startch)o(ar,)o(ncha)o(rs,a)o(rra)o(y,)42
+b(>)47 b(status\))0 2490 y Fc(6.7.3)112 b(Edit)37 b(Ro)m(ws)g(or)h
+(Columns)0 2696 y Fi(1)81 b Fj(Insert)26 b(blank)h(ro)m(ws)h(in)m(to)g
 (an)f(existing)h(ASCI)s(I)e(or)h(binary)g(table)h(\(in)g(the)f(CDU\).)h
-(All)g(the)g(ro)m(ws)f(F)m(OLLO)m(W-)227 2022 y(ING)35
+(All)g(the)g(ro)m(ws)f(F)m(OLLO)m(W-)227 2809 y(ING)35
 b(ro)m(w)g(FR)m(O)m(W)g(are)g(shifted)f(do)m(wn)g(b)m(y)h(NR)m(O)m(WS)g
 (ro)m(ws.)53 b(If)34 b(FR)m(O)m(W)i(or)e(FR)m(O)m(WLL)i(equals)e(0)h
-(then)227 2134 y(the)27 b(blank)f(ro)m(ws)h(are)g(inserted)f(at)h(the)g
+(then)227 2922 y(the)27 b(blank)f(ro)m(ws)h(are)g(inserted)f(at)h(the)g
 (b)s(eginning)f(of)g(the)h(table.)41 b(These)26 b(routines)g(mo)s(dify)
-g(the)h(NAXIS2)227 2247 y(k)m(eyw)m(ord)35 b(to)h(re\015ect)f(the)g
+g(the)h(NAXIS2)227 3035 y(k)m(eyw)m(ord)35 b(to)h(re\015ect)f(the)g
 (new)f(n)m(um)m(b)s(er)f(of)i(ro)m(ws)g(in)f(the)h(table.)54
 b(Note)36 b(that)f(it)h(is)e(*not*)i(necessary)f(to)227
-2360 y(insert)c(ro)m(ws)f(in)g(a)h(table)g(b)s(efore)f(writing)g(data)i
+3147 y(insert)c(ro)m(ws)f(in)g(a)h(table)g(b)s(efore)f(writing)g(data)i
 (to)f(those)g(ro)m(ws)f(\(indeed,)g(it)h(w)m(ould)g(b)s(e)e
-(ine\016cien)m(t)j(to)f(do)227 2473 y(so\).)54 b(Instead,)35
+(ine\016cien)m(t)j(to)f(do)227 3260 y(so\).)54 b(Instead,)35
 b(one)g(ma)m(y)g(simply)f(write)h(data)g(to)g(an)m(y)g(ro)m(w)f(of)h
 (the)g(table,)h(whether)e(that)h(ro)m(w)g(of)f(data)227
-2586 y(already)d(exists)g(or)g(not.)382 2844 y Ff
-(FTIROW\(unit,frow,nrows,)41 b(>)48 b(status\))382 2957
+3373 y(already)d(exists)g(or)g(not.)382 3616 y Ff
+(FTIROW\(unit,frow,nrows,)41 b(>)48 b(status\))382 3729
 y(FTIROWLL\(unit,frowll,nro)o(wsl)o(l,)42 b(>)47 b(status\))0
-3215 y Fi(2)81 b Fj(Delete)25 b(ro)m(ws)f(from)f(an)g(existing)i(ASCI)s
+3971 y Fi(2)81 b Fj(Delete)25 b(ro)m(ws)f(from)f(an)g(existing)i(ASCI)s
 (I)c(or)j(binary)f(table)h(\(in)f(the)h(CDU\).)g(The)f(NR)m(O)m(WS)h
-(\(or)g(NR)m(O)m(WSLL\))227 3328 y(is)e(the)g(n)m(um)m(b)s(er)f(of)h
+(\(or)g(NR)m(O)m(WSLL\))227 4084 y(is)e(the)g(n)m(um)m(b)s(er)f(of)h
 (ro)m(ws)g(are)g(deleted,)i(starting)f(with)f(ro)m(w)g(FR)m(O)m(W)h
 (\(or)f(FR)m(O)m(WLL\),)h(and)f(an)m(y)g(remaining)227
-3441 y(ro)m(ws)f(in)g(the)f(table)i(are)f(shifted)g(up)e(to)j(\014ll)f
+4197 y(ro)m(ws)f(in)g(the)f(table)i(are)f(shifted)g(up)e(to)j(\014ll)f
 (in)f(the)h(space.)38 b(These)21 b(routines)f(mo)s(dify)g(the)h(NAXIS2)
-g(k)m(eyw)m(ord)227 3553 y(to)31 b(re\015ect)g(the)g(new)f(n)m(um)m(b)s
-(er)f(of)h(ro)m(ws)h(in)f(the)g(table.)382 3811 y Ff
-(FTDROW\(unit,frow,nrows,)41 b(>)48 b(status\))382 3924
+g(k)m(eyw)m(ord)227 4310 y(to)31 b(re\015ect)g(the)g(new)f(n)m(um)m(b)s
+(er)f(of)h(ro)m(ws)h(in)f(the)g(table.)382 4552 y Ff
+(FTDROW\(unit,frow,nrows,)41 b(>)48 b(status\))382 4665
 y(FTDROWLL\(unit,frowll,nro)o(wsl)o(l,)42 b(>)47 b(status\))0
-4182 y Fi(3)81 b Fj(Delete)26 b(a)f(list)g(of)g(ro)m(ws)f(from)g(an)h
+4907 y Fi(3)81 b Fj(Delete)26 b(a)f(list)g(of)g(ro)m(ws)f(from)g(an)h
 (ASCI)s(I)e(or)h(binary)g(table)h(\(in)g(the)f(CDU\).)i(In)e(the)g
-(\014rst)g(routine,)i('ro)m(wrange')227 4295 y(is)i(a)g(c)m(haracter)h
+(\014rst)g(routine,)i('ro)m(wrange')227 5020 y(is)i(a)g(c)m(haracter)h
 (string)f(listing)h(the)f(ro)m(ws)f(or)h(ro)m(w)g(ranges)g(to)g(delete)
 h(\(e.g.,)i('2-4,)e(5,)g(8-9'\).)42 b(In)27 b(the)h(second)227
-4408 y(routine,)37 b('ro)m(wlist')f(is)f(an)f(in)m(teger)j(arra)m(y)e
+5133 y(routine,)37 b('ro)m(wlist')f(is)f(an)f(in)m(teger)j(arra)m(y)e
 (of)g(ro)m(w)g(n)m(um)m(b)s(ers)e(to)j(b)s(e)e(deleted)i(from)e(the)h
-(table.)56 b(nro)m(ws)34 b(is)227 4521 y(the)e(n)m(um)m(b)s(er)e(of)h
+(table.)56 b(nro)m(ws)34 b(is)227 5246 y(the)e(n)m(um)m(b)s(er)e(of)h
 (ro)m(w)h(n)m(um)m(b)s(ers)e(in)h(the)g(list.)45 b(The)31
 b(\014rst)f(ro)m(w)i(in)f(the)g(table)i(is)e(1)h(not)f(0.)44
-b(The)31 b(list)h(of)g(ro)m(w)227 4634 y(n)m(um)m(b)s(ers)d(m)m(ust)h
-(b)s(e)g(sorted)h(in)f(ascending)g(order.)382 4891 y
-Ff(FTDRRG\(unit,rowrange,)42 b(>)47 b(status\))382 5004
-y(FTDRWS\(unit,rowlist,nrow)o(s,)41 b(>)48 b(status\))0
-5262 y Fi(4)81 b Fj(Insert)43 b(a)i(blank)f(column)h(\(or)f(columns\))h
-(in)m(to)g(an)f(existing)i(ASCI)s(I)d(or)h(binary)g(table)h(\(in)g(the)
-f(CDU\).)227 5375 y(COLNUM)c(sp)s(eci\014es)g(the)h(column)f(n)m(um)m
-(b)s(er)f(that)i(the)f(\(\014rst\))g(new)g(column)g(should)f(o)s(ccup)m
-(y)i(in)f(the)227 5488 y(table.)58 b(NCOLS)34 b(sp)s(eci\014es)h(ho)m
-(w)h(man)m(y)g(columns)f(are)h(to)g(b)s(e)f(inserted.)57
-b(An)m(y)35 b(existing)i(columns)e(from)227 5601 y(this)k(p)s(osition)f
-(and)g(higher)g(are)h(mo)m(v)m(ed)g(o)m(v)m(er)h(to)f(allo)m(w)h(ro)s
-(om)e(for)h(the)f(new)g(column\(s\).)65 b(The)38 b(index)227
-5714 y(n)m(um)m(b)s(er)j(on)h(all)h(the)f(follo)m(wing)h(k)m(eyw)m
-(ords)g(will)f(b)s(e)f(incremen)m(ted)i(if)f(necessary)g(to)h
-(re\015ect)f(the)g(new)p eop end
+b(The)31 b(list)h(of)g(ro)m(w)227 5359 y(n)m(um)m(b)s(ers)d(m)m(ust)h
+(b)s(e)g(sorted)h(in)f(ascending)g(order.)382 5601 y
+Ff(FTDRRG\(unit,rowrange,)42 b(>)47 b(status\))382 5714
+y(FTDRWS\(unit,rowlist,nrow)o(s,)41 b(>)48 b(status\))p
+eop end
 %%Page: 60 66
-TeXDict begin 60 65 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.60) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(60)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)227 555 y Fj(p)s(osition)i(of)f(the)g
-(column\(s\))h(in)f(the)g(table:)43 b(TBCOLn,)30 b(TF)m(ORMn,)i
-(TTYPEn,)e(TUNITn,)h(TNULLn,)227 668 y(TSCALn,)22 b(TZER)m(On,)g
-(TDISPn,)g(TDIMn,)h(TLMINn,)g(TLMAXn,)f(TDMINn,)i(TDMAXn,)f(TCTYPn,)227
-781 y(TCRPXn,)30 b(TCR)-10 b(VLn,)29 b(TCDL)-8 b(Tn,)30
-b(TCR)m(OTn,)f(and)g(TCUNIn.)382 1035 y Ff(FTICOL\(unit,colnum,ttype)o
-(,tf)o(orm,)41 b(>)48 b(status\))382 1148 y(FTICLS\(unit,colnum,ncols)o
-(,tt)o(ype,)o(tfor)o(m,)41 b(>)48 b(status\))0 1403 y
-Fi(5)81 b Fj(Mo)s(dify)37 b(the)g(v)m(ector)i(length)f(of)f(a)h(binary)
-e(table)i(column)f(\(e.g.,)k(c)m(hange)e(a)e(column)g(from)g(TF)m(ORMn)
-g(=)227 1515 y('1E')31 b(to)h('20E'\).)g(The)e(v)m(ector)i(length)e(ma)
-m(y)h(b)s(e)f(increased)h(or)f(decreased)h(from)f(the)g(curren)m(t)h(v)
--5 b(alue.)382 1770 y Ff(FTMVEC\(unit,colnum,newve)o(cle)o(n,)42
-b(>)47 b(status\))0 2024 y Fi(6)81 b Fj(Delete)29 b(a)f(column)g(from)f
+TeXDict begin 60 65 bop 0 299 a Fj(60)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fi(4)81 b Fj(Insert)43 b(a)i(blank)f(column)h
+(\(or)f(columns\))h(in)m(to)g(an)f(existing)i(ASCI)s(I)d(or)h(binary)g
+(table)h(\(in)g(the)f(CDU\).)227 668 y(COLNUM)c(sp)s(eci\014es)g(the)h
+(column)f(n)m(um)m(b)s(er)f(that)i(the)f(\(\014rst\))g(new)g(column)g
+(should)f(o)s(ccup)m(y)i(in)f(the)227 781 y(table.)58
+b(NCOLS)34 b(sp)s(eci\014es)h(ho)m(w)h(man)m(y)g(columns)f(are)h(to)g
+(b)s(e)f(inserted.)57 b(An)m(y)35 b(existing)i(columns)e(from)227
+894 y(this)k(p)s(osition)f(and)g(higher)g(are)h(mo)m(v)m(ed)g(o)m(v)m
+(er)h(to)f(allo)m(w)h(ro)s(om)e(for)h(the)f(new)g(column\(s\).)65
+b(The)38 b(index)227 1007 y(n)m(um)m(b)s(er)j(on)h(all)h(the)f(follo)m
+(wing)h(k)m(eyw)m(ords)g(will)f(b)s(e)f(incremen)m(ted)i(if)f
+(necessary)g(to)h(re\015ect)f(the)g(new)227 1120 y(p)s(osition)32
+b(of)f(the)g(column\(s\))h(in)f(the)g(table:)43 b(TBCOLn,)30
+b(TF)m(ORMn,)i(TTYPEn,)e(TUNITn,)h(TNULLn,)227 1233 y(TSCALn,)22
+b(TZER)m(On,)g(TDISPn,)g(TDIMn,)h(TLMINn,)g(TLMAXn,)f(TDMINn,)i
+(TDMAXn,)f(TCTYPn,)227 1346 y(TCRPXn,)30 b(TCR)-10 b(VLn,)29
+b(TCDL)-8 b(Tn,)30 b(TCR)m(OTn,)f(and)g(TCUNIn.)382 1584
+y Ff(FTICOL\(unit,colnum,ttype)o(,tf)o(orm,)41 b(>)48
+b(status\))382 1697 y(FTICLS\(unit,colnum,ncols)o(,tt)o(ype,)o(tfor)o
+(m,)41 b(>)48 b(status\))0 1935 y Fi(5)81 b Fj(Mo)s(dify)37
+b(the)g(v)m(ector)i(length)f(of)f(a)h(binary)e(table)i(column)f
+(\(e.g.,)k(c)m(hange)e(a)e(column)g(from)g(TF)m(ORMn)g(=)227
+2048 y('1E')31 b(to)h('20E'\).)g(The)e(v)m(ector)i(length)e(ma)m(y)h(b)
+s(e)f(increased)h(or)f(decreased)h(from)f(the)g(curren)m(t)h(v)-5
+b(alue.)382 2287 y Ff(FTMVEC\(unit,colnum,newve)o(cle)o(n,)42
+b(>)47 b(status\))0 2525 y Fi(6)81 b Fj(Delete)29 b(a)f(column)g(from)f
 (an)g(existing)i(ASCI)s(I)d(or)i(binary)e(table)j(\(in)f(the)f(CDU\).)i
-(The)e(index)g(n)m(um)m(b)s(er)f(of)i(all)227 2137 y(the)k(k)m(eyw)m
+(The)e(index)g(n)m(um)m(b)s(er)f(of)i(all)227 2638 y(the)k(k)m(eyw)m
 (ords)h(listed)f(ab)s(o)m(v)m(e)i(\(for)e(FTICOL\))f(will)h(b)s(e)g
 (decremen)m(ted)g(if)g(necessary)h(to)g(re\015ect)f(the)g(new)227
-2250 y(p)s(osition)26 b(of)g(the)g(column\(s\))g(in)f(the)h(table.)40
+2751 y(p)s(osition)26 b(of)g(the)g(column\(s\))g(in)f(the)h(table.)40
 b(Those)26 b(index)f(k)m(eyw)m(ords)h(that)g(refer)f(to)i(the)f
-(deleted)g(column)227 2363 y(will)33 b(also)g(b)s(e)f(deleted.)47
+(deleted)g(column)227 2864 y(will)33 b(also)g(b)s(e)f(deleted.)47
 b(Note)33 b(that)g(the)g(ph)m(ysical)g(size)g(of)f(the)h(FITS)e(\014le)
-i(will)f(not)h(b)s(e)e(reduced)h(b)m(y)g(this)227 2476
+i(will)f(not)h(b)s(e)e(reduced)h(b)m(y)g(this)227 2977
 y(op)s(eration,)e(and)e(the)h(empt)m(y)g(FITS)f(blo)s(c)m(ks)h(if)g(an)
 m(y)g(at)g(the)g(end)f(of)h(the)g(\014le)g(will)g(b)s(e)f(padded)g
-(with)g(zeros.)382 2730 y Ff(FTDCOL\(unit,colnum,)42
-b(>)48 b(status\))0 2984 y Fi(7)81 b Fj(Cop)m(y)30 b(a)g(column)g(from)
+(with)g(zeros.)382 3216 y Ff(FTDCOL\(unit,colnum,)42
+b(>)48 b(status\))0 3454 y Fi(7)81 b Fj(Cop)m(y)30 b(a)g(column)g(from)
 g(one)g(HDU)h(to)g(another)f(\(or)h(to)g(the)f(same)h(HDU\).)g(If)f
-(createcol)j(=)c(TR)m(UE,)i(then)f(a)227 3097 y(new)20
+(createcol)j(=)c(TR)m(UE,)i(then)f(a)227 3567 y(new)20
 b(column)g(will)h(b)s(e)f(inserted)g(in)g(the)h(output)f(table,)k(at)d
 (p)s(osition)f(`outcolumn',)j(otherwise)e(the)g(existing)227
-3210 y(output)29 b(column)f(will)h(b)s(e)f(o)m(v)m(erwritten)i(\(in)f
+3680 y(output)29 b(column)f(will)h(b)s(e)f(o)m(v)m(erwritten)i(\(in)f
 (whic)m(h)f(case)i(it)f(m)m(ust)f(ha)m(v)m(e)i(a)f(compatible)h(datat)m
-(yp)s(e\).)42 b(Note)227 3323 y(that)31 b(the)g(\014rst)e(column)i(in)f
-(a)g(table)i(is)e(at)h(coln)m(um)g(=)f(1.)382 3577 y
+(yp)s(e\).)42 b(Note)227 3793 y(that)31 b(the)g(\014rst)e(column)i(in)f
+(a)g(table)i(is)e(at)h(coln)m(um)g(=)f(1.)382 4031 y
 Ff(FTCPCL\(inunit,outunit,in)o(col)o(num,)o(outc)o(oln)o(um,c)o(reat)o
-(eco)o(l,)42 b(>)47 b(status\);)0 3716 y
-SDict begin H.S end
- 0 3716 a 0 3716
-a
-SDict begin 13.6 H.A end
- 0 3716 a 0 3716 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.6.7.4) cvn /DEST pdfmark
-end
- 0 3716 a 151 x Fc(6.7.4)112 b(Read)38
-b(and)h(W)-9 b(rite)36 b(Column)j(Data)e(Routines)0 4086
-y Fj(These)22 b(subroutines)f(put)h(or)g(get)i(data)f(v)-5
+(eco)o(l,)42 b(>)47 b(status\);)0 4319 y Fc(6.7.4)112
+b(Read)38 b(and)h(W)-9 b(rite)36 b(Column)j(Data)e(Routines)0
+4538 y Fj(These)22 b(subroutines)f(put)h(or)g(get)i(data)f(v)-5
 b(alues)22 b(in)g(the)h(curren)m(t)f(ASCI)s(I)f(or)h(Binary)g(table)i
-(extension.)38 b(Automatic)0 4199 y(data)21 b(t)m(yp)s(e)g(con)m(v)m
+(extension.)38 b(Automatic)0 4650 y(data)21 b(t)m(yp)s(e)g(con)m(v)m
 (ersion)g(is)f(p)s(erformed)f(for)h(n)m(umerical)h(data)g(t)m(yp)s(es)g
 (\(B,I,J,E,D\))h(if)e(the)h(data)g(t)m(yp)s(e)f(of)h(the)f(column)0
-4312 y(\(de\014ned)32 b(b)m(y)i(the)f(TF)m(ORM)h(k)m(eyw)m(ord\))g
+4763 y(\(de\014ned)32 b(b)m(y)i(the)f(TF)m(ORM)h(k)m(eyw)m(ord\))g
 (di\013ers)f(from)f(the)i(data)g(t)m(yp)s(e)f(of)h(the)f(calling)i
-(subroutine.)48 b(The)33 b(data)0 4425 y(v)-5 b(alues)30
+(subroutine.)48 b(The)33 b(data)0 4876 y(v)-5 b(alues)30
 b(are)h(also)g(scaled)f(b)m(y)g(the)g(TSCALn)f(and)g(TZER)m(On)g
 (header)h(v)-5 b(alues)30 b(as)g(they)g(are)h(b)s(eing)e(written)h(to)h
-(or)0 4538 y(read)j(from)f(the)h(FITS)f(arra)m(y)-8 b(.)51
+(or)0 4989 y(read)j(from)f(the)h(FITS)f(arra)m(y)-8 b(.)51
 b(The)33 b(fttscl)i(subroutine)d(MUST)i(b)s(e)f(used)g(to)h(de\014ne)f
-(the)h(scaling)h(parameters)0 4650 y(when)d(writing)h(data)h(to)g(the)f
+(the)h(scaling)h(parameters)0 5102 y(when)d(writing)h(data)h(to)g(the)f
 (table)h(or)f(to)h(o)m(v)m(erride)g(the)g(default)f(scaling)h(v)-5
-b(alues)34 b(giv)m(en)g(in)f(the)g(header)g(when)0 4763
+b(alues)34 b(giv)m(en)g(in)f(the)g(header)g(when)0 5215
 y(reading)27 b(from)g(the)g(table.)40 b(Note)29 b(that)e(it)h(is)f
 (*not*)h(necessary)f(to)h(insert)f(ro)m(ws)g(in)f(a)i(table)g(b)s
-(efore)e(writing)h(data)0 4876 y(to)j(those)h(ro)m(ws)e(\(indeed,)h(it)
+(efore)e(writing)h(data)0 5328 y(to)j(those)h(ro)m(ws)e(\(indeed,)h(it)
 g(w)m(ould)g(b)s(e)f(ine\016cien)m(t)i(to)f(do)g(so\).)41
 b(Instead,)30 b(one)g(ma)m(y)g(simply)f(write)h(data)g(to)h(an)m(y)0
-4989 y(ro)m(w)f(of)h(the)g(table,)g(whether)f(that)h(ro)m(w)f(of)h
-(data)g(already)g(exists)g(or)f(not.)0 5149 y(In)i(the)i(case)g(of)f
+5441 y(ro)m(w)f(of)h(the)g(table,)g(whether)f(that)h(ro)m(w)f(of)h
+(data)g(already)g(exists)g(or)f(not.)0 5601 y(In)i(the)i(case)g(of)f
 (binary)g(tables)h(with)f(v)m(ector)h(elemen)m(ts,)i(the)d('felem')h
-(parameter)g(de\014nes)e(the)i(starting)g(pixel)0 5262
+(parameter)g(de\014nes)e(the)i(starting)g(pixel)0 5714
 y(within)k(the)g(elemen)m(t)i(v)m(ector.)65 b(This)38
 b(parameter)g(is)g(ignored)h(with)e(ASCI)s(I)g(tables.)65
-b(Similarly)-8 b(,)41 b(in)d(the)g(case)0 5375 y(of)45
+b(Similarly)-8 b(,)41 b(in)d(the)g(case)p eop end
+%%Page: 61 67
+TeXDict begin 61 66 bop 0 299 a Fh(6.7.)72 b(FITS)30
+b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31 b(D)m(A)-8
+b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(61)0 555 y(of)45
 b(binary)e(tables)i(the)g('nelemen)m(ts')h(parameter)f(sp)s(eci\014es)f
 (the)g(total)i(n)m(um)m(b)s(er)d(of)i(v)m(ector)h(v)-5
-b(alues)45 b(read)f(or)0 5488 y(written)36 b(\(con)m(tin)m(uing)h(on)f
+b(alues)45 b(read)f(or)0 668 y(written)36 b(\(con)m(tin)m(uing)h(on)f
 (subsequen)m(t)f(ro)m(ws)g(if)h(required\))f(and)h(not)g(the)g(n)m(um)m
-(b)s(er)e(of)i(table)h(elemen)m(ts.)58 b(Tw)m(o)0 5601
+(b)s(er)e(of)i(table)h(elemen)m(ts.)58 b(Tw)m(o)0 781
 y(sets)36 b(of)f(subroutines)g(are)g(pro)m(vided)g(to)i(get)f(the)g
 (column)f(data)h(whic)m(h)f(di\013er)g(in)h(the)f(w)m(a)m(y)i
-(unde\014ned)c(pixels)0 5714 y(are)f(handled.)42 b(The)31
+(unde\014ned)c(pixels)0 894 y(are)f(handled.)42 b(The)31
 b(\014rst)g(set)h(of)f(routines)h(\(FTGCV\))g(simply)f(return)f(an)h
-(arra)m(y)h(of)f(data)h(elemen)m(ts)h(in)e(whic)m(h)p
-eop end
-%%Page: 61 67
-TeXDict begin 61 66 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.61) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.7.)72
-b(FITS)30 b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31
-b(D)m(A)-8 b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(61)0
-555 y(unde\014ned)41 b(pixels)j(are)g(set)g(equal)g(to)h(a)f(v)-5
+(arra)m(y)h(of)f(data)h(elemen)m(ts)h(in)e(whic)m(h)0
+1007 y(unde\014ned)41 b(pixels)j(are)g(set)g(equal)g(to)h(a)f(v)-5
 b(alue)44 b(sp)s(eci\014ed)f(b)m(y)g(the)h(user)f(in)g(the)h('n)m(ullv)
--5 b(al')44 b(parameter.)81 b(An)0 668 y(additional)44
+-5 b(al')44 b(parameter.)81 b(An)0 1120 y(additional)44
 b(feature)g(of)g(these)g(subroutines)e(is)i(that)g(if)f(the)h(user)e
 (sets)i(n)m(ullv)-5 b(al)44 b(=)f(0,)48 b(then)43 b(no)g(c)m(hec)m(ks)i
-(for)0 781 y(unde\014ned)33 b(pixels)j(will)g(b)s(e)e(p)s(erformed,)i
+(for)0 1233 y(unde\014ned)33 b(pixels)j(will)g(b)s(e)e(p)s(erformed,)i
 (th)m(us)f(increasing)h(the)g(sp)s(eed)e(of)i(the)g(program.)55
-b(The)35 b(second)h(set)g(of)0 894 y(routines)h(\(FTGCF\))h(returns)d
+b(The)35 b(second)h(set)g(of)0 1346 y(routines)h(\(FTGCF\))h(returns)d
 (the)i(data)h(elemen)m(t)g(arra)m(y)g(and)e(in)h(addition)g(a)g
-(logical)j(arra)m(y)d(of)g(\015ags)g(whic)m(h)0 1007
+(logical)j(arra)m(y)d(of)g(\015ags)g(whic)m(h)0 1458
 y(de\014nes)29 b(whether)h(the)h(corresp)s(onding)e(data)i(pixel)g(is)f
-(unde\014ned.)0 1167 y(An)m(y)41 b(column,)i(regardless)e(of)g(it's)g
+(unde\014ned.)0 1619 y(An)m(y)41 b(column,)i(regardless)e(of)g(it's)g
 (in)m(trinsic)g(datat)m(yp)s(e,)k(ma)m(y)c(b)s(e)f(read)h(as)g(a)g
-(string.)71 b(It)41 b(should)f(b)s(e)g(noted)0 1280 y(ho)m(w)m(ev)m(er)
+(string.)71 b(It)41 b(should)f(b)s(e)g(noted)0 1732 y(ho)m(w)m(ev)m(er)
 32 b(that)f(reading)f(a)h(n)m(umeric)f(column)g(as)h(a)f(string)h(is)f
 (10)h(-)g(100)g(times)g(slo)m(w)m(er)h(than)e(reading)g(the)h(same)0
-1393 y(column)g(as)h(a)g(n)m(um)m(b)s(er)e(due)h(to)h(the)g(large)h(o)m
+1844 y(column)g(as)h(a)g(n)m(um)m(b)s(er)e(due)h(to)h(the)g(large)h(o)m
 (v)m(erhead)f(in)g(constructing)g(the)g(formatted)g(strings.)44
-b(The)31 b(displa)m(y)0 1506 y(format)26 b(of)g(the)h(returned)d
+b(The)31 b(displa)m(y)0 1957 y(format)26 b(of)g(the)h(returned)d
 (strings)i(will)g(b)s(e)g(determined)f(b)m(y)h(the)g(TDISPn)f(k)m(eyw)m
-(ord,)j(if)d(it)i(exists,)h(otherwise)e(b)m(y)0 1619
+(ord,)j(if)d(it)i(exists,)h(otherwise)e(b)m(y)0 2070
 y(the)i(datat)m(yp)s(e)h(of)g(the)f(column.)40 b(The)28
 b(length)g(of)h(the)f(returned)f(strings)h(can)g(b)s(e)g(determined)g
-(with)f(the)i(ftgcdw)0 1732 y(routine.)41 b(The)30 b(follo)m(wing)h
+(with)f(the)i(ftgcdw)0 2183 y(routine.)41 b(The)30 b(follo)m(wing)h
 (TDISPn)f(displa)m(y)g(formats)h(are)f(curren)m(tly)h(supp)s(orted:)191
-1952 y Ff(Iw.m)142 b(Integer)191 2065 y(Ow.m)g(Octal)46
-b(integer)191 2178 y(Zw.m)142 b(Hexadecimal)45 b(integer)191
-2291 y(Fw.d)142 b(Fixed)46 b(floating)g(point)191 2404
-y(Ew.d)142 b(Exponential)45 b(floating)g(point)191 2517
-y(Dw.d)142 b(Exponential)45 b(floating)g(point)191 2630
+2403 y Ff(Iw.m)142 b(Integer)191 2516 y(Ow.m)g(Octal)46
+b(integer)191 2629 y(Zw.m)142 b(Hexadecimal)45 b(integer)191
+2742 y(Fw.d)142 b(Fixed)46 b(floating)g(point)191 2854
+y(Ew.d)142 b(Exponential)45 b(floating)g(point)191 2967
+y(Dw.d)142 b(Exponential)45 b(floating)g(point)191 3080
 y(Gw.d)142 b(General;)46 b(uses)g(Fw.d)h(if)g(significance)d(not)j
-(lost,)g(else)f(Ew.d)0 2850 y Fj(where)37 b(w)h(is)g(the)g(width)f(in)h
+(lost,)g(else)f(Ew.d)0 3300 y Fj(where)37 b(w)h(is)g(the)g(width)f(in)h
 (c)m(haracters)h(of)f(the)h(displa)m(y)m(ed)f(v)-5 b(alues,)41
 b(m)c(is)h(the)g(minim)m(um)g(n)m(um)m(b)s(er)e(of)i(digits)0
-2963 y(displa)m(y)m(ed,)31 b(and)f(d)g(is)g(the)h(n)m(um)m(b)s(er)e(of)
+3413 y(displa)m(y)m(ed,)31 b(and)f(d)g(is)g(the)h(n)m(um)m(b)s(er)e(of)
 h(digits)h(to)g(the)g(righ)m(t)g(of)g(the)f(decimal.)42
-b(The)30 b(.m)g(\014eld)g(is)g(optional.)0 3184 y Fi(1)81
+b(The)30 b(.m)g(\014eld)g(is)g(optional.)0 3632 y Fi(1)81
 b Fj(Put)30 b(elemen)m(ts)i(in)m(to)g(an)e(ASCI)s(I)f(or)i(binary)f
 (table)i(column)e(\(in)h(the)g(CDU\).)g(\(The)g(SPP)f(FSPCLS)f(routine)
-227 3297 y(has)38 b(an)f(additional)i(in)m(teger)g(argumen)m(t)f(after)
+227 3745 y(has)38 b(an)f(additional)i(in)m(teger)g(argumen)m(t)f(after)
 h(the)f(V)-10 b(ALUES)37 b(c)m(haracter)i(string)f(whic)m(h)f(sp)s
-(eci\014es)h(the)227 3410 y(size)31 b(of)g(the)g(1st)g(dimension)e(of)i
-(this)f(2-D)i(CHAR)e(arra)m(y\).)227 3553 y(The)24 b(alternate)i(v)m
+(eci\014es)h(the)227 3858 y(size)31 b(of)g(the)g(1st)g(dimension)e(of)i
+(this)f(2-D)i(CHAR)e(arra)m(y\).)227 4002 y(The)24 b(alternate)i(v)m
 (ersion)f(of)g(these)g(routines,)h(whose)e(names)g(end)g(in)g('LL')h
-(after)g(the)g(datat)m(yp)s(e)g(c)m(haracter,)227 3666
+(after)g(the)g(datat)m(yp)s(e)g(c)m(haracter,)227 4115
 y(supp)s(ort)34 b(large)j(tables)f(with)g(more)f(then)h(2*31)h(ro)m
 (ws.)57 b(When)35 b(calling)i(these)f(routines,)h(the)f(fro)m(w)g(and)
-227 3779 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s(e)f(64-bit)h(in)m
+227 4228 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s(e)f(64-bit)h(in)m
 (teger*8)i(v)-5 b(ariables,)31 b(instead)g(of)g(normal)f(4-b)m(yte)i
-(in)m(tegers.)382 4000 y Ff(FTPCL[SLBIJKEDCM]\(unit,c)o(oln)o(um,f)o
+(in)m(tegers.)382 4447 y Ff(FTPCL[SLBIJKEDCM]\(unit,c)o(oln)o(um,f)o
 (row,)o(fel)o(em,n)o(elem)o(ent)o(s,va)o(lues)o(,)42
-b(>)47 b(status\))382 4113 y(FTPCL[LBIJKEDCM]LL\(unit,)o(col)o(num,)o
+b(>)47 b(status\))382 4560 y(FTPCL[LBIJKEDCM]LL\(unit,)o(col)o(num,)o
 (frow)o(,fe)o(lem,)o(nele)o(men)o(ts,v)o(alue)o(s,)41
-b(>)48 b(status\))0 4333 y Fi(2)81 b Fj(Put)29 b(elemen)m(ts)i(in)m(to)
+b(>)48 b(status\))0 4780 y Fi(2)81 b Fj(Put)29 b(elemen)m(ts)i(in)m(to)
 g(an)f(ASCI)s(I)e(or)i(binary)f(table)i(column)e(\(in)h(the)g(CDU\))g
-(substituting)g(the)g(appropriate)227 4446 y(FITS)c(n)m(ull)g(v)-5
+(substituting)g(the)g(appropriate)227 4893 y(FITS)c(n)m(ull)g(v)-5
 b(alue)26 b(for)g(an)m(y)h(elemen)m(ts)g(that)g(are)f(equal)h(to)g
 (NULL)-10 b(V)g(AL.)26 b(F)-8 b(or)27 b(ASCI)s(I)e(T)-8
-b(ABLE)26 b(extensions,)227 4559 y(the)31 b(n)m(ull)f(v)-5
+b(ABLE)26 b(extensions,)227 5006 y(the)31 b(n)m(ull)f(v)-5
 b(alue)31 b(de\014ned)e(b)m(y)h(the)g(previous)g(call)i(to)f(FTSNUL)f
 (will)g(b)s(e)g(substituted;)g(F)-8 b(or)31 b(in)m(teger)h(FITS)227
-4672 y(columns,)39 b(in)e(a)h(binary)f(table)h(the)f(n)m(ull)h(v)-5
+5119 y(columns,)39 b(in)e(a)h(binary)f(table)h(the)f(n)m(ull)h(v)-5
 b(alue)37 b(de\014ned)g(b)m(y)g(the)g(previous)g(call)i(to)f(FTTNUL)f
-(will)h(b)s(e)227 4785 y(substituted;)28 b(F)-8 b(or)28
+(will)h(b)s(e)227 5232 y(substituted;)28 b(F)-8 b(or)28
 b(\015oating)h(p)s(oin)m(t)e(FITS)f(columns)h(a)h(sp)s(ecial)g(IEEE)f
 (NaN)h(\(Not-a-Num)m(b)s(er\))h(v)-5 b(alue)28 b(will)227
-4898 y(b)s(e)i(substituted.)227 5042 y(The)24 b(alternate)i(v)m(ersion)
+5344 y(b)s(e)i(substituted.)227 5488 y(The)24 b(alternate)i(v)m(ersion)
 f(of)g(these)g(routines,)h(whose)e(names)g(end)g(in)g('LL')h(after)g
-(the)g(datat)m(yp)s(e)g(c)m(haracter,)227 5155 y(supp)s(ort)34
+(the)g(datat)m(yp)s(e)g(c)m(haracter,)227 5601 y(supp)s(ort)34
 b(large)j(tables)f(with)g(more)f(then)h(2*31)h(ro)m(ws.)57
 b(When)35 b(calling)i(these)f(routines,)h(the)f(fro)m(w)g(and)227
-5267 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s(e)f(64-bit)h(in)m
+5714 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s(e)f(64-bit)h(in)m
 (teger*8)i(v)-5 b(ariables,)31 b(instead)g(of)g(normal)f(4-b)m(yte)i
-(in)m(tegers.)382 5488 y Ff(FTPCN[SBIJKED]\(unit,coln)o(um,)o(frow)o
+(in)m(tegers.)p eop end
+%%Page: 62 68
+TeXDict begin 62 67 bop 0 299 a Fj(62)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTPCN[SBIJKED]\(unit,coln)o(um,)o(frow)o
 (,fel)o(em,)o(nele)o(ment)o(s,v)o(alue)o(s,nu)o(llv)o(al)42
-b(>)47 b(status\))382 5601 y(FTPCN[SBIJKED]LL\(unit,co)o(lnu)o(m,\(I)o
+b(>)47 b(status\))382 668 y(FTPCN[SBIJKED]LL\(unit,co)o(lnu)o(m,\(I)o
 (*8\))41 b(frow,\(I*8\))k(felem,nelements,values,)764
-5714 y(nullval)g(>)j(status\))p eop end
-%%Page: 62 68
-TeXDict begin 62 67 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.62) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(62)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fi(3)81 b Fj(Put)37
+781 y(nullval)g(>)j(status\))0 1009 y Fi(3)81 b Fj(Put)37
 b(bit)h(v)-5 b(alues)38 b(in)m(to)h(a)f(binary)f(b)m(yte)h(\('B'\))i
 (or)d(bit)h(\('X'\))h(table)g(column)f(\(in)f(the)h(CDU\).)h(LRA)-8
-b(Y)38 b(is)g(an)227 668 y(arra)m(y)c(of)g(logical)h(v)-5
+b(Y)38 b(is)g(an)227 1122 y(arra)m(y)c(of)g(logical)h(v)-5
 b(alues)34 b(corresp)s(onding)e(to)i(the)g(sequence)f(of)h(bits)f(to)h
 (b)s(e)f(written.)49 b(If)33 b(LRA)-8 b(Y)34 b(is)f(true)227
-781 y(then)f(the)g(corresp)s(onding)f(bit)h(is)g(set)g(to)h(1,)g
+1235 y(then)f(the)g(corresp)s(onding)f(bit)h(is)g(set)g(to)h(1,)g
 (otherwise)f(the)g(bit)g(is)g(set)h(to)g(0.)45 b(Note)34
-b(that)e(in)g(the)g(case)h(of)227 894 y('X')g(columns,)g(FITSIO)e(will)
-i(write)f(to)h(all)g(8)g(bits)f(of)g(eac)m(h)i(b)m(yte)f(whether)e
-(they)i(are)g(formally)f(v)-5 b(alid)33 b(or)227 1007
+b(that)e(in)g(the)g(case)h(of)227 1348 y('X')g(columns,)g(FITSIO)e
+(will)i(write)f(to)h(all)g(8)g(bits)f(of)g(eac)m(h)i(b)m(yte)f(whether)
+e(they)i(are)g(formally)f(v)-5 b(alid)33 b(or)227 1460
 y(not.)46 b(Th)m(us)31 b(if)h(the)g(column)g(is)f(de\014ned)g(as)h
 ('4X',)i(and)d(one)h(calls)h(FTPCLX)f(with)f(fbit=1)h(and)f(n)m(bit=8,)
-227 1120 y(then)j(all)h(8)f(bits)g(will)g(b)s(e)f(written)h(in)m(to)h
+227 1573 y(then)j(all)h(8)f(bits)g(will)g(b)s(e)f(written)h(in)m(to)h
 (the)f(\014rst)g(b)m(yte)g(\(as)h(opp)s(osed)e(to)i(writing)e(the)i
-(\014rst)e(4)h(bits)g(in)m(to)227 1233 y(the)d(\014rst)f(ro)m(w)g(and)g
+(\014rst)e(4)h(bits)g(in)m(to)227 1686 y(the)d(\014rst)f(ro)m(w)g(and)g
 (then)g(the)h(next)f(4)h(bits)f(in)m(to)i(the)e(next)h(ro)m(w\),)g(ev)m
 (en)g(though)f(the)h(last)g(4)g(bits)f(of)h(eac)m(h)227
-1346 y(b)m(yte)g(are)g(formally)g(not)g(de\014ned.)382
-1604 y Ff(FTPCLX\(unit,colnum,frow,)o(fbi)o(t,nb)o(it,l)o(ray)o(,)42
-b(>)47 b(status\))0 1863 y Fi(4)81 b Fj(Set)30 b(table)h(elemen)m(ts)h
-(in)e(a)h(column)f(as)h(unde\014ned)382 2121 y Ff
+1799 y(b)m(yte)g(are)g(formally)g(not)g(de\014ned.)382
+2027 y Ff(FTPCLX\(unit,colnum,frow,)o(fbi)o(t,nb)o(it,l)o(ray)o(,)42
+b(>)47 b(status\))0 2255 y Fi(4)81 b Fj(Set)30 b(table)h(elemen)m(ts)h
+(in)e(a)h(column)f(as)h(unde\014ned)382 2482 y Ff
 (FTPCLU\(unit,colnum,frow,)o(fel)o(em,n)o(elem)o(ent)o(s,)42
-b(>)47 b(status\))0 2380 y Fi(5)81 b Fj(Get)34 b(elemen)m(ts)g(from)f
+b(>)47 b(status\))0 2710 y Fi(5)81 b Fj(Get)34 b(elemen)m(ts)g(from)f
 (an)g(ASCI)s(I)f(or)h(binary)g(table)h(column)f(\(in)g(the)g(CDU\).)i
-(These)e(routines)g(return)f(the)227 2493 y(v)-5 b(alues)30
+(These)e(routines)g(return)f(the)227 2823 y(v)-5 b(alues)30
 b(of)g(the)g(table)h(column)f(arra)m(y)g(elemen)m(ts.)42
 b(Unde\014ned)28 b(arra)m(y)j(elemen)m(ts)g(will)f(b)s(e)f(returned)g
-(with)h(a)227 2606 y(v)-5 b(alue)26 b(=)g(n)m(ullv)-5
+(with)h(a)227 2936 y(v)-5 b(alue)26 b(=)g(n)m(ullv)-5
 b(al,)27 b(unless)e(n)m(ullv)-5 b(al)26 b(=)f(0)h(\(or)g(=)f(')h(')g
 (for)f(ftgcvs\))i(in)e(whic)m(h)g(case)i(no)e(c)m(hec)m(king)j(for)d
-(unde\014ned)227 2719 y(v)-5 b(alues)28 b(will)g(b)s(e)f(p)s(erformed.)
+(unde\014ned)227 3049 y(v)-5 b(alues)28 b(will)g(b)s(e)f(p)s(erformed.)
 39 b(The)27 b(ANYF)h(parameter)g(is)g(set)g(to)g(true)g(if)g(an)m(y)f
-(of)h(the)g(returned)f(elemen)m(ts)227 2831 y(are)f(unde\014ned.)37
+(of)h(the)g(returned)f(elemen)m(ts)227 3162 y(are)f(unde\014ned.)37
 b(\(Note:)i(the)26 b(ftgcl)g(routine)f(simple)g(gets)h(an)g(arra)m(y)f
 (of)g(logical)j(data)e(v)-5 b(alues)25 b(without)h(an)m(y)227
-2944 y(c)m(hec)m(ks)39 b(for)e(unde\014ned)e(v)-5 b(alues;)41
+3275 y(c)m(hec)m(ks)39 b(for)e(unde\014ned)e(v)-5 b(alues;)41
 b(use)c(the)g(ftgc\015)h(routine)f(to)h(c)m(hec)m(k)g(for)f
-(unde\014ned)e(logical)40 b(elemen)m(ts\).)227 3057 y(\(The)29
+(unde\014ned)e(logical)40 b(elemen)m(ts\).)227 3388 y(\(The)29
 b(SPP)f(FSGCVS)g(routine)g(has)h(an)f(additional)i(in)m(teger)g
 (argumen)m(t)f(after)g(the)g(V)-10 b(ALUES)28 b(c)m(haracter)227
-3170 y(string)j(whic)m(h)f(sp)s(eci\014es)g(the)g(size)i(of)e(the)h
+3501 y(string)j(whic)m(h)f(sp)s(eci\014es)g(the)g(size)i(of)e(the)h
 (1st)g(dimension)e(of)i(this)f(2-D)i(CHAR)e(arra)m(y\).)227
-3320 y(The)24 b(alternate)i(v)m(ersion)f(of)g(these)g(routines,)h
+3646 y(The)24 b(alternate)i(v)m(ersion)f(of)g(these)g(routines,)h
 (whose)e(names)g(end)g(in)g('LL')h(after)g(the)g(datat)m(yp)s(e)g(c)m
-(haracter,)227 3433 y(supp)s(ort)34 b(large)j(tables)f(with)g(more)f
+(haracter,)227 3758 y(supp)s(ort)34 b(large)j(tables)f(with)g(more)f
 (then)h(2*31)h(ro)m(ws.)57 b(When)35 b(calling)i(these)f(routines,)h
-(the)f(fro)m(w)g(and)227 3546 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s
+(the)f(fro)m(w)g(and)227 3871 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s
 (e)f(64-bit)h(in)m(teger*8)i(v)-5 b(ariables,)31 b(instead)g(of)g
-(normal)f(4-b)m(yte)i(in)m(tegers.)382 3805 y Ff
+(normal)f(4-b)m(yte)i(in)m(tegers.)382 4099 y Ff
 (FTGCL\(unit,colnum,frow,f)o(ele)o(m,ne)o(leme)o(nts)o(,)42
-b(>)47 b(values,status\))382 3918 y(FTGCV[SBIJKEDCM]\(unit,co)o(lnu)o
+b(>)47 b(values,status\))382 4212 y(FTGCV[SBIJKEDCM]\(unit,co)o(lnu)o
 (m,fr)o(ow,f)o(ele)o(m,ne)o(leme)o(nts)o(,nul)o(lval)o(,)42
-b(>)1098 4030 y(values,anyf,status\))382 4143 y
+b(>)1098 4325 y(values,anyf,status\))382 4438 y
 (FTGCV[BIJKEDCM]LL\(unit,c)o(oln)o(um,\()o(I*8\))f(frow,)46
-b(\(I*8\))h(felem,)f(nelements,)716 4256 y(nullval,)f(>)j
-(values,anyf,status\))0 4515 y Fi(6)81 b Fj(Get)44 b(elemen)m(ts)h(and)
+b(\(I*8\))h(felem,)f(nelements,)716 4551 y(nullval,)f(>)j
+(values,anyf,status\))0 4779 y Fi(6)81 b Fj(Get)44 b(elemen)m(ts)h(and)
 d(n)m(ull)i(\015ags)f(from)g(an)h(ASCI)s(I)d(or)j(binary)e(table)j
-(column)e(\(in)g(the)h(CHDU\).)g(These)227 4628 y(routines)29
+(column)e(\(in)g(the)h(CHDU\).)g(These)227 4891 y(routines)29
 b(return)e(the)i(v)-5 b(alues)29 b(of)g(the)g(table)h(column)e(arra)m
 (y)i(elemen)m(ts.)41 b(An)m(y)29 b(unde\014ned)d(arra)m(y)k(elemen)m
-(ts)227 4741 y(will)37 b(ha)m(v)m(e)h(the)f(corresp)s(onding)f(\015agv)
+(ts)227 5004 y(will)37 b(ha)m(v)m(e)h(the)f(corresp)s(onding)f(\015agv)
 -5 b(als)37 b(elemen)m(t)i(set)e(equal)g(to)h(.TR)m(UE.)f(The)f(ANYF)i
-(parameter)f(is)227 4854 y(set)30 b(to)g(true)g(if)f(an)m(y)h(of)f(the)
+(parameter)f(is)227 5117 y(set)30 b(to)g(true)g(if)f(an)m(y)h(of)f(the)
 h(returned)e(elemen)m(ts)j(are)f(unde\014ned.)38 b(\(The)29
-b(SPP)f(FSGCFS)h(routine)h(has)f(an)227 4967 y(additional)e(in)m(teger)
+b(SPP)f(FSGCFS)h(routine)h(has)f(an)227 5230 y(additional)e(in)m(teger)
 h(argumen)m(t)e(after)h(the)f(V)-10 b(ALUES)26 b(c)m(haracter)i(string)
 e(whic)m(h)f(sp)s(eci\014es)h(the)h(size)f(of)h(the)227
-5079 y(1st)k(dimension)f(of)h(this)f(2-D)h(CHAR)g(arra)m(y\).)227
-5229 y(The)24 b(alternate)i(v)m(ersion)f(of)g(these)g(routines,)h
+5343 y(1st)k(dimension)f(of)h(this)f(2-D)h(CHAR)g(arra)m(y\).)227
+5488 y(The)24 b(alternate)i(v)m(ersion)f(of)g(these)g(routines,)h
 (whose)e(names)g(end)g(in)g('LL')h(after)g(the)g(datat)m(yp)s(e)g(c)m
-(haracter,)227 5342 y(supp)s(ort)34 b(large)j(tables)f(with)g(more)f
+(haracter,)227 5601 y(supp)s(ort)34 b(large)j(tables)f(with)g(more)f
 (then)h(2*31)h(ro)m(ws.)57 b(When)35 b(calling)i(these)f(routines,)h
-(the)f(fro)m(w)g(and)227 5455 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s
+(the)f(fro)m(w)g(and)227 5714 y(felem)31 b(parameters)g(*m)m(ust*)g(b)s
 (e)f(64-bit)h(in)m(teger*8)i(v)-5 b(ariables,)31 b(instead)g(of)g
-(normal)f(4-b)m(yte)i(in)m(tegers.)382 5714 y Ff
-(FTGCF[SLBIJKEDCM]\(unit,c)o(oln)o(um,f)o(row,)o(fel)o(em,n)o(elem)o
-(ent)o(s,)42 b(>)p eop end
+(normal)f(4-b)m(yte)i(in)m(tegers.)p eop end
 %%Page: 63 69
-TeXDict begin 63 68 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.63) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.7.)72
-b(FITS)30 b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31
-b(D)m(A)-8 b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(63)1193
-555 y Ff(values,flagvals,anyf,stat)o(us\))382 668 y
-(FTGCF[BIJKED]LL\(unit,col)o(num)o(,)42 b(\(I*8\))k(frow,)h(\(I*8\))f
-(felem,nelements,)d(>)1193 781 y(values,flagvals,anyf,stat)o(us\))0
-1034 y Fi(7)81 b Fj(Get)29 b(an)f(arbitrary)g(data)h(subsection)f(from)
+TeXDict begin 63 68 bop 0 299 a Fh(6.7.)72 b(FITS)30
+b(ASCI)s(I)f(AND)i(BINAR)-8 b(Y)31 b(T)-8 b(ABLE)31 b(D)m(A)-8
+b(T)g(A)32 b(I/O)e(SUBR)m(OUTINES)979 b Fj(63)382 555
+y Ff(FTGCF[SLBIJKEDCM]\(unit,c)o(oln)o(um,f)o(row,)o(fel)o(em,n)o(elem)
+o(ent)o(s,)42 b(>)1193 668 y(values,flagvals,anyf,stat)o(us\))382
+781 y(FTGCF[BIJKED]LL\(unit,col)o(num)o(,)g(\(I*8\))k(frow,)h(\(I*8\))f
+(felem,nelements,)d(>)1193 894 y(values,flagvals,anyf,stat)o(us\))0
+1131 y Fi(7)81 b Fj(Get)29 b(an)f(arbitrary)g(data)h(subsection)f(from)
 g(an)g(N-dimensional)h(arra)m(y)g(in)f(a)g(binary)g(table)h(v)m(ector)h
-(column.)227 1147 y(Unde\014ned)k(pixels)h(in)g(the)h(arra)m(y)g(will)f
+(column.)227 1244 y(Unde\014ned)k(pixels)h(in)g(the)h(arra)m(y)g(will)f
 (b)s(e)g(set)h(equal)f(to)h(the)g(v)-5 b(alue)36 b(of)f('n)m(ullv)-5
-b(al',)38 b(unless)c(n)m(ullv)-5 b(al=0)36 b(in)227 1260
+b(al',)38 b(unless)c(n)m(ullv)-5 b(al=0)36 b(in)227 1357
 y(whic)m(h)d(case)i(no)e(testing)i(for)e(unde\014ned)e(pixels)j(will)f
 (b)s(e)g(p)s(erformed.)49 b(The)32 b(\014rst)h(and)g(last)h(ro)m(ws)g
-(in)f(the)227 1373 y(table)28 b(to)f(b)s(e)f(read)g(are)h(sp)s
+(in)f(the)227 1470 y(table)28 b(to)f(b)s(e)f(read)g(are)h(sp)s
 (eci\014ed)e(b)m(y)i(fpixels\(naxis+1\))g(and)f(lpixels\(naxis+1\),)j
-(and)d(hence)g(are)h(treated)227 1486 y(as)f(the)f(next)h(higher)f
+(and)d(hence)g(are)h(treated)227 1582 y(as)f(the)f(next)h(higher)f
 (dimension)g(of)g(the)h(FITS)e(N-dimensional)i(arra)m(y)-8
 b(.)40 b(The)25 b(INCS)f(parameter)i(sp)s(eci\014es)227
-1599 y(the)31 b(sampling)f(in)m(terv)-5 b(al)32 b(in)e(eac)m(h)h
+1695 y(the)31 b(sampling)f(in)m(terv)-5 b(al)32 b(in)e(eac)m(h)h
 (dimension)f(b)s(et)m(w)m(een)h(the)g(data)g(elemen)m(ts)g(that)g(will)
-g(b)s(e)f(returned.)382 1852 y Ff(FTGSV[BIJKED]\(unit,colnu)o(m,n)o
+g(b)s(e)f(returned.)382 1932 y Ff(FTGSV[BIJKED]\(unit,colnu)o(m,n)o
 (axis)o(,nax)o(es,)o(fpix)o(els,)o(lpi)o(xels)o(,inc)o(s,n)o(ullv)o
-(al,)41 b(>)1002 1965 y(array,anyf,status\))0 2218 y
+(al,)41 b(>)1002 2045 y(array,anyf,status\))0 2282 y
 Fi(8)81 b Fj(Get)29 b(an)f(arbitrary)g(data)h(subsection)f(from)g(an)g
 (N-dimensional)h(arra)m(y)g(in)f(a)g(binary)g(table)h(v)m(ector)h
-(column.)227 2331 y(An)m(y)39 b(Unde\014ned)e(pixels)i(in)g(the)g(arra)
+(column.)227 2395 y(An)m(y)39 b(Unde\014ned)e(pixels)i(in)g(the)g(arra)
 m(y)g(will)g(ha)m(v)m(e)h(the)f(corresp)s(onding)f('\015agv)-5
-b(als')40 b(elemen)m(t)g(set)f(equal)227 2443 y(to)d(.TR)m(UE.)f(The)f
+b(als')40 b(elemen)m(t)g(set)f(equal)227 2508 y(to)d(.TR)m(UE.)f(The)f
 (\014rst)g(and)g(last)i(ro)m(ws)f(in)f(the)h(table)h(to)f(b)s(e)g(read)
 f(are)h(sp)s(eci\014ed)f(b)m(y)h(fpixels\(naxis+1\))227
-2556 y(and)k(lpixels\(naxis+1\),)k(and)38 b(hence)i(are)f(treated)i(as)
+2621 y(and)k(lpixels\(naxis+1\),)k(and)38 b(hence)i(are)f(treated)i(as)
 e(the)g(next)h(higher)f(dimension)f(of)i(the)f(FITS)g(N-)227
-2669 y(dimensional)g(arra)m(y)-8 b(.)66 b(The)38 b(INCS)g(parameter)h
+2734 y(dimensional)g(arra)m(y)-8 b(.)66 b(The)38 b(INCS)g(parameter)h
 (sp)s(eci\014es)f(the)g(sampling)h(in)m(terv)-5 b(al)40
-b(in)e(eac)m(h)i(dimension)227 2782 y(b)s(et)m(w)m(een)31
+b(in)e(eac)m(h)i(dimension)227 2847 y(b)s(et)m(w)m(een)31
 b(the)g(data)g(elemen)m(ts)h(that)f(will)f(b)s(e)g(returned.)382
-3035 y Ff(FTGSF[BIJKED]\(unit,colnu)o(m,n)o(axis)o(,nax)o(es,)o(fpix)o
-(els,)o(lpi)o(xels)o(,inc)o(s,)41 b(>)1002 3148 y
-(array,flagvals,anyf,statu)o(s\))0 3401 y Fi(9)81 b Fj(Get)33
+3084 y Ff(FTGSF[BIJKED]\(unit,colnu)o(m,n)o(axis)o(,nax)o(es,)o(fpix)o
+(els,)o(lpi)o(xels)o(,inc)o(s,)41 b(>)1002 3197 y
+(array,flagvals,anyf,statu)o(s\))0 3433 y Fi(9)81 b Fj(Get)33
 b(bit)g(v)-5 b(alues)34 b(from)e(a)h(b)m(yte)h(\('B'\))g(or)f(bit)g
 (\(`X`\))h(table)g(column)f(\(in)g(the)g(CDU\).)g(LRA)-8
-b(Y)34 b(is)f(an)f(arra)m(y)i(of)227 3514 y(logical)41
+b(Y)34 b(is)f(an)f(arra)m(y)i(of)227 3546 y(logical)41
 b(v)-5 b(alues)39 b(corresp)s(onding)f(to)h(the)g(sequence)f(of)h(bits)
 g(to)g(b)s(e)f(read.)65 b(If)38 b(LRA)-8 b(Y)39 b(is)f(true)h(then)f
-(the)227 3627 y(corresp)s(onding)c(bit)g(w)m(as)g(set)h(to)g(1,)h
+(the)227 3659 y(corresp)s(onding)c(bit)g(w)m(as)g(set)h(to)g(1,)h
 (otherwise)f(the)f(bit)h(w)m(as)f(set)h(to)g(0.)53 b(Note)35
-b(that)g(in)f(the)h(case)g(of)f('X')227 3740 y(columns,)41
+b(that)g(in)f(the)h(case)g(of)f('X')227 3772 y(columns,)41
 b(FITSIO)d(will)h(read)f(all)i(8)f(bits)g(of)g(eac)m(h)h(b)m(yte)f
 (whether)f(they)h(are)g(formally)h(v)-5 b(alid)39 b(or)f(not.)227
-3853 y(Th)m(us)c(if)g(the)h(column)f(is)g(de\014ned)f(as)i('4X',)h(and)
+3885 y(Th)m(us)c(if)g(the)h(column)f(is)g(de\014ned)f(as)i('4X',)h(and)
 d(one)i(calls)h(FTGCX)e(with)g(fbit=1)h(and)e(n)m(bit=8,)j(then)227
-3966 y(all)30 b(8)g(bits)f(will)g(b)s(e)g(read)g(from)g(the)g(\014rst)f
+3998 y(all)30 b(8)g(bits)f(will)g(b)s(e)g(read)g(from)g(the)g(\014rst)f
 (b)m(yte)i(\(as)g(opp)s(osed)e(to)i(reading)f(the)h(\014rst)e(4)i(bits)
-f(from)f(the)i(\014rst)227 4079 y(ro)m(w)g(and)e(then)h(the)h(\014rst)e
+f(from)f(the)i(\014rst)227 4111 y(ro)m(w)g(and)e(then)h(the)h(\014rst)e
 (4)i(bits)f(from)g(the)g(next)g(ro)m(w\),)i(ev)m(en)f(though)f(the)g
-(last)h(4)g(bits)f(of)g(eac)m(h)i(b)m(yte)f(are)227 4192
-y(formally)h(not)g(de\014ned.)382 4445 y Ff(FTGCX\(unit,colnum,frow,f)o
+(last)h(4)g(bits)f(of)g(eac)m(h)i(b)m(yte)f(are)227 4224
+y(formally)h(not)g(de\014ned.)382 4461 y Ff(FTGCX\(unit,colnum,frow,f)o
 (bit)o(,nbi)o(t,)42 b(>)47 b(lray,status\))0 4698 y Fi(10)f
 Fj(Read)31 b(an)m(y)g(consecutiv)m(e)h(set)f(of)g(bits)g(from)f(an)g
 ('X')i(or)e('B')i(column)e(and)g(in)m(terpret)h(them)g(as)g(an)f
 (unsigned)227 4811 y(n-bit)k(in)m(teger.)54 b(NBIT)35
 b(m)m(ust)f(b)s(e)f(less)i(than)f(or)g(equal)h(to)g(16)g(when)f
 (calling)h(FTGCXI,)g(and)f(less)g(than)227 4924 y(or)e(equal)g(to)g(32)
 g(when)e(calling)j(FTGCXJ;)f(there)f(is)h(no)f(limit)h(on)g(the)f(v)-5
@@ -11874,30 +9402,18 @@
 m(W.)h(Note)g(that)g(the)227 5601 y(n)m(um)m(b)s(ering)27
 b(con)m(v)m(en)m(tion)j(used)d(here)g(for)h(the)g(FBIT)f(parameter)i
 (adopts)e(1)h(for)g(the)g(\014rst)f(elemen)m(t)i(of)f(the)227
 5714 y(v)m(ector)k(of)f(bits;)f(this)h(is)f(the)h(Most)g(Signi\014can)m
 (t)g(Bit)g(of)g(the)f(in)m(teger)i(v)-5 b(alue.)p eop
 end
 %%Page: 64 70
-TeXDict begin 64 69 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.64) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(64)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTGCX[IJD]\(unit,colnum,f)o
-(row)o(,nro)o(ws,f)o(bit)o(,nbi)o(t,)42 b(>)47 b(array,status\))0
+TeXDict begin 64 69 bop 0 299 a Fj(64)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTGCX[IJD]\(unit,colnum,f)o(row)o(,nro)o
+(ws,f)o(bit)o(,nbi)o(t,)42 b(>)47 b(array,status\))0
 788 y Fi(11)f Fj(Get)37 b(the)e(descriptor)h(for)f(a)h(v)-5
 b(ariable)37 b(length)f(column)f(in)g(a)h(binary)f(table.)57
 b(The)35 b(descriptor)h(consists)g(of)227 901 y(2)c(in)m(teger)g
 (parameters:)42 b(the)31 b(n)m(um)m(b)s(er)f(of)h(elemen)m(ts)i(in)d
 (the)h(arra)m(y)h(and)e(the)h(starting)h(o\013set)g(relativ)m(e)h(to)
 227 1014 y(the)28 b(start)f(of)g(the)h(heap.)39 b(The)27
 b(\014rst)f(routine)h(returns)f(a)h(single)h(descriptor)f(whereas)g
@@ -11914,32 +9430,25 @@
 b(These)32 b(subroutines)e(can)j(b)s(e)227 2157 y(used)f(in)h
 (conjunction)g(with)g(FTGDES)g(to)g(enable)h(2)f(or)g(more)g(arra)m(ys)
 h(to)f(p)s(oin)m(t)g(to)h(the)f(same)g(storage)227 2270
 y(lo)s(cation)f(to)f(sa)m(v)m(e)h(storage)g(space)f(if)f(the)h(arra)m
 (ys)g(are)g(iden)m(tical.)382 2503 y Ff(FTPDES\(unit,colnum,rownu)o
 (m,n)o(elem)o(ents)o(,of)o(fset)o(,)42 b(>)47 b(status\))382
 2615 y(FTPDESLL\(unit,colnum,row)o(num)o(,nel)o(emen)o(tsl)o(l,of)o
-(fset)o(ll,)41 b(>)48 b(status\))0 2761 y
-SDict begin H.S end
- 0 2761 a 0
-2761 a
-SDict begin 13.6 H.A end
- 0 2761 a 0 2761 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.8) cvn /DEST pdfmark
-end
- 0 2761 a 184 x Fe(6.8)135 b(Ro)l(w)46
-b(Selection)g(and)f(Calculator)h(Routines)0 3195 y Fj(These)21
-b(routines)f(all)i(parse)f(and)f(ev)-5 b(aluate)23 b(an)d(input)g
-(string)h(con)m(taining)i(a)e(user)f(de\014ned)g(arithmetic)i
-(expression.)0 3308 y(The)29 b(\014rst)f(3)i(routines)f(select)i(ro)m
-(ws)e(in)g(a)h(FITS)e(table,)j(based)e(on)g(whether)g(the)g(expression)
-g(ev)-5 b(aluates)31 b(to)f(true)0 3421 y(\(not)e(equal)f(to)h(zero\))g
-(or)f(false)h(\(zero\).)41 b(The)27 b(other)g(routines)g(ev)-5
-b(aluate)29 b(the)e(expression)g(and)f(calculate)k(a)d(v)-5
-b(alue)0 3534 y(for)35 b(eac)m(h)h(ro)m(w)g(of)f(the)h(table.)56
+(fset)o(ll,)41 b(>)48 b(status\))0 2945 y Fe(6.8)135
+b(Ro)l(w)46 b(Selection)g(and)f(Calculator)h(Routines)0
+3195 y Fj(These)21 b(routines)f(all)i(parse)f(and)f(ev)-5
+b(aluate)23 b(an)d(input)g(string)h(con)m(taining)i(a)e(user)f
+(de\014ned)g(arithmetic)i(expression.)0 3308 y(The)29
+b(\014rst)f(3)i(routines)f(select)i(ro)m(ws)e(in)g(a)h(FITS)e(table,)j
+(based)e(on)g(whether)g(the)g(expression)g(ev)-5 b(aluates)31
+b(to)f(true)0 3421 y(\(not)e(equal)f(to)h(zero\))g(or)f(false)h
+(\(zero\).)41 b(The)27 b(other)g(routines)g(ev)-5 b(aluate)29
+b(the)e(expression)g(and)f(calculate)k(a)d(v)-5 b(alue)0
+3534 y(for)35 b(eac)m(h)h(ro)m(w)g(of)f(the)h(table.)56
 b(The)35 b(allo)m(w)m(ed)i(expression)e(syn)m(tax)g(is)h(describ)s(ed)e
 (in)h(the)g(ro)m(w)h(\014lter)f(section)h(in)0 3647 y(the)h(earlier)h
 (`Extended)e(File)i(Name)f(Syn)m(tax')g(c)m(hapter)h(of)f(this)f(do)s
 (cumen)m(t.)60 b(The)36 b(expression)h(ma)m(y)g(also)h(b)s(e)0
 3760 y(written)28 b(to)i(a)e(text)i(\014le,)f(and)f(the)h(name)f(of)h
 (the)f(\014le,)h(prep)s(ended)e(with)h(a)h('@')f(c)m(haracter)i(ma)m(y)
 f(b)s(e)f(supplied)f(for)0 3873 y(the)34 b('expr')g(parameter)g(\(e.g.)
@@ -11964,28 +9473,16 @@
 (output)g(\014le;)j(if)d(the)g(output)g(table)h(is)f(not)h(empt)m(y)-8
 b(,)37 b(then)e(this)g(routine)227 5601 y(will)28 b(app)s(end)e(the)i
 (new)f(selected)i(ro)m(ws)e(after)h(the)g(existing)h(ro)m(ws.)39
 b(If)27 b(the)h(\014les)g(are)f(the)h(same,)h(delete)g(the)227
 5714 y(F)-10 b(ALSE)30 b(ro)m(ws)h(\(preserv)m(e)f(the)h(TR)m(UE)f(ro)m
 (ws\).)p eop end
 %%Page: 65 71
-TeXDict begin 65 70 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.65) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.9.)72
-b(CELESTIAL)29 b(COORDINA)-8 b(TE)30 b(SYSTEM)f(SUBR)m(OUTINES)1307
+TeXDict begin 65 70 bop 0 299 a Fh(6.9.)72 b(CELESTIAL)29
+b(COORDINA)-8 b(TE)30 b(SYSTEM)f(SUBR)m(OUTINES)1307
 b Fj(65)430 555 y Ff(FTSROW\(inunit,)43 b(outunit,)j(expr,)g(>)i
 (status\))0 816 y Fi(4)81 b Fj(Calculate)28 b(an)f(expression)f(for)h
 (the)f(indicated)i(ro)m(ws)e(of)h(a)g(table,)i(returning)d(the)h
 (results,)g(cast)h(as)f(datat)m(yp)s(e)227 929 y(\(TSHOR)-8
 b(T,)32 b(TDOUBLE,)h(etc\),)h(in)e(arra)m(y)-8 b(.)48
 b(If)31 b(n)m(ulv)-5 b(al==NULL,)33 b(UNDEFs)g(will)f(b)s(e)g(zero)s
 (ed)g(out.)47 b(F)-8 b(or)227 1042 y(v)m(ector)37 b(results,)f(the)f(n)
@@ -12037,199 +9534,159 @@
 (expression,)j(and)d(are)227 4641 y(equiv)-5 b(alen)m(t)26
 b(to)f(the)g(result)f(of)g(\014ts)p 1380 4641 28 4 v
 33 w(read)p 1585 4641 V 32 w(tdim\(\).)40 b(Note)25 b(that)g(strings)f
 (are)h(considered)f(to)h(b)s(e)f(one)g(elemen)m(t)227
 4754 y(regardless)31 b(of)g(string)f(length.)41 b(If)30
 b(maxdim)g(==)g(0,)h(then)f(naxes)g(is)h(optional.)430
 5015 y Ff(FTTEXP\(unit,)44 b(expr,)i(maxdim)g(>)i(datatype,)d(nelem,)h
-(naxis,)g(naxes,)g(status\))0 5174 y
-SDict begin H.S end
- 0 5174 a 0 5174
-a
-SDict begin 13.6 H.A end
- 0 5174 a 0 5174 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.9) cvn /DEST pdfmark
-end
- 0 5174 a 176 x Fe(6.9)135 b(Celestial)48
+(naxis,)g(naxes,)g(status\))0 5350 y Fe(6.9)135 b(Celestial)48
 b(Co)t(ordinate)e(System)f(Subroutines)0 5601 y Fj(The)36
 b(FITS)g(comm)m(unit)m(y)h(has)f(adopted)h(a)g(set)g(of)g(k)m(eyw)m
 (ord)g(con)m(v)m(en)m(tions)h(that)f(de\014ne)f(the)h(transformations)0
 5714 y(needed)30 b(to)i(con)m(v)m(ert)g(b)s(et)m(w)m(een)f(pixel)g(lo)s
 (cations)h(in)e(an)h(image)h(and)e(the)g(corresp)s(onding)g(celestial)j
 (co)s(ordinates)p eop end
 %%Page: 66 72
-TeXDict begin 66 71 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.66) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(66)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fj(on)25 b(the)h(sky)-8
-b(,)27 b(or)e(more)g(generally)-8 b(,)29 b(that)d(de\014ne)e(w)m(orld)h
-(co)s(ordinates)i(that)e(are)h(to)g(b)s(e)f(asso)s(ciated)i(with)e(an)m
-(y)h(pixel)0 668 y(lo)s(cation)36 b(in)e(an)h(n-dimensional)f(FITS)g
-(arra)m(y)-8 b(.)54 b(CFITSIO)33 b(is)h(distributed)g(with)g(a)h
-(couple)f(of)h(self-con)m(tained)0 781 y(W)-8 b(orld)28
-b(Co)s(ordinate)f(System)f(\(W)m(CS\))i(routines,)g(ho)m(w)m(ev)m(er,)h
-(these)f(routines)f(DO)g(NOT)f(supp)s(ort)f(all)j(the)f(latest)0
-894 y(W)m(CS)38 b(con)m(v)m(en)m(tions,)k(so)d(it)g(is)f(STR)m(ONGL)-8
+TeXDict begin 66 71 bop 0 299 a Fj(66)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fj(on)25 b(the)h(sky)-8 b(,)27
+b(or)e(more)g(generally)-8 b(,)29 b(that)d(de\014ne)e(w)m(orld)h(co)s
+(ordinates)i(that)e(are)h(to)g(b)s(e)f(asso)s(ciated)i(with)e(an)m(y)h
+(pixel)0 668 y(lo)s(cation)36 b(in)e(an)h(n-dimensional)f(FITS)g(arra)m
+(y)-8 b(.)54 b(CFITSIO)33 b(is)h(distributed)g(with)g(a)h(couple)f(of)h
+(self-con)m(tained)0 781 y(W)-8 b(orld)28 b(Co)s(ordinate)f(System)f
+(\(W)m(CS\))i(routines,)g(ho)m(w)m(ev)m(er,)h(these)f(routines)f(DO)g
+(NOT)f(supp)s(ort)f(all)j(the)f(latest)0 894 y(W)m(CS)38
+b(con)m(v)m(en)m(tions,)k(so)d(it)g(is)f(STR)m(ONGL)-8
 b(Y)38 b(RECOMMENDED)h(that)f(soft)m(w)m(are)i(dev)m(elop)s(ers)e(use)g
 (a)h(more)0 1007 y(robust)30 b(external)h(W)m(CS)f(library)-8
 b(.)41 b(Sev)m(eral)31 b(recommended)f(libraries)h(are:)95
-1285 y Ff(WCSLIB)47 b(-)95 b(supported)45 b(by)i(Mark)g(Calabretta)95
-1398 y(WCSTools)f(-)h(supported)f(by)h(Doug)g(Mink)95
-1511 y(AST)g(library)f(-)i(developed)d(by)i(the)g(U.K.)g(Starlink)e
-(project)0 1788 y Fj(More)30 b(information)f(ab)s(out)g(the)g(W)m(CS)g
+1289 y Ff(WCSLIB)47 b(-)95 b(supported)45 b(by)i(Mark)g(Calabretta)95
+1402 y(WCSTools)f(-)h(supported)f(by)h(Doug)g(Mink)95
+1515 y(AST)g(library)f(-)i(developed)d(by)i(the)g(U.K.)g(Starlink)e
+(project)0 1797 y Fj(More)30 b(information)f(ab)s(out)g(the)g(W)m(CS)g
 (k)m(eyw)m(ord)h(con)m(v)m(en)m(tions)h(and)d(links)h(to)h(all)g(of)f
-(these)g(W)m(CS)g(libraries)h(can)0 1901 y(b)s(e)g(found)f(on)h(the)h
+(these)g(W)m(CS)g(libraries)h(can)0 1910 y(b)s(e)g(found)f(on)h(the)h
 (FITS)e(Supp)s(ort)g(O\016ce)h(w)m(eb)g(site)i(at)f(h)m
 (ttp://\014ts.gsfc.nasa.go)m(v)j(under)29 b(the)h(W)m(CS)h(link.)0
-2061 y(The)i(functions)h(pro)m(vided)g(in)f(these)i(external)f(W)m(CS)g
+2070 y(The)i(functions)h(pro)m(vided)g(in)f(these)i(external)f(W)m(CS)g
 (libraries)h(will)f(need)g(access)h(to)g(the)f(W)m(CS)g(information)0
-2174 y(con)m(tained)i(in)f(the)h(FITS)e(\014le)i(headers.)55
+2183 y(con)m(tained)i(in)f(the)h(FITS)e(\014le)i(headers.)55
 b(One)35 b(con)m(v)m(enien)m(t)i(w)m(a)m(y)f(to)g(pass)f(this)g
-(information)h(to)g(the)f(external)0 2287 y(library)k(is)h(to)h(use)e
+(information)h(to)g(the)f(external)0 2296 y(library)k(is)h(to)h(use)e
 (FITSIO)g(to)h(cop)m(y)h(the)f(header)f(k)m(eyw)m(ords)h(in)m(to)h(one)
-f(long)g(c)m(haracter)i(string,)g(and)d(then)0 2400 y(pass)29
+f(long)g(c)m(haracter)i(string,)g(and)d(then)0 2409 y(pass)29
 b(this)h(string)g(to)g(an)g(in)m(terface)h(routine)f(in)g(the)g
 (external)g(library)g(that)g(will)g(extract)i(the)e(necessary)g(W)m(CS)
-0 2513 y(information)h(\(e.g.,)h(see)f(the)f(astFitsChan)h(and)f
+0 2522 y(information)h(\(e.g.,)h(see)f(the)f(astFitsChan)h(and)f
 (astPutCards)g(routines)g(in)g(the)h(Starlink)f(AST)g(library\).)0
-2673 y(The)24 b(follo)m(wing)j(FITSIO)c(routines)i(DO)g(NOT)f(supp)s
+2682 y(The)24 b(follo)m(wing)j(FITSIO)c(routines)i(DO)g(NOT)f(supp)s
 (ort)f(the)i(more)g(recen)m(t)h(W)m(CS)f(con)m(v)m(en)m(tions)i(that)f
-(ha)m(v)m(e)g(b)s(een)0 2786 y(appro)m(v)m(ed)37 b(as)h(part)f(of)g
+(ha)m(v)m(e)g(b)s(een)0 2795 y(appro)m(v)m(ed)37 b(as)h(part)f(of)g
 (the)h(FITS)e(standard.)61 b(Consequen)m(tly)-8 b(,)39
 b(the)f(follo)m(wing)g(routines)g(ARE)f(NO)m(W)h(DEP-)0
-2899 y(RECA)-8 b(TED.)29 b(It)f(is)h(STR)m(ONGL)-8 b(Y)28
+2908 y(RECA)-8 b(TED.)29 b(It)f(is)h(STR)m(ONGL)-8 b(Y)28
 b(RECOMMENDED)h(that)g(soft)m(w)m(are)h(dev)m(elop)s(ers)f(not)g(use)f
-(these)h(routines,)0 3012 y(and)h(instead)g(use)g(an)h(external)g(W)m
+(these)h(routines,)0 3021 y(and)h(instead)g(use)g(an)h(external)g(W)m
 (CS)f(library)-8 b(,)31 b(as)g(describ)s(ed)e(ab)s(o)m(v)m(e.)0
-3172 y(These)21 b(routines)g(are)g(included)f(mainly)h(for)g(bac)m(kw)m
+3181 y(These)21 b(routines)g(are)g(included)f(mainly)h(for)g(bac)m(kw)m
 (ard)g(compatibilit)m(y)j(with)c(existing)i(soft)m(w)m(are.)39
-b(They)21 b(supp)s(ort)0 3285 y(the)30 b(follo)m(wing)i(standard)d(map)
+b(They)21 b(supp)s(ort)0 3294 y(the)30 b(follo)m(wing)i(standard)d(map)
 g(pro)5 b(jections:)41 b(-SIN,)30 b(-T)-8 b(AN,)31 b(-AR)m(C,)g(-NCP)-8
-b(,)30 b(-GLS,)g(-MER,)h(and)e(-AIT)h(\(these)0 3398
+b(,)30 b(-GLS,)g(-MER,)h(and)e(-AIT)h(\(these)0 3407
 y(are)f(the)g(legal)h(v)-5 b(alues)29 b(for)f(the)h(co)s(ordt)m(yp)s(e)
 f(parameter\).)41 b(These)28 b(routines)h(are)g(based)f(on)g(similar)h
-(functions)f(in)0 3511 y(Classic)j(AIPS.)f(All)h(the)g(angular)f(quan)m
+(functions)f(in)0 3520 y(Classic)j(AIPS.)f(All)h(the)g(angular)f(quan)m
 (tities)i(are)f(giv)m(en)g(in)f(units)g(of)g(degrees.)0
-3789 y Fi(1)81 b Fj(Get)22 b(the)g(v)-5 b(alues)21 b(of)h(all)g(the)g
+3802 y Fi(1)81 b Fj(Get)22 b(the)g(v)-5 b(alues)21 b(of)h(all)g(the)g
 (standard)f(FITS)f(celestial)k(co)s(ordinate)f(system)e(k)m(eyw)m(ords)
-h(from)f(the)h(header)f(of)h(a)227 3902 y(FITS)j(image)i(\(i.e.,)h(the)
+h(from)f(the)h(header)f(of)h(a)227 3915 y(FITS)j(image)i(\(i.e.,)h(the)
 d(primary)g(arra)m(y)h(or)f(an)h(image)g(extension\).)40
 b(These)26 b(v)-5 b(alues)25 b(ma)m(y)h(then)g(b)s(e)e(passed)227
-4015 y(to)39 b(the)e(subroutines)g(that)h(p)s(erform)e(the)i(co)s
+4028 y(to)39 b(the)e(subroutines)g(that)h(p)s(erform)e(the)i(co)s
 (ordinate)g(transformations.)63 b(If)37 b(an)m(y)h(or)g(all)g(of)g(the)
-g(W)m(CS)227 4127 y(k)m(eyw)m(ords)32 b(are)f(not)g(presen)m(t,)h(then)
+g(W)m(CS)227 4141 y(k)m(eyw)m(ords)32 b(are)f(not)g(presen)m(t,)h(then)
 f(default)g(v)-5 b(alues)31 b(will)h(b)s(e)e(returned.)41
 b(If)31 b(the)g(\014rst)g(co)s(ordinate)g(axis)h(is)227
-4240 y(the)d(declination-lik)m(e)j(co)s(ordinate,)e(then)e(this)g
+4254 y(the)d(declination-lik)m(e)j(co)s(ordinate,)e(then)e(this)g
 (routine)h(will)g(sw)m(ap)f(them)h(so)g(that)g(the)g(longitudinal-lik)m
-(e)227 4353 y(co)s(ordinate)i(is)g(returned)e(as)i(the)f(\014rst)g
-(axis.)227 4513 y(If)35 b(the)h(\014le)f(uses)g(the)g(new)m(er)h('CDj)p
-1454 4513 28 4 v 32 w(i')g(W)m(CS)f(transformation)h(matrix)g(k)m(eyw)m
-(ords)f(instead)h(of)f(old)h(st)m(yle)227 4625 y('CDEL)-8
+(e)227 4367 y(co)s(ordinate)i(is)g(returned)e(as)i(the)f(\014rst)g
+(axis.)227 4528 y(If)35 b(the)h(\014le)f(uses)g(the)g(new)m(er)h('CDj)p
+1454 4528 28 4 v 32 w(i')g(W)m(CS)f(transformation)h(matrix)g(k)m(eyw)m
+(ords)f(instead)h(of)f(old)h(st)m(yle)227 4641 y('CDEL)-8
 b(Tn')37 b(and)f('CR)m(OT)-8 b(A2')38 b(k)m(eyw)m(ords,)h(then)e(this)f
 (routine)h(will)g(calculate)j(and)c(return)g(the)h(v)-5
-b(alues)227 4738 y(of)33 b(the)g(equiv)-5 b(alen)m(t)35
+b(alues)227 4754 y(of)33 b(the)g(equiv)-5 b(alen)m(t)35
 b(old-st)m(yle)f(k)m(eyw)m(ords.)49 b(Note)34 b(that)g(the)f(con)m(v)m
 (ersion)h(from)e(the)i(new-st)m(yle)g(k)m(eyw)m(ords)227
-4851 y(to)e(the)f(old-st)m(yle)h(v)-5 b(alues)31 b(is)g(sometimes)g
+4867 y(to)e(the)f(old-st)m(yle)h(v)-5 b(alues)31 b(is)g(sometimes)g
 (only)g(an)g(appro)m(ximation,)h(so)e(if)h(the)g(appro)m(ximation)h(is)
-e(larger)227 4964 y(than)37 b(an)h(in)m(ternally)g(de\014ned)e
+e(larger)227 4980 y(than)37 b(an)h(in)m(ternally)g(de\014ned)e
 (threshold)h(lev)m(el,)k(then)c(CFITSIO)f(will)i(still)g(return)e(the)i
-(appro)m(ximate)227 5077 y(W)m(CS)f(k)m(eyw)m(ord)g(v)-5
+(appro)m(ximate)227 5093 y(W)m(CS)f(k)m(eyw)m(ord)g(v)-5
 b(alues,)39 b(but)d(will)h(also)h(return)d(with)i(status)g(=)f(506,)k
-(to)e(w)m(arn)e(the)h(calling)h(program)227 5190 y(that)30
+(to)e(w)m(arn)e(the)h(calling)h(program)227 5206 y(that)30
 b(appro)m(ximations)f(ha)m(v)m(e)h(b)s(een)e(made.)40
 b(It)29 b(is)g(then)f(up)g(to)h(the)g(calling)i(program)d(to)h(decide)h
-(whether)227 5303 y(the)k(appro)m(ximations)g(are)g(su\016cien)m(tly)g
+(whether)227 5319 y(the)k(appro)m(ximations)g(are)g(su\016cien)m(tly)g
 (accurate)i(for)d(the)h(particular)f(application,)j(or)e(whether)f
-(more)227 5416 y(precise)e(W)m(CS)f(transformations)h(m)m(ust)f(b)s(e)g
+(more)227 5432 y(precise)e(W)m(CS)f(transformations)h(m)m(ust)f(b)s(e)g
 (p)s(erformed)f(using)h(new-st)m(yle)h(W)m(CS)g(k)m(eyw)m(ords)f
-(directly)-8 b(.)382 5694 y Ff(FTGICS\(unit,)44 b(>)k
+(directly)-8 b(.)382 5714 y Ff(FTGICS\(unit,)44 b(>)k
 (xrval,yrval,xrpix,yrpix)o(,xin)o(c,yi)o(nc,)o(rot,)o(coor)o(dty)o
 (pe,s)o(tatu)o(s\))p eop end
 %%Page: 67 73
-TeXDict begin 67 72 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.67) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.10.)73
-b(FILE)30 b(CHECKSUM)f(SUBR)m(OUTINES)2080 b Fj(67)0
-555 y Fi(2)81 b Fj(Get)34 b(the)f(v)-5 b(alues)33 b(of)g(all)h(the)f
-(standard)f(FITS)h(celestial)i(co)s(ordinate)f(system)f(k)m(eyw)m(ords)
-g(from)g(the)g(header)227 668 y(of)j(a)h(FITS)e(table)h(where)g(the)g
-(X)g(and)f(Y)h(\(or)g(RA)g(and)g(DEC)f(co)s(ordinates)i(are)f(stored)g
-(in)g(2)g(separate)227 781 y(columns)c(of)g(the)g(table.)46
-b(These)31 b(v)-5 b(alues)32 b(ma)m(y)h(then)e(b)s(e)h(passed)f(to)h
-(the)g(subroutines)f(that)h(p)s(erform)f(the)227 894
-y(co)s(ordinate)g(transformations.)382 1114 y Ff
-(FTGTCS\(unit,xcol,ycol,)42 b(>)716 1227 y(xrval,yrval,xrpix,yrpix,)o
-(xinc)o(,yi)o(nc,r)o(ot,c)o(oor)o(dtyp)o(e,st)o(atu)o(s\))0
-1446 y Fi(3)81 b Fj(Calculate)42 b(the)g(celestial)h(co)s(ordinate)f
-(corresp)s(onding)e(to)i(the)f(input)f(X)h(and)g(Y)g(pixel)g(lo)s
-(cation)i(in)e(the)227 1559 y(image.)382 1779 y Ff
-(FTWLDP\(xpix,ypix,xrval,y)o(rva)o(l,xr)o(pix,)o(yrp)o(ix,x)o(inc,)o
-(yin)o(c,ro)o(t,)1241 1892 y(coordtype,)k(>)i(xpos,ypos,status\))0
-2112 y Fi(4)81 b Fj(Calculate)42 b(the)g(X)f(and)f(Y)h(pixel)h(lo)s
-(cation)g(corresp)s(onding)e(to)i(the)f(input)f(celestial)k(co)s
-(ordinate)e(in)f(the)227 2225 y(image.)382 2445 y Ff
-(FTXYPX\(xpos,ypos,xrval,y)o(rva)o(l,xr)o(pix,)o(yrp)o(ix,x)o(inc,)o
-(yin)o(c,ro)o(t,)1241 2557 y(coordtype,)k(>)i(xpix,ypix,status\))0
-2708 y
-SDict begin H.S end
- 0 2708 a 0 2708 a
-SDict begin 13.6 H.A end
- 0 2708 a 0 2708 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.10) cvn /DEST pdfmark
-end
- 0 2708 a 177
-x Fe(6.10)136 b(File)45 b(Chec)l(ksum)g(Subroutines)0
-3135 y Fj(The)33 b(follo)m(wing)h(routines)f(either)h(compute)f(or)h(v)
--5 b(alidate)34 b(the)g(c)m(hec)m(ksums)f(for)g(the)h(CHDU.)g(The)e(D)m
-(A)-8 b(T)g(ASUM)0 3248 y(k)m(eyw)m(ord)33 b(is)f(used)f(to)i(store)f
-(the)h(n)m(umerical)f(v)-5 b(alue)33 b(of)f(the)g(32-bit,)i(1's)f
-(complemen)m(t)g(c)m(hec)m(ksum)g(for)f(the)g(data)0
-3361 y(unit)26 b(alone.)40 b(If)25 b(there)h(is)h(no)e(data)i(unit)f
-(then)f(the)h(v)-5 b(alue)27 b(is)f(set)g(to)h(zero.)40
-b(The)26 b(n)m(umerical)g(v)-5 b(alue)27 b(is)f(stored)g(as)g(an)0
-3474 y(ASCI)s(I)20 b(string)i(of)h(digits,)h(enclosed)f(in)e(quotes,)k
-(b)s(ecause)d(the)g(v)-5 b(alue)23 b(ma)m(y)f(b)s(e)f(to)s(o)i(large)g
-(to)g(represen)m(t)f(as)g(a)h(32-bit)0 3587 y(signed)28
-b(in)m(teger.)41 b(The)27 b(CHECKSUM)g(k)m(eyw)m(ord)i(is)f(used)f(to)h
-(store)h(the)f(ASCI)s(I)e(enco)s(ded)i(COMPLEMENT)f(of)0
-3700 y(the)f(c)m(hec)m(ksum)h(for)f(the)h(en)m(tire)g(HDU.)g(Storing)f
-(the)h(complemen)m(t,)h(rather)e(than)g(the)h(actual)g(c)m(hec)m(ksum,)
-h(forces)0 3812 y(the)k(c)m(hec)m(ksum)h(for)f(the)h(whole)f(HDU)h(to)g
-(equal)g(zero.)47 b(If)31 b(the)i(\014le)f(has)g(b)s(een)f(mo)s
-(di\014ed)g(since)i(the)f(c)m(hec)m(ksums)0 3925 y(w)m(ere)39
-b(computed,)i(then)e(the)g(HDU)g(c)m(hec)m(ksum)h(will)f(usually)f(not)
-h(equal)h(zero.)66 b(These)39 b(c)m(hec)m(ksum)g(k)m(eyw)m(ord)0
-4038 y(con)m(v)m(en)m(tions)34 b(are)f(based)f(on)g(a)g(pap)s(er)f(b)m
-(y)h(Rob)g(Seaman)g(published)f(in)h(the)g(pro)s(ceedings)g(of)g(the)h
-(AD)m(ASS)f(IV)0 4151 y(conference)f(in)f(Baltimore)i(in)f(No)m(v)m(em)
-m(b)s(er)g(1994)h(and)e(a)h(later)g(revision)g(in)f(June)f(1995.)0
-4371 y Fi(1)81 b Fj(Compute)33 b(and)g(write)h(the)g(D)m(A)-8
+TeXDict begin 67 72 bop 0 299 a Fh(6.10.)73 b(FILE)30
+b(CHECKSUM)f(SUBR)m(OUTINES)2080 b Fj(67)0 555 y Fi(2)81
+b Fj(Get)34 b(the)f(v)-5 b(alues)33 b(of)g(all)h(the)f(standard)f(FITS)
+h(celestial)i(co)s(ordinate)f(system)f(k)m(eyw)m(ords)g(from)g(the)g
+(header)227 668 y(of)j(a)h(FITS)e(table)h(where)g(the)g(X)g(and)f(Y)h
+(\(or)g(RA)g(and)g(DEC)f(co)s(ordinates)i(are)f(stored)g(in)g(2)g
+(separate)227 781 y(columns)c(of)g(the)g(table.)46 b(These)31
+b(v)-5 b(alues)32 b(ma)m(y)h(then)e(b)s(e)h(passed)f(to)h(the)g
+(subroutines)f(that)h(p)s(erform)f(the)227 894 y(co)s(ordinate)g
+(transformations.)382 1114 y Ff(FTGTCS\(unit,xcol,ycol,)42
+b(>)716 1227 y(xrval,yrval,xrpix,yrpix,)o(xinc)o(,yi)o(nc,r)o(ot,c)o
+(oor)o(dtyp)o(e,st)o(atu)o(s\))0 1446 y Fi(3)81 b Fj(Calculate)42
+b(the)g(celestial)h(co)s(ordinate)f(corresp)s(onding)e(to)i(the)f
+(input)f(X)h(and)g(Y)g(pixel)g(lo)s(cation)i(in)e(the)227
+1559 y(image.)382 1779 y Ff(FTWLDP\(xpix,ypix,xrval,y)o(rva)o(l,xr)o
+(pix,)o(yrp)o(ix,x)o(inc,)o(yin)o(c,ro)o(t,)1241 1892
+y(coordtype,)k(>)i(xpos,ypos,status\))0 2112 y Fi(4)81
+b Fj(Calculate)42 b(the)g(X)f(and)f(Y)h(pixel)h(lo)s(cation)g(corresp)s
+(onding)e(to)i(the)f(input)f(celestial)k(co)s(ordinate)e(in)f(the)227
+2225 y(image.)382 2445 y Ff(FTXYPX\(xpos,ypos,xrval,y)o(rva)o(l,xr)o
+(pix,)o(yrp)o(ix,x)o(inc,)o(yin)o(c,ro)o(t,)1241 2557
+y(coordtype,)k(>)i(xpix,ypix,status\))0 2885 y Fe(6.10)136
+b(File)45 b(Chec)l(ksum)g(Subroutines)0 3135 y Fj(The)33
+b(follo)m(wing)h(routines)f(either)h(compute)f(or)h(v)-5
+b(alidate)34 b(the)g(c)m(hec)m(ksums)f(for)g(the)h(CHDU.)g(The)e(D)m(A)
+-8 b(T)g(ASUM)0 3248 y(k)m(eyw)m(ord)33 b(is)f(used)f(to)i(store)f(the)
+h(n)m(umerical)f(v)-5 b(alue)33 b(of)f(the)g(32-bit,)i(1's)f(complemen)
+m(t)g(c)m(hec)m(ksum)g(for)f(the)g(data)0 3361 y(unit)26
+b(alone.)40 b(If)25 b(there)h(is)h(no)e(data)i(unit)f(then)f(the)h(v)-5
+b(alue)27 b(is)f(set)g(to)h(zero.)40 b(The)26 b(n)m(umerical)g(v)-5
+b(alue)27 b(is)f(stored)g(as)g(an)0 3474 y(ASCI)s(I)20
+b(string)i(of)h(digits,)h(enclosed)f(in)e(quotes,)k(b)s(ecause)d(the)g
+(v)-5 b(alue)23 b(ma)m(y)f(b)s(e)f(to)s(o)i(large)g(to)g(represen)m(t)f
+(as)g(a)h(32-bit)0 3587 y(signed)28 b(in)m(teger.)41
+b(The)27 b(CHECKSUM)g(k)m(eyw)m(ord)i(is)f(used)f(to)h(store)h(the)f
+(ASCI)s(I)e(enco)s(ded)i(COMPLEMENT)f(of)0 3700 y(the)f(c)m(hec)m(ksum)
+h(for)f(the)h(en)m(tire)g(HDU.)g(Storing)f(the)h(complemen)m(t,)h
+(rather)e(than)g(the)h(actual)g(c)m(hec)m(ksum,)h(forces)0
+3812 y(the)k(c)m(hec)m(ksum)h(for)f(the)h(whole)f(HDU)h(to)g(equal)g
+(zero.)47 b(If)31 b(the)i(\014le)f(has)g(b)s(een)f(mo)s(di\014ed)g
+(since)i(the)f(c)m(hec)m(ksums)0 3925 y(w)m(ere)39 b(computed,)i(then)e
+(the)g(HDU)g(c)m(hec)m(ksum)h(will)f(usually)f(not)h(equal)h(zero.)66
+b(These)39 b(c)m(hec)m(ksum)g(k)m(eyw)m(ord)0 4038 y(con)m(v)m(en)m
+(tions)34 b(are)f(based)f(on)g(a)g(pap)s(er)f(b)m(y)h(Rob)g(Seaman)g
+(published)f(in)h(the)g(pro)s(ceedings)g(of)g(the)h(AD)m(ASS)f(IV)0
+4151 y(conference)f(in)f(Baltimore)i(in)f(No)m(v)m(em)m(b)s(er)g(1994)h
+(and)e(a)h(later)g(revision)g(in)f(June)f(1995.)0 4371
+y Fi(1)81 b Fj(Compute)33 b(and)g(write)h(the)g(D)m(A)-8
 b(T)g(ASUM)35 b(and)e(CHECKSUM)g(k)m(eyw)m(ord)h(v)-5
 b(alues)34 b(for)f(the)h(CHDU)g(in)m(to)h(the)227 4484
 y(curren)m(t)25 b(header.)38 b(The)24 b(D)m(A)-8 b(T)g(ASUM)27
 b(v)-5 b(alue)25 b(is)f(the)h(32-bit)h(c)m(hec)m(ksum)f(for)f(the)h
 (data)g(unit,)h(expressed)e(as)h(a)227 4597 y(decimal)32
 b(in)m(teger)f(enclosed)g(in)f(single)h(quotes.)41 b(The)30
 b(CHECKSUM)g(k)m(eyw)m(ord)g(v)-5 b(alue)31 b(is)f(a)h(16-c)m(haracter)
@@ -12248,42 +9705,30 @@
 (calculates)j(the)e(new)f(c)m(hec)m(ksum)h(for)f(the)227
 5601 y(curren)m(t)40 b(header)g(unit,)j(adds)c(it)i(to)g(the)f(data)h
 (unit)f(c)m(hec)m(ksum,)k(enco)s(des)c(the)g(v)-5 b(alue)41
 b(in)m(to)g(an)f(ASCI)s(I)227 5714 y(string,)31 b(and)f(writes)g(the)h
 (string)f(to)h(the)g(CHECKSUM)e(k)m(eyw)m(ord.)p eop
 end
 %%Page: 68 74
-TeXDict begin 68 73 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.68) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(68)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTUCKS\(unit,)44
-b(>)k(status\))0 807 y Fi(3)81 b Fj(V)-8 b(erify)35 b(the)f(CHDU)h(b)m
-(y)g(computing)f(the)h(c)m(hec)m(ksums)g(and)f(comparing)h(them)f(with)
-g(the)h(k)m(eyw)m(ords.)53 b(The)227 920 y(data)34 b(unit)f(is)g(v)m
-(eri\014ed)g(correctly)h(if)f(the)h(computed)f(c)m(hec)m(ksum)g(equals)
-h(the)f(v)-5 b(alue)34 b(of)f(the)g(D)m(A)-8 b(T)g(ASUM)227
-1033 y(k)m(eyw)m(ord.)64 b(The)37 b(c)m(hec)m(ksum)i(for)f(the)g(en)m
-(tire)g(HDU)h(\(header)f(plus)f(data)i(unit\))e(is)h(correct)h(if)f(it)
-h(equals)227 1146 y(zero.)55 b(The)34 b(output)g(D)m(A)-8
-b(T)g(A)m(OK)37 b(and)d(HDUOK)h(parameters)g(in)f(this)h(subroutine)e
-(are)i(in)m(tegers)h(whic)m(h)227 1259 y(will)27 b(ha)m(v)m(e)g(a)f(v)
--5 b(alue)27 b(=)f(1)g(if)g(the)h(data)f(or)g(HDU)h(is)f(v)m(eri\014ed)
-h(correctly)-8 b(,)29 b(a)d(v)-5 b(alue)27 b(=)e(0)i(if)f(the)g(D)m(A)
--8 b(T)g(ASUM)28 b(or)227 1372 y(CHECKSUM)h(k)m(eyw)m(ord)g(is)h(not)f
+TeXDict begin 68 73 bop 0 299 a Fj(68)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)382 555 y Ff(FTUCKS\(unit,)44 b(>)k(status\))0
+807 y Fi(3)81 b Fj(V)-8 b(erify)35 b(the)f(CHDU)h(b)m(y)g(computing)f
+(the)h(c)m(hec)m(ksums)g(and)f(comparing)h(them)f(with)g(the)h(k)m(eyw)
+m(ords.)53 b(The)227 920 y(data)34 b(unit)f(is)g(v)m(eri\014ed)g
+(correctly)h(if)f(the)h(computed)f(c)m(hec)m(ksum)g(equals)h(the)f(v)-5
+b(alue)34 b(of)f(the)g(D)m(A)-8 b(T)g(ASUM)227 1033 y(k)m(eyw)m(ord.)64
+b(The)37 b(c)m(hec)m(ksum)i(for)f(the)g(en)m(tire)g(HDU)h(\(header)f
+(plus)f(data)i(unit\))e(is)h(correct)h(if)f(it)h(equals)227
+1146 y(zero.)55 b(The)34 b(output)g(D)m(A)-8 b(T)g(A)m(OK)37
+b(and)d(HDUOK)h(parameters)g(in)f(this)h(subroutine)e(are)i(in)m
+(tegers)h(whic)m(h)227 1259 y(will)27 b(ha)m(v)m(e)g(a)f(v)-5
+b(alue)27 b(=)f(1)g(if)g(the)h(data)f(or)g(HDU)h(is)f(v)m(eri\014ed)h
+(correctly)-8 b(,)29 b(a)d(v)-5 b(alue)27 b(=)e(0)i(if)f(the)g(D)m(A)-8
+b(T)g(ASUM)28 b(or)227 1372 y(CHECKSUM)h(k)m(eyw)m(ord)g(is)h(not)f
 (presen)m(t,)h(or)f(v)-5 b(alue)30 b(=)f(-1)h(if)f(the)h(computed)f(c)m
 (hec)m(ksum)h(is)f(not)h(correct.)382 1623 y Ff(FTVCKS\(unit,)44
 b(>)k(dataok,hduok,status\))0 1875 y Fi(4)81 b Fj(Compute)25
 b(and)h(return)f(the)i(c)m(hec)m(ksum)g(v)-5 b(alues)26
 b(for)g(the)h(CHDU)f(\(as)h(double)f(precision)h(v)-5
 b(ariables\))27 b(without)227 1988 y(creating)46 b(or)e(mo)s(difying)g
 (the)h(CHECKSUM)e(and)h(D)m(A)-8 b(T)g(ASUM)46 b(k)m(eyw)m(ords.)83
@@ -12298,25 +9743,17 @@
 (complemen)m(ted)h(b)s(efore)f(enco)s(ding.)382 2969
 y Ff(FTESUM\(sum,complement,)42 b(>)47 b(checksum\))0
 3221 y Fi(6)81 b Fj(Deco)s(de)39 b(a)f(16)h(c)m(haracter)h(c)m(hec)m
 (ksum)e(string)g(in)m(to)h(a)g(double)e(precision)h(v)-5
 b(alue.)65 b(If)37 b(COMPLEMENT)g(=)227 3334 y(.true.)k(then)30
 b(the)h(32-bit)g(sum)f(v)-5 b(alue)31 b(will)f(b)s(e)g(complemen)m(ted)
 i(after)e(deco)s(ding.)382 3586 y Ff(FTDSUM\(checksum,compleme)o(nt,)41
-b(>)48 b(sum\))0 3742 y
-SDict begin H.S end
- 0 3742 a 0 3742 a
-SDict begin 13.6 H.A end
- 0 3742 a 0
-3742 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.11) cvn /DEST pdfmark
-end
- 0 3742 a 176 x Fe(6.11)180 b(Date)46 b(and)f(Time)g(Utilit)l(y)i
-(Routines)0 4168 y Fj(The)29 b(follo)m(wing)i(routines)f(help)f(to)i
-(construct)f(or)f(parse)h(the)g(FITS)f(date/time)i(strings.)41
+b(>)48 b(sum\))0 3918 y Fe(6.11)180 b(Date)46 b(and)f(Time)g(Utilit)l
+(y)i(Routines)0 4168 y Fj(The)29 b(follo)m(wing)i(routines)f(help)f(to)
+i(construct)f(or)f(parse)h(the)g(FITS)f(date/time)i(strings.)41
 b(Starting)30 b(in)f(the)h(y)m(ear)0 4281 y(2000,)k(the)d(FITS)g(D)m(A)
 -8 b(TE)32 b(k)m(eyw)m(ord)g(v)-5 b(alues)31 b(\(and)h(the)f(v)-5
 b(alues)32 b(of)f(other)h(`D)m(A)-8 b(TE-')33 b(k)m(eyw)m(ords\))f(m)m
 (ust)f(ha)m(v)m(e)i(the)0 4394 y(form)j('YYYY-MM-DD')k(\(date)e(only\))
 f(or)g('YYYY-MM-DDThh:mm:ss.ddd...')61 b(\(date)38 b(and)e(time\))h
 (where)0 4507 y(the)30 b(n)m(um)m(b)s(er)f(of)i(decimal)g(places)g(in)f
 (the)g(seconds)g(v)-5 b(alue)31 b(is)f(optional.)42 b(These)30
@@ -12332,207 +9769,161 @@
 b(as)e(indicated)f(b)m(y)g(a)g(returned)f(timeref)h(v)-5
 b(alue)27 b(=)e(0.)40 b(If)26 b(the)g(returned)e(v)-5
 b(alue)227 5601 y(of)31 b(timeref)g(=)g(1)g(then)f(this)h(indicates)g
 (that)h(it)f(w)m(as)g(not)g(p)s(ossible)f(to)h(con)m(v)m(ert)i(the)d
 (lo)s(cal)i(time)g(to)f(UTC,)227 5714 y(and)f(th)m(us)g(the)h(lo)s(cal)
 g(time)g(w)m(as)g(returned.)p eop end
 %%Page: 69 75
-TeXDict begin 69 74 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.69) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.12.)73
-b(GENERAL)30 b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(69)382
-555 y Ff(FTGSTM\(>)45 b(datestr,)h(timeref,)f(status\))0
-821 y Fi(3)81 b Fj(Construct)26 b(a)i(date)g(string)f(from)g(the)g
-(input)f(date)i(v)-5 b(alues.)40 b(If)27 b(the)g(y)m(ear)h(is)g(b)s(et)
-m(w)m(een)f(1900)i(and)e(1998,)j(inclu-)227 934 y(siv)m(e,)38
-b(then)c(the)i(returned)d(date)j(string)f(will)g(ha)m(v)m(e)i(the)e
-(old)g(FITS)f(format)i(\('dd/mm/yy'\),)h(otherwise)227
-1047 y(the)32 b(date)g(string)f(will)g(ha)m(v)m(e)i(the)e(new)g(FITS)g
-(format)g(\('YYYY-MM-DD'\).)36 b(Use)c(FTTM2S)f(instead)g(to)227
-1160 y(alw)m(a)m(ys)h(return)d(a)i(date)g(string)g(using)e(the)i(new)f
-(FITS)g(format.)382 1426 y Ff(FTDT2S\()46 b(year,)g(month,)g(day,)h(>)g
-(datestr,)f(status\))0 1692 y Fi(4)81 b Fj(Construct)34
-b(a)i(new-format)f(date)h(+)f(time)h(string)f
-(\('YYYY-MM-DDThh:mm:ss.ddd...'\).)57 b(If)34 b(the)i(y)m(ear,)227
-1805 y(mon)m(th,)d(and)e(da)m(y)h(v)-5 b(alues)32 b(all)h(=)e(0)h(then)
-g(only)g(the)g(time)g(is)g(enco)s(ded)f(with)h(format)g
-('hh:mm:ss.ddd...'.)227 1918 y(The)j(decimals)h(parameter)g(sp)s
-(eci\014es)e(ho)m(w)i(man)m(y)f(decimal)h(places)g(of)f(fractional)i
-(seconds)e(to)h(include)227 2030 y(in)30 b(the)h(string.)41
-b(If)29 b(`decimals')j(is)f(negativ)m(e,)h(then)f(only)f(the)h(date)g
-(will)f(b)s(e)g(return)f(\('YYYY-MM-DD'\).)382 2296 y
-Ff(FTTM2S\()46 b(year,)g(month,)g(day,)h(hour,)f(minute,)g(second,)g
-(decimals,)764 2409 y(>)h(datestr,)f(status\))0 2675
-y Fi(5)81 b Fj(Return)44 b(the)g(date)i(as)f(read)f(from)h(the)g(input)
-e(string,)49 b(where)44 b(the)h(string)g(ma)m(y)g(b)s(e)f(in)h(either)g
-(the)g(old)227 2788 y(\('dd/mm/yy'\))31 b(or)g(new)e
+TeXDict begin 69 74 bop 0 299 a Fh(6.12.)73 b(GENERAL)30
+b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(69)382 555 y Ff(FTGSTM\(>)45
+b(datestr,)h(timeref,)f(status\))0 823 y Fi(3)81 b Fj(Construct)26
+b(a)i(date)g(string)f(from)g(the)g(input)f(date)i(v)-5
+b(alues.)40 b(If)27 b(the)g(y)m(ear)h(is)g(b)s(et)m(w)m(een)f(1900)i
+(and)e(1998,)j(inclu-)227 936 y(siv)m(e,)38 b(then)c(the)i(returned)d
+(date)j(string)f(will)g(ha)m(v)m(e)i(the)e(old)g(FITS)f(format)i
+(\('dd/mm/yy'\),)h(otherwise)227 1048 y(the)32 b(date)g(string)f(will)g
+(ha)m(v)m(e)i(the)e(new)g(FITS)g(format)g(\('YYYY-MM-DD'\).)36
+b(Use)c(FTTM2S)f(instead)g(to)227 1161 y(alw)m(a)m(ys)h(return)d(a)i
+(date)g(string)g(using)e(the)i(new)f(FITS)g(format.)382
+1429 y Ff(FTDT2S\()46 b(year,)g(month,)g(day,)h(>)g(datestr,)f
+(status\))0 1696 y Fi(4)81 b Fj(Construct)34 b(a)i(new-format)f(date)h
+(+)f(time)h(string)f(\('YYYY-MM-DDThh:mm:ss.ddd...'\).)57
+b(If)34 b(the)i(y)m(ear,)227 1809 y(mon)m(th,)d(and)e(da)m(y)h(v)-5
+b(alues)32 b(all)h(=)e(0)h(then)g(only)g(the)g(time)g(is)g(enco)s(ded)f
+(with)h(format)g('hh:mm:ss.ddd...'.)227 1922 y(The)j(decimals)h
+(parameter)g(sp)s(eci\014es)e(ho)m(w)i(man)m(y)f(decimal)h(places)g(of)
+f(fractional)i(seconds)e(to)h(include)227 2035 y(in)30
+b(the)h(string.)41 b(If)29 b(`decimals')j(is)f(negativ)m(e,)h(then)f
+(only)f(the)h(date)g(will)f(b)s(e)g(return)f(\('YYYY-MM-DD'\).)382
+2302 y Ff(FTTM2S\()46 b(year,)g(month,)g(day,)h(hour,)f(minute,)g
+(second,)g(decimals,)764 2415 y(>)h(datestr,)f(status\))0
+2683 y Fi(5)81 b Fj(Return)44 b(the)g(date)i(as)f(read)f(from)h(the)g
+(input)e(string,)49 b(where)44 b(the)h(string)g(ma)m(y)g(b)s(e)f(in)h
+(either)g(the)g(old)227 2796 y(\('dd/mm/yy'\))31 b(or)g(new)e
 (\('YYYY-MM-DDThh:mm:ss')k(or)d('YYYY-MM-DD'\))k(FITS)c(format.)382
-3054 y Ff(FTS2DT\(datestr,)43 b(>)48 b(year,)e(month,)g(day,)h
-(status\))0 3320 y Fi(6)81 b Fj(Return)30 b(the)h(date)h(and)f(time)h
+3063 y Ff(FTS2DT\(datestr,)43 b(>)48 b(year,)e(month,)g(day,)h
+(status\))0 3330 y Fi(6)81 b Fj(Return)30 b(the)h(date)h(and)f(time)h
 (as)f(read)g(from)g(the)h(input)e(string,)h(where)g(the)h(string)f(ma)m
-(y)h(b)s(e)e(in)h(either)h(the)227 3433 y(old)d(or)f(new)g(FITS)g
+(y)h(b)s(e)e(in)h(either)h(the)227 3443 y(old)d(or)f(new)g(FITS)g
 (format.)40 b(The)28 b(returned)f(hours,)h(min)m(utes,)h(and)f(seconds)
 g(v)-5 b(alues)29 b(will)f(b)s(e)g(set)h(to)g(zero)227
-3546 y(if)k(the)h(input)e(string)h(do)s(es)g(not)h(include)f(the)g
+3556 y(if)k(the)h(input)e(string)h(do)s(es)g(not)h(include)f(the)g
 (time)h(\('dd/mm/yy')f(or)h('YYYY-MM-DD'\))j(.)c(Similarly)-8
-b(,)227 3659 y(the)36 b(returned)e(y)m(ear,)j(mon)m(th,)g(and)d(date)i
+b(,)227 3669 y(the)36 b(returned)e(y)m(ear,)j(mon)m(th,)g(and)d(date)i
 (v)-5 b(alues)36 b(will)f(b)s(e)g(set)h(to)g(zero)g(if)f(the)g(date)h
-(is)f(not)h(included)e(in)227 3772 y(the)d(input)e(string)i
-(\('hh:mm:ss.ddd...'\).)382 4037 y Ff(FTS2TM\(datestr,)43
+(is)f(not)h(included)e(in)227 3782 y(the)d(input)e(string)i
+(\('hh:mm:ss.ddd...'\).)382 4050 y Ff(FTS2TM\(datestr,)43
 b(>)48 b(year,)e(month,)g(day,)h(hour,)f(minute,)g(second,)g(status\))0
-4202 y
-SDict begin H.S end
- 0 4202 a 0 4202 a
-SDict begin 13.6 H.A end
- 0 4202 a 0 4202 a
-SDict begin [/View [/XYZ H.V]/Dest (section.6.12) cvn /DEST pdfmark
-end
- 0 4202 a 176
-x Fe(6.12)136 b(General)45 b(Utilit)l(y)i(Subroutines)0
-4630 y Fj(The)30 b(follo)m(wing)i(utilit)m(y)f(subroutines)f(ma)m(y)h
-(b)s(e)e(useful)h(for)g(certain)h(applications:)0 4896
+4392 y Fe(6.12)136 b(General)45 b(Utilit)l(y)i(Subroutines)0
+4644 y Fj(The)30 b(follo)m(wing)i(utilit)m(y)f(subroutines)f(ma)m(y)h
+(b)s(e)e(useful)h(for)g(certain)h(applications:)0 4912
 y Fi(1)81 b Fj(Return)29 b(the)i(starting)g(b)m(yte)g(address)e(of)i
-(the)f(CHDU)h(and)f(the)h(next)f(HDU.)382 5162 y Ff(FTGHAD\(iunit,)44
-b(>)j(curaddr,)f(nextaddr\))0 5428 y Fi(2)81 b Fj(Con)m(v)m(ert)31
+(the)f(CHDU)h(and)f(the)h(next)f(HDU.)382 5179 y Ff(FTGHAD\(iunit,)44
+b(>)j(curaddr,)f(nextaddr\))0 5446 y Fi(2)81 b Fj(Con)m(v)m(ert)31
 b(a)g(c)m(haracter)h(string)e(to)h(upp)s(ercase)e(\(op)s(erates)j(in)e
-(place\).)382 5694 y Ff(FTUPCH\(string\))p eop end
+(place\).)382 5714 y Ff(FTUPCH\(string\))p eop end
 %%Page: 70 76
-TeXDict begin 70 75 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.70) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(70)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fi(3)81 b Fj(Compare)43
-b(the)i(input)e(template)i(string)f(against)h(the)g(reference)f(string)
-g(to)h(see)g(if)f(they)g(matc)m(h.)82 b(The)227 668 y(template)36
+TeXDict begin 70 75 bop 0 299 a Fj(70)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)0 555 y Fi(3)81 b Fj(Compare)43 b(the)i(input)e
+(template)i(string)f(against)h(the)g(reference)f(string)g(to)h(see)g
+(if)f(they)g(matc)m(h.)82 b(The)227 668 y(template)36
 b(string)f(ma)m(y)g(con)m(tain)g(wildcard)f(c)m(haracters:)51
 b('*')35 b(will)g(matc)m(h)g(an)m(y)g(sequence)g(of)f(c)m(haracters)227
 781 y(\(including)j(zero)h(c)m(haracters\))g(and)e(')10
 b(?')60 b(will)38 b(matc)m(h)f(an)m(y)g(single)h(c)m(haracter)g(in)f
 (the)g(reference)g(string.)227 894 y(The)31 b('#')g(c)m(haracter)i
 (will)f(matc)m(h)g(an)m(y)f(consecutiv)m(e)j(string)d(of)g(decimal)h
 (digits)g(\(0)g(-)g(9\).)43 b(If)31 b(CASESN)f(=)227
 1007 y(.true.)45 b(then)31 b(the)g(matc)m(h)i(will)f(b)s(e)f(case)h
 (sensitiv)m(e.)46 b(The)31 b(returned)f(MA)-8 b(TCH)32
 b(parameter)g(will)g(b)s(e)f(.true.)227 1120 y(if)j(the)h(2)f(strings)g
 (matc)m(h,)j(and)c(EXA)m(CT)h(will)h(b)s(e)e(.true.)53
 b(if)34 b(the)g(matc)m(h)h(is)g(exact)g(\(i.e.,)i(if)d(no)g(wildcard)
 227 1233 y(c)m(haracters)e(w)m(ere)f(used)f(in)g(the)g(matc)m(h\).)42
 b(Both)31 b(strings)f(m)m(ust)h(b)s(e)e(68)j(c)m(haracters)f(or)g(less)
-f(in)g(length.)382 1505 y Ff(FTCMPS\(str_template,)42
-b(string,)k(casesen,)f(>)j(match,)e(exact\))0 1778 y
+f(in)g(length.)382 1507 y Ff(FTCMPS\(str_template,)42
+b(string,)k(casesen,)f(>)j(match,)e(exact\))0 1781 y
 Fi(4)81 b Fj(T)-8 b(est)31 b(that)g(the)f(k)m(eyw)m(ord)h(name)f(con)m
 (tains)i(only)e(legal)j(c)m(haracters:)42 b(A-Z,0-9,)32
-b(h)m(yphen,)d(and)h(underscore.)382 2051 y Ff(FTTKEY\(keyword,)43
-b(>)48 b(status\))0 2324 y Fi(5)81 b Fj(T)-8 b(est)31
+b(h)m(yphen,)d(and)h(underscore.)382 2054 y Ff(FTTKEY\(keyword,)43
+b(>)48 b(status\))0 2328 y Fi(5)81 b Fj(T)-8 b(est)31
 b(that)g(the)f(k)m(eyw)m(ord)h(record)f(con)m(tains)i(only)e(legal)i
-(prin)m(table)f(ASCI)s(I)e(c)m(haracters)382 2597 y Ff(FTTREC\(card,)44
-b(>)k(status\))0 2869 y Fi(6)81 b Fj(T)-8 b(est)25 b(whether)f(the)h
+(prin)m(table)f(ASCI)s(I)e(c)m(haracters)382 2602 y Ff(FTTREC\(card,)44
+b(>)k(status\))0 2876 y Fi(6)81 b Fj(T)-8 b(est)25 b(whether)f(the)h
 (curren)m(t)f(header)h(con)m(tains)g(an)m(y)g(NULL)g(\(ASCI)s(I)e(0\))j
 (c)m(haracters.)40 b(These)24 b(c)m(haracters)j(are)227
-2982 y(illegal)37 b(in)d(the)h(header,)g(but)f(they)g(will)h(go)g
+2989 y(illegal)37 b(in)d(the)h(header,)g(but)f(they)g(will)h(go)g
 (undetected)g(b)m(y)f(most)h(of)g(the)f(CFITSIO)f(k)m(eyw)m(ord)i
-(header)227 3095 y(routines,)29 b(b)s(ecause)f(the)h(n)m(ull)f(is)g(in)
+(header)227 3102 y(routines,)29 b(b)s(ecause)f(the)h(n)m(ull)f(is)g(in)
 m(terpreted)g(as)h(the)f(normal)g(end-of-string)h(terminator.)41
-b(This)27 b(routine)227 3208 y(returns)h(the)g(p)s(osition)h(of)g(the)g
+b(This)27 b(routine)227 3215 y(returns)h(the)g(p)s(osition)h(of)g(the)g
 (\014rst)f(n)m(ull)g(c)m(haracter)i(in)f(the)f(header,)h(or)g(zero)g
 (if)g(there)g(are)g(no)f(n)m(ulls.)40 b(F)-8 b(or)227
-3321 y(example)37 b(a)f(returned)f(v)-5 b(alue)37 b(of)f(110)h(w)m
+3328 y(example)37 b(a)f(returned)f(v)-5 b(alue)37 b(of)f(110)h(w)m
 (ould)f(indicate)h(that)g(the)f(\014rst)f(NULL)h(is)g(lo)s(cated)h(in)f
-(the)g(30th)227 3434 y(c)m(haracter)28 b(of)f(the)g(second)f(k)m(eyw)m
+(the)g(30th)227 3441 y(c)m(haracter)28 b(of)f(the)g(second)f(k)m(eyw)m
 (ord)h(in)f(the)h(header)f(\(recall)i(that)f(eac)m(h)h(header)e(record)
-h(is)f(80)h(c)m(haracters)227 3547 y(long\).)56 b(Note)36
+h(is)f(80)h(c)m(haracters)227 3554 y(long\).)56 b(Note)36
 b(that)g(this)f(is)g(one)g(of)g(the)g(few)g(FITSIO)f(routines)h(in)f
 (whic)m(h)h(the)g(returned)f(v)-5 b(alue)36 b(is)f(not)227
-3660 y(necessarily)d(equal)e(to)i(the)e(status)h(v)-5
-b(alue\).)382 3933 y Ff(FTNCHK\(unit,)44 b(>)k(status\))0
-4205 y Fi(7)81 b Fj(P)m(arse)27 b(a)f(header)h(k)m(eyw)m(ord)g(record)f
+3667 y(necessarily)d(equal)e(to)i(the)e(status)h(v)-5
+b(alue\).)382 3941 y Ff(FTNCHK\(unit,)44 b(>)k(status\))0
+4215 y Fi(7)81 b Fj(P)m(arse)27 b(a)f(header)h(k)m(eyw)m(ord)g(record)f
 (and)g(return)f(the)i(name)f(of)h(the)f(k)m(eyw)m(ord)h(and)f(the)h
-(length)f(of)h(the)g(name.)227 4318 y(The)34 b(k)m(eyw)m(ord)h(name)f
+(length)f(of)h(the)g(name.)227 4327 y(The)34 b(k)m(eyw)m(ord)h(name)f
 (normally)h(o)s(ccupies)f(the)h(\014rst)e(8)i(c)m(haracters)g(of)g(the)
-f(record,)i(except)f(under)e(the)227 4431 y(HIERAR)m(CH)e(con)m(v)m(en)
+f(record,)i(except)f(under)e(the)227 4440 y(HIERAR)m(CH)e(con)m(v)m(en)
 m(tion)h(where)e(the)h(name)f(can)h(b)s(e)f(up)f(to)i(70)g(c)m
-(haracters)h(in)e(length.)382 4704 y Ff(FTGKNM\(card,)44
+(haracters)h(in)e(length.)382 4714 y Ff(FTGKNM\(card,)44
 b(>)k(keyname,)d(keylength,)g(staThe)h('\\#')h(character)e(will)i
-(match)f(any)h(consecutive)e(string)191 4817 y(of)i(decimal)f(digits)g
-(\(0)h(-)h(9\).)f(tus\))0 5090 y Fi(8)81 b Fj(P)m(arse)34
+(match)f(any)h(consecutive)e(string)191 4827 y(of)i(decimal)f(digits)g
+(\(0)h(-)h(9\).)f(tus\))0 5101 y Fi(8)81 b Fj(P)m(arse)34
 b(a)h(header)f(k)m(eyw)m(ord)h(record.)52 b(This)33 b(subroutine)g
 (parses)h(the)g(input)g(header)g(record)g(to)h(return)e(the)227
-5203 y(v)-5 b(alue)27 b(\(as)g(a)g(c)m(haracter)g(string\))g(and)f
+5214 y(v)-5 b(alue)27 b(\(as)g(a)g(c)m(haracter)g(string\))g(and)f
 (commen)m(t)h(strings.)39 b(If)26 b(the)g(k)m(eyw)m(ord)h(has)f(no)g(v)
--5 b(alue)27 b(\(columns)f(9-10)227 5316 y(not)h(equal)f(to)h('=)f
+-5 b(alue)27 b(\(columns)f(9-10)227 5327 y(not)h(equal)f(to)h('=)f
 ('\),)i(then)e(the)g(v)-5 b(alue)27 b(string)f(is)g(returned)f(blank)h
 (and)f(the)h(commen)m(t)i(string)e(is)g(set)g(equal)227
-5428 y(to)31 b(column)g(9)f(-)h(80)g(of)g(the)f(input)g(string.)382
-5701 y Ff(FTPSVC\(card,)44 b(>)k(value,comment,status\))p
+5440 y(to)31 b(column)g(9)f(-)h(80)g(of)g(the)f(input)g(string.)382
+5714 y Ff(FTPSVC\(card,)44 b(>)k(value,comment,status\))p
 eop end
 %%Page: 71 77
-TeXDict begin 71 76 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.71) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.12.)73
-b(GENERAL)30 b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(71)0
-555 y Fi(9)81 b Fj(Construct)41 b(a)h(prop)s(erly)f(formated)h(80-c)m
-(haracter)i(header)e(k)m(eyw)m(ord)g(record)f(from)h(the)g(input)e(k)m
-(eyw)m(ord)227 668 y(name,)25 b(k)m(eyw)m(ord)f(v)-5
-b(alue,)25 b(and)e(k)m(eyw)m(ord)h(commen)m(t)g(strings.)38
-b(Hierarc)m(hical)26 b(k)m(eyw)m(ord)e(names)f(\(e.g.,)j("ESO)227
-781 y(TELE)e(CAM"\))i(are)f(supp)s(orted.)37 b(The)25
-b(v)-5 b(alue)25 b(string)g(ma)m(y)h(con)m(tain)g(an)f(in)m(teger,)i
-(\015oating)f(p)s(oin)m(t,)g(logical,)227 894 y(or)31
-b(quoted)f(c)m(haracter)i(string)e(\(e.g.,)j("12",)f("15.7",)h("T",)e
-(or)g("'NGC)g(1313'"\).)382 1153 y Ff(FTMKKY\(keyname,)43
-b(value,)k(comment,)e(>)j(card,)e(status\))0 1413 y Fi(10)g
-Fj(Construct)35 b(a)g(sequence)g(k)m(eyw)m(ord)g(name)g(\(R)m(OOT)g(+)f
-(nnn\).)54 b(This)34 b(subroutine)f(app)s(ends)g(the)j(sequence)227
-1526 y(n)m(um)m(b)s(er)29 b(to)i(the)g(ro)s(ot)g(string)f(to)h(create)h
-(a)f(k)m(eyw)m(ord)g(name)f(\(e.g.,)i('NAXIS')f(+)f(2)h(=)f('NAXIS2'\))
-382 1785 y Ff(FTKEYN\(keyroot,seq_no,)42 b(>)47 b(keyword,status\))0
-2045 y Fi(11)f Fj(Construct)30 b(a)g(sequence)g(k)m(eyw)m(ord)h(name)f
-(\(n)f(+)h(R)m(OOT\).)g(This)f(subroutine)g(concatenates)j(the)f
-(sequence)227 2158 y(n)m(um)m(b)s(er)20 b(to)j(the)e(fron)m(t)h(of)g
-(the)f(ro)s(ot)h(string)g(to)g(create)h(a)f(k)m(eyw)m(ord)g(name)g
-(\(e.g.,)j(1)d(+)f('CTYP')g(=)g('1CTYP'\))382 2417 y
-Ff(FTNKEY\(seq_no,keyroot,)42 b(>)47 b(keyword,status\))0
-2677 y Fi(12)f Fj(Determine)35 b(the)f(datat)m(yp)s(e)g(of)g(a)g(k)m
-(eyw)m(ord)h(v)-5 b(alue)34 b(string.)50 b(This)33 b(subroutine)g
-(parses)g(the)h(k)m(eyw)m(ord)g(v)-5 b(alue)227 2790
-y(string)31 b(\(usually)f(columns)g(11-30)j(of)d(the)h(header)f
-(record\))g(to)i(determine)e(its)h(datat)m(yp)s(e.)382
-3049 y Ff(FTDTYP\(value,)44 b(>)j(dtype,status\))0 3309
-y Fi(13)f Fj(Return)c(the)i(class)g(of)f(input)f(header)h(record.)79
-b(The)43 b(record)g(is)g(classi\014ed)g(in)m(to)h(one)g(of)f(the)g
+TeXDict begin 71 76 bop 0 299 a Fh(6.12.)73 b(GENERAL)30
+b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(71)0 555 y Fi(9)81
+b Fj(Construct)41 b(a)h(prop)s(erly)f(formated)h(80-c)m(haracter)i
+(header)e(k)m(eyw)m(ord)g(record)f(from)h(the)g(input)e(k)m(eyw)m(ord)
+227 668 y(name,)25 b(k)m(eyw)m(ord)f(v)-5 b(alue,)25
+b(and)e(k)m(eyw)m(ord)h(commen)m(t)g(strings.)38 b(Hierarc)m(hical)26
+b(k)m(eyw)m(ord)e(names)f(\(e.g.,)j("ESO)227 781 y(TELE)e(CAM"\))i(are)
+f(supp)s(orted.)37 b(The)25 b(v)-5 b(alue)25 b(string)g(ma)m(y)h(con)m
+(tain)g(an)f(in)m(teger,)i(\015oating)f(p)s(oin)m(t,)g(logical,)227
+894 y(or)31 b(quoted)f(c)m(haracter)i(string)e(\(e.g.,)j("12",)f
+("15.7",)h("T",)e(or)g("'NGC)g(1313'"\).)382 1153 y Ff
+(FTMKKY\(keyname,)43 b(value,)k(comment,)e(>)j(card,)e(status\))0
+1413 y Fi(10)g Fj(Construct)35 b(a)g(sequence)g(k)m(eyw)m(ord)g(name)g
+(\(R)m(OOT)g(+)f(nnn\).)54 b(This)34 b(subroutine)f(app)s(ends)g(the)j
+(sequence)227 1526 y(n)m(um)m(b)s(er)29 b(to)i(the)g(ro)s(ot)g(string)f
+(to)h(create)h(a)f(k)m(eyw)m(ord)g(name)f(\(e.g.,)i('NAXIS')f(+)f(2)h
+(=)f('NAXIS2'\))382 1785 y Ff(FTKEYN\(keyroot,seq_no,)42
+b(>)47 b(keyword,status\))0 2045 y Fi(11)f Fj(Construct)30
+b(a)g(sequence)g(k)m(eyw)m(ord)h(name)f(\(n)f(+)h(R)m(OOT\).)g(This)f
+(subroutine)g(concatenates)j(the)f(sequence)227 2158
+y(n)m(um)m(b)s(er)20 b(to)j(the)e(fron)m(t)h(of)g(the)f(ro)s(ot)h
+(string)g(to)g(create)h(a)f(k)m(eyw)m(ord)g(name)g(\(e.g.,)j(1)d(+)f
+('CTYP')g(=)g('1CTYP'\))382 2417 y Ff(FTNKEY\(seq_no,keyroot,)42
+b(>)47 b(keyword,status\))0 2677 y Fi(12)f Fj(Determine)35
+b(the)f(datat)m(yp)s(e)g(of)g(a)g(k)m(eyw)m(ord)h(v)-5
+b(alue)34 b(string.)50 b(This)33 b(subroutine)g(parses)g(the)h(k)m(eyw)
+m(ord)g(v)-5 b(alue)227 2790 y(string)31 b(\(usually)f(columns)g(11-30)
+j(of)d(the)h(header)f(record\))g(to)i(determine)e(its)h(datat)m(yp)s
+(e.)382 3049 y Ff(FTDTYP\(value,)44 b(>)j(dtype,status\))0
+3309 y Fi(13)f Fj(Return)c(the)i(class)g(of)f(input)f(header)h(record.)
+79 b(The)43 b(record)g(is)g(classi\014ed)g(in)m(to)h(one)g(of)f(the)g
 (follo)m(wing)227 3422 y(categories)36 b(\(the)e(class)f(v)-5
 b(alues)34 b(are)f(de\014ned)f(in)h(\014tsio.h\).)49
 b(Note)35 b(that)e(this)g(is)g(one)h(of)f(the)g(few)g(FITSIO)227
 3535 y(routines)e(that)f(do)s(es)h(not)f(return)f(a)i(status)g(v)-5
 b(alue.)334 3794 y Ff(Class)94 b(Value)619 b(Keywords)95
 3907 y(TYP_STRUC_KEY)92 b(10)j(SIMPLE,)46 b(BITPIX,)g(NAXIS,)g(NAXISn,)
 g(EXTEND,)g(BLOCKED,)1002 4020 y(GROUPS,)g(PCOUNT,)g(GCOUNT,)g(END)1002
@@ -12551,50 +9942,37 @@
 b(TUNITn)95 5375 y(TYP_DISP_KEY)140 b(80)95 b(TDISPn)95
 5488 y(TYP_HDUID_KEY)d(90)j(EXTNAME,)46 b(EXTVER,)g(EXTLEVEL,)f
 (HDUNAME,)g(HDUVER,)h(HDULEVEL)95 5601 y(TYP_CKSUM_KEY)f(100)94
 b(CHECKSUM,)46 b(DATASUM)95 5714 y(TYP_WCS_KEY)141 b(110)94
 b(CTYPEn,)46 b(CUNITn,)g(CRVALn,)g(CRPIXn,)g(CROTAn,)f(CDELTn)p
 eop end
 %%Page: 72 78
-TeXDict begin 72 77 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.72) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(72)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)1002 555 y Ff(CDj_is,)46
-b(PVj_ms,)g(LONPOLEs,)f(LATPOLEs)1002 668 y(TCTYPn,)h(TCTYns,)g
-(TCUNIn,)g(TCUNns,)g(TCRVLn,)f(TCRVns,)h(TCRPXn,)1002
-781 y(TCRPks,)g(TCDn_k,)g(TCn_ks,)g(TPVn_m,)g(TPn_ms,)f(TCDLTn,)h
-(TCROTn)1002 894 y(jCTYPn,)g(jCTYns,)g(jCUNIn,)g(jCUNns,)g(jCRVLn,)f
-(jCRVns,)h(iCRPXn,)1002 1007 y(iCRPns,)g(jiCDn,)94 b(jiCDns,)46
-b(jPVn_m,)g(jPn_ms,)f(jCDLTn,)h(jCROTn)1002 1120 y(\(i,j,m,n)g(are)h
-(integers,)e(s)i(is)h(any)f(letter\))95 1233 y(TYP_REFSYS_KEY)d(120)j
-(EQUINOXs,)f(EPOCH,)g(MJD-OBSs,)f(RADECSYS,)g(RADESYSs)95
-1346 y(TYP_COMM_KEY)140 b(130)47 b(COMMENT,)f(HISTORY,)f(\(blank)h
-(keyword\))95 1458 y(TYP_CONT_KEY)140 b(140)47 b(CONTINUE)95
-1571 y(TYP_USER_KEY)140 b(150)47 b(all)g(other)g(keywords)430
-1797 y(class)f(=)h(FTGKCL)f(\(char)h(*card\))0 2042 y
-Fi(14)f Fj(P)m(arse)f(the)g('TF)m(ORM')h(binary)e(table)i(column)e
-(format)h(string.)84 b(This)44 b(subroutine)g(parses)g(the)h(input)227
-2155 y(TF)m(ORM)27 b(c)m(haracter)g(string)f(and)g(returns)f(the)h(in)m
-(teger)h(datat)m(yp)s(e)g(co)s(de,)h(the)e(rep)s(eat)g(coun)m(t)h(of)f
-(the)g(\014eld,)227 2268 y(and,)f(in)e(the)h(case)g(of)g(c)m(haracter)h
-(string)e(\014elds,)i(the)e(length)h(of)g(the)g(unit)f(string.)38
-b(The)23 b(follo)m(wing)i(datat)m(yp)s(e)227 2381 y(co)s(des)e(are)h
-(returned)e(\(the)h(negativ)m(e)i(of)f(the)f(v)-5 b(alue)23
-b(is)g(returned)f(if)h(the)g(column)g(con)m(tains)h(v)-5
+TeXDict begin 72 77 bop 0 299 a Fj(72)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)1002 555 y Ff(CDj_is,)46 b(PVj_ms,)g(LONPOLEs,)f
+(LATPOLEs)1002 668 y(TCTYPn,)h(TCTYns,)g(TCUNIn,)g(TCUNns,)g(TCRVLn,)f
+(TCRVns,)h(TCRPXn,)1002 781 y(TCRPks,)g(TCDn_k,)g(TCn_ks,)g(TPVn_m,)g
+(TPn_ms,)f(TCDLTn,)h(TCROTn)1002 894 y(jCTYPn,)g(jCTYns,)g(jCUNIn,)g
+(jCUNns,)g(jCRVLn,)f(jCRVns,)h(iCRPXn,)1002 1007 y(iCRPns,)g(jiCDn,)94
+b(jiCDns,)46 b(jPVn_m,)g(jPn_ms,)f(jCDLTn,)h(jCROTn)1002
+1120 y(\(i,j,m,n)g(are)h(integers,)e(s)i(is)h(any)f(letter\))95
+1233 y(TYP_REFSYS_KEY)d(120)j(EQUINOXs,)f(EPOCH,)g(MJD-OBSs,)f
+(RADECSYS,)g(RADESYSs)95 1346 y(TYP_COMM_KEY)140 b(130)47
+b(COMMENT,)f(HISTORY,)f(\(blank)h(keyword\))95 1458 y(TYP_CONT_KEY)140
+b(140)47 b(CONTINUE)95 1571 y(TYP_USER_KEY)140 b(150)47
+b(all)g(other)g(keywords)430 1797 y(class)f(=)h(FTGKCL)f(\(char)h
+(*card\))0 2042 y Fi(14)f Fj(P)m(arse)f(the)g('TF)m(ORM')h(binary)e
+(table)i(column)e(format)h(string.)84 b(This)44 b(subroutine)g(parses)g
+(the)h(input)227 2155 y(TF)m(ORM)27 b(c)m(haracter)g(string)f(and)g
+(returns)f(the)h(in)m(teger)h(datat)m(yp)s(e)g(co)s(de,)h(the)e(rep)s
+(eat)g(coun)m(t)h(of)f(the)g(\014eld,)227 2268 y(and,)f(in)e(the)h
+(case)g(of)g(c)m(haracter)h(string)e(\014elds,)i(the)e(length)h(of)g
+(the)g(unit)f(string.)38 b(The)23 b(follo)m(wing)i(datat)m(yp)s(e)227
+2381 y(co)s(des)e(are)h(returned)e(\(the)h(negativ)m(e)i(of)f(the)f(v)
+-5 b(alue)23 b(is)g(returned)f(if)h(the)g(column)g(con)m(tains)h(v)-5
 b(ariable-length)227 2494 y(arra)m(ys\):)764 2739 y Ff(Datatype)761
 b(DATACODE)46 b(value)764 2852 y(bit,)g(X)907 b(1)764
 2965 y(byte,)46 b(B)811 b(11)764 3078 y(logical,)45 b(L)668
 b(14)764 3191 y(ASCII)46 b(character,)f(A)286 b(16)764
 3304 y(short)46 b(integer,)g(I)381 b(21)764 3417 y(integer,)45
 b(J)668 b(41)764 3530 y(real,)46 b(E)811 b(42)764 3643
 y(double)46 b(precision,)f(D)238 b(82)764 3756 y(complex)809
@@ -12623,31 +10001,19 @@
 (inclusiv)m(e.)47 b(Wider)32 b('F')h(columns)f(will)h(return)e(a)i
 (double)f(precision)g(data)h(co)s(de)g(\(=)227 5356 y(82\).)54
 b('Ew.d')34 b(format)g(columns)g(will)h(ha)m(v)m(e)g(dataco)s(de)g(=)f
 (42,)j(and)c('Dw.d')i(format)f(columns)g(will)h(ha)m(v)m(e)227
 5469 y(dataco)s(de)d(=)e(82.)382 5714 y Ff(FTASFM\(tform,)44
 b(>)j(datacode,width,decimals,st)o(atus)o(\))p eop end
 %%Page: 73 79
-TeXDict begin 73 78 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.73) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.12.)73
-b(GENERAL)30 b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(73)0
-555 y Fi(16)46 b Fj(Calculate)32 b(the)f(starting)g(column)g(p)s
-(ositions)f(and)g(total)i(ASCI)s(I)d(table)j(width)d(based)i(on)f(the)h
-(input)e(arra)m(y)227 668 y(of)e(ASCI)s(I)e(table)i(TF)m(ORM)g(v)-5
+TeXDict begin 73 78 bop 0 299 a Fh(6.12.)73 b(GENERAL)30
+b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(73)0 555 y Fi(16)46
+b Fj(Calculate)32 b(the)f(starting)g(column)g(p)s(ositions)f(and)g
+(total)i(ASCI)s(I)d(table)j(width)d(based)i(on)f(the)h(input)e(arra)m
+(y)227 668 y(of)e(ASCI)s(I)e(table)i(TF)m(ORM)g(v)-5
 b(alues.)40 b(The)26 b(SP)-8 b(A)m(CE)27 b(input)e(parameter)i
 (de\014nes)f(ho)m(w)h(man)m(y)f(blank)h(spaces)227 781
 y(to)40 b(lea)m(v)m(e)i(b)s(et)m(w)m(een)e(eac)m(h)g(column)g(\(it)g
 (is)f(recommended)g(to)h(ha)m(v)m(e)h(one)e(space)h(b)s(et)m(w)m(een)g
 (columns)f(for)227 894 y(b)s(etter)31 b(h)m(uman)e(readabilit)m(y\).)
 382 1153 y Ff(FTGABC\(tfields,tform,spa)o(ce,)41 b(>)48
 b(rowlen,tbcol,status\))0 1413 y Fi(17)e Fj(P)m(arse)36
@@ -12711,31 +10077,19 @@
 (e)f(deleted)i(from)e(the)h(FITS)f(header.)0 5601 y Fi(-)80
 b Fj(The)40 b(second)g(exception)h(is)f(that)h(if)f(the)g(template)h
 (string)f(starts)g(with)g(a)h(min)m(us)e(sign)h(and)f(is)h(follo)m(w)m
 (ed)227 5714 y(b)m(y)33 b(2)g(tok)m(ens)g(then)g(the)f(second)h(tok)m
 (en)h(is)e(in)m(terpreted)h(as)g(the)g(new)f(name)g(for)h(the)g(k)m
 (eyw)m(ord)g(sp)s(eci\014ed)p eop end
 %%Page: 74 80
-TeXDict begin 74 79 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.74) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(74)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)227 555 y Fj(b)m(y)k(\014rst)e(tok)m(en.)
-52 b(In)33 b(this)g(case)i(the)e(old)h(k)m(eyw)m(ord)g(name)g
-(\(\014rst)f(tok)m(en\))i(is)e(returned)g(in)g(c)m(haracters)i(1-8)227
+TeXDict begin 74 79 bop 0 299 a Fj(74)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)227 555 y Fj(b)m(y)k(\014rst)e(tok)m(en.)52
+b(In)33 b(this)g(case)i(the)e(old)h(k)m(eyw)m(ord)g(name)g(\(\014rst)f
+(tok)m(en\))i(is)e(returned)g(in)g(c)m(haracters)i(1-8)227
 668 y(of)e(the)g(returned)e(CARD)i(string,)g(and)f(the)h(new)f(k)m(eyw)
 m(ord)h(name)g(\(the)g(second)f(tok)m(en\))i(is)f(returned)e(in)227
 781 y(c)m(haracters)c(41-48)h(of)e(the)f(returned)g(CARD)g(string.)40
 b(These)25 b(old)h(and)f(new)g(names)g(ma)m(y)h(then)f(b)s(e)g(passed)
 227 894 y(to)31 b(the)g(FTMNAM)g(subroutine)f(whic)m(h)g(will)g(c)m
 (hange)i(the)e(k)m(eyw)m(ord)h(name.)0 1158 y(The)f(HDTYPE)g(output)g
 (parameter)h(indicates)g(ho)m(w)g(the)f(returned)g(CARD)g(string)g
@@ -12777,79 +10131,36 @@
 (ro)m(w)g(ranges,)h(and)e(return)g(in)m(teger)i(arra)m(ys)f(con-)227
 5601 y(taining)27 b(the)f(\014rst)f(and)g(last)i(ro)m(w)f(in)f(eac)m(h)
 i(range.)40 b(F)-8 b(or)26 b(example,)i(if)d(ro)m(wlist)i(=)e("3-5,)k
 (6,)e(8-9")h(then)d(it)i(will)227 5714 y(return)34 b(n)m(umranges)h(=)g
 (3,)h(rangemin)f(=)g(3,)i(6,)g(8)e(and)g(rangemax)g(=)g(5,)i(6,)g(9.)55
 b(A)m(t)36 b(most,)h('maxranges')p eop end
 %%Page: 75 81
-TeXDict begin 75 80 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.75) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(6.12.)73
-b(GENERAL)30 b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(75)227
-555 y(n)m(um)m(b)s(er)31 b(of)h(ranges)f(will)h(b)s(e)g(returned.)43
-b('maxro)m(ws')32 b(is)g(the)g(maxim)m(um)g(n)m(um)m(b)s(er)e(of)i(ro)m
-(ws)g(in)f(the)h(table;)227 668 y(an)m(y)e(ro)m(ws)f(or)g(ranges)g
-(larger)h(than)f(this)g(will)g(b)s(e)g(ignored.)40 b(The)29
-b(ro)m(ws)g(m)m(ust)g(b)s(e)f(sp)s(eci\014ed)h(in)f(increasing)227
-781 y(order,)33 b(and)f(the)g(ranges)h(m)m(ust)f(not)g(o)m(v)m(erlap.)
-48 b(A)33 b(min)m(us)e(sign)i(ma)m(y)g(b)s(e)e(use)h(to)h(sp)s(ecify)f
+TeXDict begin 75 80 bop 0 299 a Fh(6.12.)73 b(GENERAL)30
+b(UTILITY)g(SUBR)m(OUTINES)1979 b Fj(75)227 555 y(n)m(um)m(b)s(er)31
+b(of)h(ranges)f(will)h(b)s(e)g(returned.)43 b('maxro)m(ws')32
+b(is)g(the)g(maxim)m(um)g(n)m(um)m(b)s(er)e(of)i(ro)m(ws)g(in)f(the)h
+(table;)227 668 y(an)m(y)e(ro)m(ws)f(or)g(ranges)g(larger)h(than)f
+(this)g(will)g(b)s(e)g(ignored.)40 b(The)29 b(ro)m(ws)g(m)m(ust)g(b)s
+(e)f(sp)s(eci\014ed)h(in)f(increasing)227 781 y(order,)33
+b(and)f(the)g(ranges)h(m)m(ust)f(not)g(o)m(v)m(erlap.)48
+b(A)33 b(min)m(us)e(sign)i(ma)m(y)g(b)s(e)e(use)h(to)h(sp)s(ecify)f
 (all)h(the)g(ro)m(ws)f(to)227 894 y(the)h(upp)s(er)d(or)j(lo)m(w)m(er)h
 (b)s(ound,)d(so)i("50-")h(means)e(all)i(the)f(ro)m(ws)f(from)g(50)h(to)
 h(the)e(end)g(of)h(the)f(table,)j(and)227 1007 y("-")d(means)e(all)h
 (the)g(ro)m(ws)f(in)g(the)h(table,)g(from)f(1)h(-)g(maxro)m(ws.)191
 1267 y Ff(FTRWRG\(rowlist,)44 b(maxrows,)h(maxranges,)g(>)525
 1380 y(numranges,)g(rangemin,)g(rangemax,)h(status\))p
 eop end
 %%Page: 76 82
-TeXDict begin 76 81 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.76) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(76)1319
-b Fh(CHAPTER)29 b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10
-b(A)m(CE)30 b(SUBR)m(OUTINES)p eop end
+TeXDict begin 76 81 bop 0 299 a Fj(76)1319 b Fh(CHAPTER)29
+b(6.)112 b(AD)m(V)-10 b(ANCED)32 b(INTERF)-10 b(A)m(CE)30
+b(SUBR)m(OUTINES)p eop end
 %%Page: 77 83
-TeXDict begin 77 82 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.77) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0
-464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.7) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(7)0
+TeXDict begin 77 82 bop 0 1225 a Fg(Chapter)65 b(7)0
 1687 y Fm(The)77 b(CFITSIO)f(Iterator)i(F)-19 b(unction)0
 2180 y Fj(The)41 b(\014ts)p 325 2180 28 4 v 33 w(iterate)p
 614 2180 V 34 w(data)i(function)e(in)h(CFITSIO)e(pro)m(vides)i(a)g
 (unique)e(metho)s(d)i(of)g(executing)h(an)e(arbitrary)0
 2293 y(user-supplied)35 b(`w)m(ork')i(function)f(that)h(op)s(erates)g
 (on)g(ro)m(ws)f(of)h(data)g(in)f(FITS)g(tables)h(or)f(on)h(pixels)f(in)
 h(FITS)0 2406 y(images.)i(Rather)24 b(than)e(explicitly)j(reading)e
@@ -12904,92 +10215,52 @@
 (2)g(steps)e(in)h(using)f(the)h(CFITSIO)e(iterator)j(function.)42
 b(The)30 b(\014rst)g(step)h(is)g(to)g(design)g(the)0
 5714 y(w)m(ork)26 b(function)f(itself)h(whic)m(h)f(m)m(ust)h(ha)m(v)m
 (e)g(a)g(prescrib)s(ed)e(set)i(of)g(input)f(parameters.)39
 b(One)25 b(of)h(these)g(parameters)1905 5942 y(77)p eop
 end
 %%Page: 78 84
-TeXDict begin 78 83 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.78) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(78)1455
-b Fh(CHAPTER)30 b(7.)112 b(THE)30 b(CFITSIO)e(ITERA)-8
-b(TOR)30 b(FUNCTION)0 555 y Fj(is)f(a)g(structure)g(con)m(taining)i(p)s
-(oin)m(ters)d(to)i(the)f(arra)m(ys)h(of)f(data;)h(the)f(w)m(ork)h
-(function)e(can)i(p)s(erform)d(an)m(y)i(desired)0 668
-y(op)s(erations)k(on)h(these)f(arra)m(ys)h(and)e(do)s(es)h(not)g(need)g
-(to)h(w)m(orry)f(ab)s(out)g(ho)m(w)g(the)h(input)e(data)i(w)m(ere)f
-(read)g(from)0 781 y(the)e(\014le)f(or)g(ho)m(w)h(the)f(output)g(data)h
-(get)h(written)e(bac)m(k)h(to)h(the)e(\014le.)0 941 y(The)24
-b(second)h(step)g(is)f(to)i(design)e(the)h(driv)m(er)g(routine)f(that)i
-(op)s(ens)e(all)h(the)g(necessary)g(FITS)f(\014les)h(and)f(initializes)
-0 1054 y(the)41 b(input)g(parameters)g(to)h(the)g(iterator)g(function.)
-73 b(The)41 b(driv)m(er)g(program)g(calls)h(the)g(CFITSIO)e(iterator)0
-1167 y(function)30 b(whic)m(h)g(then)g(reads)g(the)h(data)g(and)f
-(passes)g(it)h(to)g(the)g(user's)e(w)m(ork)i(function.)0
-1327 y(F)-8 b(urther)41 b(details)i(on)f(using)f(the)h(iterator)h
-(function)f(can)g(b)s(e)f(found)f(in)i(the)g(companion)g(CFITSIO)e
-(User's)0 1440 y(Guide,)31 b(and)e(in)h(the)h(iter)p
+TeXDict begin 78 83 bop 0 299 a Fj(78)1455 b Fh(CHAPTER)30
+b(7.)112 b(THE)30 b(CFITSIO)e(ITERA)-8 b(TOR)30 b(FUNCTION)0
+555 y Fj(is)f(a)g(structure)g(con)m(taining)i(p)s(oin)m(ters)d(to)i
+(the)f(arra)m(ys)h(of)f(data;)h(the)f(w)m(ork)h(function)e(can)i(p)s
+(erform)d(an)m(y)i(desired)0 668 y(op)s(erations)k(on)h(these)f(arra)m
+(ys)h(and)e(do)s(es)h(not)g(need)g(to)h(w)m(orry)f(ab)s(out)g(ho)m(w)g
+(the)h(input)e(data)i(w)m(ere)f(read)g(from)0 781 y(the)e(\014le)f(or)g
+(ho)m(w)h(the)f(output)g(data)h(get)h(written)e(bac)m(k)h(to)h(the)e
+(\014le.)0 941 y(The)24 b(second)h(step)g(is)f(to)i(design)e(the)h
+(driv)m(er)g(routine)f(that)i(op)s(ens)e(all)h(the)g(necessary)g(FITS)f
+(\014les)h(and)f(initializes)0 1054 y(the)41 b(input)g(parameters)g(to)
+h(the)g(iterator)g(function.)73 b(The)41 b(driv)m(er)g(program)g(calls)
+h(the)g(CFITSIO)e(iterator)0 1167 y(function)30 b(whic)m(h)g(then)g
+(reads)g(the)h(data)g(and)f(passes)g(it)h(to)g(the)g(user's)e(w)m(ork)i
+(function.)0 1327 y(F)-8 b(urther)41 b(details)i(on)f(using)f(the)h
+(iterator)h(function)f(can)g(b)s(e)f(found)f(in)i(the)g(companion)g
+(CFITSIO)e(User's)0 1440 y(Guide,)31 b(and)e(in)h(the)h(iter)p
 874 1440 28 4 v 33 w(a.f,)g(iter)p 1197 1440 V 34 w(b.f)f(and)f(iter)p
 1677 1440 V 34 w(c.f)h(example)h(programs.)p eop end
 %%Page: 79 85
-TeXDict begin 79 84 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.79) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a 0
-464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.8) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(8)0
+TeXDict begin 79 84 bop 0 1225 a Fg(Chapter)65 b(8)0
 1687 y Fm(Extended)77 b(File)g(Name)g(Syn)-6 b(tax)0
-2060 y
-SDict begin H.S end
- 0 2060 a 0 2060 a
-SDict begin 13.6 H.A end
- 0 2060 a 0 2060 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.1) cvn /DEST pdfmark
-end
- 0 2060 a 156
-x Fe(8.1)135 b(Ov)l(erview)0 2466 y Fj(CFITSIO)30 b(supp)s(orts)f(an)j
-(extended)f(syn)m(tax)h(when)f(sp)s(ecifying)g(the)h(name)f(of)h(the)g
-(data)g(\014le)f(to)h(b)s(e)f(op)s(ened)g(or)0 2579 y(created)g(that)g
-(includes)f(the)h(follo)m(wing)h(features:)136 2813 y
-Fd(\017)46 b Fj(CFITSIO)40 b(can)i(read)f(IRAF)h(format)g(images)g
-(whic)m(h)f(ha)m(v)m(e)i(header)e(\014le)h(names)f(that)h(end)f(with)g
-(the)227 2926 y('.imh')d(extension,)i(as)e(w)m(ell)g(as)g(reading)f
-(and)g(writing)g(FITS)g(\014les,)i(This)e(feature)h(is)f(implemen)m
-(ted)h(in)227 3039 y(CFITSIO)29 b(b)m(y)i(\014rst)e(con)m(v)m(erting)k
-(the)d(IRAF)h(image)h(in)m(to)f(a)g(temp)s(orary)f(FITS)g(format)h
-(\014le)f(in)g(memory)-8 b(,)227 3152 y(then)35 b(op)s(ening)f(the)h
-(FITS)f(\014le.)54 b(An)m(y)35 b(of)g(the)g(usual)f(CFITSIO)g(routines)
-g(then)h(ma)m(y)g(b)s(e)f(used)g(to)i(read)227 3265 y(the)31
-b(image)g(header)f(or)h(data.)41 b(Similarly)-8 b(,)31
-b(ra)m(w)f(binary)g(data)h(arra)m(ys)f(can)h(b)s(e)f(read)g(b)m(y)g
-(con)m(v)m(erting)i(them)227 3378 y(on)f(the)f(\015y)g(in)m(to)h
+2216 y Fe(8.1)135 b(Ov)l(erview)0 2466 y Fj(CFITSIO)30
+b(supp)s(orts)f(an)j(extended)f(syn)m(tax)h(when)f(sp)s(ecifying)g(the)
+h(name)f(of)h(the)g(data)g(\014le)f(to)h(b)s(e)f(op)s(ened)g(or)0
+2579 y(created)g(that)g(includes)f(the)h(follo)m(wing)h(features:)136
+2813 y Fd(\017)46 b Fj(CFITSIO)40 b(can)i(read)f(IRAF)h(format)g
+(images)g(whic)m(h)f(ha)m(v)m(e)i(header)e(\014le)h(names)f(that)h(end)
+f(with)g(the)227 2926 y('.imh')d(extension,)i(as)e(w)m(ell)g(as)g
+(reading)f(and)g(writing)g(FITS)g(\014les,)i(This)e(feature)h(is)f
+(implemen)m(ted)h(in)227 3039 y(CFITSIO)29 b(b)m(y)i(\014rst)e(con)m(v)
+m(erting)k(the)d(IRAF)h(image)h(in)m(to)f(a)g(temp)s(orary)f(FITS)g
+(format)h(\014le)f(in)g(memory)-8 b(,)227 3152 y(then)35
+b(op)s(ening)f(the)h(FITS)f(\014le.)54 b(An)m(y)35 b(of)g(the)g(usual)f
+(CFITSIO)g(routines)g(then)h(ma)m(y)g(b)s(e)f(used)g(to)i(read)227
+3265 y(the)31 b(image)g(header)f(or)h(data.)41 b(Similarly)-8
+b(,)31 b(ra)m(w)f(binary)g(data)h(arra)m(ys)f(can)h(b)s(e)f(read)g(b)m
+(y)g(con)m(v)m(erting)i(them)227 3378 y(on)f(the)f(\015y)g(in)m(to)h
 (virtual)g(FITS)f(images.)136 3557 y Fd(\017)46 b Fj(FITS)37
 b(\014les)g(on)g(the)g(In)m(ternet)h(can)f(b)s(e)g(read)g(\(and)g
 (sometimes)h(written\))f(using)g(the)g(FTP)-8 b(,)38
 b(HTTP)-8 b(,)37 b(or)227 3670 y(R)m(OOT)30 b(proto)s(cols.)136
 3849 y Fd(\017)46 b Fj(FITS)30 b(\014les)g(can)h(b)s(e)f(pip)s(ed)f(b)s
 (et)m(w)m(een)i(tasks)f(on)h(the)f(stdin)g(and)g(stdout)g(streams.)136
 4028 y Fd(\017)46 b Fj(FITS)20 b(\014les)h(can)g(b)s(e)f(read)g(and)g
@@ -13019,30 +10290,18 @@
 (binning)g(the)g(v)-5 b(alues)27 b(in)f(table)i(columns,)f(resulting)
 227 5601 y(in)36 b(a)g(virtual)h(N-dimensional)f(FITS)g(image.)59
 b(The)35 b(application)i(program)f(then)g(only)g(sees)g(the)h(FITS)227
 5714 y(image)32 b(\(in)e(the)h(primary)e(arra)m(y\))j(instead)e(of)h
 (the)f(original)i(FITS)d(table.)1905 5942 y(79)p eop
 end
 %%Page: 80 86
-TeXDict begin 80 85 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.80) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(80)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(The)43 b(latter)i(3)f(features)g(in)f(particular)h(add)
-f(v)m(ery)h(p)s(o)m(w)m(erful)f(data)h(pro)s(cessing)f(capabilities)j
+TeXDict begin 80 85 bop 0 299 a Fj(80)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(The)43 b(latter)i(3)f(features)g(in)f(particular)h(add)f(v)m
+(ery)h(p)s(o)m(w)m(erful)f(data)h(pro)s(cessing)f(capabilities)j
 (directly)e(in)m(to)0 668 y(CFITSIO,)29 b(and)g(hence)h(in)m(to)h(ev)m
 (ery)f(task)h(that)f(uses)g(CFITSIO)e(to)j(read)f(or)g(write)g(FITS)f
 (\014les.)40 b(F)-8 b(or)31 b(example,)0 781 y(these)d(features)f
 (transform)f(a)i(v)m(ery)f(simple)g(program)g(that)h(just)f(copies)h
 (an)f(input)f(FITS)g(\014le)h(to)h(a)g(new)e(output)0
 894 y(\014le)36 b(\(lik)m(e)h(the)f(`\014tscop)m(y')h(program)f(that)g
 (is)g(distributed)f(with)g(CFITSIO\))g(in)m(to)i(a)f(m)m(ultipurp)s
@@ -13115,43 +10374,31 @@
 Ff('myfile.fits[3;)e(Images\(10\)]')p Fj(:)49 b(op)s(ens)35
 b(a)i(cop)m(y)g(of)f(the)g(image)i(con)m(tained)f(in)f(the)h(10th)f(ro)
 m(w)h(of)227 5601 y(the)26 b('Images')i(column)d(in)h(the)g(binary)g
 (table)g(in)g(the)g(3th)h(extension)f(of)g(the)h(FITS)e(\014le.)39
 b(The)26 b(application)227 5714 y(just)k(sees)h(this)f(single)h(image)h
 (as)e(the)h(primary)e(arra)m(y)-8 b(.)p eop end
 %%Page: 81 87
-TeXDict begin 81 86 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.81) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.1.)72
-b(O)m(VER)-10 b(VIEW)3086 b Fj(81)136 555 y Fd(\017)46
-b Ff('myfile.fits[1:512:2,)c(1:512:2]')p Fj(:)49 b(op)s(ens)35
-b(a)h(section)h(of)e(the)h(input)f(image)i(ranging)f(from)f(the)227
-668 y(1st)26 b(to)g(the)f(512th)h(pixel)g(in)e(X)i(and)e(Y,)i(and)e
-(selects)j(ev)m(ery)e(second)h(pixel)f(in)g(b)s(oth)f(dimensions,)i
-(resulting)227 781 y(in)k(a)h(256)h(x)e(256)i(pixel)e(image)i(in)e
-(this)g(case.)136 981 y Fd(\017)46 b Ff('myfile.fits[EVENTS][col)41
-b(Rad)47 b(=)h(sqrt\(X**2)d(+)j(Y**2\)]')p Fj(:)38 b(creates)30
-b(and)f(op)s(ens)f(a)h(temp)s(orary)227 1094 y(\014le)f(on)f(the)g
-(\015y)g(\(in)g(memory)g(or)g(on)h(disk\))f(that)g(is)h(iden)m(tical)h
-(to)f(m)m(y\014le.\014ts)f(except)h(that)g(it)g(will)g(con)m(tain)227
-1207 y(a)41 b(new)f(column)g(in)h(the)f(EVENTS)g(extension)h(called)h
-('Rad')f(whose)f(v)-5 b(alue)41 b(is)f(computed)h(using)f(the)227
-1320 y(indicated)31 b(expression)f(whic)m(h)g(is)h(a)g(function)f(of)g
-(the)h(v)-5 b(alues)30 b(in)h(the)f(X)h(and)e(Y)i(columns.)136
-1520 y Fd(\017)46 b Ff('myfile.fits[EVENTS][PHA)41 b(>)48
+TeXDict begin 81 86 bop 0 299 a Fh(8.1.)72 b(O)m(VER)-10
+b(VIEW)3086 b Fj(81)136 555 y Fd(\017)46 b Ff('myfile.fits[1:512:2,)c
+(1:512:2]')p Fj(:)49 b(op)s(ens)35 b(a)h(section)h(of)e(the)h(input)f
+(image)i(ranging)f(from)f(the)227 668 y(1st)26 b(to)g(the)f(512th)h
+(pixel)g(in)e(X)i(and)e(Y,)i(and)e(selects)j(ev)m(ery)e(second)h(pixel)
+f(in)g(b)s(oth)f(dimensions,)i(resulting)227 781 y(in)k(a)h(256)h(x)e
+(256)i(pixel)e(image)i(in)e(this)g(case.)136 981 y Fd(\017)46
+b Ff('myfile.fits[EVENTS][col)41 b(Rad)47 b(=)h(sqrt\(X**2)d(+)j
+(Y**2\)]')p Fj(:)38 b(creates)30 b(and)f(op)s(ens)f(a)h(temp)s(orary)
+227 1094 y(\014le)f(on)f(the)g(\015y)g(\(in)g(memory)g(or)g(on)h
+(disk\))f(that)g(is)h(iden)m(tical)h(to)f(m)m(y\014le.\014ts)f(except)h
+(that)g(it)g(will)g(con)m(tain)227 1207 y(a)41 b(new)f(column)g(in)h
+(the)f(EVENTS)g(extension)h(called)h('Rad')f(whose)f(v)-5
+b(alue)41 b(is)f(computed)h(using)f(the)227 1320 y(indicated)31
+b(expression)f(whic)m(h)g(is)h(a)g(function)f(of)g(the)h(v)-5
+b(alues)30 b(in)h(the)f(X)h(and)e(Y)i(columns.)136 1520
+y Fd(\017)46 b Ff('myfile.fits[EVENTS][PHA)41 b(>)48
 b(5]')p Fj(:)37 b(creates)27 b(and)e(op)s(ens)g(a)h(temp)s(orary)f
 (FITS)g(\014les)g(that)h(is)g(iden)m(ti-)227 1633 y(cal)k(to)g('m)m
 (y\014le.\014ts')f(except)h(that)f(the)g(EVENTS)f(table)i(will)f(only)g
 (con)m(tain)h(the)f(ro)m(ws)g(that)h(ha)m(v)m(e)g(v)-5
 b(alues)227 1746 y(of)28 b(the)g(PHA)f(column)g(greater)i(than)e(5.)40
 b(In)27 b(general,)i(an)m(y)f(arbitrary)f(b)s(o)s(olean)h(expression)f
 (using)g(a)h(C)f(or)227 1859 y(F)-8 b(ortran-lik)m(e)31
@@ -13197,62 +10444,42 @@
 (primary)h(array)g(or)i(image)e(HDU:)143 5375 y
 (filetype://BaseFilename\(o)o(utNa)o(me\))o([HDU)o(loca)o(tio)o(n][I)o
 (mage)o(Sec)o(tion)o(])0 5601 y(When)h(opening)e(an)j(existing)d(table)
 i(HDU:)143 5714 y(filetype://BaseFilename\(o)o(utNa)o(me\))o([HDU)o
 (loca)o(tio)o(n][c)o(olFi)o(lte)o(r][r)o(owFi)o(lte)o(r][b)o(inSp)o
 (ec])p eop end
 %%Page: 82 88
-TeXDict begin 82 87 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.82) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(82)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(The)41 b(\014let)m(yp)s(e,)k(BaseFilename,)i(outName,)e
-(HDUlo)s(cation,)i(and)41 b(ImageSection)i(comp)s(onen)m(ts,)i(if)d
-(presen)m(t,)0 668 y(m)m(ust)30 b(b)s(e)g(giv)m(en)i(in)e(that)h
-(order,)g(but)f(the)g(colFilter,)j(ro)m(wFilter,)g(and)c(binSp)s(ec)h
-(sp)s(eci\014ers)f(ma)m(y)j(follo)m(w)f(in)g(an)m(y)0
-781 y(order.)39 b(Regardless)29 b(of)g(the)f(order,)g(ho)m(w)m(ev)m
-(er,)i(the)f(colFilter)h(sp)s(eci\014er,)e(if)g(presen)m(t,)h(will)g(b)
-s(e)e(pro)s(cessed)h(\014rst)f(b)m(y)0 894 y(CFITSIO,)i(follo)m(w)m(ed)
-j(b)m(y)e(the)h(ro)m(wFilter)h(sp)s(eci\014er,)e(and)f(\014nally)i(b)m
-(y)f(the)g(binSp)s(ec)f(sp)s(eci\014er.)0 1054 y(Multiple)40
-b(colFilter)i(or)e(ro)m(wFilter)h(sp)s(eci\014cations)f(ma)m(y)g(app)s
-(ear)f(as)h(separated)g(brac)m(k)m(eted)h(expressions,)h(in)0
-1167 y(an)m(y)c(order.)62 b(Multiple)39 b(colFilter)h(or)d(ro)m
-(wFilter)i(expressions)f(are)g(treated)g(in)m(ternally)h(as)f(a)g
-(single)g(e\013ectiv)m(e)0 1280 y(expression,)30 b(with)f(order)h(of)g
-(op)s(erations)g(determined)f(from)h(left)g(to)h(righ)m(t.)41
+TeXDict begin 82 87 bop 0 299 a Fj(82)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(The)41 b(\014let)m(yp)s(e,)k(BaseFilename,)i(outName,)e(HDUlo)
+s(cation,)i(and)41 b(ImageSection)i(comp)s(onen)m(ts,)i(if)d(presen)m
+(t,)0 668 y(m)m(ust)30 b(b)s(e)g(giv)m(en)i(in)e(that)h(order,)g(but)f
+(the)g(colFilter,)j(ro)m(wFilter,)g(and)c(binSp)s(ec)h(sp)s(eci\014ers)
+f(ma)m(y)j(follo)m(w)f(in)g(an)m(y)0 781 y(order.)39
+b(Regardless)29 b(of)g(the)f(order,)g(ho)m(w)m(ev)m(er,)i(the)f
+(colFilter)h(sp)s(eci\014er,)e(if)g(presen)m(t,)h(will)g(b)s(e)e(pro)s
+(cessed)h(\014rst)f(b)m(y)0 894 y(CFITSIO,)i(follo)m(w)m(ed)j(b)m(y)e
+(the)h(ro)m(wFilter)h(sp)s(eci\014er,)e(and)f(\014nally)i(b)m(y)f(the)g
+(binSp)s(ec)f(sp)s(eci\014er.)0 1054 y(Multiple)40 b(colFilter)i(or)e
+(ro)m(wFilter)h(sp)s(eci\014cations)f(ma)m(y)g(app)s(ear)f(as)h
+(separated)g(brac)m(k)m(eted)h(expressions,)h(in)0 1167
+y(an)m(y)c(order.)62 b(Multiple)39 b(colFilter)h(or)d(ro)m(wFilter)i
+(expressions)f(are)g(treated)g(in)m(ternally)h(as)f(a)g(single)g
+(e\013ectiv)m(e)0 1280 y(expression,)30 b(with)f(order)h(of)g(op)s
+(erations)g(determined)f(from)h(left)g(to)h(righ)m(t.)41
 b(CFITSIO)28 b(do)s(es)i(not)g(supp)s(ort)e(the)0 1393
 y(@\014lename.txt)j(complex)g(syn)m(tax)g(option)g(if)f(m)m(ultiple)h
-(expressions)f(are)h(also)h(used.)0 1540 y
-SDict begin H.S end
- 0 1540 a 0
-1540 a
-SDict begin 13.6 H.A end
- 0 1540 a 0 1540 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.2) cvn /DEST pdfmark
-end
- 0 1540 a 179 x Fe(8.2)135 b(Filet)l(yp)t(e)0
-1969 y Fj(The)37 b(t)m(yp)s(e)g(of)g(\014le)g(determines)g(the)g
-(medium)f(on)h(whic)m(h)g(the)g(\014le)g(is)h(lo)s(cated)g(\(e.g.,)i
-(disk)d(or)g(net)m(w)m(ork\))h(and,)0 2082 y(hence,)f(whic)m(h)e(in)m
-(ternal)h(device)g(driv)m(er)f(is)g(used)f(b)m(y)h(CFITSIO)f(to)i(read)
-f(and/or)g(write)g(the)g(\014le.)56 b(Curren)m(tly)0
-2195 y(supp)s(orted)29 b(t)m(yp)s(es)h(are)382 2405 y
-Ff(file://)93 b(-)48 b(file)e(on)i(local)e(magnetic)g(disk)g
+(expressions)f(are)h(also)h(used.)0 1719 y Fe(8.2)135
+b(Filet)l(yp)t(e)0 1969 y Fj(The)37 b(t)m(yp)s(e)g(of)g(\014le)g
+(determines)g(the)g(medium)f(on)h(whic)m(h)g(the)g(\014le)g(is)h(lo)s
+(cated)g(\(e.g.,)i(disk)d(or)g(net)m(w)m(ork\))h(and,)0
+2082 y(hence,)f(whic)m(h)e(in)m(ternal)h(device)g(driv)m(er)f(is)g
+(used)f(b)m(y)h(CFITSIO)f(to)i(read)f(and/or)g(write)g(the)g(\014le.)56
+b(Curren)m(tly)0 2195 y(supp)s(orted)29 b(t)m(yp)s(es)h(are)382
+2405 y Ff(file://)93 b(-)48 b(file)e(on)i(local)e(magnetic)g(disk)g
 (\(default\))382 2518 y(ftp://)141 b(-)48 b(a)f(readonly)f(file)g
 (accessed)g(with)h(the)g(anonymous)e(FTP)i(protocol.)907
 2631 y(It)g(also)g(supports)93 b(ftp://username:password@)o(host)o(nam)
 o(e/..)o(.)907 2744 y(for)47 b(accessing)e(password-protected)e(ftp)k
 (sites.)382 2857 y(http://)93 b(-)48 b(a)f(readonly)f(file)g(accessed)g
 (with)h(the)g(HTTP)f(protocol.)93 b(It)907 2969 y(supports)45
 b(username:password)e(just)k(like)g(the)g(ftp)g(driver.)907
@@ -13274,155 +10501,107 @@
 b(opens)e(a)i(temporary)d(file)i(in)g(core)f(memory.)94
 b(The)47 b(file)907 4550 y(disappears)e(when)h(the)h(program)f(exits)h
 (so)g(this)f(is)i(mainly)907 4663 y(useful)e(for)h(test)f(purposes)g
 (when)h(a)g(permanent)e(output)h(file)907 4776 y(is)h(not)g(desired.)0
 4986 y Fj(If)35 b(the)h(\014let)m(yp)s(e)g(is)f(not)h(sp)s(eci\014ed,)h
 (then)e(t)m(yp)s(e)h(\014le://)h(is)e(assumed.)56 b(The)35
 b(double)g(slashes)h('//')h(are)f(optional)0 5099 y(and)30
-b(ma)m(y)h(b)s(e)e(omitted)j(in)e(most)h(cases.)0 5236
-y
-SDict begin H.S end
- 0 5236 a 0 5236 a
-SDict begin 13.6 H.A end
- 0 5236 a 0 5236 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.2.1) cvn /DEST pdfmark
-end
- 0 5236 a 146 x
-Fc(8.2.1)112 b(Notes)37 b(ab)s(out)i(HTTP)d(pro)m(xy)i(serv)m(ers)0
+b(ma)m(y)h(b)s(e)e(omitted)j(in)e(most)h(cases.)0 5382
+y Fc(8.2.1)112 b(Notes)37 b(ab)s(out)i(HTTP)d(pro)m(xy)i(serv)m(ers)0
 5601 y Fj(A)32 b(pro)m(xy)g(HTTP)f(serv)m(er)h(ma)m(y)h(b)s(e)e(used)g
 (b)m(y)h(de\014ning)f(the)h(address)f(\(URL\))i(and)e(p)s(ort)g(n)m(um)
 m(b)s(er)g(of)h(the)g(pro)m(xy)0 5714 y(serv)m(er)f(with)f(the)g(h)m
 (ttp)p 801 5714 28 4 v 33 w(pro)m(xy)g(en)m(vironmen)m(t)h(v)-5
 b(ariable.)42 b(F)-8 b(or)31 b(example)p eop end
 %%Page: 83 89
-TeXDict begin 83 88 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.83) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.2.)72
-b(FILETYPE)3128 b Fj(83)191 555 y Ff(setenv)46 b(http_proxy)f
-(http://heasarc.gsfc.nasa)o(.gov)o(:312)o(8)0 793 y Fj(will)38
-b(cause)g(CFITSIO)f(to)h(use)g(p)s(ort)f(3128)i(on)f(the)g(heasarc)g
-(pro)m(xy)g(serv)m(er)g(whenev)m(er)g(reading)g(a)g(FITS)f(\014le)0
-906 y(with)30 b(HTTP)-8 b(.)0 1030 y
-SDict begin H.S end
- 0 1030 a 0 1030
-a
-SDict begin 13.6 H.A end
- 0 1030 a 0 1030 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.2.2) cvn /DEST pdfmark
-end
- 0 1030 a 164 x Fc(8.2.2)112 b(Notes)37
-b(ab)s(out)i(the)e(stream)h(\014let)m(yp)s(e)g(driv)m(er)0
-1413 y Fj(The)e(stream)h(driv)m(er)f(can)h(b)s(e)f(used)g(to)h
-(e\016cien)m(tly)i(read)d(a)h(FITS)f(\014le)h(from)f(the)h(stdin)f
-(\014le)g(stream)h(or)g(write)0 1525 y(a)44 b(FITS)e(to)i(the)g(stdout)
-f(\014le)g(stream.)80 b(Ho)m(w)m(ev)m(er,)49 b(b)s(ecause)43
-b(these)h(input)e(and)h(output)g(streams)g(m)m(ust)h(b)s(e)0
-1638 y(accessed)30 b(sequen)m(tially)-8 b(,)31 b(the)e(FITS)f(\014le)g
-(reading)h(or)f(writing)h(application)h(m)m(ust)e(also)i(read)e(and)g
-(write)h(the)g(\014le)0 1751 y(sequen)m(tially)-8 b(,)33
-b(at)e(least)g(within)f(the)h(tolerances)h(describ)s(ed)d(b)s(elo)m(w.)
-0 1911 y(CFITSIO)34 b(supp)s(orts)f(2)j(di\013eren)m(t)f(metho)s(ds)g
-(for)g(accessing)i(FITS)d(\014les)h(on)h(the)f(stdin)g(and)f(stdout)h
-(streams.)0 2024 y(The)c(original)i(metho)s(d,)f(whic)m(h)f(is)h(in)m
-(v)m(ok)m(ed)h(b)m(y)f(sp)s(ecifying)f(a)h(dash)f(c)m(haracter,)j("-",)
-g(as)d(the)h(name)g(of)g(the)g(\014le)0 2137 y(when)g(op)s(ening)g(or)h
-(creating)h(it,)g(w)m(orks)e(b)m(y)h(storing)g(a)g(complete)h(cop)m(y)g
-(of)f(the)g(en)m(tire)g(FITS)f(\014le)h(in)f(memory)-8
-b(.)0 2250 y(In)35 b(this)g(case,)k(when)34 b(reading)i(from)f(stdin,)i
-(CFITSIO)d(will)i(cop)m(y)h(the)e(en)m(tire)i(stream)f(in)m(to)h
-(memory)e(b)s(efore)0 2363 y(doing)c(an)m(y)h(pro)s(cessing)f(of)h(the)
-f(\014le.)44 b(Similarly)-8 b(,)32 b(when)f(writing)g(to)h(stdout,)g
-(CFITSIO)d(will)j(create)h(a)f(cop)m(y)g(of)0 2476 y(the)h(en)m(tire)g
-(FITS)f(\014le)g(in)h(memory)-8 b(,)33 b(b)s(efore)f(\014nally)h
-(\015ushing)e(it)i(out)f(to)i(the)e(stdout)h(stream)g(when)e(the)i
-(FITS)0 2589 y(\014le)g(is)g(closed.)49 b(Bu\013ering)33
-b(the)g(en)m(tire)h(FITS)e(\014le)h(in)g(this)f(w)m(a)m(y)i(allo)m(ws)g
-(the)f(application)i(to)e(randomly)g(access)0 2702 y(an)m(y)h(part)f
-(of)h(the)f(FITS)g(\014le,)i(in)e(an)m(y)h(order,)f(but)g(it)h(also)h
-(requires)e(that)h(the)f(user)g(ha)m(v)m(e)i(su\016cien)m(t)f(a)m(v)-5
-b(ailable)0 2815 y(memory)30 b(\(or)g(virtual)g(memory\))g(to)h(store)f
-(the)g(en)m(tire)h(\014le,)f(whic)m(h)f(ma)m(y)i(not)f(b)s(e)f(p)s
-(ossible)g(in)h(the)g(case)h(of)f(v)m(ery)0 2928 y(large)h(\014les.)0
-3088 y(The)e(new)m(er)g(stream)h(\014let)m(yp)s(e)g(pro)m(vides)f(a)h
+TeXDict begin 83 88 bop 0 299 a Fh(8.2.)72 b(FILETYPE)3128
+b Fj(83)191 555 y Ff(setenv)46 b(http_proxy)f(http://heasarc.gsfc.nasa)
+o(.gov)o(:312)o(8)0 798 y Fj(will)38 b(cause)g(CFITSIO)f(to)h(use)g(p)s
+(ort)f(3128)i(on)f(the)g(heasarc)g(pro)m(xy)g(serv)m(er)g(whenev)m(er)g
+(reading)g(a)g(FITS)f(\014le)0 911 y(with)30 b(HTTP)-8
+b(.)0 1199 y Fc(8.2.2)112 b(Notes)37 b(ab)s(out)i(the)e(stream)h
+(\014let)m(yp)s(e)g(driv)m(er)0 1418 y Fj(The)e(stream)h(driv)m(er)f
+(can)h(b)s(e)f(used)g(to)h(e\016cien)m(tly)i(read)d(a)h(FITS)f(\014le)h
+(from)f(the)h(stdin)f(\014le)g(stream)h(or)g(write)0
+1531 y(a)44 b(FITS)e(to)i(the)g(stdout)f(\014le)g(stream.)80
+b(Ho)m(w)m(ev)m(er,)49 b(b)s(ecause)43 b(these)h(input)e(and)h(output)g
+(streams)g(m)m(ust)h(b)s(e)0 1644 y(accessed)30 b(sequen)m(tially)-8
+b(,)31 b(the)e(FITS)f(\014le)g(reading)h(or)f(writing)h(application)h
+(m)m(ust)e(also)i(read)e(and)g(write)h(the)g(\014le)0
+1757 y(sequen)m(tially)-8 b(,)33 b(at)e(least)g(within)f(the)h
+(tolerances)h(describ)s(ed)d(b)s(elo)m(w.)0 1917 y(CFITSIO)34
+b(supp)s(orts)f(2)j(di\013eren)m(t)f(metho)s(ds)g(for)g(accessing)i
+(FITS)d(\014les)h(on)h(the)f(stdin)g(and)f(stdout)h(streams.)0
+2030 y(The)c(original)i(metho)s(d,)f(whic)m(h)f(is)h(in)m(v)m(ok)m(ed)h
+(b)m(y)f(sp)s(ecifying)f(a)h(dash)f(c)m(haracter,)j("-",)g(as)d(the)h
+(name)g(of)g(the)g(\014le)0 2143 y(when)g(op)s(ening)g(or)h(creating)h
+(it,)g(w)m(orks)e(b)m(y)h(storing)g(a)g(complete)h(cop)m(y)g(of)f(the)g
+(en)m(tire)g(FITS)f(\014le)h(in)f(memory)-8 b(.)0 2256
+y(In)35 b(this)g(case,)k(when)34 b(reading)i(from)f(stdin,)i(CFITSIO)d
+(will)i(cop)m(y)h(the)e(en)m(tire)i(stream)f(in)m(to)h(memory)e(b)s
+(efore)0 2368 y(doing)c(an)m(y)h(pro)s(cessing)f(of)h(the)f(\014le.)44
+b(Similarly)-8 b(,)32 b(when)f(writing)g(to)h(stdout,)g(CFITSIO)d(will)
+j(create)h(a)f(cop)m(y)g(of)0 2481 y(the)h(en)m(tire)g(FITS)f(\014le)g
+(in)h(memory)-8 b(,)33 b(b)s(efore)f(\014nally)h(\015ushing)e(it)i(out)
+f(to)i(the)e(stdout)h(stream)g(when)e(the)i(FITS)0 2594
+y(\014le)g(is)g(closed.)49 b(Bu\013ering)33 b(the)g(en)m(tire)h(FITS)e
+(\014le)h(in)g(this)f(w)m(a)m(y)i(allo)m(ws)g(the)f(application)i(to)e
+(randomly)g(access)0 2707 y(an)m(y)h(part)f(of)h(the)f(FITS)g(\014le,)i
+(in)e(an)m(y)h(order,)f(but)g(it)h(also)h(requires)e(that)h(the)f(user)
+g(ha)m(v)m(e)i(su\016cien)m(t)f(a)m(v)-5 b(ailable)0
+2820 y(memory)30 b(\(or)g(virtual)g(memory\))g(to)h(store)f(the)g(en)m
+(tire)h(\014le,)f(whic)m(h)f(ma)m(y)i(not)f(b)s(e)f(p)s(ossible)g(in)h
+(the)g(case)h(of)f(v)m(ery)0 2933 y(large)h(\014les.)0
+3093 y(The)e(new)m(er)g(stream)h(\014let)m(yp)s(e)g(pro)m(vides)f(a)h
 (more)f(memory-e\016cien)m(t)i(metho)s(d)e(of)h(accessing)h(FITS)d
-(\014les)h(on)h(the)0 3201 y(stdin)37 b(or)h(stdout)g(streams.)64
+(\014les)h(on)h(the)0 3206 y(stdin)37 b(or)h(stdout)g(streams.)64
 b(Instead)38 b(of)g(storing)g(a)g(cop)m(y)h(of)f(the)g(en)m(tire)h
-(FITS)e(\014le)h(in)g(memory)-8 b(,)40 b(CFITSIO)0 3314
+(FITS)e(\014le)h(in)g(memory)-8 b(,)40 b(CFITSIO)0 3319
 y(only)32 b(uses)g(a)g(set)h(of)f(in)m(ternal)h(bu\013er)e(whic)m(h)h
 (b)m(y)g(default)g(can)g(store)h(40)g(FITS)e(blo)s(c)m(ks,)i(or)g(ab)s
-(out)e(100K)i(b)m(ytes)0 3427 y(of)f(the)f(FITS)g(\014le.)43
+(out)e(100K)i(b)m(ytes)0 3432 y(of)f(the)f(FITS)g(\014le.)43
 b(The)31 b(application)i(program)e(m)m(ust)g(pro)s(cess)g(the)h(FITS)e
-(\014le)i(sequen)m(tially)h(from)e(b)s(eginning)0 3539
+(\014le)i(sequen)m(tially)h(from)e(b)s(eginning)0 3545
 y(to)h(end,)e(within)g(this)h(100K)h(bu\013er.)41 b(Generally)32
 b(sp)s(eaking)f(the)g(application)h(program)f(m)m(ust)f(conform)h(to)h
-(the)0 3652 y(follo)m(wing)g(restrictions:)136 3891 y
+(the)0 3658 y(follo)m(wing)g(restrictions:)136 3901 y
 Fd(\017)46 b Fj(The)36 b(program)f(m)m(ust)h(\014nish)e(reading)i(or)g
 (writing)f(the)h(header)g(k)m(eyw)m(ords)g(b)s(efore)f(reading)h(or)g
-(writing)227 4004 y(an)m(y)31 b(data)g(in)f(the)h(HDU.)136
-4184 y Fd(\017)46 b Fj(The)24 b(HDU)h(can)f(con)m(tain)i(at)e(most)h
+(writing)227 4013 y(an)m(y)31 b(data)g(in)f(the)h(HDU.)136
+4195 y Fd(\017)46 b Fj(The)24 b(HDU)h(can)f(con)m(tain)i(at)e(most)h
 (ab)s(out)f(1400)h(header)f(k)m(eyw)m(ords.)39 b(This)24
-b(is)g(the)g(maxim)m(um)g(that)h(can)f(\014t)227 4297
+b(is)g(the)g(maxim)m(um)g(that)h(can)f(\014t)227 4308
 y(in)g(the)g(nominal)h(40)g(FITS)e(blo)s(c)m(k)i(bu\013er.)37
 b(In)24 b(principle,)h(this)f(limit)h(could)f(b)s(e)g(increased)g(b)m
-(y)g(recompiling)227 4410 y(CFITSIO)29 b(with)h(a)h(larger)g(bu\013er)e
+(y)g(recompiling)227 4421 y(CFITSIO)29 b(with)h(a)h(larger)g(bu\013er)e
 (limit,)j(whic)m(h)e(is)g(set)h(b)m(y)f(the)h(NIOBUF)g(parameter)g(in)f
-(\014tsio2.h.)136 4590 y Fd(\017)46 b Fj(The)32 b(program)g(m)m(ust)f
+(\014tsio2.h.)136 4603 y Fd(\017)46 b Fj(The)32 b(program)g(m)m(ust)f
 (read)h(or)g(write)h(the)f(data)g(in)g(a)g(sequen)m(tial)i(manner)d
-(from)h(the)g(b)s(eginning)f(to)i(the)227 4703 y(end)26
+(from)h(the)g(b)s(eginning)f(to)i(the)227 4716 y(end)26
 b(of)g(the)h(HDU.)g(Note)h(that)f(CFITSIO's)e(in)m(ternal)i(100K)g
 (bu\013er)e(allo)m(ws)j(a)e(little)j(latitude)e(in)f(meeting)227
-4816 y(this)31 b(requiremen)m(t.)136 4997 y Fd(\017)46
+4829 y(this)31 b(requiremen)m(t.)136 5011 y Fd(\017)46
 b Fj(The)30 b(program)g(cannot)h(mo)m(v)m(e)h(bac)m(k)f(to)g(a)g
-(previous)f(HDU)h(in)f(the)h(FITS)e(\014le.)136 5177
+(previous)f(HDU)h(in)f(the)h(FITS)e(\014le.)136 5193
 y Fd(\017)46 b Fj(Reading)c(or)f(writing)f(of)h(v)-5
 b(ariable)42 b(length)f(arra)m(y)h(columns)e(in)h(binary)f(tables)i(is)
-f(not)g(supp)s(orted)e(on)227 5290 y(streams,)29 b(b)s(ecause)f(this)g
+f(not)g(supp)s(orted)e(on)227 5306 y(streams,)29 b(b)s(ecause)f(this)g
 (requires)g(mo)m(ving)g(bac)m(k)h(and)f(forth)f(b)s(et)m(w)m(een)i(the)
-f(\014xed-length)g(p)s(ortion)g(of)g(the)227 5403 y(binary)i(table)h
+f(\014xed-length)g(p)s(ortion)g(of)g(the)227 5419 y(binary)i(table)h
 (and)f(the)g(follo)m(wing)i(heap)e(area)i(where)e(the)g(arra)m(ys)h
-(are)g(actually)h(stored.)136 5583 y Fd(\017)46 b Fj(Reading)25
+(are)g(actually)h(stored.)136 5601 y Fd(\017)46 b Fj(Reading)25
 b(or)g(writing)f(of)h(tile-compressed)h(images)g(is)e(not)h(supp)s
 (orted)e(on)h(streams,)i(b)s(ecause)f(the)g(images)227
-5696 y(are)31 b(in)m(ternally)g(stored)g(using)f(v)-5
+5714 y(are)31 b(in)m(ternally)g(stored)g(using)f(v)-5
 b(ariable)31 b(length)g(arra)m(ys.)p eop end
 %%Page: 84 90
-TeXDict begin 84 89 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.84) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(84)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.2.3) cvn /DEST pdfmark
-end
- 0 464 a
-91 x Fc(8.2.3)112 b(Notes)37 b(ab)s(out)i(the)e(gsiftp)h(\014let)m(yp)s
-(e)0 774 y Fj(DEPENDENCIES:)c(Globus)h(to)s(olkit)h(\(2.4.3)g(or)f
+TeXDict begin 84 89 bop 0 299 a Fj(84)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fc(8.2.3)112 b(Notes)37 b(ab)s(out)i(the)e(gsiftp)h(\014let)m(yp)
+s(e)0 774 y Fj(DEPENDENCIES:)c(Globus)h(to)s(olkit)h(\(2.4.3)g(or)f
 (higher\))f(\(GT\))h(should)f(b)s(e)g(installed.)53 b(There)34
 b(are)h(t)m(w)m(o)h(dif-)0 887 y(feren)m(t)31 b(w)m(a)m(ys)g(to)g
 (install)g(GT:)0 1047 y(1\))43 b(goto)h(the)f(globus)f(to)s(olkit)i(w)m
 (eb)e(page)i(www.globus.org)e(and)g(follo)m(w)h(the)g(do)m(wnload)g
 (and)e(compilation)0 1160 y(instructions;)0 1320 y(2\))j(goto)i(the)d
 (Virtual)i(Data)g(T)-8 b(o)s(olkit)45 b(w)m(eb)e(page)i(h)m
 (ttp://vdt.cs.wisc.edu/)g(and)e(follo)m(w)i(the)f(instructions)0
@@ -13456,23 +10635,15 @@
 w(TMPFILE=/y)m(our/lo)s(cation/y)m(ourtmp\014le\).)0
 3279 y(Grid)34 b(FTP)g(supp)s(orts)f(m)m(ulti)h(c)m(hannel)h(transfer.)
 52 b(By)35 b(default)f(a)h(single)g(c)m(hannel)g(transmission)f(is)g(a)
 m(v)-5 b(ailable.)0 3392 y(Ho)m(w)m(ev)m(er,)34 b(it)d(is)h(p)s
 (ossible)e(to)i(mo)s(dify)e(this)i(b)s(eha)m(vior)f(setting)h(the)f
 (GSIFTP)p 2691 3392 V 33 w(STREAMS)f(en)m(vironmen)m(t)h(v)-5
 b(ari-)0 3505 y(able)31 b(\(ex.)41 b(exp)s(ort)30 b(GSIFTP)p
-1016 3505 V 33 w(STREAMS=8\).)0 3650 y
-SDict begin H.S end
- 0 3650 a 0 3650
-a
-SDict begin 13.6 H.A end
- 0 3650 a 0 3650 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.2.4) cvn /DEST pdfmark
-end
- 0 3650 a 140 x Fc(8.2.4)112 b(Notes)37
+1016 3505 V 33 w(STREAMS=8\).)0 3790 y Fc(8.2.4)112 b(Notes)37
 b(ab)s(out)i(the)e(ro)s(ot)g(\014let)m(yp)s(e)0 4009
 y Fj(The)20 b(original)j(ro)s(otd)d(serv)m(er)h(can)h(b)s(e)e(obtained)
 h(from:)36 b Ff(ftp://root.cern.ch/root)o(/roo)o(td.t)o(ar.)o(gz)15
 b Fj(but,)22 b(for)0 4122 y(it)33 b(to)h(w)m(ork)f(correctly)h(with)e
 (CFITSIO)g(one)h(has)f(to)i(use)e(a)i(mo)s(di\014ed)d(v)m(ersion)j
 (whic)m(h)e(supp)s(orts)f(a)i(command)0 4235 y(to)41
 b(return)d(the)j(length)f(of)g(the)g(\014le.)70 b(This)39
@@ -13491,44 +10662,31 @@
 (\(whic)m(h)f(requires)g(ro)s(otd)g(to)h(b)s(e)f(started)h(as)f(ro)s
 (ot\).)65 b(T)-8 b(o)39 b(run)e(ro)s(otd)h(via)h(inetd)f(add)g(the)0
 5257 y(follo)m(wing)32 b(line)f(to)g(/etc/services:)95
 5485 y Ff(rootd)238 b(432/tcp)0 5714 y Fj(and)30 b(to)h
 (/etc/inetd.conf,)i(add)d(the)g(follo)m(wing)i(line:)p
 eop end
 %%Page: 85 91
-TeXDict begin 85 90 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.85) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.2.)72
-b(FILETYPE)3128 b Fj(85)95 555 y Ff(rootd)47 b(stream)f(tcp)h(nowait)f
-(root)h(/user/rdm/root/bin/root)o(d)42 b(rootd)k(-i)0
-829 y Fj(F)-8 b(orce)34 b(inetd)e(to)i(reread)e(its)h(conf)f(\014le)h
-(with)f("kill)h(-HUP)g(<pid)f(inetd>".)47 b(Y)-8 b(ou)33
-b(can)g(also)g(start)g(ro)s(otd)g(b)m(y)f(hand)0 942
-y(running)j(directly)i(under)d(y)m(our)j(priv)-5 b(ate)37
-b(accoun)m(t)g(\(no)g(ro)s(ot)g(system)f(privileges)h(needed\).)59
-b(F)-8 b(or)37 b(example)g(to)0 1054 y(start)e(ro)s(otd)e(listening)i
-(on)f(p)s(ort)f(5151)j(just)d(t)m(yp)s(e:)49 b Ff(rootd)d(-p)h(5151)33
-b Fj(Notice:)50 b(no)34 b(&)f(is)h(needed.)51 b(Ro)s(otd)35
-b(will)0 1167 y(go)c(in)m(to)h(bac)m(kground)e(b)m(y)g(itself.)95
-1441 y Ff(Rootd)47 b(arguments:)191 1554 y(-i)763 b(says)47
-b(we)g(were)f(started)g(by)h(inetd)191 1667 y(-p)g(port#)476
-b(specifies)45 b(a)j(different)d(port)i(to)g(listen)f(on)191
-1780 y(-d)h(level)476 b(level)46 b(of)i(debug)e(info)h(written)e(to)j
-(syslog)1050 1893 y(0)f(=)h(no)f(debug)f(\(default\))1050
-2005 y(1)h(=)h(minimum)1050 2118 y(2)f(=)h(medium)1050
+TeXDict begin 85 90 bop 0 299 a Fh(8.2.)72 b(FILETYPE)3128
+b Fj(85)95 555 y Ff(rootd)47 b(stream)f(tcp)h(nowait)f(root)h
+(/user/rdm/root/bin/root)o(d)42 b(rootd)k(-i)0 829 y
+Fj(F)-8 b(orce)34 b(inetd)e(to)i(reread)e(its)h(conf)f(\014le)h(with)f
+("kill)h(-HUP)g(<pid)f(inetd>".)47 b(Y)-8 b(ou)33 b(can)g(also)g(start)
+g(ro)s(otd)g(b)m(y)f(hand)0 942 y(running)j(directly)i(under)d(y)m(our)
+j(priv)-5 b(ate)37 b(accoun)m(t)g(\(no)g(ro)s(ot)g(system)f(privileges)
+h(needed\).)59 b(F)-8 b(or)37 b(example)g(to)0 1054 y(start)e(ro)s(otd)
+e(listening)i(on)f(p)s(ort)f(5151)j(just)d(t)m(yp)s(e:)49
+b Ff(rootd)d(-p)h(5151)33 b Fj(Notice:)50 b(no)34 b(&)f(is)h(needed.)51
+b(Ro)s(otd)35 b(will)0 1167 y(go)c(in)m(to)h(bac)m(kground)e(b)m(y)g
+(itself.)95 1441 y Ff(Rootd)47 b(arguments:)191 1554
+y(-i)763 b(says)47 b(we)g(were)f(started)g(by)h(inetd)191
+1667 y(-p)g(port#)476 b(specifies)45 b(a)j(different)d(port)i(to)g
+(listen)f(on)191 1780 y(-d)h(level)476 b(level)46 b(of)i(debug)e(info)h
+(written)e(to)j(syslog)1050 1893 y(0)f(=)h(no)f(debug)f(\(default\))
+1050 2005 y(1)h(=)h(minimum)1050 2118 y(2)f(=)h(medium)1050
 2231 y(3)f(=)h(maximum)0 2505 y Fj(Ro)s(otd)29 b(can)f(also)h(b)s(e)f
 (con\014gured)g(for)g(anon)m(ymous)g(usage)h(\(lik)m(e)h(anon)m(ymous)e
 (ftp\).)40 b(T)-8 b(o)29 b(setup)f(ro)s(otd)g(to)h(accept)0
 2618 y(anon)m(ymous)h(logins)h(do)g(the)f(follo)m(wing)i(\(while)f(b)s
 (eing)f(logged)i(in)e(as)g(ro)s(ot\):)143 2891 y Ff(-)48
 b(Add)f(the)f(following)g(line)g(to)i(/etc/passwd:)239
 3117 y(rootd:*:71:72:Anonymous)41 b(rootd:/var/spool/rootd:/b)o(in/)o
@@ -13543,55 +10701,34 @@
 5036 y(Where)f(/var/spool/rootd)d(must)k(match)f(the)h(rootd)g(home)f
 (directory)g(as)239 5149 y(specified)f(in)i(the)g(rootd)f(/etc/passwd)f
 (entry.)143 5375 y(-)j(To)f(make)f(writeable)g(directories)e(for)j
 (anonymous)f(do,)h(for)f(example:)239 5601 y(mkdir)g
 (/var/spool/rootd/pub)239 5714 y(chown)g(rootd:rootd)f
 (/var/spool/rootd/pub)p eop end
 %%Page: 86 92
-TeXDict begin 86 91 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.86) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(86)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(That's)42 b(all.)76 b(Sev)m(eral)43 b(additional)g
-(remarks:)64 b(y)m(ou)42 b(can)g(login)h(to)g(an)f(anon)m(ymous)f(serv)
-m(er)i(either)f(with)g(the)0 668 y(names)31 b("anon)m(ymous")h(or)f
-("ro)s(otd".)43 b(The)31 b(passw)m(ord)f(should)g(b)s(e)h(of)g(t)m(yp)s
-(e)g(user@host.do.main.)43 b(Only)30 b(the)h(@)0 781
-y(is)e(enforced)f(for)h(the)f(time)i(b)s(eing.)39 b(In)28
-b(anon)m(ymous)h(mo)s(de)f(the)g(top)h(of)g(the)g(\014le)f(tree)i(is)e
-(set)h(to)h(the)e(ro)s(otd)h(home)0 894 y(directory)-8
-b(,)39 b(therefore)e(only)f(\014les)h(b)s(elo)m(w)f(the)h(home)f
-(directory)h(can)f(b)s(e)g(accessed.)60 b(Anon)m(ymous)36
-b(mo)s(de)g(only)0 1007 y(w)m(orks)30 b(when)g(the)g(serv)m(er)h(is)f
-(started)h(via)g(inetd.)0 1132 y
-SDict begin H.S end
- 0 1132 a 0 1132 a
-SDict begin 13.6 H.A end
- 0
-1132 a 0 1132 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.2.5) cvn /DEST pdfmark
-end
- 0 1132 a 164 x Fc(8.2.5)112 b(Notes)37
-b(ab)s(out)i(the)e(shmem)i(\014let)m(yp)s(e:)0 1515 y
-Fj(Shared)34 b(memory)h(\014les)g(are)g(curren)m(tly)g(supp)s(orted)e
-(on)i(most)h(Unix)f(platforms,)h(where)f(the)g(shared)f(memory)0
-1627 y(segmen)m(ts)d(are)g(managed)g(b)m(y)f(the)g(op)s(erating)h
-(system)g(k)m(ernel)f(and)g(`liv)m(e')i(indep)s(enden)m(tly)d(of)i(pro)
-s(cesses.)40 b(They)0 1740 y(are)34 b(not)g(deleted)h(\(b)m(y)f
-(default\))g(when)f(the)h(pro)s(cess)f(whic)m(h)h(created)h(them)f
+TeXDict begin 86 91 bop 0 299 a Fj(86)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(That's)42 b(all.)76 b(Sev)m(eral)43 b(additional)g(remarks:)64
+b(y)m(ou)42 b(can)g(login)h(to)g(an)f(anon)m(ymous)f(serv)m(er)i
+(either)f(with)g(the)0 668 y(names)31 b("anon)m(ymous")h(or)f("ro)s
+(otd".)43 b(The)31 b(passw)m(ord)f(should)g(b)s(e)h(of)g(t)m(yp)s(e)g
+(user@host.do.main.)43 b(Only)30 b(the)h(@)0 781 y(is)e(enforced)f(for)
+h(the)f(time)i(b)s(eing.)39 b(In)28 b(anon)m(ymous)h(mo)s(de)f(the)g
+(top)h(of)g(the)g(\014le)f(tree)i(is)e(set)h(to)h(the)e(ro)s(otd)h
+(home)0 894 y(directory)-8 b(,)39 b(therefore)e(only)f(\014les)h(b)s
+(elo)m(w)f(the)h(home)f(directory)h(can)f(b)s(e)g(accessed.)60
+b(Anon)m(ymous)36 b(mo)s(de)g(only)0 1007 y(w)m(orks)30
+b(when)g(the)g(serv)m(er)h(is)f(started)h(via)g(inetd.)0
+1296 y Fc(8.2.5)112 b(Notes)37 b(ab)s(out)i(the)e(shmem)i(\014let)m(yp)
+s(e:)0 1515 y Fj(Shared)34 b(memory)h(\014les)g(are)g(curren)m(tly)g
+(supp)s(orted)e(on)i(most)h(Unix)f(platforms,)h(where)f(the)g(shared)f
+(memory)0 1627 y(segmen)m(ts)d(are)g(managed)g(b)m(y)f(the)g(op)s
+(erating)h(system)g(k)m(ernel)f(and)g(`liv)m(e')i(indep)s(enden)m(tly)d
+(of)i(pro)s(cesses.)40 b(They)0 1740 y(are)34 b(not)g(deleted)h(\(b)m
+(y)f(default\))g(when)f(the)h(pro)s(cess)f(whic)m(h)h(created)h(them)f
 (terminates,)h(although)g(they)f(will)0 1853 y(disapp)s(ear)e(if)h(the)
 h(system)f(is)g(reb)s(o)s(oted.)49 b(Applications)34
 b(can)g(create)h(shared)d(memory)h(\014les)g(in)g(CFITSIO)f(b)m(y)0
 1966 y(calling:)143 2214 y Ff(fit_create_file\(&fitsfile)o(ptr,)41
 b("shmem://h2",)j(&status\);)0 2462 y Fj(where)25 b(the)g(ro)s(ot)h
 (`\014le')f(names)h(are)f(curren)m(tly)g(restricted)h(to)g(b)s(e)f
 ('h0',)i('h1',)g('h2',)g('h3',)f(etc.,)i(up)d(to)g(a)h(maxim)m(um)0
@@ -13634,43 +10771,23 @@
 (then)f(t)m(yp)s(e)g(`smem)f(-h')h(to)h(get)g(a)f(list)g(of)g(v)-5
 b(alid)27 b(options.)0 4793 y(Executing)37 b(smem)f(without)g(an)m(y)h
 (options)g(causes)f(it)h(to)g(list)g(all)g(the)g(shared)e(memory)i
 (segmen)m(ts)g(curren)m(tly)0 4906 y(residing)c(in)g(the)g(system)h
 (and)e(managed)i(b)m(y)f(the)h(shared)e(memory)h(driv)m(er.)49
 b(T)-8 b(o)34 b(get)g(a)g(list)g(of)f(all)h(the)g(shared)0
 5019 y(memory)c(ob)5 b(jects,)32 b(run)d(the)h(system)h(utilit)m(y)g
-(program)f(`ip)s(cs)h([-a]'.)0 5177 y
-SDict begin H.S end
- 0 5177 a 0 5177
-a
-SDict begin 13.6 H.A end
- 0 5177 a 0 5177 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.3) cvn /DEST pdfmark
-end
- 0 5177 a 174 x Fe(8.3)135 b(Base)46
+(program)f(`ip)s(cs)h([-a]'.)0 5351 y Fe(8.3)135 b(Base)46
 b(Filename)0 5601 y Fj(The)31 b(base)g(\014lename)h(is)f(the)h(name)f
 (of)h(the)f(\014le)h(optionally)g(including)f(the)h(director/sub)s
 (directory)f(path,)h(and)0 5714 y(in)e(the)h(case)g(of)g(`ftp',)f(`h)m
 (ttp',)i(and)d(`ro)s(ot')j(\014let)m(yp)s(es,)e(the)h(mac)m(hine)g
 (iden)m(ti\014er.)41 b(Examples:)p eop end
 %%Page: 87 93
-TeXDict begin 87 92 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.87) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.3.)72
-b(BASE)30 b(FILENAME)2830 b Fj(87)191 555 y Ff(myfile.fits)191
+TeXDict begin 87 92 bop 0 299 a Fh(8.3.)72 b(BASE)30
+b(FILENAME)2830 b Fj(87)191 555 y Ff(myfile.fits)191
 668 y(!data.fits)191 781 y(/data/myfile.fits)191 894
 y(fits.gsfc.nasa.gov/ftp/s)o(ampl)o(eda)o(ta/m)o(yfil)o(e.f)o(its.)o
 (gz)0 1120 y Fj(When)29 b(creating)h(a)f(new)f(output)h(\014le)g(on)g
 (magnetic)h(disk)e(\(of)i(t)m(yp)s(e)f(\014le://\))h(if)f(the)g(base)g
 (\014lename)g(b)s(egins)f(with)0 1233 y(an)34 b(exclamation)j(p)s(oin)m
 (t)d(\(!\))54 b(then)34 b(an)m(y)g(existing)i(\014le)e(with)g(that)h
 (same)g(basename)g(will)g(b)s(e)e(deleted)i(prior)f(to)0
@@ -13744,30 +10861,18 @@
 b(floating)g(point)239 5375 y(d)381 b(64-bit)46 b(floating)g(point)0
 5601 y Fj(An)40 b(optional)h(second)f(c)m(haracter)i(sp)s(eci\014es)e
 (the)h(b)m(yte)f(order)g(of)g(the)h(arra)m(y)g(v)-5 b(alues:)60
 b(b)40 b(or)g(B)h(indicates)g(big)0 5714 y(endian)f(\(as)h(in)f(FITS)f
 (\014les)i(and)f(the)g(nativ)m(e)i(format)e(of)h(SUN)f(UNIX)h(w)m
 (orkstations)g(and)f(Mac)i(PCs\))e(and)p eop end
 %%Page: 88 94
-TeXDict begin 88 93 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.88) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(88)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(l)41 b(or)g(L)g(indicates)g(little)i(endian)e(\(nativ)m
-(e)h(format)g(of)f(DEC)f(OSF)h(w)m(orkstations)h(and)e(IBM)i(PCs\).)72
+TeXDict begin 88 93 bop 0 299 a Fj(88)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(l)41 b(or)g(L)g(indicates)g(little)i(endian)e(\(nativ)m(e)h
+(format)g(of)f(DEC)f(OSF)h(w)m(orkstations)h(and)e(IBM)i(PCs\).)72
 b(If)40 b(this)0 668 y(c)m(haracter)32 b(is)e(omitted)i(then)e(the)g
 (arra)m(y)h(is)g(assumed)e(to)i(ha)m(v)m(e)h(the)f(nativ)m(e)g(b)m(yte)
 g(order)f(of)h(the)f(lo)s(cal)i(mac)m(hine.)0 781 y(These)d(datat)m(yp)
 s(e)h(c)m(haracters)h(are)e(then)g(follo)m(w)m(ed)i(b)m(y)e(a)h(series)
 f(of)g(one)h(or)f(more)g(in)m(teger)i(v)-5 b(alues)29
 b(separated)h(b)m(y)0 894 y(commas)h(whic)m(h)g(de\014ne)e(the)i(size)h
 (of)e(eac)m(h)i(dimension)e(of)h(the)g(ra)m(w)f(arra)m(y)-8
@@ -13813,23 +10918,15 @@
 (output)f(FITS)g(\014le,)i(and)f(task2)g(reads)g(an)g(input)f(FITS)g
 (\014le,)i(the)f(FITS)f(\014le)h(ma)m(y)0 3487 y(b)s(e)j(pip)s(ed)f(b)s
 (et)m(w)m(een)i(the)f(2)h(tasks)g(b)m(y)f(sp)s(ecifying)143
 3744 y Ff(task1)47 b(-)g(|)g(task2)g(-)0 4001 y Fj(where)30
 b(the)h(v)m(ertical)i(bar)e(is)f(the)h(Unix)g(piping)f(sym)m(b)s(ol.)42
 b(This)30 b(assumes)g(that)i(the)f(2)g(tasks)g(read)g(the)g(name)g(of)0
 4114 y(the)g(FITS)e(\014le)i(o\013)f(of)h(the)g(command)f(line.)0
-4251 y
-SDict begin H.S end
- 0 4251 a 0 4251 a
-SDict begin 13.6 H.A end
- 0 4251 a 0 4251 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.4) cvn /DEST pdfmark
-end
- 0 4251 a 197
-x Fe(8.4)135 b(Output)45 b(File)g(Name)h(when)f(Op)t(ening)g(an)g
+4448 y Fe(8.4)135 b(Output)45 b(File)g(Name)h(when)f(Op)t(ening)g(an)g
 (Existing)h(File)0 4698 y Fj(An)36 b(optional)i(output)e(\014lename)h
 (ma)m(y)h(b)s(e)e(sp)s(eci\014ed)g(in)g(paren)m(theses)h(immediately)h
 (follo)m(wing)g(the)f(base)g(\014le)0 4811 y(name)28
 b(to)h(b)s(e)f(op)s(ened.)39 b(This)28 b(is)g(mainly)g(useful)g(in)g
 (those)g(cases)i(where)d(CFITSIO)g(creates)j(a)e(temp)s(orary)g(cop)m
 (y)0 4924 y(of)i(the)f(input)g(FITS)f(\014le)i(b)s(efore)f(it)h(is)f
 (op)s(ened)g(and)f(passed)h(to)h(the)g(application)h(program.)40
@@ -13848,28 +10945,16 @@
 (\014le)g(to)h(b)s(e)e(created)i(on)f(disk,)g(instead)h(of)f(a)g(temp)s
 (orary)0 5601 y(\014le)38 b(in)f(memory)-8 b(,)40 b(b)m(y)d(supplying)f
 (the)i(name)g(in)f(paren)m(theses)h(immediately)h(follo)m(wing)g(the)e
 (base)h(\014le)g(name.)0 5714 y(The)30 b(output)g(\014lename)g(can)h
 (include)f(the)h(')10 b(!')41 b(clobb)s(er)30 b(\015ag.)p
 eop end
 %%Page: 89 95
-TeXDict begin 89 94 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.89) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.4.)72
-b(OUTPUT)30 b(FILE)g(NAME)h(WHEN)g(OPENING)f(AN)h(EXISTING)e(FILE)967
+TeXDict begin 89 94 bop 0 299 a Fh(8.4.)72 b(OUTPUT)30
+b(FILE)g(NAME)h(WHEN)g(OPENING)f(AN)h(EXISTING)e(FILE)967
 b Fj(89)0 555 y(Th)m(us,)48 b(if)d(the)g(input)f(\014lename)h(to)g
 (CFITSIO)f(is:)70 b Ff(file1.fits.gz\(file2.fit)o(s\))39
 b Fj(then)44 b(CFITSIO)g(will)0 668 y(uncompress)39 b
 (`\014le1.\014ts.gz')j(in)m(to)f(the)f(lo)s(cal)h(disk)e(\014le)h
 (`\014le2.\014ts')h(b)s(efore)f(op)s(ening)f(it.)70 b(CFITSIO)38
 b(do)s(es)i(not)0 781 y(automatically)33 b(delete)f(the)e(output)g
 (\014le,)h(so)g(it)g(will)f(still)i(exist)f(after)g(the)f(application)i
@@ -13942,37 +11027,17 @@
 (uncompressed)0 5488 y(v)m(ersion)27 b(exists.)41 b(This)26
 b(can)h(get)h(rather)f(confusing,)h(so)f(users)f(should)g(use)h(a)g
 (certain)h(amoun)m(t)g(of)f(caution)h(when)0 5601 y(using)34
 b(the)h(output)f(\014le)h(sp)s(eci\014er)f(with)h(FTP)f(or)h(HTTP)f
 (\014le)h(t)m(yp)s(es,)h(to)f(mak)m(e)h(sure)e(they)h(get)h(the)f(b)s
 (eha)m(vior)0 5714 y(that)c(they)g(exp)s(ect.)p eop end
 %%Page: 90 96
-TeXDict begin 90 95 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.90) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(90)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.5) cvn /DEST pdfmark
-end
- 0 464 a
-91 x Fe(8.5)135 b(T)-11 b(emplate)46 b(File)g(Name)f(when)g(Creating)h
+TeXDict begin 90 95 bop 0 299 a Fj(90)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fe(8.5)135 b(T)-11 b(emplate)46 b(File)g(Name)f(when)g(Creating)h
 (a)g(New)f(File)0 808 y Fj(When)38 b(a)h(new)f(FITS)g(\014le)h(is)g
 (created)g(with)g(a)f(call)i(to)g(\014ts)p 2101 808 28
 4 v 32 w(create)p 2369 808 V 35 w(\014le,)g(the)f(name)g(of)g(a)g
 (template)h(\014le)e(ma)m(y)0 921 y(b)s(e)h(supplied)g(in)h(paren)m
 (theses)g(immediately)h(follo)m(wing)g(the)g(name)f(of)g(the)g(new)f
 (\014le)h(to)h(b)s(e)e(created.)71 b(This)0 1034 y(template)27
 b(is)e(used)g(to)h(de\014ne)f(the)h(structure)f(of)h(one)f(or)h(more)g
@@ -13982,23 +11047,15 @@
 (same)g(k)m(eyw)m(ords)g(in)0 1260 y(eac)m(h)25 b(HDU)g(as)g(in)f(the)g
 (template)i(FITS)d(\014le,)j(but)d(all)j(the)e(data)h(units)e(will)i(b)
 s(e)f(\014lled)g(with)f(zeros.)40 b(The)24 b(template)0
 1373 y(\014le)i(ma)m(y)h(also)g(b)s(e)e(an)h(ASCI)s(I)e(text)j(\014le,)
 g(where)f(eac)m(h)h(line)f(\(in)g(general\))i(describ)s(es)d(one)h
 (FITS)f(k)m(eyw)m(ord)i(record.)0 1486 y(The)j(format)h(of)f(the)h
 (ASCI)s(I)e(template)i(\014le)g(is)f(describ)s(ed)f(b)s(elo)m(w.)0
-1654 y
-SDict begin H.S end
- 0 1654 a 0 1654 a
-SDict begin 13.6 H.A end
- 0 1654 a 0 1654 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.6) cvn /DEST pdfmark
-end
- 0 1654 a 179
-x Fe(8.6)135 b(Image)46 b(Tile-Compression)h(Sp)t(eci\014cation)0
+1833 y Fe(8.6)135 b(Image)46 b(Tile-Compression)h(Sp)t(eci\014cation)0
 2086 y Fj(When)28 b(sp)s(ecifying)g(the)h(name)g(of)f(the)h(output)f
 (FITS)g(\014le)g(to)h(b)s(e)f(created,)i(the)f(user)f(can)g(indicate)i
 (that)f(images)0 2198 y(should)d(b)s(e)h(written)g(in)g
 (tile-compressed)h(format)g(\(see)g(section)g(5.5,)h(\\Primary)e(Arra)m
 (y)h(or)f(IMA)m(GE)h(Extension)0 2311 y(I/O)f(Routines"\))i(b)m(y)e
 (enclosing)h(the)g(compression)f(parameters)h(in)f(square)g(brac)m(k)m
 (ets)i(follo)m(wing)g(the)f(ro)s(ot)f(disk)0 2424 y(\014le)j(name.)41
@@ -14009,23 +11066,15 @@
 b(GZIP])47 b(-)g(use)g(the)g(specified)e(compression)g(algorithm;)191
 3034 y(myfile.fit[compress)d(Rice])238 b(only)46 b(the)h(first)g
 (letter)f(of)h(the)g(algorithm)191 3147 y(myfile.fit[compress)42
 b(PLIO])238 b(name)46 b(is)i(required.)191 3373 y(myfile.fit[compress)
 42 b(Rice)47 b(100,100])141 b(-)48 b(use)e(100)h(x)h(100)f(pixel)f
 (tile)h(size)191 3486 y(myfile.fit[compress)42 b(Rice)47
 b(100,100;2])e(-)j(as)f(above,)f(and)h(use)g(noisebits)e(=)i(2)0
-3657 y
-SDict begin H.S end
- 0 3657 a 0 3657 a
-SDict begin 13.6 H.A end
- 0 3657 a 0 3657 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.7) cvn /DEST pdfmark
-end
- 0 3657 a 176
-x Fe(8.7)135 b(HDU)46 b(Lo)t(cation)f(Sp)t(eci\014cation)0
+3833 y Fe(8.7)135 b(HDU)46 b(Lo)t(cation)f(Sp)t(eci\014cation)0
 4086 y Fj(The)c(optional)h(HDU)h(lo)s(cation)g(sp)s(eci\014er)d
 (de\014nes)h(whic)m(h)g(HDU)h(\(Header-Data)i(Unit,)h(also)d(kno)m(wn)f
 (as)h(an)0 4199 y(`extension'\))36 b(within)d(the)i(FITS)e(\014le)h(to)
 h(initially)h(op)s(en.)51 b(It)34 b(m)m(ust)g(immediately)i(follo)m(w)f
 (the)f(base)h(\014le)f(name)0 4312 y(\(or)g(the)g(output)g(\014le)g
 (name)f(if)h(presen)m(t\).)52 b(If)33 b(it)h(is)g(not)g(sp)s(eci\014ed)
 g(then)f(the)h(\014rst)f(HDU)i(\(the)f(primary)f(arra)m(y\))0
@@ -14055,45 +11104,33 @@
 b(alue)37 b(of)f(the)0 5601 y(EXTVER)27 b(k)m(eyw)m(ord\))i(and)e(the)h
 (extension)h(t)m(yp)s(e)e(\(v)-5 b(alue)29 b(of)f(the)g(XTENSION)f(k)m
 (eyw)m(ord:)40 b(IMA)m(GE,)29 b(ASCI)s(I)d(or)0 5714
 y(T)-8 b(ABLE,)36 b(or)f(BINT)-8 b(ABLE\),)36 b(separated)f(b)m(y)g
 (commas)h(and)e(all)i(enclosed)g(in)f(square)g(brac)m(k)m(ets.)56
 b(If)34 b(the)h(v)-5 b(alue)p eop end
 %%Page: 91 97
-TeXDict begin 91 96 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.91) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.8.)72
-b(IMA)m(GE)31 b(SECTION)2835 b Fj(91)0 555 y(of)34 b(EXTVER)f(and)f
-(XTENSION)h(are)h(not)f(sp)s(eci\014ed,)h(then)f(the)h(\014rst)e
-(extension)j(with)e(the)g(correct)i(v)-5 b(alue)34 b(of)0
-668 y(EXTNAME)39 b(is)g(op)s(ened.)67 b(The)38 b(extension)i(name)f
-(and)f(t)m(yp)s(e)i(are)f(not)h(case)g(sensitiv)m(e,)j(and)38
-b(the)h(extension)0 781 y(t)m(yp)s(e)29 b(ma)m(y)g(b)s(e)f(abbreviated)
-h(to)g(a)g(single)g(letter)h(\(e.g.,)h(I)d(=)g(IMA)m(GE)i(extension)f
-(or)f(primary)g(arra)m(y)-8 b(,)30 b(A)f(or)f(T)g(=)0
-894 y(ASCI)s(I)d(table)i(extension,)h(and)e(B)h(=)f(binary)g(table)h
-(BINT)-8 b(ABLE)27 b(extension\).)41 b(If)26 b(the)g(HDU)h(lo)s(cation)
-i(sp)s(eci\014er)0 1007 y(is)h(equal)h(to)g(`[PRIMAR)-8
-b(Y]')32 b(or)f(`[P]',)g(then)f(the)h(primary)e(arra)m(y)i(\(the)g
-(\014rst)f(HDU\))h(will)g(b)s(e)f(op)s(ened.)0 1167 y(FITS)k(images)i
-(are)f(most)h(commonly)f(stored)g(in)g(the)g(primary)f(arra)m(y)h(or)g
-(an)g(image)h(extension,)h(but)d(images)0 1280 y(can)d(also)h(b)s(e)e
-(stored)h(as)h(a)f(v)m(ector)h(in)f(a)g(single)h(cell)g(of)f(a)h
-(binary)e(table)i(\(i.e.)43 b(eac)m(h)32 b(ro)m(w)f(of)g(the)h(v)m
-(ector)g(column)0 1393 y(con)m(tains)d(a)g(di\013eren)m(t)f(image\).)42
+TeXDict begin 91 96 bop 0 299 a Fh(8.8.)72 b(IMA)m(GE)31
+b(SECTION)2835 b Fj(91)0 555 y(of)34 b(EXTVER)f(and)f(XTENSION)h(are)h
+(not)f(sp)s(eci\014ed,)h(then)f(the)h(\014rst)e(extension)j(with)e(the)
+g(correct)i(v)-5 b(alue)34 b(of)0 668 y(EXTNAME)39 b(is)g(op)s(ened.)67
+b(The)38 b(extension)i(name)f(and)f(t)m(yp)s(e)i(are)f(not)h(case)g
+(sensitiv)m(e,)j(and)38 b(the)h(extension)0 781 y(t)m(yp)s(e)29
+b(ma)m(y)g(b)s(e)f(abbreviated)h(to)g(a)g(single)g(letter)h(\(e.g.,)h
+(I)d(=)g(IMA)m(GE)i(extension)f(or)f(primary)g(arra)m(y)-8
+b(,)30 b(A)f(or)f(T)g(=)0 894 y(ASCI)s(I)d(table)i(extension,)h(and)e
+(B)h(=)f(binary)g(table)h(BINT)-8 b(ABLE)27 b(extension\).)41
+b(If)26 b(the)g(HDU)h(lo)s(cation)i(sp)s(eci\014er)0
+1007 y(is)h(equal)h(to)g(`[PRIMAR)-8 b(Y]')32 b(or)f(`[P]',)g(then)f
+(the)h(primary)e(arra)m(y)i(\(the)g(\014rst)f(HDU\))h(will)g(b)s(e)f
+(op)s(ened.)0 1167 y(FITS)k(images)i(are)f(most)h(commonly)f(stored)g
+(in)g(the)g(primary)f(arra)m(y)h(or)g(an)g(image)h(extension,)h(but)d
+(images)0 1280 y(can)d(also)h(b)s(e)e(stored)h(as)h(a)f(v)m(ector)h(in)
+f(a)g(single)h(cell)g(of)f(a)h(binary)e(table)i(\(i.e.)43
+b(eac)m(h)32 b(ro)m(w)f(of)g(the)h(v)m(ector)g(column)0
+1393 y(con)m(tains)d(a)g(di\013eren)m(t)f(image\).)42
 b(Suc)m(h)27 b(an)h(image)i(can)e(b)s(e)g(op)s(ened)f(with)h(CFITSIO)e
 (b)m(y)i(sp)s(ecifying)g(the)g(desired)0 1506 y(column)k(name)g(and)f
 (the)h(ro)m(w)g(n)m(um)m(b)s(er)f(after)h(the)g(binary)f(table)i(HDU)g
 (sp)s(eci\014er)e(as)h(sho)m(wn)g(in)f(the)h(follo)m(wing)0
 1619 y(examples.)71 b(The)40 b(column)g(name)h(is)f(separated)h(from)f
 (the)h(HDU)g(sp)s(eci\014er)f(b)m(y)g(a)h(semicolon)g(and)f(the)h(ro)m
 (w)0 1732 y(n)m(um)m(b)s(er)29 b(is)h(enclosed)h(in)e(paren)m(theses.)
@@ -14123,76 +11160,56 @@
 (also)g(requires)f(XTENSION)f(=)j('BINTABLE')143 3376
 y(myfile.fits[3;)c(images\(17\)])h(-)i(opens)g(the)g(image)f(in)h(row)g
 (17)g(of)g(the)g('images')1527 3489 y(column)f(in)i(the)e(3rd)h
 (extension)f(of)h(the)g(file.)143 3602 y(myfile.fits[3;)d
 (images\(exposure)g(>)j(100\)])g(-)g(as)g(above,)f(but)h(opens)g(the)f
 (image)907 3714 y(in)h(the)g(first)f(row)h(that)g(has)g(an)g
 ('exposure')e(column)h(value)907 3827 y(greater)g(than)g(100.)0
-3982 y
-SDict begin H.S end
- 0 3982 a 0 3982 a
-SDict begin 13.6 H.A end
- 0 3982 a 0 3982 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.8) cvn /DEST pdfmark
-end
- 0 3982 a 176
-x Fe(8.8)135 b(Image)46 b(Section)0 4408 y Fj(A)41 b(virtual)g(\014le)f
-(con)m(taining)i(a)f(rectangular)h(subsection)e(of)h(an)g(image)g(can)g
-(b)s(e)f(extracted)i(and)e(op)s(ened)g(b)m(y)0 4521 y(sp)s(ecifying)32
-b(the)h(range)g(of)g(pixels)g(\(start:end\))g(along)h(eac)m(h)g(axis)f
-(to)g(b)s(e)f(extracted)i(from)e(the)h(original)g(image.)0
-4634 y(One)d(can)h(also)h(sp)s(ecify)e(an)h(optional)h(pixel)f
-(incremen)m(t)g(\(start:end:step\))h(for)f(eac)m(h)h(axis)f(of)g(the)g
-(input)e(image.)0 4747 y(A)f(pixel)f(step)h(=)f(1)h(will)g(b)s(e)f
-(assumed)f(if)i(it)g(is)f(not)h(sp)s(eci\014ed.)39 b(If)27
-b(the)h(start)g(pixel)g(is)f(larger)i(then)e(the)h(end)e(pixel,)0
-4860 y(then)32 b(the)g(image)h(will)f(b)s(e)f(\015ipp)s(ed)f(\(pro)s
-(ducing)h(a)h(mirror)g(image\))h(along)g(that)f(dimension.)45
+4158 y Fe(8.8)135 b(Image)46 b(Section)0 4408 y Fj(A)41
+b(virtual)g(\014le)f(con)m(taining)i(a)f(rectangular)h(subsection)e(of)
+h(an)g(image)g(can)g(b)s(e)f(extracted)i(and)e(op)s(ened)g(b)m(y)0
+4521 y(sp)s(ecifying)32 b(the)h(range)g(of)g(pixels)g(\(start:end\))g
+(along)h(eac)m(h)g(axis)f(to)g(b)s(e)f(extracted)i(from)e(the)h
+(original)g(image.)0 4634 y(One)d(can)h(also)h(sp)s(ecify)e(an)h
+(optional)h(pixel)f(incremen)m(t)g(\(start:end:step\))h(for)f(eac)m(h)h
+(axis)f(of)g(the)g(input)e(image.)0 4747 y(A)f(pixel)f(step)h(=)f(1)h
+(will)g(b)s(e)f(assumed)f(if)i(it)g(is)f(not)h(sp)s(eci\014ed.)39
+b(If)27 b(the)h(start)g(pixel)g(is)f(larger)i(then)e(the)h(end)e
+(pixel,)0 4860 y(then)32 b(the)g(image)h(will)f(b)s(e)f(\015ipp)s(ed)f
+(\(pro)s(ducing)h(a)h(mirror)g(image\))h(along)g(that)f(dimension.)45
 b(An)32 b(asterisk,)h('*',)0 4973 y(ma)m(y)39 b(b)s(e)e(used)h(to)h(sp)
 s(ecify)f(the)g(en)m(tire)h(range)g(of)f(an)h(axis,)i(and)c('-*')j
 (will)e(\015ip)g(the)g(en)m(tire)h(axis.)65 b(The)38
 b(input)0 5086 y(image)31 b(can)f(b)s(e)f(in)g(the)h(primary)f(arra)m
 (y)-8 b(,)31 b(in)e(an)g(image)i(extension,)g(or)f(con)m(tained)g(in)g
 (a)g(v)m(ector)h(cell)g(of)f(a)g(binary)0 5199 y(table.)40
 b(In)25 b(the)h(later)h(2)f(cases)h(the)f(extension)h(name)f(or)f(n)m
 (um)m(b)s(er)g(m)m(ust)h(b)s(e)f(sp)s(eci\014ed)g(b)s(efore)h(the)g
 (image)h(section)0 5312 y(sp)s(eci\014er.)0 5472 y(Examples:)95
 5714 y Ff(myfile.fits[1:512:2,)43 b(2:512:2])i(-)95 b(open)47
 b(a)h(256x256)d(pixel)i(image)p eop end
 %%Page: 92 98
-TeXDict begin 92 97 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.92) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(92)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)668 555 y Ff(consisting)45 b(of)i(the)g(odd)g(numbered)f(columns)g
-(\(1st)g(axis\))h(and)668 668 y(the)g(even)g(numbered)e(rows)i(\(2nd)g
-(axis\))f(of)h(the)g(image)f(in)i(the)668 781 y(primary)e(array)g(of)i
-(the)e(file.)95 1007 y(myfile.fits[*,)e(512:256])i(-)h(open)g(an)g
-(image)g(consisting)e(of)i(all)g(the)g(columns)668 1120
-y(in)g(the)g(input)g(image,)f(but)h(only)f(rows)h(256)g(through)f(512.)
-668 1233 y(The)h(image)f(will)h(be)g(flipped)f(along)g(the)h(2nd)g
-(axis)g(since)668 1346 y(the)g(starting)f(pixel)g(is)h(greater)f(than)h
-(the)g(ending)f(pixel.)95 1571 y(myfile.fits[*:2,)e(512:256:2])h(-)i
-(same)g(as)g(above)f(but)h(keeping)f(only)668 1684 y(every)h(other)f
-(row)h(and)g(column)f(in)h(the)g(input)f(image.)95 1910
-y(myfile.fits[-*,)e(*])j(-)h(copy)e(the)h(entire)f(image,)g(flipping)g
-(it)h(along)668 2023 y(the)g(first)f(axis.)95 2249 y
-(myfile.fits[3][1:256,1:256)o(])c(-)47 b(opens)g(a)g(subsection)e(of)i
-(the)g(image)g(that)668 2362 y(is)g(in)h(the)e(3rd)h(extension)f(of)h
-(the)g(file.)95 2588 y(myfile.fits[4;)d(images\(12\)][1:10,1:10])e(-)48
+TeXDict begin 92 97 bop 0 299 a Fj(92)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)668
+555 y Ff(consisting)45 b(of)i(the)g(odd)g(numbered)f(columns)g(\(1st)g
+(axis\))h(and)668 668 y(the)g(even)g(numbered)e(rows)i(\(2nd)g(axis\))f
+(of)h(the)g(image)f(in)i(the)668 781 y(primary)e(array)g(of)i(the)e
+(file.)95 1007 y(myfile.fits[*,)e(512:256])i(-)h(open)g(an)g(image)g
+(consisting)e(of)i(all)g(the)g(columns)668 1120 y(in)g(the)g(input)g
+(image,)f(but)h(only)f(rows)h(256)g(through)f(512.)668
+1233 y(The)h(image)f(will)h(be)g(flipped)f(along)g(the)h(2nd)g(axis)g
+(since)668 1346 y(the)g(starting)f(pixel)g(is)h(greater)f(than)h(the)g
+(ending)f(pixel.)95 1571 y(myfile.fits[*:2,)e(512:256:2])h(-)i(same)g
+(as)g(above)f(but)h(keeping)f(only)668 1684 y(every)h(other)f(row)h
+(and)g(column)f(in)h(the)g(input)f(image.)95 1910 y(myfile.fits[-*,)e
+(*])j(-)h(copy)e(the)h(entire)f(image,)g(flipping)g(it)h(along)668
+2023 y(the)g(first)f(axis.)95 2249 y(myfile.fits[3][1:256,1:256)o(])c
+(-)47 b(opens)g(a)g(subsection)e(of)i(the)g(image)g(that)668
+2362 y(is)g(in)h(the)e(3rd)h(extension)f(of)h(the)g(file.)95
+2588 y(myfile.fits[4;)d(images\(12\)][1:10,1:10])e(-)48
 b(open)e(an)h(image)g(consisting)286 2700 y(of)h(the)e(first)h(10)g
 (pixels)f(in)h(both)g(dimensions.)e(The)i(original)286
 2813 y(image)g(resides)f(in)h(the)g(12th)f(row)h(of)g(the)g('images')f
 (vector)286 2926 y(column)g(in)i(the)f(table)f(in)h(the)g(4th)g
 (extension)e(of)i(the)g(file.)0 3203 y Fj(When)23 b(CFITSIO)f(op)s(ens)
 h(an)g(image)h(section)h(it)f(\014rst)f(creates)h(a)g(temp)s(orary)f
 (\014le)h(con)m(taining)h(the)e(image)i(section)0 3315
@@ -14202,63 +11219,44 @@
 (p)s(ossible)f(to)h(write)g(to)g(or)g(mo)s(dify)f(the)g(input)g(\014le)
 g(when)g(sp)s(ecifying)g(an)h(image)h(section.)0 3541
 y(Note)39 b(that)f(CFITSIO)e(automatically)k(up)s(dates)d(the)g(w)m
 (orld)h(co)s(ordinate)g(system)g(k)m(eyw)m(ords)f(in)g(the)h(header)0
 3654 y(of)33 b(the)h(image)g(section,)h(if)e(they)h(exist,)h(so)e(that)
 h(the)f(co)s(ordinate)h(asso)s(ciated)h(with)e(eac)m(h)h(pixel)f(in)g
 (the)h(image)0 3767 y(section)e(will)e(b)s(e)g(computed)g(correctly)-8
-b(.)0 3941 y
-SDict begin H.S end
- 0 3941 a 0 3941 a
-SDict begin 13.6 H.A end
- 0 3941 a 0 3941 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.9) cvn /DEST pdfmark
-end
- 0 3941
-a 179 x Fe(8.9)135 b(Image)46 b(T)-11 b(ransform)45 b(Filters)0
-4374 y Fj(CFITSIO)33 b(can)h(apply)g(a)h(user-sp)s(eci\014ed)e
-(mathematical)j(function)e(to)h(the)g(v)-5 b(alue)34
-b(of)h(ev)m(ery)g(pixel)f(in)g(a)h(FITS)0 4487 y(image,)29
-b(th)m(us)e(creating)h(a)g(new)e(virtual)h(image)i(in)d(computer)h
-(memory)g(that)h(is)f(then)f(op)s(ened)h(and)f(read)h(b)m(y)g(the)0
-4600 y(application)32 b(program.)40 b(The)30 b(original)i(FITS)d(image)
-j(is)e(not)h(mo)s(di\014ed)e(b)m(y)h(this)h(pro)s(cess.)0
-4760 y(The)20 b(image)j(transformation)e(sp)s(eci\014er)f(is)h(app)s
-(ended)e(to)j(the)f(input)f(FITS)h(\014le)g(name)g(and)f(is)h(enclosed)
-h(in)e(square)0 4873 y(brac)m(k)m(ets.)42 b(It)29 b(b)s(egins)f(with)h
-(the)g(letters)i('PIX')e(to)h(distinguish)e(it)i(from)e(other)i(t)m(yp)
-s(es)f(of)g(FITS)f(\014le)h(\014lters)g(that)0 4986 y(are)36
-b(recognized)i(b)m(y)e(CFITSIO.)e(The)i(image)h(transforming)f
-(function)f(ma)m(y)i(use)f(an)m(y)g(of)g(the)h(mathematical)0
-5099 y(op)s(erators)44 b(listed)h(in)f(the)h(follo)m(wing)h('Ro)m(w)f
-(Filtering)g(Sp)s(eci\014cation')g(section)h(of)e(this)h(do)s(cumen)m
-(t.)82 b(Some)0 5212 y(examples)31 b(of)f(image)i(transform)e
-(\014lters)g(are:)48 5488 y Ff([pix)46 b(X)i(*)f(2.0])715
-b(-)48 b(multiply)d(each)i(pixel)f(by)h(2.0)48 5601 y([pix)f
-(sqrt\(X\)])714 b(-)48 b(take)e(the)h(square)f(root)h(of)g(each)g
-(pixel)48 5714 y([pix)f(X)i(+)f(#ZEROPT)571 b(-)48 b(add)e(the)h(value)
-g(of)g(the)g(ZEROPT)f(keyword)p eop end
+b(.)0 4120 y Fe(8.9)135 b(Image)46 b(T)-11 b(ransform)45
+b(Filters)0 4374 y Fj(CFITSIO)33 b(can)h(apply)g(a)h(user-sp)s
+(eci\014ed)e(mathematical)j(function)e(to)h(the)g(v)-5
+b(alue)34 b(of)h(ev)m(ery)g(pixel)f(in)g(a)h(FITS)0 4487
+y(image,)29 b(th)m(us)e(creating)h(a)g(new)e(virtual)h(image)i(in)d
+(computer)h(memory)g(that)h(is)f(then)f(op)s(ened)h(and)f(read)h(b)m(y)
+g(the)0 4600 y(application)32 b(program.)40 b(The)30
+b(original)i(FITS)d(image)j(is)e(not)h(mo)s(di\014ed)e(b)m(y)h(this)h
+(pro)s(cess.)0 4760 y(The)20 b(image)j(transformation)e(sp)s(eci\014er)
+f(is)h(app)s(ended)e(to)j(the)f(input)f(FITS)h(\014le)g(name)g(and)f
+(is)h(enclosed)h(in)e(square)0 4873 y(brac)m(k)m(ets.)42
+b(It)29 b(b)s(egins)f(with)h(the)g(letters)i('PIX')e(to)h(distinguish)e
+(it)i(from)e(other)i(t)m(yp)s(es)f(of)g(FITS)f(\014le)h(\014lters)g
+(that)0 4986 y(are)36 b(recognized)i(b)m(y)e(CFITSIO.)e(The)i(image)h
+(transforming)f(function)f(ma)m(y)i(use)f(an)m(y)g(of)g(the)h
+(mathematical)0 5099 y(op)s(erators)44 b(listed)h(in)f(the)h(follo)m
+(wing)h('Ro)m(w)f(Filtering)g(Sp)s(eci\014cation')g(section)h(of)e
+(this)h(do)s(cumen)m(t.)82 b(Some)0 5212 y(examples)31
+b(of)f(image)i(transform)e(\014lters)g(are:)48 5488 y
+Ff([pix)46 b(X)i(*)f(2.0])715 b(-)48 b(multiply)d(each)i(pixel)f(by)h
+(2.0)48 5601 y([pix)f(sqrt\(X\)])714 b(-)48 b(take)e(the)h(square)f
+(root)h(of)g(each)g(pixel)48 5714 y([pix)f(X)i(+)f(#ZEROPT)571
+b(-)48 b(add)e(the)h(value)g(of)g(the)g(ZEROPT)f(keyword)p
+eop end
 %%Page: 93 99
-TeXDict begin 93 98 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.93) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.9.)72
-b(IMA)m(GE)31 b(TRANSF)m(ORM)g(FIL)-8 b(TERS)2237 b Fj(93)48
-555 y Ff([pix)46 b(X>0)h(?)h(log10\(X\))d(:)j(-99.])e(-)i(if)f(the)g
-(pixel)f(value)g(is)i(greater)1480 668 y(than)e(0,)h(compute)f(the)h
-(base)g(10)g(log,)1480 781 y(else)f(set)h(the)g(pixel)f(=)i(-99.)0
+TeXDict begin 93 98 bop 0 299 a Fh(8.9.)72 b(IMA)m(GE)31
+b(TRANSF)m(ORM)g(FIL)-8 b(TERS)2237 b Fj(93)48 555 y
+Ff([pix)46 b(X>0)h(?)h(log10\(X\))d(:)j(-99.])e(-)i(if)f(the)g(pixel)f
+(value)g(is)i(greater)1480 668 y(than)e(0,)h(compute)f(the)h(base)g(10)
+g(log,)1480 781 y(else)f(set)h(the)g(pixel)f(=)i(-99.)0
 1043 y Fj(Use)24 b(the)g(letter)h('X')f(in)f(the)h(expression)g(to)g
 (represen)m(t)g(the)g(curren)m(t)f(pixel)h(v)-5 b(alue)24
 b(in)f(the)h(image.)40 b(The)23 b(expression)0 1156 y(is)38
 b(ev)-5 b(aluated)39 b(indep)s(enden)m(tly)e(for)g(eac)m(h)i(pixel)f
 (in)g(the)g(image)h(and)e(ma)m(y)h(b)s(e)g(a)g(function)f(of)h(1\))h
 (the)f(original)0 1269 y(pixel)32 b(v)-5 b(alue,)32 b(2\))g(the)f(v)-5
 b(alue)32 b(of)f(other)h(pixels)f(in)g(the)g(image)i(at)f(a)f(giv)m(en)
@@ -14313,29 +11311,17 @@
 b(it)e(is)f(p)s(ermitted)g(to)h(use)e(m)m(ultiple)i(column)0
 5241 y(\014ltering)31 b(expressions.)40 b(F)-8 b(or)31
 b(example,)g(the)g(syn)m(tax)95 5477 y Ff(filename.fits[col)44
 b(*][col)i(-Y][col)f(Z=X+1])0 5714 y Fj(w)m(ould)30 b(b)s(e)g(treated)h
 (as)g(equiv)-5 b(alen)m(t)32 b(to)f(joining)f(the)h(expressions)f(with)
 g(semicolons,)i(or)p eop end
 %%Page: 94 100
-TeXDict begin 94 99 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191 a
--8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.94) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(94)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)95 555 y Ff(filename.fits[col)44 b(*;)j(-Y;col)f(Z=X+1])0
+TeXDict begin 94 99 bop 0 299 a Fj(94)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)95
+555 y Ff(filename.fits[col)44 b(*;)j(-Y;col)f(Z=X+1])0
 791 y Fj(Please)37 b(note)e(that)h(if)g(m)m(ultiple)g(column)f
 (\014ltering)g(expressions)g(are)h(used,)g(it)g(is)f(not)h(p)s
 (ermitted)f(to)h(also)g(use)0 904 y(the)31 b Ff([col)46
 b(@filename.txt])27 b Fj(syn)m(tax)k(in)f(an)m(y)g(of)h(the)f
 (individual)g(expressions.)0 1064 y(By)d(default,)g(the)f(datat)m(yp)s
 (e)i(of)e(the)g(resulting)h(image)g(will)g(b)s(e)e(the)i(same)f(as)h
 (the)f(original)i(image,)g(but)e(one)g(ma)m(y)0 1177
@@ -14357,23 +11343,15 @@
 b(F)-8 b(or)32 b(example:)239 2639 y Ff(myfile.fits[3][pixr1)90
 b(sqrt\(X\)])0 2900 y Fj(will)23 b(create)i(a)e(virtual)g(FITS)f
 (\014le)h(con)m(taining)h(only)f(a)g(primary)f(arra)m(y)i(image)g(with)
 e(32-bit)i(\015oating)g(p)s(oin)m(t)f(pixels)0 3013 y(that)29
 b(ha)m(v)m(e)h(a)f(v)-5 b(alue)30 b(equal)f(to)g(the)g(square)g(ro)s
 (ot)g(of)g(the)g(pixels)f(in)h(the)g(image)h(that)f(is)g(in)f(the)h
 (3rd)f(extension)i(of)0 3126 y(the)h('m)m(y\014le.\014ts')g(\014le.)0
-3282 y
-SDict begin H.S end
- 0 3282 a 0 3282 a
-SDict begin 13.6 H.A end
- 0 3282 a 0 3282 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.10) cvn /DEST pdfmark
-end
- 0 3282 a 179
-x Fe(8.10)136 b(Column)45 b(and)f(Keyw)l(ord)i(Filtering)g(Sp)t
+3461 y Fe(8.10)136 b(Column)45 b(and)f(Keyw)l(ord)i(Filtering)g(Sp)t
 (eci\014cation)0 3712 y Fj(The)27 b(optional)i(column/k)m(eyw)m(ord)g
 (\014ltering)f(sp)s(eci\014er)f(is)h(used)f(to)i(mo)s(dify)e(the)h
 (column)g(structure)f(and/or)h(the)0 3825 y(header)38
 b(k)m(eyw)m(ords)h(in)f(the)h(HDU)g(that)h(w)m(as)f(selected)h(with)e
 (the)h(previous)f(HDU)h(lo)s(cation)h(sp)s(eci\014er.)65
 b(This)0 3938 y(\014ltering)42 b(sp)s(eci\014er)f(m)m(ust)h(b)s(e)f
 (enclosed)i(in)e(square)h(brac)m(k)m(ets)h(and)e(can)h(b)s(e)f
@@ -14406,28 +11384,16 @@
 (and)g(columns)g(to)h(b)s(e)e(deleted,)j(then)e(all)h(the)g(columns)f
 (in)g(the)h(original)g(table)227 5601 y(except)36 b(the)e(explicitly)i
 (deleted)f(columns)f(will)h(app)s(ear)e(in)h(the)h(\014ltered)f(table)h
 (\(i.e.,)i(there)e(is)f(no)g(need)227 5714 y(to)d(explicitly)h(list)f
 (the)g(columns)f(to)h(b)s(e)f(included)f(if)i(an)m(y)f(columns)h(are)f
 (b)s(eing)g(deleted\).)p eop end
 %%Page: 95 101
-TeXDict begin 95 100 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.95) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.10.)73
-b(COLUMN)30 b(AND)h(KEYW)m(ORD)g(FIL)-8 b(TERING)30 b(SPECIFICA)-8
+TeXDict begin 95 100 bop 0 299 a Fh(8.10.)73 b(COLUMN)30
+b(AND)h(KEYW)m(ORD)g(FIL)-8 b(TERING)30 b(SPECIFICA)-8
 b(TION)1075 b Fj(95)136 555 y Fd(\017)46 b Fj(Delete)32
 b(a)d(column)g(or)g(k)m(eyw)m(ord)h(b)m(y)f(listing)h(the)f(name)g
 (preceded)g(b)m(y)g(a)g(min)m(us)g(sign)g(or)g(an)g(exclamation)227
 668 y(mark)c(\(!\),)h(e.g.,)i('-TIME')d(will)g(delete)h(the)e(TIME)h
 (column)f(if)g(it)i(exists,)g(otherwise)f(the)g(TIME)f(k)m(eyw)m(ord.)
 227 781 y(An)35 b(error)f(is)h(returned)e(if)i(neither)f(a)i(column)e
 (nor)g(k)m(eyw)m(ord)h(with)g(this)f(name)h(exists.)54
@@ -14498,31 +11464,19 @@
 (equals)h(sign)f(and)g(an)g(arithmetic)i(expression.)0
 5601 y(The)23 b(expression)g(that)i(is)e(used)g(when)g(app)s(ending)f
 (or)h(recomputing)h(columns)f(or)h(k)m(eyw)m(ords)g(can)g(b)s(e)f
 (arbitrarily)0 5714 y(complex)36 b(and)g(ma)m(y)g(b)s(e)f(a)h(function)
 g(of)g(other)g(header)g(k)m(eyw)m(ord)g(v)-5 b(alues)36
 b(and)f(other)h(columns)g(\(in)g(the)g(same)p eop end
 %%Page: 96 102
-TeXDict begin 96 101 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.96) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(96)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(ro)m(w\).)63 b(The)37 b(full)g(syn)m(tax)i(and)e(a)m(v)
--5 b(ailable)40 b(functions)d(for)g(the)h(expression)f(are)h(describ)s
-(ed)f(b)s(elo)m(w)h(in)f(the)h(ro)m(w)0 668 y(\014lter)30
+TeXDict begin 96 101 bop 0 299 a Fj(96)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(ro)m(w\).)63 b(The)37 b(full)g(syn)m(tax)i(and)e(a)m(v)-5
+b(ailable)40 b(functions)d(for)g(the)h(expression)f(are)h(describ)s(ed)
+f(b)s(elo)m(w)h(in)f(the)h(ro)m(w)0 668 y(\014lter)30
 b(sp)s(eci\014cation)i(section.)0 828 y(If)27 b(the)h(expression)g(con)
 m(tains)g(b)s(oth)f(a)h(list)h(of)f(columns)f(to)h(b)s(e)g(included)e
 (and)i(columns)f(to)h(b)s(e)f(deleted,)j(then)d(all)0
 941 y(the)34 b(columns)g(in)g(the)g(original)h(table)g(except)g(the)f
 (explicitly)i(deleted)f(columns)e(will)i(app)s(ear)e(in)h(the)g
 (\014ltered)0 1054 y(table.)40 b(If)26 b(no)g(columns)f(to)i(b)s(e)f
 (deleted)g(are)h(sp)s(eci\014ed,)f(then)g(only)g(the)h(columns)e(that)i
@@ -14537,67 +11491,47 @@
 (@\014lename.txt]'.)43 b(The)31 b(op)s(erations)g(can)0
 1666 y(extend)k(o)m(v)m(er)h(m)m(ultiple)g(lines)f(of)g(the)g(\014le,)h
 (but)e(m)m(ultiple)i(op)s(erations)f(m)m(ust)f(still)i(b)s(e)e
 (separated)i(b)m(y)e(commas)0 1779 y(or)e(semi-colons.)47
 b(An)m(y)32 b(lines)h(in)f(the)g(external)h(text)g(\014le)f(that)h(b)s
 (egin)e(with)h(2)h(slash)e(c)m(haracters)j(\('//'\))g(will)f(b)s(e)0
 1892 y(ignored)d(and)g(ma)m(y)h(b)s(e)f(used)g(to)h(add)e(commen)m(ts)j
-(in)m(to)f(the)g(\014le.)0 2052 y(Examples:)143 2419
+(in)m(to)f(the)g(\014le.)0 2052 y(Examples:)143 2439
 y Ff([col)47 b(Time,)f(rate])667 b(-)47 b(only)g(the)g(Time)g(and)g
-(rate)f(columns)g(will)1670 2532 y(appear)h(in)g(the)g(filtered)e
-(input)i(file.)143 2758 y([col)g(Time,)f(*raw])667 b(-)47
+(rate)f(columns)g(will)1670 2552 y(appear)h(in)g(the)g(filtered)e
+(input)i(file.)143 2778 y([col)g(Time,)f(*raw])667 b(-)47
 b(include)f(the)h(Time)g(column)f(and)h(any)g(other)1670
-2871 y(columns)f(whose)h(name)f(ends)h(with)g('raw'.)143
-3097 y([col)g(-TIME;)f(Good)h(==)g(STATUS])141 b(-)47
-b(deletes)f(the)h(TIME)g(column)f(and)1670 3210 y(renames)g(the)h
-(status)f(column)g(to)i('Good')143 3435 y([col)f(PI=PHA)f(*)h(1.1)g(+)h
+2891 y(columns)f(whose)h(name)f(ends)h(with)g('raw'.)143
+3117 y([col)g(-TIME;)f(Good)h(==)g(STATUS])141 b(-)47
+b(deletes)f(the)h(TIME)g(column)f(and)1670 3230 y(renames)g(the)h
+(status)f(column)g(to)i('Good')143 3456 y([col)f(PI=PHA)f(*)h(1.1)g(+)h
 (0.2;)e(#TUNIT#\(column)e(units\))i(=)i('counts';*])1575
-3548 y(-)f(creates)f(new)h(PI)g(column)f(from)h(PHA)g(values)1670
-3661 y(and)g(also)g(writes)f(the)h(TUNITn)f(keyword)1670
-3774 y(for)h(the)g(new)g(column.)94 b(The)47 b(final)f('*')1670
-3887 y(expression)f(means)i(preserve)e(all)i(the)1670
-4000 y(columns)f(in)h(the)g(input)g(table)f(in)h(the)1670
-4113 y(virtual)f(output)g(table;)94 b(without)46 b(the)h('*')1670
-4226 y(the)g(output)f(table)h(would)f(only)h(contain)1670
-4339 y(the)g(single)f('PI')h(column.)143 4565 y([col)g(rate)f(=)i
+3569 y(-)f(creates)f(new)h(PI)g(column)f(from)h(PHA)g(values)1670
+3681 y(and)g(also)g(writes)f(the)h(TUNITn)f(keyword)1670
+3794 y(for)h(the)g(new)g(column.)94 b(The)47 b(final)f('*')1670
+3907 y(expression)f(means)i(preserve)e(all)i(the)1670
+4020 y(columns)f(in)h(the)g(input)g(table)f(in)h(the)1670
+4133 y(virtual)f(output)g(table;)94 b(without)46 b(the)h('*')1670
+4246 y(the)g(output)f(table)h(would)f(only)h(contain)1670
+4359 y(the)g(single)f('PI')h(column.)143 4585 y([col)g(rate)f(=)i
 (rate/exposure,)c(TUNIT#\(&\))h(=)j('counts/s';*])1575
-4677 y(-)f(recomputes)e(the)i(rate)g(column)f(by)h(dividing)1670
-4790 y(it)h(by)f(the)g(EXPOSURE)e(keyword)h(value.)g(This)1670
-4903 y(also)h(modifies)f(the)h(value)f(of)h(the)g(TUNITn)1670
-5016 y(keyword)f(for)h(this)g(column.)f(The)h(use)f(of)i(the)1670
-5129 y('&')f(character)f(for)h(the)f(keyword)g(comment)1670
-5242 y(string)h(means)f(preserve)f(the)i(existing)1670
-5355 y(comment)f(string)g(for)h(that)g(keyword.)e(The)1670
-5468 y(final)i('*')g(preserves)e(all)i(the)g(columns)1670
-5581 y(in)h(the)f(input)f(table)g(in)h(the)g(virtual)1670
-5694 y(output)g(table.)p eop end
+4698 y(-)f(recomputes)e(the)i(rate)g(column)f(by)h(dividing)1670
+4811 y(it)h(by)f(the)g(EXPOSURE)e(keyword)h(value.)g(This)1670
+4924 y(also)h(modifies)f(the)h(value)f(of)h(the)g(TUNITn)1670
+5036 y(keyword)f(for)h(this)g(column.)f(The)h(use)f(of)i(the)1670
+5149 y('&')f(character)f(for)h(the)f(keyword)g(comment)1670
+5262 y(string)h(means)f(preserve)f(the)i(existing)1670
+5375 y(comment)f(string)g(for)h(that)g(keyword.)e(The)1670
+5488 y(final)i('*')g(preserves)e(all)i(the)g(columns)1670
+5601 y(in)h(the)f(input)f(table)g(in)h(the)g(virtual)1670
+5714 y(output)g(table.)p eop end
 %%Page: 97 103
-TeXDict begin 97 102 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.97) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.11.)73
-b(R)m(O)m(W)31 b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)2027
-b Fj(97)0 464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.11) cvn /DEST pdfmark
-end
- 0 464
-a 91 x Fe(8.11)136 b(Ro)l(w)45 b(Filtering)h(Sp)t(eci\014cation)0
+TeXDict begin 97 102 bop 0 299 a Fh(8.11.)73 b(R)m(O)m(W)31
+b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)2027 b Fj(97)0
+555 y Fe(8.11)136 b(Ro)l(w)45 b(Filtering)h(Sp)t(eci\014cation)0
 806 y Fj(When)29 b(en)m(tering)h(the)f(name)g(of)g(a)g(FITS)f(table)i
 (that)g(is)e(to)i(b)s(e)e(op)s(ened)h(b)m(y)f(a)i(program,)f(an)g
 (optional)h(ro)m(w)f(\014lter)0 919 y(ma)m(y)i(b)s(e)g(sp)s(eci\014ed)f
 (to)h(select)h(a)g(subset)e(of)h(the)g(ro)m(ws)f(in)h(the)g(table.)43
 b(A)31 b(temp)s(orary)f(new)g(FITS)g(\014le)h(is)g(created)0
 1032 y(on)25 b(the)h(\015y)e(whic)m(h)h(con)m(tains)h(only)g(those)g
 (ro)m(ws)f(for)g(whic)m(h)g(the)g(ro)m(w)g(\014lter)h(expression)f(ev)
@@ -14613,23 +11547,15 @@
 (the)h(GRADE)h(column)f(v)-5 b(alue)25 b(equals)g(50\).)0
 1596 y(When)33 b(dealing)h(with)f(tables)g(where)g(eac)m(h)h(ro)m(w)f
 (has)g(an)g(asso)s(ciated)i(time)f(and/or)f(2D)g(spatial)i(p)s
 (osition,)f(the)0 1709 y(ro)m(w)e(\014lter)h(expression)e(can)i(also)g
 (b)s(e)f(used)f(to)i(select)h(ro)m(ws)e(based)g(on)g(the)g(times)h(in)f
 (a)g(Go)s(o)s(d)g(Time)g(In)m(terv)-5 b(als)0 1822 y(\(GTI\))31
 b(extension,)g(or)f(on)h(spatial)g(p)s(osition)g(as)f(giv)m(en)i(in)e
-(a)g(SA)m(O-st)m(yle)i(region)f(\014le.)0 1973 y
-SDict begin H.S end
- 0 1973
-a 0 1973 a
-SDict begin 13.6 H.A end
- 0 1973 a 0 1973 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.11.1) cvn /DEST pdfmark
-end
- 0 1973 a 141 x Fc(8.11.1)113
+(a)g(SA)m(O-st)m(yle)i(region)f(\014le.)0 2114 y Fc(8.11.1)113
 b(General)38 b(Syn)m(tax)0 2333 y Fj(The)32 b(ro)m(w)h(\014ltering)g
 (expression)g(can)g(b)s(e)f(an)h(arbitrarily)g(complex)g(series)g(of)g
 (op)s(erations)g(p)s(erformed)f(on)g(con-)0 2446 y(stan)m(ts,)39
 b(k)m(eyw)m(ord)e(v)-5 b(alues,)38 b(and)e(column)g(data)i(tak)m(en)f
 (from)f(the)h(sp)s(eci\014ed)e(FITS)h(T)-8 b(ABLE)37
 b(extension.)59 b(The)0 2559 y(expression)37 b(m)m(ust)h(ev)-5
 b(aluate)39 b(to)g(a)f(b)s(o)s(olean)g(v)-5 b(alue)38
@@ -14683,1079 +11609,1034 @@
 (ultiple)i(ro)m(w)f(\014ltering)0 5006 y(expressions.)k(F)-8
 b(or)31 b(example,)h(the)e(expression)95 5242 y Ff(filename.fits[#ROW)
 43 b(>)48 b(5][X.gt.7])0 5478 y Fj(w)m(ould)30 b(b)s(e)g(treated)h(as)g
 (equiv)-5 b(alen)m(t)32 b(to)f(joining)f(the)h(expressions)f(with)g
 (logical)j(\\and")d(lik)m(e)i(this,)95 5714 y Ff(filename.fits[\(#ROW)
 43 b(>)k(5\)&&\(X.gt.7\)])p eop end
 %%Page: 98 104
-TeXDict begin 98 103 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.98) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(98)1618
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(Please)35 b(note)g(that)g(if)g(m)m(ultiple)g(ro)m(w)f
+TeXDict begin 98 103 bop 0 299 a Fj(98)1618 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(Please)35 b(note)g(that)g(if)g(m)m(ultiple)g(ro)m(w)f
 (\014ltering)h(expressions)e(are)i(used,)g(it)g(is)f(not)h(p)s
 (ermitted)e(to)i(also)h(use)e(the)0 668 y Ff([@filename.txt])26
 b Fj(syn)m(tax)31 b(in)f(an)m(y)h(of)f(the)h(individual)f(expressions.)
 0 828 y(Bo)s(olean)i(op)s(erators)f(can)g(b)s(e)f(used)f(in)i(the)f
 (expression)h(in)f(either)h(their)g(F)-8 b(ortran)31
 b(or)f(C)h(forms.)40 b(The)30 b(follo)m(wing)0 941 y(b)s(o)s(olean)g
-(op)s(erators)h(are)g(a)m(v)-5 b(ailable:)191 1179 y
+(op)s(erators)h(are)g(a)m(v)-5 b(ailable:)191 1191 y
 Ff("equal")428 b(.eq.)46 b(.EQ.)h(==)95 b("not)46 b(equal")476
-b(.ne.)94 b(.NE.)h(!=)191 1292 y("less)46 b(than")238
+b(.ne.)94 b(.NE.)h(!=)191 1304 y("less)46 b(than")238
 b(.lt.)46 b(.LT.)h(<)143 b("less)46 b(than/equal")188
-b(.le.)94 b(.LE.)h(<=)47 b(=<)191 1405 y("greater)e(than")95
+b(.le.)94 b(.LE.)h(<=)47 b(=<)191 1417 y("greater)e(than")95
 b(.gt.)46 b(.GT.)h(>)143 b("greater)45 b(than/equal")g(.ge.)94
-b(.GE.)h(>=)47 b(=>)191 1518 y("or")572 b(.or.)46 b(.OR.)h(||)95
-b("and")762 b(.and.)46 b(.AND.)h(&&)191 1631 y("negation")236
+b(.GE.)h(>=)47 b(=>)191 1530 y("or")572 b(.or.)46 b(.OR.)h(||)95
+b("and")762 b(.and.)46 b(.AND.)h(&&)191 1643 y("negation")236
 b(.not.)46 b(.NOT.)h(!)95 b("approx.)45 b(equal\(1e-7\)")92
-b(~)0 1869 y Fj(Note)32 b(that)g(the)f(exclamation)i(p)s(oin)m(t,)e(')
+b(~)0 1893 y Fj(Note)32 b(that)g(the)f(exclamation)i(p)s(oin)m(t,)e(')
 10 b(!',)33 b(is)e(a)g(sp)s(ecial)g(UNIX)h(c)m(haracter,)h(so)e(if)g
-(it)g(is)g(used)f(on)h(the)g(command)0 1982 y(line)i(rather)f(than)h
+(it)g(is)g(used)f(on)h(the)g(command)0 2005 y(line)i(rather)f(than)h
 (en)m(tered)g(at)g(a)g(task)g(prompt,)g(it)g(m)m(ust)f(b)s(e)g
 (preceded)h(b)m(y)f(a)h(bac)m(kslash)g(to)h(force)f(the)g(UNIX)0
-2095 y(shell)e(to)g(ignore)g(it.)0 2255 y(The)h(expression)g(ma)m(y)i
+2118 y(shell)e(to)g(ignore)g(it.)0 2279 y(The)h(expression)g(ma)m(y)i
 (also)f(include)f(arithmetic)i(op)s(erators)f(and)f(functions.)47
-b(T)-8 b(rigonometric)34 b(functions)e(use)0 2368 y(radians,)23
+b(T)-8 b(rigonometric)34 b(functions)e(use)0 2391 y(radians,)23
 b(not)g(degrees.)38 b(The)22 b(follo)m(wing)h(arithmetic)g(op)s
 (erators)g(and)e(functions)g(can)i(b)s(e)e(used)g(in)h(the)g
-(expression)0 2481 y(\(function)38 b(names)f(are)h(case)g(insensitiv)m
+(expression)0 2504 y(\(function)38 b(names)f(are)h(case)g(insensitiv)m
 (e\).)64 b(A)37 b(n)m(ull)h(v)-5 b(alue)38 b(will)f(b)s(e)g(returned)g
-(in)g(case)h(of)g(illegal)i(op)s(erations)0 2594 y(suc)m(h)30
+(in)g(case)h(of)g(illegal)i(op)s(erations)0 2617 y(suc)m(h)30
 b(as)h(divide)f(b)m(y)g(zero,)i(sqrt\(negativ)m(e\))h(log\(negativ)m
 (e\),)h(log10\(negativ)m(e\),)i(arccos\(.gt.)43 b(1\),)32
-b(arcsin\(.gt.)42 b(1\).)191 2832 y Ff("addition")522
-b(+)477 b("subtraction")d(-)191 2945 y("multiplication")234
-b(*)477 b("division")618 b(/)191 3057 y("negation")522
-b(-)477 b("exponentiation")330 b(**)143 b(^)191 3170
+b(arcsin\(.gt.)42 b(1\).)191 2867 y Ff("addition")522
+b(+)477 b("subtraction")d(-)191 2980 y("multiplication")234
+b(*)477 b("division")618 b(/)191 3093 y("negation")522
+b(-)477 b("exponentiation")330 b(**)143 b(^)191 3206
 y("absolute)45 b(value")237 b(abs\(x\))g("cosine")714
-b(cos\(x\))191 3283 y("sine")g(sin\(x\))237 b("tangent")666
-b(tan\(x\))191 3396 y("arc)47 b(cosine")427 b(arccos\(x\))93
-b("arc)47 b(sine")619 b(arcsin\(x\))191 3509 y("arc)47
+b(cos\(x\))191 3319 y("sine")g(sin\(x\))237 b("tangent")666
+b(tan\(x\))191 3432 y("arc)47 b(cosine")427 b(arccos\(x\))93
+b("arc)47 b(sine")619 b(arcsin\(x\))191 3545 y("arc)47
 b(tangent")379 b(arctan\(x\))93 b("arc)47 b(tangent")475
-b(arctan2\(y,x\))191 3622 y("hyperbolic)45 b(cos")237
+b(arctan2\(y,x\))191 3657 y("hyperbolic)45 b(cos")237
 b(cosh\(x\))189 b("hyperbolic)45 b(sin")333 b(sinh\(x\))191
-3735 y("hyperbolic)45 b(tan")237 b(tanh\(x\))189 b("round)46
-b(to)h(nearest)f(int")h(round\(x\))191 3848 y("round)f(down)h(to)g
+3770 y("hyperbolic)45 b(tan")237 b(tanh\(x\))189 b("round)46
+b(to)h(nearest)f(int")h(round\(x\))191 3883 y("round)f(down)h(to)g
 (int")94 b(floor\(x\))141 b("round)46 b(up)h(to)h(int")285
-b(ceil\(x\))191 3961 y("exponential")378 b(exp\(x\))237
-b("square)46 b(root")476 b(sqrt\(x\))191 4074 y("natural)45
+b(ceil\(x\))191 3996 y("exponential")378 b(exp\(x\))237
+b("square)46 b(root")476 b(sqrt\(x\))191 4109 y("natural)45
 b(log")381 b(log\(x\))237 b("common)46 b(log")524 b(log10\(x\))191
-4187 y("modulus")570 b(x)48 b(\045)f(y)191 4299 y("bitwise)e(AND")381
-b(x)48 b(&)f(y)286 b("bitwise)46 b(OR")524 b(x)47 b(|)h(y)191
-4412 y("bitwise)d(XOR")381 b(x)48 b(^^)f(y)238 b(\(bitwise)46
-b(operators)f(are)i(32-bit)f(int)h(only\))191 4525 y("random)f(#)h
-([0.0,1.0\)")e(random\(\))191 4638 y("random)h(Gaussian")188
-b(randomn\(\))93 b("random)46 b(Poisson")332 b(randomp\(x\))191
-4751 y("minimum")570 b(min\(x,y\))141 b("maximum")666
-b(max\(x,y\))191 4864 y("cumulative)45 b(sum")237 b(accum\(x\))141
-b("sequential)45 b(difference")g(seqdiff\(x\))191 4977
-y("if-then-else")330 b(b?x:y)191 5090 y("angular)45 b(separation")g
+4222 y("error)46 b(function")236 b(erf\(x\))h("complement)45
+b(of)i(erf")190 b(erfc\(x\))191 4335 y("gamma)46 b(function")236
+b(gamma\(x\))191 4448 y("modulus")570 b(x)48 b(\045)f(y)191
+4561 y("bitwise)e(AND")381 b(x)48 b(&)f(y)286 b("bitwise)46
+b(OR")524 b(x)47 b(|)h(y)191 4674 y("bitwise)d(XOR")381
+b(x)48 b(^^)f(y)238 b(\(bitwise)46 b(operators)f(are)i(32-bit)f(int)h
+(only\))191 4787 y("random)f(#)h([0.0,1.0\)")e(random\(\))191
+4899 y("random)h(Gaussian")188 b(randomn\(\))93 b("random)46
+b(Poisson")332 b(randomp\(x\))191 5012 y("minimum")570
+b(min\(x,y\))141 b("maximum")666 b(max\(x,y\))191 5125
+y("cumulative)45 b(sum")237 b(accum\(x\))141 b("sequential)45
+b(difference")g(seqdiff\(x\))191 5238 y("if-then-else")330
+b(b?x:y)191 5351 y("angular)45 b(separation")g
 (angsep\(ra1,dec1,ra2,de2\))c(\(all)47 b(in)g(degrees\))191
-5203 y("substring")474 b(strmid\(s,p,n\))44 b("string)i(search")237
-b(strstr\(s,r\))0 5441 y Fj(The)30 b(bit)m(wise)h(op)s(erators)f(for)h
+5464 y("substring")474 b(strmid\(s,p,n\))44 b("string)i(search")237
+b(strstr\(s,r\))0 5714 y Fj(The)30 b(bit)m(wise)h(op)s(erators)f(for)h
 (AND,)g(OR)f(and)g(X)m(OR)g(op)s(erate)h(up)s(on)e(32-bit)j(in)m(teger)
-f(expressions)f(only)-8 b(.)0 5601 y(Three)30 b(di\013eren)m(t)h
-(random)f(n)m(um)m(b)s(er)f(functions)h(are)h(pro)m(vided:)41
-b(random\(\),)30 b(with)h(no)f(argumen)m(ts,)h(pro)s(duces)f(a)0
-5714 y(uniform)g(random)f(deviate)k(b)s(et)m(w)m(een)e(0)g(and)f(1;)i
-(randomn\(\),)e(also)i(with)e(no)h(argumen)m(ts,)g(pro)s(duces)f(a)h
-(normal)p eop end
+f(expressions)f(only)-8 b(.)p eop end
 %%Page: 99 105
-TeXDict begin 99 104 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.99) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.11.)73
-b(R)m(O)m(W)31 b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)2027
-b Fj(99)0 555 y(\(Gaussian\))35 b(random)e(deviate)j(with)e(zero)h
-(mean)f(and)g(unit)f(standard)h(deviation;)j(randomp\(x\))d(pro)s
-(duces)f(a)0 668 y(P)m(oisson)27 b(random)f(deviate)h(whose)f(exp)s
+TeXDict begin 99 104 bop 0 299 a Fh(8.11.)73 b(R)m(O)m(W)31
+b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)2027 b Fj(99)0
+555 y(Three)30 b(di\013eren)m(t)h(random)f(n)m(um)m(b)s(er)f(functions)
+h(are)h(pro)m(vided:)41 b(random\(\),)30 b(with)h(no)f(argumen)m(ts,)h
+(pro)s(duces)f(a)0 668 y(uniform)g(random)f(deviate)k(b)s(et)m(w)m(een)
+e(0)g(and)f(1;)i(randomn\(\),)e(also)i(with)e(no)h(argumen)m(ts,)g(pro)
+s(duces)f(a)h(normal)0 781 y(\(Gaussian\))k(random)e(deviate)j(with)e
+(zero)h(mean)f(and)g(unit)f(standard)h(deviation;)j(randomp\(x\))d(pro)
+s(duces)f(a)0 894 y(P)m(oisson)27 b(random)f(deviate)h(whose)f(exp)s
 (ected)h(n)m(um)m(b)s(er)e(of)h(coun)m(ts)h(is)g(X.)f(X)h(ma)m(y)g(b)s
 (e)e(an)m(y)i(p)s(ositiv)m(e)g(real)g(n)m(um)m(b)s(er)0
-781 y(of)k(exp)s(ected)f(coun)m(ts,)h(including)f(fractional)i(v)-5
+1007 y(of)k(exp)s(ected)f(coun)m(ts,)h(including)f(fractional)i(v)-5
 b(alues,)31 b(but)f(the)g(return)g(v)-5 b(alue)31 b(is)f(an)g(in)m
-(teger.)0 941 y(When)d(the)g(random)g(functions)f(are)i(used)e(in)h(a)h
-(v)m(ector)g(expression,)g(b)m(y)f(default)h(the)f(same)h(random)e(v)-5
-b(alue)28 b(will)0 1054 y(b)s(e)g(used)f(when)h(ev)-5
+(teger.)0 1167 y(When)d(the)g(random)g(functions)f(are)i(used)e(in)h(a)
+h(v)m(ector)g(expression,)g(b)m(y)f(default)h(the)f(same)h(random)e(v)
+-5 b(alue)28 b(will)0 1280 y(b)s(e)g(used)f(when)h(ev)-5
 b(aluating)30 b(eac)m(h)f(elemen)m(t)h(of)f(the)g(v)m(ector.)41
 b(If)28 b(di\013eren)m(t)h(random)f(n)m(um)m(b)s(ers)f(are)i(desired,)f
-(then)0 1167 y(the)37 b(name)g(of)g(a)g(v)m(ector)i(column)e(should)e
+(then)0 1393 y(the)37 b(name)g(of)g(a)g(v)m(ector)i(column)e(should)e
 (b)s(e)i(supplied)e(as)i(the)h(single)f(argumen)m(t)g(to)h(the)f
-(random)f(function)0 1280 y(\(e.g.,)e("\015ux)c(+)h(0.1)i(*)e
+(random)f(function)0 1506 y(\(e.g.,)e("\015ux)c(+)h(0.1)i(*)e
 (random\(\015ux\)",)h(where)f("\015ux")g(is)g(the)h(name)f(of)h(a)f(v)m
-(ector)i(column\).)44 b(This)31 b(will)g(create)0 1393
+(ector)i(column\).)44 b(This)31 b(will)g(create)0 1619
 y(a)38 b(v)m(ector)i(of)e(random)f(n)m(um)m(b)s(ers)f(that)j(will)f(b)s
 (e)f(used)g(in)h(sequence)g(when)f(ev)-5 b(aluating)39
-b(eac)m(h)g(elemen)m(t)h(of)e(the)0 1506 y(v)m(ector)32
-b(expression.)0 1666 y(An)f(alternate)i(syn)m(tax)f(for)f(the)g(min)g
+b(eac)m(h)g(elemen)m(t)h(of)e(the)0 1732 y(v)m(ector)32
+b(expression.)0 1892 y(An)f(alternate)i(syn)m(tax)f(for)f(the)g(min)g
 (and)g(max)g(functions)g(has)g(only)g(a)h(single)g(argumen)m(t)g(whic)m
-(h)f(should)f(b)s(e)h(a)0 1779 y(v)m(ector)g(v)-5 b(alue)30
+(h)f(should)f(b)s(e)h(a)0 2005 y(v)m(ector)g(v)-5 b(alue)30
 b(\(see)g(b)s(elo)m(w\).)41 b(The)29 b(result)g(will)h(b)s(e)e(the)i
 (minim)m(um/maxim)m(um)f(elemen)m(t)h(con)m(tained)h(within)e(the)0
-1892 y(v)m(ector.)0 2052 y(The)35 b(accum\(x\))i(function)f(forms)f
+2118 y(v)m(ector.)0 2278 y(The)35 b(accum\(x\))i(function)f(forms)f
 (the)h(cum)m(ulativ)m(e)i(sum)d(of)h(x,)h(elemen)m(t)h(b)m(y)e(elemen)m
-(t.)58 b(V)-8 b(ector)38 b(columns)e(are)0 2165 y(supp)s(orted)h
+(t.)58 b(V)-8 b(ector)38 b(columns)e(are)0 2391 y(supp)s(orted)h
 (simply)h(b)m(y)g(p)s(erforming)f(the)i(summation)g(pro)s(cess)f
 (through)f(all)j(the)f(v)-5 b(alues.)65 b(Null)39 b(v)-5
-b(alues)39 b(are)0 2278 y(treated)30 b(as)f(0.)41 b(The)29
+b(alues)39 b(are)0 2503 y(treated)30 b(as)f(0.)41 b(The)29
 b(seqdi\013\(x\))h(function)e(forms)h(the)g(sequen)m(tial)i
 (di\013erence)e(of)h(x,)f(elemen)m(t)i(b)m(y)e(elemen)m(t.)41
-b(The)0 2391 y(\014rst)36 b(v)-5 b(alue)38 b(of)f(seqdi\013)g(is)g(the)
+b(The)0 2616 y(\014rst)36 b(v)-5 b(alue)38 b(of)f(seqdi\013)g(is)g(the)
 g(\014rst)g(v)-5 b(alue)37 b(of)g(x.)61 b(A)37 b(single)h(n)m(ull)f(v)
 -5 b(alue)38 b(in)e(x)h(causes)h(a)f(pair)g(of)g(n)m(ulls)g(in)g(the)0
-2503 y(output.)55 b(The)35 b(seqdi\013)g(and)g(accum)g(functions)g(are)
+2729 y(output.)55 b(The)35 b(seqdi\013)g(and)g(accum)g(functions)g(are)
 h(functional)f(in)m(v)m(erses,)j(i.e.,)g(seqdi\013\(accum\(x\)\))f(==)e
-(x)g(as)0 2616 y(long)c(as)g(no)f(n)m(ull)g(v)-5 b(alues)31
-b(are)g(presen)m(t.)0 2777 y(In)36 b(the)h(if-then-else)i(expression,)f
+(x)g(as)0 2842 y(long)c(as)g(no)f(n)m(ull)g(v)-5 b(alues)31
+b(are)g(presen)m(t.)0 3002 y(In)36 b(the)h(if-then-else)i(expression,)f
 ("b?x:y",)i(b)c(is)h(an)g(explicit)h(b)s(o)s(olean)f(v)-5
 b(alue)37 b(or)g(expression.)61 b(There)36 b(is)h(no)0
-2889 y(automatic)d(t)m(yp)s(e)e(con)m(v)m(ersion)h(from)e(n)m(umeric)h
+3115 y(automatic)d(t)m(yp)s(e)e(con)m(v)m(ersion)h(from)e(n)m(umeric)h
 (to)g(b)s(o)s(olean)g(v)-5 b(alues,)33 b(so)f(one)g(needs)f(to)i(use)e
-("iV)-8 b(al!=0")35 b(instead)0 3002 y(of)30 b(merely)g("iV)-8
+("iV)-8 b(al!=0")35 b(instead)0 3228 y(of)30 b(merely)g("iV)-8
 b(al")32 b(as)e(the)g(b)s(o)s(olean)g(argumen)m(t.)41
 b(x)30 b(and)f(y)h(can)g(b)s(e)f(an)m(y)h(scalar)h(data)g(t)m(yp)s(e)f
-(\(including)f(string\).)0 3163 y(The)22 b(angsep)g(function)f
+(\(including)f(string\).)0 3388 y(The)22 b(angsep)g(function)f
 (computes)i(the)f(angular)g(separation)h(in)e(degrees)i(b)s(et)m(w)m
-(een)g(2)f(celestial)j(p)s(ositions,)e(where)0 3275 y(the)36
+(een)g(2)f(celestial)j(p)s(ositions,)e(where)0 3501 y(the)36
 b(\014rst)f(2)h(parameters)g(giv)m(e)h(the)f(RA-lik)m(e)i(and)d
 (Dec-lik)m(e)j(co)s(ordinates)f(\(in)f(decimal)g(degrees\))h(of)f(the)g
-(\014rst)0 3388 y(p)s(osition,)31 b(and)e(the)i(3rd)f(and)g(4th)g
+(\014rst)0 3614 y(p)s(osition,)31 b(and)e(the)i(3rd)f(and)g(4th)g
 (parameters)h(giv)m(e)h(the)e(co)s(ordinates)i(of)e(the)h(second)f(p)s
-(osition.)0 3548 y(The)38 b(substring)f(function)i(strmid\(S,P)-8
+(osition.)0 3774 y(The)38 b(substring)f(function)i(strmid\(S,P)-8
 b(,N\))39 b(extracts)g(a)g(substring)f(from)g(S,)g(starting)h(at)g
-(string)g(p)s(osition)f(P)-8 b(,)0 3661 y(with)33 b(a)h(substring)f
+(string)g(p)s(osition)f(P)-8 b(,)0 3887 y(with)33 b(a)h(substring)f
 (length)h(N.)g(The)f(\014rst)g(c)m(haracter)j(p)s(osition)d(in)h(S)f
 (is)h(lab)s(eled)g(as)g(1.)51 b(If)33 b(P)g(is)h(0,)h(or)f(refers)f(to)
-0 3774 y(a)i(p)s(osition)g(b)s(ey)m(ond)f(the)h(end)e(of)i(S,)g(then)f
+0 4000 y(a)i(p)s(osition)g(b)s(ey)m(ond)f(the)h(end)e(of)i(S,)g(then)f
 (the)h(extracted)h(substring)d(will)i(b)s(e)f(NULL.)h(S,)f(P)-8
-b(,)36 b(and)e(N)g(ma)m(y)i(b)s(e)0 3887 y(functions)30
-b(of)g(other)h(columns.)0 4047 y(The)39 b(string)h(searc)m(h)h
+b(,)36 b(and)e(N)g(ma)m(y)i(b)s(e)0 4113 y(functions)30
+b(of)g(other)h(columns.)0 4273 y(The)39 b(string)h(searc)m(h)h
 (function)e(strstr\(S,R\))h(searc)m(hes)h(for)f(the)g(\014rst)f(o)s
-(ccurrence)h(of)g(the)g(substring)f(R)h(in)f(S.)0 4160
+(ccurrence)h(of)g(the)g(substring)f(R)h(in)f(S.)0 4386
 y(The)c(result)h(is)f(an)h(in)m(teger,)i(indicating)f(the)e(c)m
 (haracter)i(p)s(osition)f(of)g(the)g(\014rst)e(matc)m(h)j(\(where)e(1)h
-(is)g(the)g(\014rst)0 4273 y(c)m(haracter)c(p)s(osition)e(of)h(S\).)f
+(is)g(the)g(\014rst)0 4499 y(c)m(haracter)c(p)s(osition)e(of)h(S\).)f
 (If)g(no)h(matc)m(h)g(is)f(found,)g(then)g(strstr\(\))g(returns)f(a)i
-(NULL)f(v)-5 b(alue.)0 4433 y(The)37 b(follo)m(wing)i(t)m(yp)s(e)f
+(NULL)f(v)-5 b(alue.)0 4659 y(The)37 b(follo)m(wing)i(t)m(yp)s(e)f
 (casting)g(op)s(erators)g(are)g(a)m(v)-5 b(ailable,)42
 b(where)37 b(the)h(enclosing)g(paren)m(theses)g(are)g(required)0
-4546 y(and)30 b(tak)m(en)h(from)f(the)h(C)f(language)h(usage.)42
+4772 y(and)30 b(tak)m(en)h(from)f(the)h(C)f(language)h(usage.)42
 b(Also,)31 b(the)g(in)m(teger)g(to)h(real)f(casts)g(v)-5
-b(alues)30 b(to)i(double)e(precision:)764 4823 y Ff("real)46
+b(alues)30 b(to)i(double)e(precision:)764 5011 y Ff("real)46
 b(to)h(integer")189 b(\(int\))46 b(x)239 b(\(INT\))46
-b(x)764 4935 y("integer)f(to)i(real")190 b(\(float\))46
-b(i)143 b(\(FLOAT\))45 b(i)0 5212 y Fj(In)30 b(addition,)g(sev)m(eral)i
+b(x)764 5124 y("integer)f(to)i(real")190 b(\(float\))46
+b(i)143 b(\(FLOAT\))45 b(i)0 5362 y Fj(In)30 b(addition,)g(sev)m(eral)i
 (constan)m(ts)g(are)f(built)f(in)g(for)g(use)g(in)g(n)m(umerical)h
-(expressions:)382 5488 y Ff(#pi)667 b(3.1415...)284 b(#e)620
-b(2.7182...)382 5601 y(#deg)f(#pi/180)380 b(#row)524
-b(current)46 b(row)h(number)382 5714 y(#null)428 b(undefined)45
-b(value)142 b(#snull)428 b(undefined)45 b(string)p eop
-end
+(expressions:)382 5601 y Ff(#pi)667 b(3.1415...)284 b(#e)620
+b(2.7182...)382 5714 y(#deg)f(#pi/180)380 b(#row)524
+b(current)46 b(row)h(number)p eop end
 %%Page: 100 106
-TeXDict begin 100 105 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.100) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(100)1573
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(A)40 b(string)f(constan)m(t)i(m)m(ust)e(b)s(e)g
-(enclosed)h(in)g(quotes)g(as)f(in)h('Crab'.)67 b(The)39
-b("n)m(ull")i(constan)m(ts)f(are)g(useful)f(for)0 668
-y(conditionally)g(setting)g(table)g(v)-5 b(alues)38 b(to)g(a)g(NULL,)g
-(or)g(unde\014ned,)f(v)-5 b(alue)39 b(\(eg.,)i("col1==-99)f(?)62
-b(#NULL)38 b(:)0 781 y(col1"\).)0 941 y(In)m(teger)31
-b(constan)m(ts)h(ma)m(y)f(b)s(e)f(sp)s(eci\014ed)f(using)h(the)h(follo)
-m(wing)h(notation,)525 1180 y Ff(13245)142 b(decimal)46
-b(integer)525 1293 y(0x12f3)94 b(hexidecimal)45 b(integer)525
-1405 y(0o1373)94 b(octal)46 b(integer)525 1518 y(0b01001)g(binary)g
-(integer)0 1757 y Fj(Note)22 b(that)e(in)m(teger)i(constan)m(ts)g(are)e
-(only)h(allo)m(w)m(ed)h(to)f(b)s(e)e(32-bit,)24 b(i.e.)38
-b(b)s(et)m(w)m(een)21 b(-2)2787 1724 y Fa(\()2820 1757
-y Fj(31\))p Fb(and)p Fj(+2)3211 1724 y Fa(\()3244 1757
-y Fj(31\))p Fb(:I)7 b(nteg)s(er)s(constantsmay)s(beusedinany)s(ar)s
-(ithmeticexpr)s(essionw)r(her)s(eaninteg)s(er)s(w)r(oul)r(dbeappr)s
-(opr)s(iate:T)13 b(hus;)i(they)s(ar)s(edistinctf)10 b(r)s(ombitmask)s
-(s)p Fj(\()p Fb(w)r(hichmay)s(beof)g(ar)s(bitr)s(ar)s(y)s(l)r(eng)s
-(th;)15 b(al)r(l)r(ow)r(the)p Fj(")p Fb(w)r(il)r(dcar)s(d)p
-Fj(")p Fb(bit;)g(andmay)s(onl)r(y)s(beusedinl)r(og)s(ical)r(expr)s
-(essions)p Fj(;)g Fb(seebel)r(ow)r Fj(\))q Fb(:)0 1917
+TeXDict begin 100 105 bop 0 299 a Fj(100)1573 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)382
+555 y Ff(#null)428 b(undefined)45 b(value)142 b(#snull)428
+b(undefined)45 b(string)0 832 y Fj(A)40 b(string)f(constan)m(t)i(m)m
+(ust)e(b)s(e)g(enclosed)h(in)g(quotes)g(as)f(in)h('Crab'.)67
+b(The)39 b("n)m(ull")i(constan)m(ts)f(are)g(useful)f(for)0
+945 y(conditionally)g(setting)g(table)g(v)-5 b(alues)38
+b(to)g(a)g(NULL,)g(or)g(unde\014ned,)f(v)-5 b(alue)39
+b(\(eg.,)i("col1==-99)f(?)62 b(#NULL)38 b(:)0 1058 y(col1"\).)0
+1218 y(In)m(teger)31 b(constan)m(ts)h(ma)m(y)f(b)s(e)f(sp)s(eci\014ed)f
+(using)h(the)h(follo)m(wing)h(notation,)525 1466 y Ff(13245)142
+b(decimal)46 b(integer)525 1579 y(0x12f3)94 b(hexidecimal)45
+b(integer)525 1692 y(0o1373)94 b(octal)46 b(integer)525
+1805 y(0b01001)g(binary)g(integer)0 2053 y Fj(Note)22
+b(that)e(in)m(teger)i(constan)m(ts)g(are)e(only)h(allo)m(w)m(ed)h(to)f
+(b)s(e)e(32-bit,)24 b(i.e.)38 b(b)s(et)m(w)m(een)21 b(-2)2787
+2020 y Fa(\()2820 2053 y Fj(31\))p Fb(and)p Fj(+2)3211
+2020 y Fa(\()3244 2053 y Fj(31\))p Fb(:I)7 b(nteg)s(er)s(constantsmay)s
+(beusedinany)s(ar)s(ithmeticexpr)s(essionw)r(her)s(eaninteg)s(er)s(w)r
+(oul)r(dbeappr)s(opr)s(iate:T)13 b(hus;)i(they)s(ar)s(edistinctf)10
+b(r)s(ombitmask)s(s)p Fj(\()p Fb(w)r(hichmay)s(beof)g(ar)s(bitr)s(ar)s
+(y)s(l)r(eng)s(th;)15 b(al)r(l)r(ow)r(the)p Fj(")p Fb(w)r(il)r(dcar)s
+(d)p Fj(")p Fb(bit;)g(andmay)s(onl)r(y)s(beusedinl)r(og)s(ical)r(expr)s
+(essions)p Fj(;)g Fb(seebel)r(ow)r Fj(\))q Fb(:)0 2213
 y Fj(There)27 b(is)g(also)i(a)e(function)g(for)h(testing)g(if)f(t)m(w)m
 (o)i(v)-5 b(alues)28 b(are)g(close)g(to)h(eac)m(h)f(other,)h(i.e.,)g
-(if)e(they)h(are)g("near")g(eac)m(h)0 2030 y(other)c(to)h(within)e(a)h
+(if)e(they)h(are)g("near")g(eac)m(h)0 2326 y(other)c(to)h(within)e(a)h
 (user)g(sp)s(eci\014ed)f(tolerance.)40 b(The)24 b(argumen)m(ts,)h(v)-5
-b(alue)p 2502 2030 28 4 v 34 w(1)24 b(and)f(v)-5 b(alue)p
-2979 2030 V 33 w(2)25 b(can)f(b)s(e)f(in)m(teger)i(or)f(real)0
-2143 y(and)32 b(represen)m(t)h(the)g(t)m(w)m(o)h(v)-5
+b(alue)p 2502 2326 28 4 v 34 w(1)24 b(and)f(v)-5 b(alue)p
+2979 2326 V 33 w(2)25 b(can)f(b)s(e)f(in)m(teger)i(or)f(real)0
+2439 y(and)32 b(represen)m(t)h(the)g(t)m(w)m(o)h(v)-5
 b(alues)33 b(who's)f(pro)m(ximit)m(y)i(is)f(b)s(eing)f(tested)h(to)h(b)
-s(e)e(within)g(the)h(sp)s(eci\014ed)f(tolerance,)0 2256
-y(also)f(an)g(in)m(teger)g(or)g(real:)955 2520 y Ff(near\(value_1,)44
-b(value_2,)h(tolerance\))0 2785 y Fj(When)24 b(a)i(NULL,)e(or)h
+s(e)e(within)g(the)h(sp)s(eci\014ed)f(tolerance,)0 2552
+y(also)f(an)g(in)m(teger)g(or)g(real:)955 2829 y Ff(near\(value_1,)44
+b(value_2,)h(tolerance\))0 3106 y Fj(When)24 b(a)i(NULL,)e(or)h
 (unde\014ned,)f(v)-5 b(alue)25 b(is)g(encoun)m(tered)g(in)g(the)f(FITS)
 g(table,)j(the)e(expression)g(will)g(ev)-5 b(aluate)26
-b(to)0 2898 y(NULL)31 b(unless)f(the)h(unde\014ned)e(v)-5
+b(to)0 3219 y(NULL)31 b(unless)f(the)h(unde\014ned)e(v)-5
 b(alue)31 b(is)g(not)g(actually)h(required)e(for)h(ev)-5
 b(aluation,)33 b(e.g.)43 b("TR)m(UE)31 b(.or.)43 b(NULL")0
-3010 y(ev)-5 b(aluates)32 b(to)f(TR)m(UE.)g(The)f(follo)m(wing)h(t)m(w)
+3332 y(ev)-5 b(aluates)32 b(to)f(TR)m(UE.)g(The)f(follo)m(wing)h(t)m(w)
 m(o)h(functions)e(allo)m(w)i(some)f(NULL)f(detection)i(and)e(handling:)
-430 3275 y Ff("a)47 b(null)f(value?")667 b(ISNULL\(x\))430
-3388 y("define)45 b(a)j(value)e(for)h(null")190 b(DEFNULL\(x,y\))0
-3652 y Fj(The)36 b(former)h(returns)e(a)i(b)s(o)s(olean)g(v)-5
-b(alue)37 b(of)g(TR)m(UE)g(if)g(the)g(argumen)m(t)g(x)g(is)g(NULL.)g
-(The)f(later)i("de\014nes")f(a)0 3765 y(v)-5 b(alue)35
-b(to)g(b)s(e)e(substituted)h(for)g(NULL)g(v)-5 b(alues;)37
-b(it)e(returns)e(the)h(v)-5 b(alue)35 b(of)f(x)g(if)g(x)h(is)f(not)g
-(NULL,)h(otherwise)f(it)0 3878 y(returns)29 b(the)i(v)-5
-b(alue)31 b(of)f(y)-8 b(.)0 4029 y
-SDict begin H.S end
- 0 4029 a 0 4029 a
-SDict begin 13.6 H.A end
-
-0 4029 a 0 4029 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.11.2) cvn /DEST pdfmark
-end
- 0 4029 a 145 x Fc(8.11.2)113 b(Bit)36
-b(Masks)0 4394 y Fj(Bit)g(masks)f(can)h(b)s(e)f(used)f(to)i(select)h
-(out)e(ro)m(ws)h(from)e(bit)i(columns)f(\(TF)m(ORMn)g(=)g(#X\))h(in)f
-(FITS)f(\014les.)55 b(T)-8 b(o)0 4507 y(represen)m(t)30
-b(the)h(mask,)g(binary)-8 b(,)30 b(o)s(ctal,)i(and)e(hex)g(formats)g
-(are)h(allo)m(w)m(ed:)811 4772 y Ff(binary:)142 b
-(b0110xx1010000101xxxx00)o(01)811 4885 y(octal:)190 b(o720x1)46
-b(->)h(\(b111010000xxx001\))811 4998 y(hex:)286 b(h0FxD)94
-b(->)47 b(\(b00001111xxxx1101\))0 5262 y Fj(In)22 b(all)i(the)f
-(represen)m(tations,)j(an)c(x)h(or)g(X)g(is)g(allo)m(w)m(ed)i(in)d(the)
-h(mask)g(as)g(a)h(wild)e(card.)38 b(Note)25 b(that)e(the)g(x)g
-(represen)m(ts)0 5375 y(a)k(di\013eren)m(t)h(n)m(um)m(b)s(er)e(of)h
-(wild)f(card)h(bits)g(in)g(eac)m(h)h(represen)m(tation.)41
-b(All)27 b(represen)m(tations)h(are)g(case)g(insensitiv)m(e.)0
-5488 y(Although)41 b(bitmasks)g(ma)m(y)g(b)s(e)f(of)h(arbitrary)f
-(length)h(and)f(con)m(tain)i(a)g(wildcard,)h(they)e(ma)m(y)g(only)g(b)s
-(e)f(used)0 5601 y(in)c(logical)k(expressions,)e(unlik)m(e)f(in)m
-(teger)h(constan)m(ts)g(\(see)f(ab)s(o)m(v)m(e\))i(whic)m(h)d(ma)m(y)h
-(b)s(e)f(used)g(in)h(an)m(y)g(arithmetic)0 5714 y(expression.)p
+430 3609 y Ff("a)47 b(null)f(value?")667 b(ISNULL\(x\))430
+3722 y("define)45 b(a)j(value)e(for)h(null")190 b(DEFNULL\(x,y\))430
+3835 y("declare)45 b(certain)h(value)g(null")h(SETNULL\(x,y\))0
+4112 y Fj(ISNULL\(x\))24 b(returns)g(a)g(b)s(o)s(olean)h(v)-5
+b(alue)25 b(of)f(TR)m(UE)h(if)f(the)h(argumen)m(t)g(x)f(is)g(NULL.)h
+(DEFNULL\(x,y\))h("de\014nes")0 4225 y(a)31 b(v)-5 b(alue)31
+b(to)g(b)s(e)e(substituted)h(for)g(NULL)g(v)-5 b(alues;)31
+b(it)g(returns)e(the)i(v)-5 b(alue)31 b(of)f(x)h(if)f(x)g(is)h(not)f
+(NULL,)h(otherwise)f(it)0 4338 y(returns)d(the)i(v)-5
+b(alue)28 b(of)h(y)-8 b(.)40 b(SETNULL\(x,y\))28 b(allo)m(ws)i(NULL)e
+(v)-5 b(alues)29 b(to)g(b)s(e)f(inserted)g(in)m(to)h(a)g(v)-5
+b(ariable;)30 b(if)e(x==y)-8 b(,)0 4451 y(a)34 b(NULL)g(v)-5
+b(alue)35 b(is)f(returned;)g(otherwise)h(y)f(is)f(returned)g(\(x)h(and)
+g(y)g(m)m(ust)f(b)s(e)h(n)m(umerical,)h(and)f(x)f(m)m(ust)h(b)s(e)g(a)0
+4564 y(scalar\).)0 4875 y Fc(8.11.2)113 b(Bit)36 b(Masks)0
+5098 y Fj(Bit)g(masks)f(can)h(b)s(e)f(used)f(to)i(select)h(out)e(ro)m
+(ws)h(from)e(bit)i(columns)f(\(TF)m(ORMn)g(=)g(#X\))h(in)f(FITS)f
+(\014les.)55 b(T)-8 b(o)0 5211 y(represen)m(t)30 b(the)h(mask,)g
+(binary)-8 b(,)30 b(o)s(ctal,)i(and)e(hex)g(formats)g(are)h(allo)m(w)m
+(ed:)811 5488 y Ff(binary:)142 b(b0110xx1010000101xxxx00)o(01)811
+5601 y(octal:)190 b(o720x1)46 b(->)h(\(b111010000xxx001\))811
+5714 y(hex:)286 b(h0FxD)94 b(->)47 b(\(b00001111xxxx1101\))p
 eop end
 %%Page: 101 107
-TeXDict begin 101 106 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.101) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.11.)73
-b(R)m(O)m(W)31 b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)1982
-b Fj(101)0 555 y(T)-8 b(o)28 b(construct)g(the)g(b)s(o)s(olean)f
-(expression)h(using)f(the)h(mask)f(as)h(the)g(b)s(o)s(olean)f(equal)h
-(op)s(erator)g(describ)s(ed)f(ab)s(o)m(v)m(e)0 668 y(on)34
-b(a)h(bit)g(table)h(column.)53 b(F)-8 b(or)35 b(example,)i(if)d(y)m(ou)
-h(had)f(a)h(7)g(bit)g(column)f(named)g(\015ags)h(in)f(a)h(FITS)f(table)
-i(and)0 781 y(w)m(an)m(ted)31 b(all)g(ro)m(ws)g(ha)m(ving)g(the)f(bit)h
+TeXDict begin 101 106 bop 0 299 a Fh(8.11.)73 b(R)m(O)m(W)31
+b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)1982 b Fj(101)0
+555 y(In)22 b(all)i(the)f(represen)m(tations,)j(an)c(x)h(or)g(X)g(is)g
+(allo)m(w)m(ed)i(in)d(the)h(mask)g(as)g(a)h(wild)e(card.)38
+b(Note)25 b(that)e(the)g(x)g(represen)m(ts)0 668 y(a)k(di\013eren)m(t)h
+(n)m(um)m(b)s(er)e(of)h(wild)f(card)h(bits)g(in)g(eac)m(h)h(represen)m
+(tation.)41 b(All)27 b(represen)m(tations)h(are)g(case)g(insensitiv)m
+(e.)0 781 y(Although)41 b(bitmasks)g(ma)m(y)g(b)s(e)f(of)h(arbitrary)f
+(length)h(and)f(con)m(tain)i(a)g(wildcard,)h(they)e(ma)m(y)g(only)g(b)s
+(e)f(used)0 894 y(in)c(logical)k(expressions,)e(unlik)m(e)f(in)m(teger)
+h(constan)m(ts)g(\(see)f(ab)s(o)m(v)m(e\))i(whic)m(h)d(ma)m(y)h(b)s(e)f
+(used)g(in)h(an)m(y)g(arithmetic)0 1007 y(expression.)0
+1167 y(T)-8 b(o)28 b(construct)g(the)g(b)s(o)s(olean)f(expression)h
+(using)f(the)h(mask)f(as)h(the)g(b)s(o)s(olean)f(equal)h(op)s(erator)g
+(describ)s(ed)f(ab)s(o)m(v)m(e)0 1280 y(on)34 b(a)h(bit)g(table)h
+(column.)53 b(F)-8 b(or)35 b(example,)i(if)d(y)m(ou)h(had)f(a)h(7)g
+(bit)g(column)f(named)g(\015ags)h(in)f(a)h(FITS)f(table)i(and)0
+1393 y(w)m(an)m(ted)31 b(all)g(ro)m(ws)g(ha)m(ving)g(the)f(bit)h
 (pattern)f(0010011,)k(the)c(selection)j(expression)d(w)m(ould)g(b)s(e:)
-1336 1067 y Ff(flags)47 b(==)g(b0010011)191 1180 y(or)1336
-1292 y(flags)g(.eq.)f(b10011)0 1578 y Fj(It)35 b(is)g(also)h(p)s
+1336 1670 y Ff(flags)47 b(==)g(b0010011)191 1782 y(or)1336
+1895 y(flags)g(.eq.)f(b10011)0 2172 y Fj(It)35 b(is)g(also)h(p)s
 (ossible)e(to)i(test)g(if)f(a)g(range)g(of)g(bits)g(is)g(less)g(than,)h
 (less)f(than)g(equal,)i(greater)f(than)e(and)h(greater)0
-1691 y(than)30 b(equal)h(to)g(a)g(particular)g(b)s(o)s(olean)f(v)-5
-b(alue:)1336 1977 y Ff(flags)47 b(<=)g(bxxx010xx)1336
-2090 y(flags)g(.gt.)f(bxxx100xx)1336 2202 y(flags)h(.le.)f(b1xxxxxxx)0
-2488 y Fj(Notice)32 b(the)f(use)f(of)h(the)f(x)g(bit)h(v)-5
+2285 y(than)30 b(equal)h(to)g(a)g(particular)g(b)s(o)s(olean)f(v)-5
+b(alue:)1336 2562 y Ff(flags)47 b(<=)g(bxxx010xx)1336
+2675 y(flags)g(.gt.)f(bxxx100xx)1336 2788 y(flags)h(.le.)f(b1xxxxxxx)0
+3064 y Fj(Notice)32 b(the)f(use)f(of)h(the)f(x)g(bit)h(v)-5
 b(alue)31 b(to)g(limit)g(the)f(range)h(of)g(bits)f(b)s(eing)g
-(compared.)0 2648 y(It)i(is)h(not)f(necessary)h(to)g(sp)s(ecify)f(the)h
+(compared.)0 3225 y(It)i(is)h(not)f(necessary)h(to)g(sp)s(ecify)f(the)h
 (leading)g(\(most)g(signi\014can)m(t\))h(zero)f(\(0\))g(bits)f(in)g
-(the)h(mask,)g(as)g(sho)m(wn)e(in)0 2761 y(the)g(second)f(expression)g
-(ab)s(o)m(v)m(e.)0 2921 y(Bit)44 b(wise)f(AND,)h(OR)e(and)g(NOT)h(op)s
+(the)h(mask,)g(as)g(sho)m(wn)e(in)0 3338 y(the)g(second)f(expression)g
+(ab)s(o)m(v)m(e.)0 3498 y(Bit)44 b(wise)f(AND,)h(OR)e(and)g(NOT)h(op)s
 (erations)g(are)g(also)h(p)s(ossible)e(on)h(t)m(w)m(o)h(or)f(more)g
-(bit)g(\014elds)f(using)h(the)0 3034 y('&'\(AND\),)35
+(bit)g(\014elds)f(using)h(the)0 3611 y('&'\(AND\),)35
 b(')p Fd(j)p Fj('\(OR\),)g(and)e(the)h(')10 b(!'\(NOT\))34
 b(op)s(erators.)51 b(All)34 b(of)f(these)h(op)s(erators)g(result)f(in)h
-(a)g(bit)f(\014eld)g(whic)m(h)0 3147 y(can)e(then)f(b)s(e)f(used)h
+(a)g(bit)f(\014eld)g(whic)m(h)0 3723 y(can)e(then)f(b)s(e)f(used)h
 (with)g(the)h(equal)g(op)s(erator.)41 b(F)-8 b(or)31
-b(example:)1241 3433 y Ff(\(!flags\))45 b(==)j(b1101100)1241
-3546 y(\(flags)e(&)h(b1000001\))f(==)h(bx000001)0 3831
+b(example:)1241 4000 y Ff(\(!flags\))45 b(==)j(b1101100)1241
+4113 y(\(flags)e(&)h(b1000001\))f(==)h(bx000001)0 4390
 y Fj(Bit)35 b(\014elds)f(can)g(b)s(e)f(app)s(ended)g(as)h(w)m(ell)h
 (using)f(the)g('+')g(op)s(erator.)53 b(Strings)33 b(can)i(b)s(e)e
-(concatenated)j(this)e(w)m(a)m(y)-8 b(,)0 3944 y(to)s(o.)0
-4102 y
-SDict begin H.S end
- 0 4102 a 0 4102 a
-SDict begin 13.6 H.A end
- 0 4102 a 0 4102 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.11.3) cvn /DEST pdfmark
-end
- 0 4102 a 163
-x Fc(8.11.3)113 b(V)-9 b(ector)36 b(Columns)0 4490 y
-Fj(V)-8 b(ector)37 b(columns)e(can)h(also)g(b)s(e)f(used)f(in)h
+(concatenated)j(this)e(w)m(a)m(y)-8 b(,)0 4503 y(to)s(o.)0
+4814 y Fc(8.11.3)113 b(V)-9 b(ector)36 b(Columns)0 5036
+y Fj(V)-8 b(ector)37 b(columns)e(can)h(also)g(b)s(e)f(used)f(in)h
 (building)g(the)g(expression.)56 b(No)36 b(sp)s(ecial)g(syn)m(tax)f(is)
-h(required)e(if)i(one)0 4603 y(w)m(an)m(ts)46 b(to)f(op)s(erate)h(on)f
+h(required)e(if)i(one)0 5149 y(w)m(an)m(ts)46 b(to)f(op)s(erate)h(on)f
 (all)h(elemen)m(ts)g(of)f(the)h(v)m(ector.)86 b(Simply)44
 b(use)h(the)g(column)g(name)g(as)g(for)g(a)g(scalar)0
-4716 y(column.)d(V)-8 b(ector)32 b(columns)f(can)g(b)s(e)f(freely)h(in)
+5262 y(column.)d(V)-8 b(ector)32 b(columns)f(can)g(b)s(e)f(freely)h(in)
 m(termixed)h(with)e(scalar)i(columns)e(or)h(constan)m(ts)h(in)f
-(virtually)g(all)0 4829 y(expressions.)40 b(The)29 b(result)g(will)g(b)
+(virtually)g(all)0 5375 y(expressions.)40 b(The)29 b(result)g(will)g(b)
 s(e)g(of)g(the)g(same)h(dimension)e(as)i(the)f(v)m(ector.)42
-b(Tw)m(o)29 b(v)m(ectors)i(in)e(an)g(expression,)0 4942
+b(Tw)m(o)29 b(v)m(ectors)i(in)e(an)g(expression,)0 5488
 y(though,)f(need)e(to)i(ha)m(v)m(e)g(the)f(same)g(n)m(um)m(b)s(er)f(of)
 h(elemen)m(ts)h(and)e(ha)m(v)m(e)j(the)e(same)g(dimensions.)39
-b(The)26 b(only)h(places)0 5055 y(a)35 b(v)m(ector)h(column)e(cannot)h
+b(The)26 b(only)h(places)0 5601 y(a)35 b(v)m(ector)h(column)e(cannot)h
 (b)s(e)f(used)f(\(for)i(no)m(w,)g(an)m(yw)m(a)m(y\))h(are)f(the)g(SA)m
-(O)f(region)h(functions)f(and)f(the)i(NEAR)0 5168 y(b)s(o)s(olean)30
-b(function.)0 5328 y(Arithmetic)24 b(and)e(logical)k(op)s(erations)d
-(are)h(all)g(p)s(erformed)d(on)i(an)g(elemen)m(t)h(b)m(y)f(elemen)m(t)i
-(basis.)38 b(Comparing)23 b(t)m(w)m(o)0 5441 y(v)m(ector)32
-b(columns,)e(eg)h("COL1)f(==)g(COL2",)g(th)m(us)g(results)g(in)g
-(another)g(v)m(ector)i(of)e(b)s(o)s(olean)h(v)-5 b(alues)30
-b(indicating)0 5554 y(whic)m(h)g(elemen)m(ts)i(of)e(the)h(t)m(w)m(o)h
-(v)m(ectors)f(are)g(equal.)0 5714 y(Eigh)m(t)g(functions)f(are)h(a)m(v)
--5 b(ailable)33 b(that)e(op)s(erate)g(on)f(a)h(v)m(ector)h(and)d
-(return)h(a)g(scalar)i(result:)p eop end
+(O)f(region)h(functions)f(and)f(the)i(NEAR)0 5714 y(b)s(o)s(olean)30
+b(function.)p eop end
 %%Page: 102 108
-TeXDict begin 102 107 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.102) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(102)1573
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)191 555 y Ff("minimum")284 b(MIN\(V\))475 b("maximum")714
-b(MAX\(V\))191 668 y("average")284 b(AVERAGE\(V\))f("median")762
-b(MEDIAN\(V\))191 781 y("summation")188 b(SUM\(V\))475
-b("standard)46 b(deviation")188 b(STDDEV\(V\))191 894
+TeXDict begin 102 107 bop 0 299 a Fj(102)1573 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(Arithmetic)24 b(and)e(logical)k(op)s(erations)d(are)h(all)g(p)
+s(erformed)d(on)i(an)g(elemen)m(t)h(b)m(y)f(elemen)m(t)i(basis.)38
+b(Comparing)23 b(t)m(w)m(o)0 668 y(v)m(ector)32 b(columns,)e(eg)h
+("COL1)f(==)g(COL2",)g(th)m(us)g(results)g(in)g(another)g(v)m(ector)i
+(of)e(b)s(o)s(olean)h(v)-5 b(alues)30 b(indicating)0
+781 y(whic)m(h)g(elemen)m(ts)i(of)e(the)h(t)m(w)m(o)h(v)m(ectors)f(are)
+g(equal.)0 941 y(Sev)m(eral)e(functions)e(are)i(a)m(v)-5
+b(ailable)30 b(that)e(op)s(erate)h(on)f(a)g(v)m(ector.)41
+b(All)29 b(but)e(the)h(last)h(t)m(w)m(o)g(return)e(a)h(scalar)h
+(result:)191 1184 y Ff("minimum")284 b(MIN\(V\))475 b("maximum")714
+b(MAX\(V\))191 1297 y("average")284 b(AVERAGE\(V\))f("median")762
+b(MEDIAN\(V\))191 1410 y("summation")188 b(SUM\(V\))475
+b("standard)46 b(deviation")188 b(STDDEV\(V\))191 1523
 y("#)47 b(of)g(values")94 b(NELEM\(V\))379 b("#)48 b(of)f(non-null)e
-(values")94 b(NVALID\(V\))0 1180 y Fj(where)40 b(V)h(represen)m(ts)g
-(the)g(name)g(of)h(a)f(v)m(ector)h(column)f(or)g(a)h(man)m(ually)f
-(constructed)g(v)m(ector)i(using)d(curly)0 1293 y(brac)m(k)m(ets)27
-b(as)f(describ)s(ed)e(b)s(elo)m(w.)39 b(The)25 b(\014rst)g(6)h(of)g
-(these)g(functions)f(ignore)h(an)m(y)g(n)m(ull)f(v)-5
-b(alues)26 b(in)f(the)h(v)m(ector)h(when)0 1406 y(computing)k(the)f
-(result.)41 b(The)30 b(STDDEV\(\))h(function)g(computes)f(the)h(sample)
-g(standard)e(deviation,)j(i.e.)42 b(it)31 b(is)0 1519
-y(prop)s(ortional)f(to)h(1/SQR)-8 b(T\(N-1\))32 b(instead)f(of)g(1/SQR)
--8 b(T\(N\),)31 b(where)f(N)h(is)f(NV)-10 b(ALID\(V\).)0
-1679 y(The)32 b(SUM)h(function)f(literally)j(sums)c(all)j(the)f(elemen)
-m(ts)h(in)f(x,)g(returning)f(a)h(scalar)h(v)-5 b(alue.)48
-b(If)32 b(x)h(is)g(a)g(b)s(o)s(olean)0 1792 y(v)m(ector,)40
-b(SUM)c(returns)f(the)h(n)m(um)m(b)s(er)f(of)i(TR)m(UE)f(elemen)m(ts.)
-60 b(The)36 b(NELEM)g(function)g(returns)f(the)h(n)m(um)m(b)s(er)0
-1905 y(of)i(elemen)m(ts)h(in)f(v)m(ector)h(x)f(whereas)f(NV)-10
-b(ALID)39 b(return)d(the)i(n)m(um)m(b)s(er)f(of)h(non-n)m(ull)f(elemen)
-m(ts)j(in)d(the)h(v)m(ector.)0 2017 y(\(NELEM)28 b(also)h(op)s(erates)f
-(on)g(bit)f(and)g(string)h(columns,)g(returning)f(their)h(column)f
-(widths.\))40 b(As)27 b(an)h(example,)0 2130 y(to)42
-b(test)g(whether)f(all)h(elemen)m(ts)h(of)f(t)m(w)m(o)g(v)m(ectors)h
-(satisfy)f(a)g(giv)m(en)g(logical)i(comparison,)g(one)e(can)g(use)f
-(the)0 2243 y(expression)668 2529 y Ff(SUM\()47 b(COL1)f(>)i(COL2)f(\))
-g(==)g(NELEM\()f(COL1)h(\))0 2815 y Fj(whic)m(h)32 b(will)g(return)f
-(TR)m(UE)h(if)g(all)h(elemen)m(ts)g(of)f(COL1)g(are)g(greater)h(than)f
-(their)g(corresp)s(onding)f(elemen)m(ts)i(in)0 2928 y(COL2.)0
-3088 y(T)-8 b(o)32 b(sp)s(ecify)f(a)i(single)f(elemen)m(t)h(of)f(a)g(v)
-m(ector,)i(giv)m(e)f(the)f(column)f(name)h(follo)m(w)m(ed)h(b)m(y)f(a)g
-(comma-separated)h(list)0 3201 y(of)c(co)s(ordinates)g(enclosed)h(in)e
-(square)h(brac)m(k)m(ets.)41 b(F)-8 b(or)30 b(example,)g(if)e(a)h(v)m
-(ector)i(column)d(named)h(PHAS)f(exists)h(in)0 3314 y(the)e(table)g(as)
-g(a)g(one)g(dimensional,)h(256)g(comp)s(onen)m(t)f(list)g(of)g(n)m(um)m
-(b)s(ers)e(from)h(whic)m(h)h(y)m(ou)g(w)m(an)m(ted)g(to)g(select)i(the)
-0 3427 y(57th)j(comp)s(onen)m(t)g(for)f(use)g(in)g(the)h(expression,)f
-(then)h(PHAS[57])g(w)m(ould)f(do)h(the)f(tric)m(k.)45
-b(Higher)32 b(dimensional)0 3540 y(arra)m(ys)41 b(of)h(data)f(ma)m(y)h
-(app)s(ear)f(in)f(a)i(column.)73 b(But)41 b(in)g(order)f(to)i(in)m
-(terpret)f(them,)j(the)e(TDIMn)e(k)m(eyw)m(ord)0 3653
-y(m)m(ust)34 b(app)s(ear)g(in)g(the)g(header.)52 b(Assuming)34
-b(that)h(a)f(\(4,4,4,4\))k(arra)m(y)c(is)h(pac)m(k)m(ed)g(in)m(to)g
-(eac)m(h)h(ro)m(w)e(of)g(a)h(column)0 3766 y(named)26
-b(ARRA)-8 b(Y4D,)28 b(the)f(\(1,2,3,4\))i(comp)s(onen)m(t)e(elemen)m(t)
-g(of)g(eac)m(h)g(ro)m(w)g(is)f(accessed)i(b)m(y)e(ARRA)-8
-b(Y4D[1,2,3,4].)0 3878 y(Arra)m(ys)33 b(up)e(to)j(dimension)e(5)h(are)f
+(values")94 b(NVALID\(V\))191 1635 y("#)47 b(axes")333
+b(NAXIS\(V\))379 b("axis)47 b(dimension")379 b(NAXES\(V,n\))191
+1748 y("axis)46 b(pos'n")142 b(AXISELEM\(V,n\))d("vector)46
+b(element)g(pos'n")94 b(ELEMENTNUM\(V\))1670 1861 y("promote)46
+b(to)h(array")285 b(ARRAY\(X,d\))0 2104 y Fj(where)40
+b(V)h(represen)m(ts)g(the)g(name)g(of)h(a)f(v)m(ector)h(column)f(or)g
+(a)h(man)m(ually)f(constructed)g(v)m(ector)i(using)d(curly)0
+2217 y(brac)m(k)m(ets)27 b(as)f(describ)s(ed)e(b)s(elo)m(w.)39
+b(The)25 b(\014rst)g(6)h(of)g(these)g(functions)f(ignore)h(an)m(y)g(n)m
+(ull)f(v)-5 b(alues)26 b(in)f(the)h(v)m(ector)h(when)0
+2330 y(computing)k(the)f(result.)41 b(The)30 b(STDDEV\(\))h(function)g
+(computes)f(the)h(sample)g(standard)e(deviation,)j(i.e.)42
+b(it)31 b(is)0 2443 y(prop)s(ortional)f(to)h(1/SQR)-8
+b(T\(N-1\))32 b(instead)f(of)g(1/SQR)-8 b(T\(N\),)31
+b(where)f(N)h(is)f(NV)-10 b(ALID\(V\).)0 2603 y(The)25
+b(NAXIS\(V\))i(function)e(returns)g(the)h(n)m(um)m(b)s(er)f(of)h(axes)g
+(of)g(the)g(v)m(ector,)j(for)c(example)i(a)f(2D)h(arra)m(y)f(w)m(ould)g
+(b)s(e)0 2716 y(NAXIS\(V\))34 b(==)f(2.)50 b(The)32 b(NAXES\(V,n\))i
+(function)f(returns)f(the)i(dimension)e(of)i(axis)g(n,)f(for)g(example)
+h(a)g(4x2)0 2829 y(arra)m(y)h(w)m(ould)f(ha)m(v)m(e)h(NAXES\(V,1\))h
+(==)d(4.)53 b(The)33 b(ELEMENTNUM\(V\))j(and)d(AXISELEM\(V,n\))h
+(functions)0 2942 y(return)42 b(v)m(ectors)j(of)f(the)g(same)g(size)g
+(as)g(the)f(input)g(v)m(ector)i(V.)f(ELEMENTNUM\(V\))g(returns)f(the)g
+(v)m(ector)0 3054 y(elemen)m(t)28 b(p)s(osition)e(for)g(eac)m(h)i
+(elemen)m(t)f(in)f(the)h(v)m(ector,)i(starting)e(from)e(1)i(in)f(eac)m
+(h)i(ro)m(w.)39 b(The)26 b(AXISELEM\(V,n\))0 3167 y(function)k(is)g
+(similar)h(but)f(returns)f(the)i(elemen)m(t)g(p)s(osition)g(of)f(axis)h
+(n)f(only)-8 b(.)0 3328 y(The)32 b(SUM)h(function)f(literally)j(sums)c
+(all)j(the)f(elemen)m(ts)h(in)f(x,)g(returning)f(a)h(scalar)h(v)-5
+b(alue.)48 b(If)32 b(x)h(is)g(a)g(b)s(o)s(olean)0 3440
+y(v)m(ector,)40 b(SUM)c(returns)f(the)h(n)m(um)m(b)s(er)f(of)i(TR)m(UE)
+f(elemen)m(ts.)60 b(The)36 b(NELEM)g(function)g(returns)f(the)h(n)m(um)
+m(b)s(er)0 3553 y(of)i(elemen)m(ts)h(in)f(v)m(ector)h(x)f(whereas)f(NV)
+-10 b(ALID)39 b(return)d(the)i(n)m(um)m(b)s(er)f(of)h(non-n)m(ull)f
+(elemen)m(ts)j(in)d(the)h(v)m(ector.)0 3666 y(\(NELEM)28
+b(also)h(op)s(erates)f(on)g(bit)f(and)g(string)h(columns,)g(returning)f
+(their)h(column)f(widths.\))40 b(As)27 b(an)h(example,)0
+3779 y(to)42 b(test)g(whether)f(all)h(elemen)m(ts)h(of)f(t)m(w)m(o)g(v)
+m(ectors)h(satisfy)f(a)g(giv)m(en)g(logical)i(comparison,)g(one)e(can)g
+(use)f(the)0 3892 y(expression)668 4135 y Ff(SUM\()47
+b(COL1)f(>)i(COL2)f(\))g(==)g(NELEM\()f(COL1)h(\))0 4377
+y Fj(whic)m(h)32 b(will)g(return)f(TR)m(UE)h(if)g(all)h(elemen)m(ts)g
+(of)f(COL1)g(are)g(greater)h(than)f(their)g(corresp)s(onding)f(elemen)m
+(ts)i(in)0 4490 y(COL2.)0 4650 y(The)g(ARRA)-8 b(Y\(X,d\))35
+b(function)e(promotes)h(scalar)g(v)-5 b(alue)34 b(X)f(to)h(a)g(v)m
+(ector)h(\(or)f(arra)m(y\))g(table)h(elemen)m(t.)51 b(X)33
+b(ma)m(y)0 4763 y(b)s(e)h(an)m(y)h(scalar-v)-5 b(alued)36
+b(item,)g(including)f(a)g(column,)g(an)g(expression,)g(or)g(a)g
+(constan)m(t)h(v)-5 b(alue.)54 b(The)34 b(resulting)0
+4876 y(v)m(ector)39 b(or)e(arra)m(y)h(will)g(ha)m(v)m(e)g(the)g(same)g
+(scalar)g(v)-5 b(alue)38 b(replicated)g(in)m(to)h(eac)m(h)f(elemen)m(t)
+h(p)s(osition.)62 b(This)36 b(ma)m(y)0 4989 y(b)s(e)e(a)i(useful)e(w)m
+(a)m(y)i(to)g(construct)g(large)g(arra)m(ys)f(without)g(using)g(the)g
+(cum)m(b)s(ersome)g Fd(f)p Fj(v)m(ector)p Fd(g)i Fj(notation.)56
+b(The)0 5102 y(dimensions)26 b(of)h(the)h(new)e(arra)m(y)h(are)h(giv)m
+(en)g(b)m(y)f(the)g(second)g(argumen)m(t,)h(d.)39 b(d)27
+b(can)g(either)g(b)s(e)g(a)g(single)h(constan)m(t)0 5215
+y(in)m(teger)g(v)-5 b(alue,)28 b(or)f(a)f(v)m(ector)j(of)d(up)g(to)h
+(\014v)m(e)g(dimensions)f(of)g(the)h(form)f Fd(f)p Fj(Nx,Ny)-8
+b(,...)p Fd(g)p Fj(.)43 b(Th)m(us,)26 b(ARRA)-8 b(Y\(TIME,4\))0
+5328 y(w)m(ould)28 b(promote)g(TIME)g(to)h(b)s(e)e(a)i(4-v)m(ector,)i
+(and)d(ARRA)-8 b(Y\(0,)30 b Fd(f)p Fj(2,3,1)p Fd(g)p
+Fj(\))h(w)m(ould)d(construct)h(an)f(arra)m(y)g(of)g(all)h(0's)0
+5441 y(with)h(dimensions)g(2)20 b Fd(\002)g Fj(3)h Fd(\002)f
+Fj(1.)0 5601 y(T)-8 b(o)32 b(sp)s(ecify)f(a)i(single)f(elemen)m(t)h(of)
+f(a)g(v)m(ector,)i(giv)m(e)f(the)f(column)f(name)h(follo)m(w)m(ed)h(b)m
+(y)f(a)g(comma-separated)h(list)0 5714 y(of)c(co)s(ordinates)g
+(enclosed)h(in)e(square)h(brac)m(k)m(ets.)41 b(F)-8 b(or)30
+b(example,)g(if)e(a)h(v)m(ector)i(column)d(named)h(PHAS)f(exists)h(in)p
+eop end
+%%Page: 103 109
+TeXDict begin 103 108 bop 0 299 a Fh(8.11.)73 b(R)m(O)m(W)31
+b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)1982 b Fj(103)0
+555 y(the)27 b(table)g(as)g(a)g(one)g(dimensional,)h(256)g(comp)s(onen)
+m(t)f(list)g(of)g(n)m(um)m(b)s(ers)e(from)h(whic)m(h)h(y)m(ou)g(w)m(an)
+m(ted)g(to)g(select)i(the)0 668 y(57th)j(comp)s(onen)m(t)g(for)f(use)g
+(in)g(the)h(expression,)f(then)h(PHAS[57])g(w)m(ould)f(do)h(the)f(tric)
+m(k.)45 b(Higher)32 b(dimensional)0 781 y(arra)m(ys)41
+b(of)h(data)f(ma)m(y)h(app)s(ear)f(in)f(a)i(column.)73
+b(But)41 b(in)g(order)f(to)i(in)m(terpret)f(them,)j(the)e(TDIMn)e(k)m
+(eyw)m(ord)0 894 y(m)m(ust)34 b(app)s(ear)g(in)g(the)g(header.)52
+b(Assuming)34 b(that)h(a)f(\(4,4,4,4\))k(arra)m(y)c(is)h(pac)m(k)m(ed)g
+(in)m(to)g(eac)m(h)h(ro)m(w)e(of)g(a)h(column)0 1007
+y(named)26 b(ARRA)-8 b(Y4D,)28 b(the)f(\(1,2,3,4\))i(comp)s(onen)m(t)e
+(elemen)m(t)g(of)g(eac)m(h)g(ro)m(w)g(is)f(accessed)i(b)m(y)e(ARRA)-8
+b(Y4D[1,2,3,4].)0 1120 y(Arra)m(ys)33 b(up)e(to)j(dimension)e(5)h(are)f
 (curren)m(tly)h(supp)s(orted.)46 b(Eac)m(h)33 b(v)m(ector)h(index)e
-(can)h(itself)g(b)s(e)f(an)h(expression,)0 3991 y(although)39
+(can)h(itself)g(b)s(e)f(an)h(expression,)0 1233 y(although)39
 b(it)g(m)m(ust)g(ev)-5 b(aluate)40 b(to)f(an)g(in)m(teger)h(v)-5
 b(alue)39 b(within)f(the)h(b)s(ounds)d(of)j(the)g(v)m(ector.)67
-b(V)-8 b(ector)40 b(columns)0 4104 y(whic)m(h)31 b(con)m(tain)h(spaces)
+b(V)-8 b(ector)40 b(columns)0 1346 y(whic)m(h)31 b(con)m(tain)h(spaces)
 g(or)f(arithmetic)h(op)s(erators)g(m)m(ust)f(ha)m(v)m(e)h(their)f
-(names)g(enclosed)h(in)f("$")h(c)m(haracters)h(as)0 4217
-y(with)d($ARRA)-8 b(Y-4D$[1,2,3,4].)0 4377 y(A)45 b(more)f(C-lik)m(e)i
+(names)g(enclosed)h(in)f("$")h(c)m(haracters)h(as)0 1458
+y(with)d($ARRA)-8 b(Y-4D$[1,2,3,4].)0 1619 y(A)45 b(more)f(C-lik)m(e)i
 (syn)m(tax)g(for)e(sp)s(ecifying)g(v)m(ector)j(indices)d(is)h(also)h(a)
 m(v)-5 b(ailable.)85 b(The)45 b(elemen)m(t)h(used)d(in)i(the)0
-4490 y(preceding)28 b(example)h(alternativ)m(ely)i(could)d(b)s(e)g(sp)s
+1732 y(preceding)28 b(example)h(alternativ)m(ely)i(could)d(b)s(e)g(sp)s
 (eci\014ed)g(with)f(the)i(syn)m(tax)g(ARRA)-8 b(Y4D[4][3][2][1].)45
-b(Note)30 b(the)0 4603 y(rev)m(erse)40 b(order)f(of)h(indices)f(\(as)h
+b(Note)30 b(the)0 1844 y(rev)m(erse)40 b(order)f(of)h(indices)f(\(as)h
 (in)f(C\),)h(as)f(w)m(ell)i(as)e(the)h(fact)g(that)g(the)g(v)-5
-b(alues)40 b(are)f(still)i(ones-based)e(\(as)h(in)0 4716
+b(alues)40 b(are)f(still)i(ones-based)e(\(as)h(in)0 1957
 y(F)-8 b(ortran)39 b({)g(adopted)g(to)g(a)m(v)m(oid)h(am)m(biguit)m(y)g
 (for)f(1D)g(v)m(ectors\).)67 b(With)39 b(this)g(syn)m(tax,)i(one)e(do)s
-(es)f(not)h(need)f(to)0 4829 y(sp)s(ecify)30 b(all)h(of)g(the)f
+(es)f(not)h(need)f(to)0 2070 y(sp)s(ecify)30 b(all)h(of)g(the)f
 (indices.)41 b(T)-8 b(o)31 b(extract)h(a)f(3D)g(slice)g(of)g(this)f(4D)
-h(arra)m(y)-8 b(,)32 b(use)e(ARRA)-8 b(Y4D[4].)0 4989
+h(arra)m(y)-8 b(,)32 b(use)e(ARRA)-8 b(Y4D[4].)0 2230
 y(V)g(ariable-length)33 b(v)m(ector)f(columns)e(are)g(not)h(supp)s
-(orted.)0 5149 y(V)-8 b(ectors)24 b(can)e(b)s(e)f(man)m(ually)h
+(orted.)0 2391 y(V)-8 b(ectors)24 b(can)e(b)s(e)f(man)m(ually)h
 (constructed)h(within)e(the)h(expression)g(using)f(a)h(comma-separated)
-i(list)f(of)f(elemen)m(ts)0 5262 y(surrounded)35 b(b)m(y)j(curly)g
+i(list)f(of)f(elemen)m(ts)0 2503 y(surrounded)35 b(b)m(y)j(curly)g
 (braces)h(\(')p Fd(fg)p Fj('\).)66 b(F)-8 b(or)38 b(example,)j(')p
 Fd(f)p Fj(1,3,6,1)p Fd(g)p Fj(')h(is)d(a)f(4-elemen)m(t)i(v)m(ector)g
-(con)m(taining)g(the)0 5375 y(v)-5 b(alues)26 b(1,)h(3,)g(6,)g(and)e
+(con)m(taining)g(the)0 2616 y(v)-5 b(alues)26 b(1,)h(3,)g(6,)g(and)e
 (1.)40 b(The)25 b(v)m(ector)i(can)f(con)m(tain)h(only)f(b)s(o)s(olean,)
 g(in)m(teger,)j(and)c(real)h(v)-5 b(alues)26 b(\(or)g(expressions\).)0
-5488 y(The)e(elemen)m(ts)h(will)g(b)s(e)f(promoted)g(to)h(the)g
+2729 y(The)e(elemen)m(ts)h(will)g(b)s(e)f(promoted)g(to)h(the)g
 (highest)f(datat)m(yp)s(e)h(presen)m(t.)39 b(An)m(y)24
-b(elemen)m(ts)i(whic)m(h)e(are)h(themselv)m(es)0 5601
+b(elemen)m(ts)i(whic)m(h)e(are)h(themselv)m(es)0 2842
 y(v)m(ectors,)40 b(will)d(b)s(e)f(expanded)g(out)h(with)g(eac)m(h)g(of)
 g(its)g(elemen)m(ts)i(b)s(ecoming)d(an)h(elemen)m(t)h(in)f(the)g
-(constructed)0 5714 y(v)m(ector.)p eop end
-%%Page: 103 109
-TeXDict begin 103 108 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.103) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.11.)73
-b(R)m(O)m(W)31 b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)1982
-b Fj(103)0 464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.11.4) cvn /DEST pdfmark
-end
- 0 464
-a 91 x Fc(8.11.4)113 b(Go)s(o)s(d)38 b(Time)g(In)m(terv)-6
-b(al)37 b(Filtering)0 774 y Fj(A)44 b(common)g(\014ltering)h(metho)s(d)
-e(in)m(v)m(olv)m(es)j(selecting)g(ro)m(ws)e(whic)m(h)f(ha)m(v)m(e)j(a)e
-(time)h(v)-5 b(alue)44 b(whic)m(h)g(lies)g(within)0 887
-y(what)37 b(is)g(called)i(a)f(Go)s(o)s(d)f(Time)g(In)m(terv)-5
-b(al)38 b(or)f(GTI.)g(The)g(time)h(in)m(terv)-5 b(als)38
-b(are)g(de\014ned)e(in)h(a)g(separate)i(FITS)0 1000 y(table)i
-(extension)g(whic)m(h)e(con)m(tains)i(2)g(columns)f(giving)g(the)h
-(start)f(and)g(stop)g(time)g(of)g(eac)m(h)i(go)s(o)s(d)e(in)m(terv)-5
-b(al.)0 1113 y(The)34 b(\014ltering)h(op)s(eration)h(accepts)g(only)e
-(those)i(ro)m(ws)e(of)h(the)g(input)f(table)i(whic)m(h)e(ha)m(v)m(e)i
-(an)f(asso)s(ciated)h(time)0 1226 y(whic)m(h)f(falls)i(within)e(one)h
-(of)g(the)g(time)g(in)m(terv)-5 b(als)37 b(de\014ned)e(in)g(the)h(GTI)g
-(extension.)57 b(A)36 b(high)g(lev)m(el)h(function,)0
-1339 y(gti\014lter\(a,b,c,d\),)44 b(is)c(a)m(v)-5 b(ailable)42
-b(whic)m(h)d(ev)-5 b(aluates)41 b(eac)m(h)g(ro)m(w)e(of)h(the)f(input)g
-(table)h(and)f(returns)f(TR)m(UE)i(or)0 1452 y(F)-10
-b(ALSE)30 b(dep)s(ending)f(whether)h(the)g(ro)m(w)h(is)f(inside)g(or)g
-(outside)h(the)g(go)s(o)s(d)f(time)h(in)m(terv)-5 b(al.)42
-b(The)30 b(syn)m(tax)h(is)286 1696 y Ff(gtifilter\()45
-b([)j("gtifile")d([,)i(expr)g([,)g("STARTCOL",)e("STOPCOL")g(])j(])f(])
-g(\))0 1941 y Fj(where)20 b(eac)m(h)h("[]")h(demarks)e(optional)h
-(parameters.)38 b(Note)21 b(that)g(the)g(quotes)f(around)g(the)g
-(gti\014le)i(and)d(ST)-8 b(AR)g(T/STOP)0 2054 y(column)33
-b(are)h(required.)50 b(Either)34 b(single)g(or)g(double)f(quotes)h(ma)m
-(y)g(b)s(e)f(used.)50 b(In)33 b(cases)h(where)g(this)f(expression)0
-2167 y(is)d(en)m(tered)g(on)g(the)g(Unix)g(command)g(line,)g(enclose)h
-(the)f(en)m(tire)h(expression)f(in)f(double)h(quotes,)g(and)g(then)f
-(use)0 2280 y(single)c(quotes)g(within)e(the)i(expression)f(to)h
-(enclose)g(the)g('gti\014le')h(and)d(other)i(terms.)38
-b(It)25 b(is)f(also)h(usually)f(p)s(ossible)0 2393 y(to)38
-b(do)e(the)h(rev)m(erse,)j(and)c(enclose)i(the)f(whole)g(expression)g
-(in)f(single)i(quotes)f(and)f(then)h(use)f(double)g(quotes)0
-2506 y(within)d(the)g(expression.)50 b(The)33 b(gti\014le,)i(if)f(sp)s
-(eci\014ed,)f(can)h(b)s(e)f(blank)g(\(""\))i(whic)m(h)e(will)g(mean)h
-(to)g(use)f(the)h(\014rst)0 2619 y(extension)g(with)g(the)f(name)h
-("*GTI*")h(in)f(the)f(curren)m(t)h(\014le,)h(a)f(plain)f(extension)h
-(sp)s(eci\014er)f(\(eg,)j("+2",)g("[2]",)0 2731 y(or)30
-b("[STDGTI]"\))i(whic)m(h)e(will)h(b)s(e)f(used)f(to)j(select)g(an)e
-(extension)h(in)f(the)h(curren)m(t)f(\014le,)h(or)f(a)h(regular)g
-(\014lename)0 2844 y(with)f(or)h(without)f(an)h(extension)g(sp)s
-(eci\014er)f(whic)m(h)g(in)g(the)h(latter)h(case)f(will)g(mean)f(to)i
-(use)e(the)h(\014rst)e(extension)0 2957 y(with)37 b(an)g(extension)g
-(name)h("*GTI*".)62 b(Expr)36 b(can)h(b)s(e)g(an)m(y)g(arithmetic)i
-(expression,)f(including)f(simply)g(the)0 3070 y(time)f(column)g(name.)
-57 b(A)36 b(v)m(ector)h(time)g(expression)e(will)h(pro)s(duce)f(a)h(v)m
-(ector)h(b)s(o)s(olean)f(result.)57 b(ST)-8 b(AR)g(TCOL)0
-3183 y(and)27 b(STOPCOL)f(are)i(the)g(names)g(of)g(the)g(ST)-8
-b(AR)g(T/STOP)26 b(columns)i(in)f(the)h(GTI)g(extension.)41
-b(If)27 b(one)h(of)g(them)0 3296 y(is)i(sp)s(eci\014ed,)g(they)h(b)s
-(oth)f(m)m(ust)g(b)s(e.)0 3456 y(In)21 b(its)h(simplest)g(form,)i(no)d
-(parameters)h(need)g(to)h(b)s(e)e(pro)m(vided)g({)h(default)g(v)-5
-b(alues)22 b(will)h(b)s(e)e(used.)37 b(The)21 b(expression)0
-3569 y("gti\014lter\(\)")33 b(is)e(equiv)-5 b(alen)m(t)31
-b(to)334 3814 y Ff(gtifilter\()45 b("",)i(TIME,)f("*START*",)f
-("*STOP*")h(\))0 4059 y Fj(This)31 b(will)g(searc)m(h)h(the)g(curren)m
-(t)f(\014le)g(for)g(a)h(GTI)f(extension,)h(\014lter)g(the)f(TIME)g
-(column)g(in)g(the)h(curren)m(t)f(table,)0 4172 y(using)j(ST)-8
-b(AR)g(T/STOP)34 b(times)i(tak)m(en)f(from)g(columns)f(in)h(the)g(GTI)g
-(extension)g(with)g(names)f(con)m(taining)j(the)0 4284
-y(strings)32 b("ST)-8 b(AR)g(T")33 b(and)e("STOP".)46
+(constructed)0 2955 y(v)m(ector.)0 3245 y Fc(8.11.4)113
+b(Go)s(o)s(d)38 b(Time)g(In)m(terv)-6 b(al)37 b(Filtering)h(and)g
+(Calculation)0 3464 y Fj(There)27 b(are)h(t)m(w)m(o)g(functions)f(for)g
+(\014ltering)h(and)f(calculating)i(based)e(on)g(Go)s(o)s(d)h(Time)f(In)
+m(terv)-5 b(als,)29 b(or)e(GTIs.)39 b(GTIs)0 3577 y(are)c(commonly)g
+(used)f(to)h(express)f(fragmen)m(ted)h(time)g(ranges)g(that)g(are)g
+(not)g(easy)g(to)g(express)f(with)g(a)h(single)0 3690
+y(start)j(and)f(stop)h(time.)63 b(The)37 b(time)h(in)m(terv)-5
+b(als)39 b(are)f(de\014ned)e(in)i(a)g(FITS)f(table)h(extension)g(whic)m
+(h)g(con)m(tains)h(2)0 3803 y(columns)30 b(giving)h(the)g(start)g(and)f
+(stop)g(time)h(of)g(eac)m(h)g(go)s(o)s(d)f(in)m(terv)-5
+b(al.)0 3963 y(A)32 b(common)g(\014ltering)f(metho)s(d)h(in)m(v)m(olv)m
+(es)h(selecting)h(ro)m(ws)d(whic)m(h)h(ha)m(v)m(e)g(a)g(time)h(v)-5
+b(alue)32 b(whic)m(h)f(lies)i(within)e(an)m(y)0 4076
+y(GTI.)36 b(The)g(gti\014lter\(\))i(\014ltering)e(op)s(eration)h
+(accepts)g(only)f(those)h(ro)m(ws)f(of)g(the)h(input)e(table)i(whic)m
+(h)f(ha)m(v)m(e)h(an)0 4189 y(asso)s(ciated)g(time)f(whic)m(h)g(falls)g
+(within)f(one)g(of)h(the)g(time)g(in)m(terv)-5 b(als)37
+b(de\014ned)d(in)h(a)h(separate)h(GTI)e(extension.)0
+4301 y(gti\014lter\(a,b,c,d\))43 b(ev)-5 b(aluates)41
+b(eac)m(h)g(ro)m(w)g(of)f(the)g(input)f(table)i(and)f(returns)f(TR)m
+(UE)h(or)g(F)-10 b(ALSE)39 b(dep)s(ending)0 4414 y(whether)30
+b(the)g(ro)m(w)h(is)f(inside)g(or)h(outside)f(the)h(go)s(o)s(d)f(time)h
+(in)m(terv)-5 b(al.)42 b(The)30 b(syn)m(tax)h(is)286
+4669 y Ff(gtifilter\()45 b([)j("gtifile")d([,)i(expr)g([,)g
+("STARTCOL",)e("STOPCOL")g(])j(])f(])g(\))191 4782 y(or)286
+4895 y(gtifilter\()e([)j('gtifile')d([,)i(expr)g([,)g('STARTCOL',)e
+('STOPCOL')g(])j(])f(])g(\))0 5149 y Fj(where)20 b(eac)m(h)h("[]")h
+(demarks)e(optional)h(parameters.)38 b(Note)21 b(that)g(the)g(quotes)f
+(around)g(the)g(gti\014le)i(and)d(ST)-8 b(AR)g(T/STOP)0
+5262 y(column)33 b(are)h(required.)50 b(Either)34 b(single)g(or)g
+(double)f(quotes)h(ma)m(y)g(b)s(e)f(used.)50 b(In)33
+b(cases)h(where)g(this)f(expression)0 5375 y(is)d(en)m(tered)g(on)g
+(the)g(Unix)g(command)g(line,)g(enclose)h(the)f(en)m(tire)h(expression)
+f(in)f(double)h(quotes,)g(and)g(then)f(use)0 5488 y(single)c(quotes)g
+(within)e(the)i(expression)f(to)h(enclose)g(the)g('gti\014le')h(and)d
+(other)i(terms.)38 b(It)25 b(is)f(also)h(usually)f(p)s(ossible)0
+5601 y(to)38 b(do)e(the)h(rev)m(erse,)j(and)c(enclose)i(the)f(whole)g
+(expression)g(in)f(single)i(quotes)f(and)f(then)h(use)f(double)g
+(quotes)0 5714 y(within)d(the)g(expression.)50 b(The)33
+b(gti\014le,)i(if)f(sp)s(eci\014ed,)f(can)h(b)s(e)f(blank)g(\(""\))i
+(whic)m(h)e(will)g(mean)h(to)g(use)f(the)h(\014rst)p
+eop end
+%%Page: 104 110
+TeXDict begin 104 109 bop 0 299 a Fj(104)1573 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(extension)34 b(with)g(the)f(name)h("*GTI*")h(in)f(the)f
+(curren)m(t)h(\014le,)h(a)f(plain)f(extension)h(sp)s(eci\014er)f(\(eg,)
+j("+2",)g("[2]",)0 668 y(or)30 b("[STDGTI]"\))i(whic)m(h)e(will)h(b)s
+(e)f(used)f(to)j(select)g(an)e(extension)h(in)f(the)h(curren)m(t)f
+(\014le,)h(or)f(a)h(regular)g(\014lename)0 781 y(with)f(or)h(without)f
+(an)h(extension)g(sp)s(eci\014er)f(whic)m(h)g(in)g(the)h(latter)h(case)
+f(will)g(mean)f(to)i(use)e(the)h(\014rst)e(extension)0
+894 y(with)37 b(an)g(extension)g(name)h("*GTI*".)62 b(Expr)36
+b(can)h(b)s(e)g(an)m(y)g(arithmetic)i(expression,)f(including)f(simply)
+g(the)0 1007 y(time)f(column)g(name.)57 b(A)36 b(v)m(ector)h(time)g
+(expression)e(will)h(pro)s(duce)f(a)h(v)m(ector)h(b)s(o)s(olean)f
+(result.)57 b(ST)-8 b(AR)g(TCOL)0 1120 y(and)27 b(STOPCOL)f(are)i(the)g
+(names)g(of)g(the)g(ST)-8 b(AR)g(T/STOP)26 b(columns)i(in)f(the)h(GTI)g
+(extension.)41 b(If)27 b(one)h(of)g(them)0 1233 y(is)i(sp)s(eci\014ed,)
+g(they)h(b)s(oth)f(m)m(ust)g(b)s(e.)0 1393 y(In)21 b(its)h(simplest)g
+(form,)i(no)d(parameters)h(need)g(to)h(b)s(e)e(pro)m(vided)g({)h
+(default)g(v)-5 b(alues)22 b(will)h(b)s(e)e(used.)37
+b(The)21 b(expression)0 1506 y("gti\014lter\(\)")33 b(is)e(equiv)-5
+b(alen)m(t)31 b(to)334 1759 y Ff(gtifilter\()45 b("",)i(TIME,)f
+("*START*",)f("*STOP*")h(\))0 2011 y Fj(This)31 b(will)g(searc)m(h)h
+(the)g(curren)m(t)f(\014le)g(for)g(a)h(GTI)f(extension,)h(\014lter)g
+(the)f(TIME)g(column)g(in)g(the)h(curren)m(t)f(table,)0
+2124 y(using)j(ST)-8 b(AR)g(T/STOP)34 b(times)i(tak)m(en)f(from)g
+(columns)f(in)h(the)g(GTI)g(extension)g(with)g(names)f(con)m(taining)j
+(the)0 2237 y(strings)32 b("ST)-8 b(AR)g(T")33 b(and)e("STOP".)46
 b(The)32 b(wildcards)f(\('*'\))j(allo)m(w)g(sligh)m(t)f(v)-5
 b(ariations)33 b(in)f(naming)g(con)m(v)m(en)m(tions)0
-4397 y(suc)m(h)38 b(as)g("TST)-8 b(AR)g(T")39 b(or)f("ST)-8
+2350 y(suc)m(h)38 b(as)g("TST)-8 b(AR)g(T")39 b(or)f("ST)-8
 b(AR)g(TTIME".)65 b(The)37 b(same)i(default)g(v)-5 b(alues)38
-b(apply)g(for)g(unsp)s(eci\014ed)f(parame-)0 4510 y(ters)f(when)f(the)h
+b(apply)g(for)g(unsp)s(eci\014ed)f(parame-)0 2463 y(ters)f(when)f(the)h
 (\014rst)f(one)i(or)f(t)m(w)m(o)h(parameters)f(are)h(sp)s(eci\014ed.)56
 b(The)36 b(function)f(automatically)k(searc)m(hes)e(for)0
-4623 y(TIMEZER)m(O/I/F)g(k)m(eyw)m(ords)f(in)g(the)h(curren)m(t)f(and)g
+2576 y(TIMEZER)m(O/I/F)g(k)m(eyw)m(ords)f(in)g(the)h(curren)m(t)f(and)g
 (GTI)g(extensions,)i(applying)f(a)f(relativ)m(e)j(time)e(o\013set,)i
-(if)0 4736 y(necessary)-8 b(.)0 4879 y
-SDict begin H.S end
- 0 4879 a 0 4879
-a
-SDict begin 13.6 H.A end
- 0 4879 a 0 4879 a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.11.5) cvn /DEST pdfmark
-end
- 0 4879 a 145 x Fc(8.11.5)113 b(Spatial)38
-b(Region)g(Filtering)0 5243 y Fj(Another)g(common)g(\014ltering)g
+(if)0 2689 y(necessary)-8 b(.)0 2849 y(The)38 b(related)h(function,)g
+(gti\014nd\(a,b,c,d\),)i(is)e(similar)f(to)h(gti\014lter\(\))h(but)d
+(instead)h(of)h(returning)e(true/false,)0 2962 y(gti\014nd\(\))f
+(returns)e(the)i(GTI)f(n)m(um)m(b)s(er)f(that)i(brac)m(k)m(ets)h(the)f
+(requested)f(time)h(sample.)57 b(gti\014nd\(\))35 b(returns)g(the)0
+3075 y(ro)m(w)30 b(n)m(um)m(b)s(er)e(in)i(the)g(GTI)g(table)g(that)h
+(matc)m(hes)g(the)f(time)g(sample,)h(or)f(-1)g(if)g(the)g(time)h
+(sample)f(is)f(not)h(within)0 3188 y(an)m(y)g(GTI.)f(gti\014nd\(\))g
+(is)g(particularly)h(useful)f(when)f(en)m(tries)i(in)f(a)g(table)i(m)m
+(ust)e(b)s(e)f(categorized)k(b)m(y)d(whic)m(h)g(GTI)0
+3301 y(the)36 b(fall)h(within.)56 b(F)-8 b(or)37 b(example,)h(if)e(ev)m
+(en)m(ts)h(in)f(an)f(ev)m(en)m(t)j(list)e(m)m(ust)g(b)s(e)f(separated)i
+(b)m(y)e(go)s(o)s(d)h(time)h(in)m(terv)-5 b(al.)0 3413
+y(The)25 b(results)g(of)h(gti\014nd\(\))g(can)f(b)s(e)g(used)g(with)g
+(histogram)h(binning)e(tec)m(hniques)i(to)h(bin)d(an)i(ev)m(en)m(t)h
+(list)f(b)m(y)f(whic)m(h)0 3526 y(GTI.)286 3779 y Ff(gtifind\()46
+b("gtifile")f(,)j(expr)e([,)h("STARTCOL",)e("STOPCOL")g(])j(\))0
+4032 y Fj(The)33 b(requiremen)m(ts)g(for)f(sp)s(ecifying)h(the)h
+(gti\014le)g(are)f(the)g(same)h(as)f(for)g(gti\014lter\(\))i(as)e
+(describ)s(ed)f(ab)s(o)m(v)m(e.)50 b(Lik)m(e)0 4145 y(gti\014lter\(\),)
+31 b(the)e(expr)g(is)g(the)g(time-lik)m(e)i(expression)e(and)f(is)h
+(optional)h(\(defaulting)g(to)f(TIME\).)h(The)e(start)i(and)0
+4258 y(stop)g(columns)h(default)f(to)h(ST)-8 b(AR)g(T)30
+b(and)g(STOP)-8 b(.)0 4418 y(The)28 b(function,)h(gtio)m(v)m
+(erlap\(a,b,c,d,e\),)34 b(computes)28 b(the)h(o)m(v)m(erlap)h(b)s(et)m
+(w)m(een)f(a)g(user-requested)f(time)i(range)f(and)0
+4531 y(the)i(en)m(tries)g(in)f(a)h(GTI.)f(The)g(cases)i(of)e(no)g(o)m
+(v)m(erlap,)j(partial)e(o)m(v)m(erlap,)h(or)f(o)m(v)m(erlap)h(of)e(man)
+m(y)h(GTIs)f(within)g(the)0 4644 y(user)37 b(requested)h(range)g(are)g
+(handled.)61 b(gtio)m(v)m(erlap\(\))41 b(is)d(v)m(ery)g(useful)f(for)h
+(calculating)h(exp)s(osure)e(times)i(and)0 4757 y(fractional)32
+b(exp)s(osures)d(of)i(individual)f(time)h(bins,)e(sa)m(y)i(for)f(a)h
+(ligh)m(t)h(curv)m(e.)41 b(The)30 b(syn)m(tax)h(of)f(gtio)m(v)m
+(erlap\(\))k(is)286 5009 y Ff(gtioverlap\()45 b("gtifile")g(,)j
+(startExpr,)d(stopExpr)g([,)j("STARTCOL",)c("STOPCOL")i(])h(\))191
+5122 y(or)286 5235 y(gtioverlap\()e('gtifile')g(,)j(startExpr,)d
+(stopExpr)g([,)j('STARTCOL',)c('STOPCOL')i(])h(\))0 5488
+y Fj(The)27 b(requiremen)m(ts)g(for)h(sp)s(ecifying)f(the)h(gti\014le)g
+(are)g(the)g(same)g(as)f(for)h(gti\014lter\(\))h(as)f(describ)s(ed)e
+(ab)s(o)m(v)m(e.)41 b(Unlik)m(e)0 5601 y(gti\014lter\(\),)j(the)c
+(startExpr)f(and)f(stopExpr)h(are)h(not)g(optional.)69
+b(startExpr)39 b(pro)m(vides)g(a)h(start)g(of)g(the)g(user)0
+5714 y(requested)34 b(time)h(in)m(terv)-5 b(al.)53 b(startExpr)34
+b(is)g(t)m(ypically)i(TIME,)e(but)f(can)i(b)s(e)e(an)m(y)h(v)-5
+b(alid)35 b(expression.)52 b(Lik)m(ewise,)p eop end
+%%Page: 105 111
+TeXDict begin 105 110 bop 0 299 a Fh(8.11.)73 b(R)m(O)m(W)31
+b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)1982 b Fj(105)0
+555 y(stopExpr)39 b(pro)m(vides)i(the)f(stop)h(of)f(the)h(user)f
+(requested)g(time)h(in)m(terv)-5 b(al,)44 b(and)c(can)h(b)s(e)e(an)i
+(expression.)70 b(F)-8 b(or)0 668 y(example,)31 b(for)f(a)h(ligh)m(t)h
+(curv)m(e)e(with)h(a)f(TIME)g(column)g(and)g(time)h(bin)f(size)h(of)g
+(1.0)g(seconds,)g(the)f(expression)286 944 y Ff
+(gtioverlap\('gtifile',TIME,)o(TIM)o(E+1.)o(0\))0 1221
+y Fj(w)m(ould)36 b(calculate)i(the)e(amoun)m(t)g(of)g(o)m(v)m(erlap)h
+(exp)s(osure)e(time)h(b)s(et)m(w)m(een)h(eac)m(h)f(one)g(second)g(time)
+h(bin)e(and)g(the)0 1334 y(GTI)e(in)f('gti\014le'.)50
+b(In)32 b(this)h(case)h(the)f(time)g(bin)f(is)h(assumed)f(to)i(b)s
+(egin)e(at)i(the)f(time)g(sp)s(eci\014ed)f(b)m(y)h(TIME)g(and)0
+1447 y(end)d(1)h(second)g(later.)43 b(Neither)31 b(startExpr)f(nor)h
+(stopExpr)e(are)j(required)d(to)j(b)s(e)e(constan)m(t,)i(and)f(a)g
+(ligh)m(t)h(curv)m(e)0 1559 y(is)h(not)h(required)f(to)h(ha)m(v)m(e)g
+(a)g(constan)m(t)h(bin)e(size.)50 b(F)-8 b(or)34 b(tables,)i(the)d(o)m
+(v)m(erlap)i(is)f(calculated)h(for)e(eac)m(h)i(en)m(try)e(in)0
+1672 y(the)e(table.)0 1833 y(It)d(is)f(also)i(p)s(ossible)e(to)h
+(calculate)i(a)e(single)g(o)m(v)m(erlap)h(v)-5 b(alue,)29
+b(whic)m(h)e(w)m(ould)h(t)m(ypically)h(b)s(e)e(placed)h(in)f(a)h(k)m
+(eyw)m(ord.)0 1945 y(F)-8 b(or)42 b(example,)j(a)d(w)m(a)m(y)g(to)g(to)
+g(compute)g(the)f(total)i(o)m(v)m(erlap)g(exp)s(osure)d(of)i(a)f
+(\014le)h(whose)f(TIME)g(column)g(is)0 2058 y(b)s(ounded)28
+b(b)m(y)i(the)h(k)m(eyw)m(ords)g(TST)-8 b(AR)g(T)29 b(and)h(TSTOP)-8
+b(,)30 b(o)m(v)m(erlapping)h(with)f(the)h(sp)s(eci\014ed)f(GTI,)g(w)m
+(ould)g(b)s(e)286 2335 y Ff(#EXPOSURE)46 b(=)h
+(gtioverlap\('gtifile',#TST)o(ART)o(,#TS)o(TOP\))0 2611
+y Fj(The)26 b Ff(#EXPOSURE)f Fj(syn)m(tax)i(with)g(a)g(leading)h(+)e
+(ensures)g(that)i(the)f(requested)g(v)-5 b(alues)27 b(are)g(treated)h
+(as)f(k)m(eyw)m(ords.)0 2724 y(Otherwise,)41 b(a)e(column)g(named)f
+(EXPOSURE)g(will)h(b)s(e)g(created)g(with)g(the)g(\(constan)m(t\))i
+(exp)s(osure)d(v)-5 b(alue)39 b(in)0 2837 y(eac)m(h)32
+b(en)m(try)-8 b(.)0 3147 y Fc(8.11.5)113 b(Spatial)38
+b(Region)g(Filtering)0 3370 y Fj(Another)g(common)g(\014ltering)g
 (metho)s(d)f(selects)i(ro)m(ws)f(based)g(on)f(whether)h(the)g(spatial)h
-(p)s(osition)e(asso)s(ciated)0 5356 y(with)32 b(eac)m(h)i(ro)m(w)e(is)h
+(p)s(osition)e(asso)s(ciated)0 3483 y(with)32 b(eac)m(h)i(ro)m(w)e(is)h
 (lo)s(cated)h(within)e(a)h(giv)m(en)g(2-dimensional)g(region.)48
 b(The)32 b(syn)m(tax)h(for)f(this)h(high-lev)m(el)h(\014lter)0
-5469 y(is)334 5714 y Ff(regfilter\()45 b("regfilename")f([)k(,)f
-(Xexpr,)f(Yexpr)h([)g(,)h("wcs)e(cols")h(])g(])g(\))p
-eop end
-%%Page: 104 110
-TeXDict begin 104 109 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.104) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(104)1573
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(where)22 b(eac)m(h)i("[]")g(demarks)e(optional)i
-(parameters.)38 b(The)22 b(region)h(\014le)g(name)f(is)h(required)f
-(and)g(m)m(ust)g(b)s(e)g(enclosed)0 668 y(in)34 b(quotes.)51
-b(The)33 b(remaining)h(parameters)h(are)f(optional.)52
-b(There)33 b(are)i(2)f(supp)s(orted)e(formats)i(for)f(the)h(region)0
-781 y(\014le:)62 b(ASCI)s(I)39 b(\014le)h(or)h(FITS)f(binary)g(table.)
+3596 y(is)334 3872 y Ff(regfilter\()45 b("regfilename")f([)k(,)f
+(Xexpr,)f(Yexpr)h([)g(,)h("wcs)e(cols")h(])g(])g(\))0
+4148 y Fj(where)22 b(eac)m(h)i("[]")g(demarks)e(optional)i(parameters.)
+38 b(The)22 b(region)h(\014le)g(name)f(is)h(required)f(and)g(m)m(ust)g
+(b)s(e)g(enclosed)0 4261 y(in)34 b(quotes.)51 b(The)33
+b(remaining)h(parameters)h(are)f(optional.)52 b(There)33
+b(are)i(2)f(supp)s(orted)e(formats)i(for)f(the)h(region)0
+4374 y(\014le:)62 b(ASCI)s(I)39 b(\014le)h(or)h(FITS)f(binary)g(table.)
 73 b(The)40 b(region)h(\014le)g(con)m(tains)h(a)f(list)g(of)g(one)g(or)
-g(more)g(geometric)0 894 y(shap)s(es)30 b(\(circle,)j(ellipse,)g(b)s(o)
-m(x,)e(etc.\))44 b(whic)m(h)31 b(de\014nes)f(a)i(region)g(on)f(the)g
-(celestial)j(sphere)c(or)h(an)g(area)h(within)f(a)0 1007
+g(more)g(geometric)0 4487 y(shap)s(es)30 b(\(circle,)j(ellipse,)g(b)s
+(o)m(x,)e(etc.\))44 b(whic)m(h)31 b(de\014nes)f(a)i(region)g(on)f(the)g
+(celestial)j(sphere)c(or)h(an)g(area)h(within)f(a)0 4600
 y(particular)36 b(2D)g(image.)57 b(The)35 b(region)h(\014le)f(is)g(t)m
 (ypically)j(generated)e(using)f(an)g(image)i(displa)m(y)e(program)g
-(suc)m(h)0 1120 y(as)e(fv/PO)m(W)g(\(distribute)f(b)m(y)h(the)f(HEASAR)
+(suc)m(h)0 4713 y(as)e(fv/PO)m(W)g(\(distribute)f(b)m(y)h(the)f(HEASAR)
 m(C\),)h(or)g(ds9)f(\(distributed)g(b)m(y)g(the)h(Smithsonian)f
-(Astroph)m(ysical)0 1233 y(Observ)-5 b(atory\).)69 b(Users)39
+(Astroph)m(ysical)0 4826 y(Observ)-5 b(atory\).)69 b(Users)39
 b(should)g(refer)g(to)h(the)g(do)s(cumen)m(tation)h(pro)m(vided)e(with)
-g(these)h(programs)f(for)h(more)0 1346 y(details)29 b(on)f(the)g(syn)m
+g(these)h(programs)f(for)h(more)0 4939 y(details)29 b(on)f(the)g(syn)m
 (tax)h(used)e(in)h(the)h(region)f(\014les.)40 b(The)28
 b(FITS)f(region)i(\014le)f(format)h(is)f(de\014ned)f(in)h(a)g(do)s
-(cumen)m(t)0 1458 y(a)m(v)-5 b(ailable)33 b(from)d(the)g(FITS)g(Supp)s
+(cumen)m(t)0 5052 y(a)m(v)-5 b(ailable)33 b(from)d(the)g(FITS)g(Supp)s
 (ort)e(O\016ce)j(at)g(h)m(ttp://\014ts.gsfc.nasa.go)m(v/)k(registry/)c
-(region.h)m(tml)0 1619 y(In)21 b(its)h(simplest)g(form,)i(\(e.g.,)h
+(region.h)m(tml)0 5212 y(In)21 b(its)h(simplest)g(form,)i(\(e.g.,)h
 (reg\014lter\("region.reg"\))h(\))c(the)g(co)s(ordinates)g(in)g(the)g
-(default)g('X')h(and)e('Y')h(columns)0 1732 y(will)43
+(default)g('X')h(and)e('Y')h(columns)0 5325 y(will)43
 b(b)s(e)g(used)f(to)i(determine)f(if)g(eac)m(h)h(ro)m(w)f(is)g(inside)g
 (or)g(outside)g(the)g(area)h(sp)s(eci\014ed)e(in)h(the)g(region)h
-(\014le.)0 1844 y(Alternate)32 b(p)s(osition)e(column)g(names,)h(or)f
+(\014le.)0 5438 y(Alternate)32 b(p)s(osition)e(column)g(names,)h(or)f
 (expressions,)h(ma)m(y)g(b)s(e)e(en)m(tered)i(if)g(needed,)f(as)h(in)
-382 2127 y Ff(regfilter\("region.reg",)41 b(XPOS,)47
-b(YPOS\))0 2410 y Fj(Region)37 b(\014ltering)f(can)g(b)s(e)f(applied)g
-(most)h(unam)m(biguously)f(if)h(the)g(p)s(ositions)g(in)f(the)h(region)
-g(\014le)g(and)f(in)h(the)0 2523 y(table)g(to)g(b)s(e)e(\014ltered)h
-(are)h(b)s(oth)e(giv)m(e)j(in)e(terms)g(of)g(absolute)h(celestial)i(co)
-s(ordinate)e(units.)54 b(In)35 b(this)g(case)h(the)0
-2636 y(lo)s(cations)26 b(and)d(sizes)i(of)g(the)f(geometric)i(shap)s
-(es)e(in)g(the)g(region)h(\014le)f(are)h(sp)s(eci\014ed)f(in)g(angular)
-g(units)g(on)g(the)g(sky)0 2749 y(\(e.g.,)32 b(p)s(ositions)e(giv)m(en)
-i(in)e(R.A.)g(and)g(Dec.)42 b(and)30 b(sizes)h(in)f(arcseconds)g(or)h
+382 5714 y Ff(regfilter\("region.reg",)41 b(XPOS,)47
+b(YPOS\))p eop end
+%%Page: 106 112
+TeXDict begin 106 111 bop 0 299 a Fj(106)1573 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)0
+555 y Fj(Region)37 b(\014ltering)f(can)g(b)s(e)f(applied)g(most)h(unam)
+m(biguously)f(if)h(the)g(p)s(ositions)g(in)f(the)h(region)g(\014le)g
+(and)f(in)h(the)0 668 y(table)g(to)g(b)s(e)e(\014ltered)h(are)h(b)s
+(oth)e(giv)m(e)j(in)e(terms)g(of)g(absolute)h(celestial)i(co)s
+(ordinate)e(units.)54 b(In)35 b(this)g(case)h(the)0 781
+y(lo)s(cations)26 b(and)d(sizes)i(of)g(the)f(geometric)i(shap)s(es)e
+(in)g(the)g(region)h(\014le)f(are)h(sp)s(eci\014ed)f(in)g(angular)g
+(units)g(on)g(the)g(sky)0 894 y(\(e.g.,)32 b(p)s(ositions)e(giv)m(en)i
+(in)e(R.A.)g(and)g(Dec.)42 b(and)30 b(sizes)h(in)f(arcseconds)g(or)h
 (arcmin)m(utes\).)41 b(Similarly)-8 b(,)31 b(eac)m(h)h(ro)m(w)0
-2861 y(of)h(the)h(\014ltered)f(table)h(will)f(ha)m(v)m(e)i(a)e
+1007 y(of)h(the)h(\014ltered)f(table)h(will)f(ha)m(v)m(e)i(a)e
 (celestial)j(co)s(ordinate)e(asso)s(ciated)g(with)f(it.)50
-b(This)32 b(asso)s(ciation)j(is)e(usually)0 2974 y(implemen)m(ted)39
+b(This)32 b(asso)s(ciation)j(is)e(usually)0 1120 y(implemen)m(ted)39
 b(using)e(a)i(set)g(of)f(so-called)i('W)-8 b(orld)39
 b(Co)s(ordinate)g(System')f(\(or)h(W)m(CS\))f(FITS)g(k)m(eyw)m(ords)g
-(that)0 3087 y(de\014ne)27 b(the)g(co)s(ordinate)h(transformation)g
+(that)0 1233 y(de\014ne)27 b(the)g(co)s(ordinate)h(transformation)g
 (that)g(m)m(ust)f(b)s(e)f(applied)h(to)h(the)g(v)-5 b(alues)27
-b(in)g(the)h('X')g(and)e('Y')i(columns)0 3200 y(to)j(calculate)i(the)d
-(co)s(ordinate.)0 3360 y(Alternativ)m(ely)-8 b(,)30 b(one)d(can)g(p)s
+b(in)g(the)h('X')g(and)e('Y')i(columns)0 1346 y(to)j(calculate)i(the)d
+(co)s(ordinate.)0 1506 y(Alternativ)m(ely)-8 b(,)30 b(one)d(can)g(p)s
 (erform)e(spatial)j(\014ltering)e(using)g(unitless)h('pixel')g(co)s
-(ordinates)h(for)e(the)h(regions)g(and)0 3473 y(ro)m(w)33
+(ordinates)h(for)e(the)h(regions)g(and)0 1619 y(ro)m(w)33
 b(p)s(ositions.)49 b(In)33 b(this)g(case)h(the)f(user)g(m)m(ust)g(b)s
 (e)f(careful)h(to)h(ensure)f(that)g(the)h(p)s(ositions)f(in)g(the)g(2)g
-(\014les)h(are)0 3586 y(self-consisten)m(t.)54 b(A)34
+(\014les)h(are)0 1732 y(self-consisten)m(t.)54 b(A)34
 b(t)m(ypical)i(problem)d(is)h(that)h(the)f(region)h(\014le)f(ma)m(y)h
-(b)s(e)e(generated)j(using)d(a)i(binned)d(image,)0 3699
+(b)s(e)e(generated)j(using)d(a)i(binned)d(image,)0 1844
 y(but)g(the)h(un)m(binned)e(co)s(ordinates)i(are)g(giv)m(en)h(in)e(the)
 h(ev)m(en)m(t)i(table.)48 b(The)32 b(R)m(OSA)-8 b(T)33
-b(ev)m(en)m(ts)h(\014les,)g(for)e(example,)0 3812 y(ha)m(v)m(e)f(X)f
+b(ev)m(en)m(ts)h(\014les,)g(for)e(example,)0 1957 y(ha)m(v)m(e)f(X)f
 (and)f(Y)g(pixel)h(co)s(ordinates)g(that)h(range)f(from)f(1)h(-)g
 (15360.)42 b(These)30 b(co)s(ordinates)g(are)g(t)m(ypically)h(binned)0
-3925 y(b)m(y)i(a)h(factor)g(of)f(32)h(to)g(pro)s(duce)e(a)i(480x480)i
+2070 y(b)m(y)i(a)h(factor)g(of)f(32)h(to)g(pro)s(duce)e(a)i(480x480)i
 (pixel)d(image.)51 b(If)32 b(one)i(then)f(uses)g(a)g(region)h(\014le)f
-(generated)h(from)0 4038 y(this)c(image)i(\(in)f(image)g(pixel)g
+(generated)h(from)0 2183 y(this)c(image)i(\(in)f(image)g(pixel)g
 (units\))g(to)g(\014lter)f(the)h(R)m(OSA)-8 b(T)30 b(ev)m(en)m(ts)i
 (\014le,)f(then)f(the)h(X)g(and)f(Y)g(column)h(v)-5 b(alues)0
-4151 y(m)m(ust)30 b(b)s(e)g(con)m(v)m(erted)i(to)f(corresp)s(onding)e
-(pixel)i(units)f(as)g(in:)382 4433 y Ff(regfilter\("rosat.reg",)42
-b(X/32.+.5,)j(Y/32.+.5\))0 4716 y Fj(Note)h(that)f(this)f(binning)f
+2296 y(m)m(ust)30 b(b)s(e)g(con)m(v)m(erted)i(to)f(corresp)s(onding)e
+(pixel)i(units)f(as)g(in:)382 2562 y Ff(regfilter\("rosat.reg",)42
+b(X/32.+.5,)j(Y/32.+.5\))0 2829 y Fj(Note)h(that)f(this)f(binning)f
 (con)m(v)m(ersion)j(is)e(not)h(necessary)g(if)f(the)h(region)g(\014le)f
-(is)h(sp)s(eci\014ed)e(using)h(celestial)0 4829 y(co)s(ordinate)h
+(is)h(sp)s(eci\014ed)e(using)h(celestial)0 2942 y(co)s(ordinate)h
 (units)f(instead)g(of)g(pixel)h(units)f(b)s(ecause)g(CFITSIO)e(is)j
-(then)e(able)i(to)g(directly)g(compare)g(the)0 4942 y(celestial)30
+(then)e(able)i(to)g(directly)g(compare)g(the)0 3054 y(celestial)30
 b(co)s(ordinate)f(of)e(eac)m(h)i(ro)m(w)f(in)f(the)h(table)g(with)g
 (the)f(celestial)k(co)s(ordinates)d(in)f(the)h(region)g(\014le)g
-(without)0 5055 y(ha)m(ving)j(to)g(kno)m(w)f(an)m(ything)h(ab)s(out)f
+(without)0 3167 y(ha)m(ving)j(to)g(kno)m(w)f(an)m(ything)h(ab)s(out)f
 (ho)m(w)h(the)f(image)i(ma)m(y)f(ha)m(v)m(e)g(b)s(een)f(binned.)0
-5215 y(The)f(last)h("w)m(cs)g(cols")h(parameter)f(should)e(rarely)h(b)s
+3328 y(The)f(last)h("w)m(cs)g(cols")h(parameter)f(should)e(rarely)h(b)s
 (e)g(needed.)40 b(If)29 b(supplied,)f(this)i(string)f(con)m(tains)i
-(the)e(names)0 5328 y(of)37 b(the)g(2)h(columns)f(\(space)h(or)f(comma)
+(the)e(names)0 3440 y(of)37 b(the)g(2)h(columns)f(\(space)h(or)f(comma)
 g(separated\))h(whic)m(h)f(ha)m(v)m(e)h(the)g(asso)s(ciated)g(W)m(CS)f
-(k)m(eyw)m(ords.)61 b(If)37 b(not)0 5441 y(supplied,)f(the)g(\014lter)g
+(k)m(eyw)m(ords.)61 b(If)37 b(not)0 3553 y(supplied,)f(the)g(\014lter)g
 (will)h(scan)f(the)g(X)g(and)f(Y)h(expressions)g(for)g(column)f(names.)
-58 b(If)35 b(only)h(one)h(is)f(found)e(in)0 5554 y(eac)m(h)e
+58 b(If)35 b(only)h(one)h(is)f(found)e(in)0 3666 y(eac)m(h)e
 (expression,)e(those)h(columns)f(will)h(b)s(e)e(used,)h(otherwise)h(an)
-f(error)g(will)h(b)s(e)f(returned.)0 5714 y(These)g(region)h(shap)s(es)
-f(are)g(supp)s(orted)f(\(names)h(are)h(case)h(insensitiv)m(e\):)p
-eop end
-%%Page: 105 111
-TeXDict begin 105 110 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.105) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.11.)73
-b(R)m(O)m(W)31 b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)1982
-b Fj(105)334 555 y Ff(Point)428 b(\()48 b(X1,)f(Y1)g(\))715
-b(<-)48 b(One)f(pixel)f(square)g(region)334 668 y(Line)476
-b(\()48 b(X1,)f(Y1,)g(X2,)f(Y2)i(\))333 b(<-)48 b(One)f(pixel)f(wide)h
-(region)334 781 y(Polygon)332 b(\()48 b(X1,)f(Y1,)g(X2,)f(Y2,)h(...)g
-(\))95 b(<-)48 b(Rest)e(are)h(interiors)e(with)334 894
-y(Rectangle)236 b(\()48 b(X1,)f(Y1,)g(X2,)f(Y2,)h(A)h(\))334
-b(|)47 b(boundaries)e(considered)334 1007 y(Box)524 b(\()48
-b(Xc,)f(Yc,)g(Wdth,)f(Hght,)g(A)i(\))143 b(V)47 b(within)f(the)h
-(region)334 1120 y(Diamond)332 b(\()48 b(Xc,)f(Yc,)g(Wdth,)f(Hght,)g(A)
-i(\))334 1233 y(Circle)380 b(\()48 b(Xc,)f(Yc,)g(R)g(\))334
-1346 y(Annulus)332 b(\()48 b(Xc,)f(Yc,)g(Rin,)f(Rout)h(\))334
-1458 y(Ellipse)332 b(\()48 b(Xc,)f(Yc,)g(Rx,)f(Ry,)h(A)h(\))334
-1571 y(Elliptannulus)c(\()k(Xc,)f(Yc,)g(Rinx,)f(Riny,)g(Routx,)g
-(Routy,)g(Ain,)h(Aout)g(\))334 1684 y(Sector)380 b(\()48
-b(Xc,)f(Yc,)g(Amin,)f(Amax)h(\))0 1958 y Fj(where)28
-b(\(Xc,Yc\))j(is)d(the)h(co)s(ordinate)h(of)e(the)h(shap)s(e's)f(cen)m
-(ter;)j(\(X#,Y#\))e(are)g(the)g(co)s(ordinates)g(of)g(the)g(shap)s(e's)
-0 2071 y(edges;)36 b(Rxxx)d(are)h(the)f(shap)s(es')g(v)-5
-b(arious)34 b(Radii)f(or)h(semi-ma)5 b(jor/minor)34 b(axes;)i(and)d
-(Axxx)g(are)h(the)f(angles)i(of)0 2184 y(rotation)e(\(or)e(b)s(ounding)
-f(angles)i(for)f(Sector\))h(in)f(degrees.)44 b(F)-8 b(or)32
-b(rotated)h(shap)s(es,)e(the)g(rotation)i(angle)f(can)g(b)s(e)0
-2297 y(left)g(o\013,)h(indicating)f(no)f(rotation.)46
+f(error)g(will)h(b)s(e)f(returned.)0 3826 y(These)g(region)h(shap)s(es)
+f(are)g(supp)s(orted)f(\(names)h(are)h(case)h(insensitiv)m(e\):)334
+4093 y Ff(Point)428 b(\()48 b(X1,)f(Y1)g(\))715 b(<-)48
+b(One)f(pixel)f(square)g(region)334 4206 y(Line)476 b(\()48
+b(X1,)f(Y1,)g(X2,)f(Y2)i(\))333 b(<-)48 b(One)f(pixel)f(wide)h(region)
+334 4319 y(Polygon)332 b(\()48 b(X1,)f(Y1,)g(X2,)f(Y2,)h(...)g(\))95
+b(<-)48 b(Rest)e(are)h(interiors)e(with)334 4431 y(Rectangle)236
+b(\()48 b(X1,)f(Y1,)g(X2,)f(Y2,)h(A)h(\))334 b(|)47 b(boundaries)e
+(considered)334 4544 y(Box)524 b(\()48 b(Xc,)f(Yc,)g(Wdth,)f(Hght,)g(A)
+i(\))143 b(V)47 b(within)f(the)h(region)334 4657 y(Diamond)332
+b(\()48 b(Xc,)f(Yc,)g(Wdth,)f(Hght,)g(A)i(\))334 4770
+y(Circle)380 b(\()48 b(Xc,)f(Yc,)g(R)g(\))334 4883 y(Annulus)332
+b(\()48 b(Xc,)f(Yc,)g(Rin,)f(Rout)h(\))334 4996 y(Ellipse)332
+b(\()48 b(Xc,)f(Yc,)g(Rx,)f(Ry,)h(A)h(\))334 5109 y(Elliptannulus)c(\()
+k(Xc,)f(Yc,)g(Rinx,)f(Riny,)g(Routx,)g(Routy,)g(Ain,)h(Aout)g(\))334
+5222 y(Sector)380 b(\()48 b(Xc,)f(Yc,)g(Amin,)f(Amax)h(\))0
+5488 y Fj(where)28 b(\(Xc,Yc\))j(is)d(the)h(co)s(ordinate)h(of)e(the)h
+(shap)s(e's)f(cen)m(ter;)j(\(X#,Y#\))e(are)g(the)g(co)s(ordinates)g(of)
+g(the)g(shap)s(e's)0 5601 y(edges;)36 b(Rxxx)d(are)h(the)f(shap)s(es')g
+(v)-5 b(arious)34 b(Radii)f(or)h(semi-ma)5 b(jor/minor)34
+b(axes;)i(and)d(Axxx)g(are)h(the)f(angles)i(of)0 5714
+y(rotation)e(\(or)e(b)s(ounding)f(angles)i(for)f(Sector\))h(in)f
+(degrees.)44 b(F)-8 b(or)32 b(rotated)h(shap)s(es,)e(the)g(rotation)i
+(angle)f(can)g(b)s(e)p eop end
+%%Page: 107 113
+TeXDict begin 107 112 bop 0 299 a Fh(8.11.)73 b(R)m(O)m(W)31
+b(FIL)-8 b(TERING)30 b(SPECIFICA)-8 b(TION)1982 b Fj(107)0
+555 y(left)32 b(o\013,)h(indicating)f(no)f(rotation.)46
 b(Common)31 b(alternate)i(names)e(for)h(the)f(regions)h(can)g(also)h(b)
-s(e)d(used:)43 b(rotb)s(o)m(x)0 2410 y(=)29 b(b)s(o)m(x;)g
-(rotrectangle)i(=)e(rectangle;)i(\(rot\)rhom)m(bus)e(=)f
-(\(rot\)diamond;)j(and)d(pie)h(=)f(sector.)42 b(When)28
-b(a)i(shap)s(e's)0 2523 y(name)e(is)g(preceded)f(b)m(y)h(a)g(min)m(us)g
-(sign,)g('-',)i(the)e(de\014ned)e(region)j(is)f(instead)g(the)g(area)h
-(*outside*)g(its)f(b)s(oundary)0 2636 y(\(ie,)36 b(the)e(region)h(is)f
-(in)m(v)m(erted\).)53 b(All)34 b(the)g(shap)s(es)f(within)h(a)g(single)
-h(region)f(\014le)h(are)f(OR'd)f(together)j(to)e(create)0
-2749 y(the)29 b(region,)i(and)d(the)i(order)f(is)g(signi\014can)m(t.)41
+s(e)d(used:)43 b(rotb)s(o)m(x)0 668 y(=)29 b(b)s(o)m(x;)g(rotrectangle)
+i(=)e(rectangle;)i(\(rot\)rhom)m(bus)e(=)f(\(rot\)diamond;)j(and)d(pie)
+h(=)f(sector.)42 b(When)28 b(a)i(shap)s(e's)0 781 y(name)e(is)g
+(preceded)f(b)m(y)h(a)g(min)m(us)g(sign,)g('-',)i(the)e(de\014ned)e
+(region)j(is)f(instead)g(the)g(area)h(*outside*)g(its)f(b)s(oundary)0
+894 y(\(ie,)36 b(the)e(region)h(is)f(in)m(v)m(erted\).)53
+b(All)34 b(the)g(shap)s(es)f(within)h(a)g(single)h(region)f(\014le)h
+(are)f(OR'd)f(together)j(to)e(create)0 1007 y(the)29
+b(region,)i(and)d(the)i(order)f(is)g(signi\014can)m(t.)41
 b(The)29 b(o)m(v)m(erall)i(w)m(a)m(y)g(of)e(lo)s(oking)h(at)g(region)g
-(\014les)f(is)g(that)h(if)f(the)h(\014rst)0 2861 y(region)f(is)g(an)g
+(\014les)f(is)g(that)h(if)f(the)h(\014rst)0 1120 y(region)f(is)g(an)g
 (excluded)g(region)g(then)f(a)i(dumm)m(y)d(included)h(region)i(of)f
 (the)g(whole)g(detector)h(is)f(inserted)f(in)h(the)0
-2974 y(fron)m(t.)40 b(Then)25 b(eac)m(h)j(region)f(sp)s(eci\014cation)h
+1233 y(fron)m(t.)40 b(Then)25 b(eac)m(h)j(region)f(sp)s(eci\014cation)h
 (as)f(it)g(is)g(pro)s(cessed)f(o)m(v)m(errides)h(an)m(y)g(selections)i
-(inside)d(of)h(that)g(region)0 3087 y(sp)s(eci\014ed)36
+(inside)d(of)h(that)g(region)0 1346 y(sp)s(eci\014ed)36
 b(b)m(y)g(previous)g(regions.)59 b(Another)37 b(w)m(a)m(y)g(of)g
 (thinking)f(ab)s(out)g(this)g(is)h(that)g(if)f(a)h(previous)f(excluded)
-0 3200 y(region)31 b(is)f(completely)i(inside)f(of)f(a)h(subsequen)m(t)
+0 1458 y(region)31 b(is)f(completely)i(inside)f(of)f(a)h(subsequen)m(t)
 e(included)h(region)h(the)g(excluded)f(region)h(is)f(ignored.)0
-3360 y(The)44 b(p)s(ositional)i(co)s(ordinates)g(ma)m(y)f(b)s(e)g(giv)m
+1619 y(The)44 b(p)s(ositional)i(co)s(ordinates)g(ma)m(y)f(b)s(e)g(giv)m
 (en)h(either)f(in)g(pixel)g(units,)j(decimal)e(degrees)g(or)f
-(hh:mm:ss.s,)0 3473 y(dd:mm:ss.s)25 b(units.)38 b(The)26
+(hh:mm:ss.s,)0 1732 y(dd:mm:ss.s)25 b(units.)38 b(The)26
 b(shap)s(e)f(sizes)i(ma)m(y)f(b)s(e)g(giv)m(en)h(in)e(pixels,)j
 (degrees,)f(arcmin)m(utes,)h(or)e(arcseconds.)40 b(Lo)s(ok)0
-3586 y(at)31 b(examples)g(of)f(region)h(\014le)g(pro)s(duced)d(b)m(y)i
+1844 y(at)31 b(examples)g(of)f(region)h(\014le)g(pro)s(duced)d(b)m(y)i
 (fv/PO)m(W)h(or)g(ds9)f(for)g(further)f(details)i(of)g(the)f(region)h
-(\014le)f(format.)0 3746 y(There)37 b(are)g(three)g(functions)g(that)g
+(\014le)f(format.)0 2005 y(There)37 b(are)g(three)g(functions)g(that)g
 (are)h(primarily)f(for)f(use)h(with)g(SA)m(O)g(region)g(\014les)g(and)g
-(the)g(FSA)m(OI)g(task,)0 3859 y(but)e(they)h(can)h(b)s(e)e(used)g
+(the)g(FSA)m(OI)g(task,)0 2118 y(but)e(they)h(can)h(b)s(e)e(used)g
 (directly)-8 b(.)59 b(They)36 b(return)f(a)h(b)s(o)s(olean)g(true)g(or)
 g(false)g(dep)s(ending)f(on)h(whether)f(a)i(t)m(w)m(o)0
-3972 y(dimensional)31 b(p)s(oin)m(t)f(is)g(in)g(the)h(region)g(or)f
-(not:)191 4246 y Ff("point)46 b(in)h(a)h(circular)d(region")477
-4359 y(circle\(xcntr,ycntr,radius)o(,Xco)o(lumn)o(,Yc)o(olum)o(n\))191
-4585 y("point)h(in)h(an)g(elliptical)e(region")430 4698
+2230 y(dimensional)31 b(p)s(oin)m(t)f(is)g(in)g(the)h(region)g(or)f
+(not:)191 2492 y Ff("point)46 b(in)h(a)h(circular)d(region")477
+2605 y(circle\(xcntr,ycntr,radius)o(,Xco)o(lumn)o(,Yc)o(olum)o(n\))191
+2831 y("point)h(in)h(an)g(elliptical)e(region")430 2944
 y(ellipse\(xcntr,ycntr,xhl)o(f_w)o(dth,)o(yhlf)o(_wd)o(th,r)o(otat)o
-(ion)o(,Xco)o(lumn)o(,Yc)o(olum)o(n\))191 4924 y("point)h(in)h(a)h
-(rectangular)c(region")620 5036 y(box\(xcntr,ycntr,xfll_wdth,)o(yfll)o
+(ion)o(,Xco)o(lumn)o(,Yc)o(olum)o(n\))191 3169 y("point)h(in)h(a)h
+(rectangular)c(region")620 3282 y(box\(xcntr,ycntr,xfll_wdth,)o(yfll)o
 (_wd)o(th,r)o(otat)o(ion)o(,Xco)o(lumn)o(,Yc)o(olum)o(n\))191
-5262 y(where)334 5375 y(\(xcntr,ycntr\))g(are)j(the)g(\(x,y\))f
+3508 y(where)334 3621 y(\(xcntr,ycntr\))g(are)j(the)g(\(x,y\))f
 (position)g(of)h(the)g(center)f(of)h(the)g(region)334
-5488 y(\(xhlf_wdth,yhlf_wdth\))42 b(are)47 b(the)g(\(x,y\))f(half)h
-(widths)f(of)h(the)g(region)334 5601 y(\(xfll_wdth,yfll_wdth\))42
+3734 y(\(xhlf_wdth,yhlf_wdth\))42 b(are)47 b(the)g(\(x,y\))f(half)h
+(widths)f(of)h(the)g(region)334 3847 y(\(xfll_wdth,yfll_wdth\))42
 b(are)47 b(the)g(\(x,y\))f(full)h(widths)f(of)h(the)g(region)334
-5714 y(\(radius\))f(is)h(half)f(the)h(diameter)f(of)h(the)g(circle)p
-eop end
-%%Page: 106 112
-TeXDict begin 106 111 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.106) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(106)1573
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)334 555 y Ff(\(rotation\))45 b(is)i(the)g(angle\(degrees\))d(that)
-j(the)g(region)f(is)h(rotated)f(with)620 668 y(respect)g(to)h
-(\(xcntr,ycntr\))334 781 y(\(Xcoord,Ycoord\))d(are)j(the)g(\(x,y\))f
-(coordinates)f(to)i(test,)f(usually)g(column)620 894
-y(names)334 1007 y(NOTE:)g(each)h(parameter)e(can)i(itself)f(be)i(an)f
-(expression,)d(not)j(merely)f(a)620 1120 y(column)h(name)f(or)h
-(constant.)0 1263 y
-SDict begin H.S end
- 0 1263 a 0 1263 a
-SDict begin 13.6 H.A end
- 0 1263 a 0 1263
-a
-SDict begin [/View [/XYZ H.V]/Dest (subsection.8.11.6) cvn /DEST pdfmark
-end
- 0 1263 a 164 x Fc(8.11.6)113 b(Example)38 b(Ro)m(w)f(Filters)191
-1649 y Ff([)47 b(binary)f(&&)i(mag)f(<=)g(5.0])380 b(-)48
-b(Extract)e(all)h(binary)f(stars)g(brighter)1766 1762
+3960 y(\(radius\))f(is)h(half)f(the)h(diameter)f(of)h(the)g(circle)334
+4073 y(\(rotation\))e(is)i(the)g(angle\(degrees\))d(that)j(the)g
+(region)f(is)h(rotated)f(with)620 4186 y(respect)g(to)h
+(\(xcntr,ycntr\))334 4299 y(\(Xcoord,Ycoord\))d(are)j(the)g(\(x,y\))f
+(coordinates)f(to)i(test,)f(usually)g(column)620 4411
+y(names)334 4524 y(NOTE:)g(each)h(parameter)e(can)i(itself)f(be)i(an)f
+(expression,)d(not)j(merely)f(a)620 4637 y(column)h(name)f(or)h
+(constant.)0 4930 y Fc(8.11.6)113 b(Example)38 b(Ro)m(w)f(Filters)191
+5149 y Ff([)47 b(binary)f(&&)i(mag)f(<=)g(5.0])380 b(-)48
+b(Extract)e(all)h(binary)f(stars)g(brighter)1766 5262
 y(than)94 b(fifth)47 b(magnitude)e(\(note)h(that)1766
-1875 y(the)h(initial)f(space)g(is)h(necessary)e(to)1766
-1988 y(prevent)h(it)h(from)g(being)f(treated)g(as)h(a)1766
-2101 y(binning)f(specification\))191 2327 y([#row)g(>=)h(125)g(&&)h
-(#row)e(<=)h(175])142 b(-)48 b(Extract)e(row)h(numbers)e(125)i(through)
-f(175)191 2552 y([IMAGE[4,5])f(.gt.)h(100])476 b(-)48
-b(Extract)e(all)h(rows)f(that)h(have)g(the)1766 2665
-y(\(4,5\))f(component)g(of)h(the)g(IMAGE)f(column)1766
-2778 y(greater)g(than)g(100)191 3004 y([abs\(sin\(theta)e(*)j(#deg\)\))
-f(<)i(0.5])e(-)i(Extract)e(all)h(rows)f(having)g(the)1766
-3117 y(absolute)f(value)i(of)g(the)g(sine)g(of)g(theta)1766
-3230 y(less)94 b(than)47 b(a)g(half)g(where)f(the)h(angles)1766
-3343 y(are)g(tabulated)e(in)i(degrees)191 3569 y([SUM\()f(SPEC)h(>)g
+5375 y(the)h(initial)f(space)g(is)h(necessary)e(to)1766
+5488 y(prevent)h(it)h(from)g(being)f(treated)g(as)h(a)1766
+5601 y(binning)f(specification\))p eop end
+%%Page: 108 114
+TeXDict begin 108 113 bop 0 299 a Fj(108)1573 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)191
+555 y Ff([#row)46 b(>=)h(125)g(&&)h(#row)e(<=)h(175])142
+b(-)48 b(Extract)e(row)h(numbers)e(125)i(through)f(175)191
+781 y([IMAGE[4,5])f(.gt.)h(100])476 b(-)48 b(Extract)e(all)h(rows)f
+(that)h(have)g(the)1766 894 y(\(4,5\))f(component)g(of)h(the)g(IMAGE)f
+(column)1766 1007 y(greater)g(than)g(100)191 1233 y([abs\(sin\(theta)e
+(*)j(#deg\)\))f(<)i(0.5])e(-)i(Extract)e(all)h(rows)f(having)g(the)1766
+1346 y(absolute)f(value)i(of)g(the)g(sine)g(of)g(theta)1766
+1458 y(less)94 b(than)47 b(a)g(half)g(where)f(the)h(angles)1766
+1571 y(are)g(tabulated)e(in)i(degrees)191 1797 y([SUM\()f(SPEC)h(>)g
 (3*BACKGRND)e(\)>=1])94 b(-)48 b(Extract)e(all)h(rows)f(containing)f(a)
-1766 3681 y(spectrum,)g(held)i(in)g(vector)f(column)1766
-3794 y(SPEC,)g(with)h(at)g(least)f(one)h(value)g(3)1766
-3907 y(times)f(greater)g(than)h(the)g(background)1766
-4020 y(level)f(held)h(in)g(a)h(keyword,)d(BACKGRND)191
-4246 y([VCOL=={1,4,2}])759 b(-)48 b(Extract)e(all)h(rows)f(whose)h
-(vector)f(column)1766 4359 y(VCOL)h(contains)e(the)i(3-elements)e(1,)i
-(4,)g(and)1766 4472 y(2.)191 4698 y([@rowFilter.txt])711
+1766 1910 y(spectrum,)g(held)i(in)g(vector)f(column)1766
+2023 y(SPEC,)g(with)h(at)g(least)f(one)h(value)g(3)1766
+2136 y(times)f(greater)g(than)h(the)g(background)1766
+2249 y(level)f(held)h(in)g(a)h(keyword,)d(BACKGRND)191
+2475 y([VCOL=={1,4,2}])759 b(-)48 b(Extract)e(all)h(rows)f(whose)h
+(vector)f(column)1766 2588 y(VCOL)h(contains)e(the)i(3-elements)e(1,)i
+(4,)g(and)1766 2700 y(2.)191 2926 y([@rowFilter.txt])711
 b(-)48 b(Extract)e(rows)g(using)h(the)g(expression)1766
-4811 y(contained)e(within)h(the)h(text)g(file)1766 4924
-y(rowFilter.txt)191 5149 y([gtifilter\(\)])855 b(-)48
-b(Search)e(the)h(current)f(file)g(for)h(a)h(GTI)239 5262
-y(extension,)92 b(filter)i(the)47 b(TIME)239 5375 y(column)f(in)h(the)g
-(current)f(table,)g(using)239 5488 y(START/STOP)f(times)h(taken)g(from)
-239 5601 y(columns)f(in)j(the)f(GTI)94 b(extension)p
-eop end
-%%Page: 107 113
-TeXDict begin 107 112 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.107) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.12.)113
-b(BINNING)31 b(OR)f(HISTOGRAMMING)h(SPECIFICA)-8 b(TION)1268
-b Fj(107)191 555 y Ff([regfilter\("pow.reg"\)])423 b(-)48
-b(Extract)e(rows)g(which)h(have)f(a)i(coordinate)1766
-668 y(\(as)f(given)f(in)h(the)g(X)h(and)f(Y)g(columns\))1766
-781 y(within)f(the)h(spatial)f(region)g(specified)1766
-894 y(in)h(the)g(pow.reg)f(region)g(file.)191 1120 y
-([regfilter\("pow.reg",)c(Xs,)47 b(Ys\)])f(-)i(Same)f(as)g(above,)f
-(except)g(that)h(the)1766 1233 y(Xs)g(and)g(Ys)g(columns)f(will)h(be)g
-(used)f(to)1766 1346 y(determine)f(the)i(coordinate)e(of)i(each)1766
-1458 y(row)g(in)g(the)g(table.)0 1593 y
-SDict begin H.S end
- 0 1593 a 0 1593
-a
-SDict begin 13.6 H.A end
- 0 1593 a 0 1593 a
-SDict begin [/View [/XYZ H.V]/Dest (section.8.12) cvn /DEST pdfmark
-end
- 0 1593 a 196 x Fe(8.12)180 b(Binning)45
-b(or)g(Histogramming)i(Sp)t(eci\014cation)0 2040 y Fj(The)22
+3039 y(contained)e(within)h(the)h(text)g(file)1766 3152
+y(rowFilter.txt)191 3378 y([gtifilter\(\)])855 b(-)48
+b(Search)e(the)h(current)f(file)g(for)h(a)h(GTI)239 3491
+y(extension,)92 b(filter)i(the)47 b(TIME)239 3604 y(column)f(in)h(the)g
+(current)f(table,)g(using)239 3717 y(START/STOP)f(times)h(taken)g(from)
+239 3830 y(columns)f(in)j(the)f(GTI)94 b(extension)191
+4055 y([regfilter\("pow.reg"\)])423 b(-)48 b(Extract)e(rows)g(which)h
+(have)f(a)i(coordinate)1766 4168 y(\(as)f(given)f(in)h(the)g(X)h(and)f
+(Y)g(columns\))1766 4281 y(within)f(the)h(spatial)f(region)g(specified)
+1766 4394 y(in)h(the)g(pow.reg)f(region)g(file.)191 4620
+y([regfilter\("pow.reg",)c(Xs,)47 b(Ys\)])f(-)i(Same)f(as)g(above,)f
+(except)g(that)h(the)1766 4733 y(Xs)g(and)g(Ys)g(columns)f(will)h(be)g
+(used)f(to)1766 4846 y(determine)f(the)i(coordinate)e(of)i(each)1766
+4959 y(row)g(in)g(the)g(table.)0 5341 y Fe(8.12)180 b(Binning)45
+b(or)g(Histogramming)i(Sp)t(eci\014cation)0 5601 y Fj(The)22
 b(optional)i(binning)e(sp)s(eci\014er)g(is)h(enclosed)h(in)f(square)f
 (brac)m(k)m(ets)j(and)d(can)h(b)s(e)f(distinguished)g(from)h(a)g
-(general)0 2152 y(ro)m(w)32 b(\014lter)h(sp)s(eci\014cation)g(b)m(y)f
+(general)0 5714 y(ro)m(w)32 b(\014lter)h(sp)s(eci\014cation)g(b)m(y)f
 (the)h(fact)g(that)g(it)g(b)s(egins)f(with)g(the)g(k)m(eyw)m(ord)h
-('bin')f(not)h(immediately)g(follo)m(w)m(ed)0 2265 y(b)m(y)41
-b(an)f(equals)i(sign.)72 b(When)41 b(binning)e(is)i(sp)s(eci\014ed,)i
-(a)e(temp)s(orary)g(N-dimensional)g(FITS)f(primary)g(arra)m(y)0
-2378 y(is)j(created)h(b)m(y)f(computing)h(the)f(histogram)h(of)f(the)g
-(v)-5 b(alues)44 b(in)e(the)i(sp)s(eci\014ed)e(columns)h(of)g(a)h(FITS)
-e(table)0 2491 y(extension.)f(After)30 b(the)f(histogram)h(is)g
+('bin')f(not)h(immediately)g(follo)m(w)m(ed)p eop end
+%%Page: 109 115
+TeXDict begin 109 114 bop 0 299 a Fh(8.12.)113 b(BINNING)31
+b(OR)f(HISTOGRAMMING)h(SPECIFICA)-8 b(TION)1268 b Fj(109)0
+555 y(b)m(y)41 b(an)f(equals)i(sign.)72 b(When)41 b(binning)e(is)i(sp)s
+(eci\014ed,)i(a)e(temp)s(orary)g(N-dimensional)g(FITS)f(primary)g(arra)
+m(y)0 668 y(is)j(created)h(b)m(y)f(computing)h(the)f(histogram)h(of)f
+(the)g(v)-5 b(alues)44 b(in)e(the)i(sp)s(eci\014ed)e(columns)h(of)g(a)h
+(FITS)e(table)0 781 y(extension.)f(After)30 b(the)f(histogram)h(is)g
 (computed)f(the)h(input)e(FITS)h(\014le)h(con)m(taining)h(the)e(table)i
-(is)e(then)g(closed)0 2604 y(and)34 b(the)h(temp)s(orary)f(FITS)g
+(is)e(then)g(closed)0 894 y(and)34 b(the)h(temp)s(orary)f(FITS)g
 (primary)g(arra)m(y)h(is)g(op)s(ened)f(and)g(passed)g(to)h(the)g
-(application)h(program.)54 b(Th)m(us,)0 2717 y(the)39
+(application)h(program.)54 b(Th)m(us,)0 1007 y(the)39
 b(application)h(program)f(nev)m(er)g(sees)g(the)g(original)h(FITS)e
 (table)i(and)e(only)h(sees)h(the)f(image)h(in)e(the)h(new)0
-2830 y(temp)s(orary)32 b(\014le)h(\(whic)m(h)g(has)f(no)h(additional)g
+1120 y(temp)s(orary)32 b(\014le)h(\(whic)m(h)g(has)f(no)h(additional)g
 (extensions\).)49 b(Ob)m(viously)-8 b(,)34 b(the)f(application)h
-(program)e(m)m(ust)h(b)s(e)0 2943 y(exp)s(ecting)e(to)g(op)s(en)f(a)h
+(program)e(m)m(ust)h(b)s(e)0 1233 y(exp)s(ecting)e(to)g(op)s(en)f(a)h
 (FITS)e(image)j(and)e(not)g(a)h(FITS)f(table)h(in)f(this)g(case.)0
-3103 y(The)g(data)h(t)m(yp)s(e)f(of)h(the)f(FITS)g(histogram)g(image)i
+1393 y(The)g(data)h(t)m(yp)s(e)f(of)h(the)f(FITS)g(histogram)g(image)i
 (ma)m(y)f(b)s(e)f(sp)s(eci\014ed)f(b)m(y)h(app)s(ending)f('b')h(\(for)h
-(8-bit)g(b)m(yte\),)g('i')0 3216 y(\(for)g(16-bit)g(in)m(tegers\),)h
+(8-bit)g(b)m(yte\),)g('i')0 1506 y(\(for)g(16-bit)g(in)m(tegers\),)h
 ('j')f(\(for)g(32-bit)g(in)m(teger\),)i('r')d(\(for)h(32-bit)g
 (\015oating)h(p)s(oin)m(ts\),)e(or)h('d')f(\(for)h(64-bit)g(double)0
-3329 y(precision)d(\015oating)h(p)s(oin)m(t\))g(to)f(the)h('bin')e(k)m
+1619 y(precision)d(\015oating)h(p)s(oin)m(t\))g(to)f(the)h('bin')e(k)m
 (eyw)m(ord)i(\(e.g.)41 b('[binr)28 b(X]')g(creates)i(a)e(real)h
-(\015oating)g(p)s(oin)m(t)f(image\).)41 b(If)0 3442 y(the)26
+(\015oating)g(p)s(oin)m(t)f(image\).)41 b(If)0 1732 y(the)26
 b(datat)m(yp)s(e)h(is)f(not)g(explicitly)i(sp)s(eci\014ed)d(then)h(a)g
 (32-bit)h(in)m(teger)h(image)f(will)f(b)s(e)f(created)i(b)m(y)f
-(default,)i(unless)0 3555 y(the)h(w)m(eigh)m(ting)h(option)f(is)g(also)
+(default,)i(unless)0 1844 y(the)h(w)m(eigh)m(ting)h(option)f(is)g(also)
 h(sp)s(eci\014ed)e(in)g(whic)m(h)h(case)g(the)g(image)h(will)f(ha)m(v)m
-(e)h(a)f(32-bit)h(\015oating)g(p)s(oin)m(t)e(data)0 3668
-y(t)m(yp)s(e)j(b)m(y)f(default.)0 3828 y(The)24 b(histogram)g(image)i
+(e)h(a)f(32-bit)h(\015oating)g(p)s(oin)m(t)e(data)0 1957
+y(t)m(yp)s(e)j(b)m(y)f(default.)0 2118 y(The)24 b(histogram)g(image)i
 (ma)m(y)f(ha)m(v)m(e)g(from)f(1)g(to)h(4)g(dimensions)e(\(axes\),)k
 (dep)s(ending)c(on)h(the)g(n)m(um)m(b)s(er)f(of)h(columns)0
-3941 y(that)31 b(are)g(sp)s(eci\014ed.)40 b(The)30 b(general)h(form)f
-(of)g(the)h(binning)e(sp)s(eci\014cation)i(is:)48 4183
+2230 y(that)31 b(are)g(sp)s(eci\014ed.)40 b(The)30 b(general)h(form)f
+(of)g(the)h(binning)e(sp)s(eci\014cation)i(is:)48 2470
 y Ff([bin{bijrd})92 b(Xcol=min:max:binsize,)42 b(Ycol=)47
-b(...,)f(Zcol=...,)f(Tcol=...;)h(weight])0 4425 y Fj(in)39
+b(...,)f(Zcol=...,)f(Tcol=...;)h(weight])0 2709 y Fj(in)39
 b(whic)m(h)g(up)f(to)i(4)g(columns,)h(eac)m(h)f(corresp)s(onding)e(to)i
 (an)g(axis)f(of)h(the)f(image,)k(are)d(listed.)67 b(The)39
-b(column)0 4538 y(names)27 b(are)h(case)h(insensitiv)m(e,)g(and)e(the)h
+b(column)0 2822 y(names)27 b(are)h(case)h(insensitiv)m(e,)g(and)e(the)h
 (column)f(n)m(um)m(b)s(er)f(ma)m(y)i(b)s(e)f(giv)m(en)h(instead)g(of)g
-(the)g(name,)g(preceded)f(b)m(y)0 4650 y(a)32 b(p)s(ound)e(sign)i
+(the)g(name,)g(preceded)f(b)m(y)0 2935 y(a)32 b(p)s(ound)e(sign)i
 (\(e.g.,)i([bin)d(#4=1:512]\).)47 b(If)31 b(the)h(column)g(name)g(is)f
 (not)h(sp)s(eci\014ed,)g(then)f(CFITSIO)g(will)h(\014rst)0
-4763 y(try)37 b(to)h(use)f(the)g('preferred)f(column')i(as)f(sp)s
+3048 y(try)37 b(to)h(use)f(the)g('preferred)f(column')i(as)f(sp)s
 (eci\014ed)g(b)m(y)g(the)g(CPREF)g(k)m(eyw)m(ord)h(if)f(it)g(exists)h
-(\(e.g.,)j('CPREF)0 4876 y(=)i('DETX,DETY'\),)h(otherwise)g(column)f
+(\(e.g.,)j('CPREF)0 3161 y(=)i('DETX,DETY'\),)h(otherwise)g(column)f
 (names)g('X',)h('Y',)g('Z',)f(and)f('T')i(will)f(b)s(e)f(assumed)h(for)
-g(eac)m(h)h(of)0 4989 y(the)37 b(4)h(axes,)i(resp)s(ectiv)m(ely)-8
+g(eac)m(h)h(of)0 3274 y(the)37 b(4)h(axes,)i(resp)s(ectiv)m(ely)-8
 b(.)62 b(In)37 b(cases)h(where)e(the)i(column)f(name)g(could)g(b)s(e)f
-(confused)h(with)g(an)g(arithmetic)0 5102 y(expression,)30
+(confused)h(with)g(an)g(arithmetic)0 3386 y(expression,)30
 b(enclose)i(the)f(column)f(name)g(in)g(paren)m(theses)h(to)g(force)g
 (the)f(name)h(to)g(b)s(e)f(in)m(terpreted)g(literally)-8
-b(.)0 5262 y(Eac)m(h)33 b(column)f(name)g(ma)m(y)h(b)s(e)f(follo)m(w)m
-(ed)h(b)m(y)g(an)f(equals)g(sign)h(and)e(then)h(the)g(lo)m(w)m(er)i
-(and)e(upp)s(er)e(range)i(of)h(the)0 5375 y(histogram,)f(and)e(the)h
-(size)h(of)f(the)g(histogram)h(bins,)e(separated)h(b)m(y)g(colons.)43
-b(Spaces)31 b(are)g(allo)m(w)m(ed)i(b)s(efore)e(and)0
-5488 y(after)e(the)g(equals)g(sign)f(but)g(not)h(within)f(the)h
-('min:max:binsize')g(string.)40 b(The)29 b(min,)f(max)h(and)f(binsize)h
-(v)-5 b(alues)0 5601 y(ma)m(y)32 b(b)s(e)e(in)m(teger)i(or)f
-(\015oating)h(p)s(oin)m(t)f(n)m(um)m(b)s(ers,)f(or)h(they)g(ma)m(y)g(b)
-s(e)g(the)g(names)g(of)g(k)m(eyw)m(ords)g(in)g(the)g(header)g(of)0
-5714 y(the)g(table.)41 b(If)30 b(the)h(latter,)h(then)e(the)g(v)-5
-b(alue)31 b(of)g(that)g(k)m(eyw)m(ord)f(is)h(substituted)f(in)m(to)h
-(the)g(expression.)p eop end
-%%Page: 108 114
-TeXDict begin 108 113 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.108) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(108)1573
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)0 555 y Fj(Default)37 b(v)-5 b(alues)36 b(for)g(the)g(min,)h(max)f
-(and)g(binsize)g(quan)m(tities)h(will)f(b)s(e)f(used)h(if)f(not)i
-(explicitly)g(giv)m(en)g(in)f(the)0 668 y(binning)29
-b(expression)h(as)h(sho)m(wn)f(in)g(these)h(examples:)191
-917 y Ff([bin)47 b(x)g(=)g(:512:2])94 b(-)47 b(use)g(default)f(minimum)
-g(value)191 1030 y([bin)h(x)g(=)g(1::2])190 b(-)47 b(use)g(default)f
-(maximum)g(value)191 1143 y([bin)h(x)g(=)g(1:512])142
-b(-)47 b(use)g(default)f(bin)h(size)191 1256 y([bin)g(x)g(=)g(1:])286
-b(-)47 b(use)g(default)f(maximum)g(value)g(and)h(bin)g(size)191
-1368 y([bin)g(x)g(=)g(:512])190 b(-)47 b(use)g(default)f(minimum)g
-(value)g(and)h(bin)g(size)191 1481 y([bin)g(x)g(=)g(2])334
-b(-)47 b(use)g(default)f(minimum)g(and)h(maximum)f(values)191
-1594 y([bin)h(x])524 b(-)47 b(use)g(default)f(minimum,)g(maximum)g(and)
-g(bin)h(size)191 1707 y([bin)g(4])524 b(-)47 b(default)f(2-D)h(image,)f
-(bin)h(size)g(=)g(4)h(in)f(both)g(axes)191 1820 y([bin])619
-b(-)47 b(default)f(2-D)h(image)0 2069 y Fj(CFITSIO)31
-b(will)i(use)f(the)h(v)-5 b(alue)33 b(of)g(the)g(TLMINn,)f(TLMAXn,)h
-(and)f(TDBINn)h(k)m(eyw)m(ords,)h(if)e(they)h(exist,)h(for)0
-2182 y(the)j(default)f(min,)i(max,)g(and)e(binsize,)i(resp)s(ectiv)m
-(ely)-8 b(.)61 b(If)36 b(they)h(do)f(not)h(exist)g(then)f(CFITSIO)f
-(will)i(use)f(the)0 2295 y(actual)d(minim)m(um)e(and)h(maxim)m(um)g(v)
--5 b(alues)32 b(in)g(the)g(column)f(for)h(the)g(histogram)h(min)e(and)h
-(max)g(v)-5 b(alues.)45 b(The)0 2408 y(default)34 b(binsize)f(will)h(b)
-s(e)f(set)h(to)h(1,)g(or)e(\(max)h(-)g(min\))f(/)h(10.,)i(whic)m(hev)m
-(er)e(is)g(smaller,)h(so)e(that)i(the)e(histogram)0 2520
-y(will)e(ha)m(v)m(e)g(at)g(least)h(10)f(bins)f(along)h(eac)m(h)h(axis.)
-0 2681 y(A)41 b(shortcut)g(notation)h(is)f(allo)m(w)m(ed)i(if)e(all)h
-(the)f(columns/axes)h(ha)m(v)m(e)g(the)f(same)g(binning)f(sp)s
-(eci\014cation.)74 b(In)0 2794 y(this)33 b(case)g(all)h(the)f(column)f
+b(.)0 3547 y(In)31 b(addition)h(to)g(binning)f(b)m(y)g(a)h(FITS)f
+(column,)h(an)m(y)g(arbitrary)f(calculator)j(expression)e(ma)m(y)g(b)s
+(e)f(sp)s(eci\014ed)g(as)0 3660 y(w)m(ell.)42 b(Usage)31
+b(of)g(this)f(form)g(w)m(ould)g(app)s(ear)g(as:)48 3899
+y Ff([bin)94 b(Xcol\(arbitrary)44 b(expression\)=min:max:bins)o(ize,)d
+(...)47 b(])0 4138 y Fj(The)23 b(column)h(name)g(m)m(ust)f(still)i(b)s
+(e)e(sp)s(eci\014ed,)h(and)g(is)f(used)g(to)i(lab)s(el)f(co)s(ordinate)
+g(axes)h(of)f(the)g(resulting)f(image.)0 4251 y(The)30
+b(expression)g(app)s(ears)g(immediately)i(after)e(the)h(name,)g
+(enclosed)g(in)f(paren)m(theses.)41 b(The)30 b(expression)g(ma)m(y)0
+4364 y(use)h(an)m(y)i(com)m(bination)g(of)f(columns,)g(k)m(eyw)m(ords,)
+g(functions)g(and)f(constan)m(ts)i(and)e(allo)m(w)m(ed)j(b)m(y)d(the)h
+(CFITSIO)0 4477 y(calculator.)0 4637 y(The)d(column)f(name)h(\(and)g
+(optional)h(expression\))f(ma)m(y)h(b)s(e)e(follo)m(w)m(ed)j(b)m(y)e
+(an)g(equals)g(sign)g(and)g(then)f(the)i(lo)m(w)m(er)0
+4750 y(and)f(upp)s(er)f(range)i(of)f(the)h(histogram,)h(and)e(the)h
+(size)g(of)g(the)g(histogram)g(bins,)f(separated)h(b)m(y)g(colons.)41
+b(Spaces)0 4863 y(are)30 b(allo)m(w)m(ed)i(b)s(efore)e(and)f(after)i
+(the)f(equals)h(sign)f(but)f(not)h(within)g(the)g('min:max:binsize')h
+(string.)41 b(The)29 b(min,)0 4976 y(max)37 b(and)g(binsize)g(v)-5
+b(alues)38 b(ma)m(y)g(b)s(e)f(in)m(teger)h(or)g(\015oating)g(p)s(oin)m
+(t)f(n)m(um)m(b)s(ers,)h(or)f(they)h(ma)m(y)f(b)s(e)g(the)h(names)f(of)
+0 5089 y(k)m(eyw)m(ords)f(in)g(the)h(header)f(of)g(the)g(table.)59
+b(If)36 b(the)g(latter,)k(then)c(the)g(v)-5 b(alue)37
+b(of)f(that)h(k)m(eyw)m(ord)f(is)h(substituted)0 5202
+y(in)m(to)31 b(the)g(expression.)0 5362 y(Default)37
+b(v)-5 b(alues)36 b(for)g(the)g(min,)h(max)f(and)g(binsize)g(quan)m
+(tities)h(will)f(b)s(e)f(used)h(if)f(not)i(explicitly)g(giv)m(en)g(in)f
+(the)0 5475 y(binning)29 b(expression)h(as)h(sho)m(wn)f(in)g(these)h
+(examples:)191 5714 y Ff([bin)47 b(x)g(=)g(:512:2])94
+b(-)47 b(use)g(default)f(minimum)g(value)p eop end
+%%Page: 110 116
+TeXDict begin 110 115 bop 0 299 a Fj(110)1573 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)191
+555 y Ff([bin)47 b(x)g(=)g(1::2])190 b(-)47 b(use)g(default)f(maximum)g
+(value)191 668 y([bin)h(x)g(=)g(1:512])142 b(-)47 b(use)g(default)f
+(bin)h(size)191 781 y([bin)g(x)g(=)g(1:])286 b(-)47 b(use)g(default)f
+(maximum)g(value)g(and)h(bin)g(size)191 894 y([bin)g(x)g(=)g(:512])190
+b(-)47 b(use)g(default)f(minimum)g(value)g(and)h(bin)g(size)191
+1007 y([bin)g(x)g(=)g(2])334 b(-)47 b(use)g(default)f(minimum)g(and)h
+(maximum)f(values)191 1120 y([bin)h(x])524 b(-)47 b(use)g(default)f
+(minimum,)g(maximum)g(and)g(bin)h(size)191 1233 y([bin)g(4])524
+b(-)47 b(default)f(2-D)h(image,)f(bin)h(size)g(=)g(4)h(in)f(both)g
+(axes)191 1346 y([bin])619 b(-)47 b(default)f(2-D)h(image)0
+1610 y Fj(CFITSIO)31 b(will)i(use)f(the)h(v)-5 b(alue)33
+b(of)g(the)g(TLMINn,)f(TLMAXn,)h(and)f(TDBINn)h(k)m(eyw)m(ords,)h(if)e
+(they)h(exist,)h(for)0 1722 y(the)j(default)f(min,)i(max,)g(and)e
+(binsize,)i(resp)s(ectiv)m(ely)-8 b(.)61 b(If)36 b(they)h(do)f(not)h
+(exist)g(then)f(CFITSIO)f(will)i(use)f(the)0 1835 y(actual)d(minim)m
+(um)e(and)h(maxim)m(um)g(v)-5 b(alues)32 b(in)g(the)g(column)f(for)h
+(the)g(histogram)h(min)e(and)h(max)g(v)-5 b(alues.)45
+b(The)0 1948 y(default)34 b(binsize)f(will)h(b)s(e)f(set)h(to)h(1,)g
+(or)e(\(max)h(-)g(min\))f(/)h(10.,)i(whic)m(hev)m(er)e(is)g(smaller,)h
+(so)e(that)i(the)e(histogram)0 2061 y(will)e(ha)m(v)m(e)g(at)g(least)h
+(10)f(bins)f(along)h(eac)m(h)h(axis.)0 2221 y(Please)d(note)f(that)g
+(if)g(explicit)h(min)e(and)g(max)h(v)-5 b(alues)28 b(\(or)f
+(TLMINn/TLMAXn)g(k)m(eyw)m(ords\))i(are)f(not)g(presen)m(t,)0
+2334 y(then)g(CFITSIO)g(m)m(ust)g(c)m(hec)m(k)j(ev)m(ery)e(v)-5
+b(alue)30 b(of)e(the)h(binned)f(quan)m(tit)m(y)i(in)e(adv)-5
+b(ance)30 b(to)f(determine)g(the)g(binning)0 2447 y(limits.)43
+b(This)30 b(is)h(esp)s(ecially)h(relev)-5 b(an)m(t)32
+b(for)f(binning)f(expressions,)h(whic)m(h)g(m)m(ust)f(b)s(e)h(ev)-5
+b(aluated)32 b(m)m(ultiple)f(times)0 2560 y(to)40 b(determine)f(the)g
+(limits)g(of)g(the)g(expression.)67 b(Th)m(us,)40 b(it)f(is)g(alw)m(a)m
+(ys)i(advisable)e(to)h(sp)s(ecify)e(min)h(and)f(max)0
+2673 y(limits)31 b(where)f(p)s(ossible.)0 2833 y(A)41
+b(shortcut)g(notation)h(is)f(allo)m(w)m(ed)i(if)e(all)h(the)f
+(columns/axes)h(ha)m(v)m(e)g(the)f(same)g(binning)f(sp)s
+(eci\014cation.)74 b(In)0 2946 y(this)33 b(case)g(all)h(the)f(column)f
 (names)h(ma)m(y)g(b)s(e)f(listed)h(within)f(paren)m(theses,)i(follo)m
-(w)m(ed)h(b)m(y)d(the)h(\(single\))h(binning)0 2906 y(sp)s
-(eci\014cation,)d(as)g(in:)191 3155 y Ff([bin)47 b(\(X,Y\)=1:512:2])191
-3268 y([bin)g(\(X,Y\))f(=)h(5])0 3517 y Fj(The)31 b(optional)i(w)m
+(w)m(ed)h(b)m(y)d(the)h(\(single\))h(binning)0 3059 y(sp)s
+(eci\014cation,)d(as)g(in:)191 3323 y Ff([bin)47 b(\(X,Y\)=1:512:2])191
+3436 y([bin)g(\(X,Y\))f(=)h(5])0 3700 y Fj(The)31 b(optional)i(w)m
 (eigh)m(ting)h(factor)e(is)g(the)g(last)g(item)h(in)e(the)h(binning)f
 (sp)s(eci\014er)g(and,)h(if)f(presen)m(t,)i(is)e(separated)0
-3630 y(from)38 b(the)g(list)h(of)f(columns)g(b)m(y)g(a)h(semi-colon.)65
+3813 y(from)38 b(the)g(list)h(of)f(columns)g(b)m(y)g(a)h(semi-colon.)65
 b(As)39 b(the)f(histogram)h(is)f(accum)m(ulated,)k(this)c(w)m(eigh)m(t)
-i(is)e(used)0 3743 y(to)d(incremen)m(ted)f(the)g(v)-5
+i(is)e(used)0 3926 y(to)d(incremen)m(ted)f(the)g(v)-5
 b(alue)35 b(of)f(the)g(appropriated)f(bin)h(in)f(the)h(histogram.)52
 b(If)34 b(the)g(w)m(eigh)m(ting)i(factor)f(is)f(not)0
-3856 y(sp)s(eci\014ed,)24 b(then)f(the)g(default)g(w)m(eigh)m(t)i(=)d
-(1)i(is)f(assumed.)37 b(The)23 b(w)m(eigh)m(ting)i(factor)f(ma)m(y)f(b)
-s(e)g(a)g(constan)m(t)i(in)m(teger)f(or)0 3968 y(\015oating)30
-b(p)s(oin)m(t)f(n)m(um)m(b)s(er,)f(or)h(the)g(name)g(of)g(a)g(k)m(eyw)m
-(ord)h(con)m(taining)g(the)g(w)m(eigh)m(ting)g(v)-5 b(alue.)41
-b(Or)28 b(the)h(w)m(eigh)m(ting)0 4081 y(factor)g(ma)m(y)g(b)s(e)e(the)
-h(name)g(of)h(a)f(table)h(column)f(in)g(whic)m(h)f(case)j(the)e(v)-5
-b(alue)28 b(in)g(that)h(column,)f(on)g(a)h(ro)m(w)f(b)m(y)g(ro)m(w)0
-4194 y(basis,)i(will)h(b)s(e)f(used.)0 4354 y(In)35 b(some)h(cases,)i
-(the)d(column)h(or)f(k)m(eyw)m(ord)h(ma)m(y)g(giv)m(e)h(the)f(recipro)s
-(cal)g(of)g(the)g(actual)h(w)m(eigh)m(t)g(v)-5 b(alue)36
-b(that)g(is)0 4467 y(needed.)49 b(In)32 b(this)h(case,)i(precede)e(the)
-h(w)m(eigh)m(t)g(k)m(eyw)m(ord)g(or)f(column)g(name)g(b)m(y)g(a)g
-(slash)g('/')h(to)g(tell)g(CFITSIO)0 4580 y(to)d(use)f(the)h(recipro)s
-(cal)g(of)f(the)h(v)-5 b(alue)31 b(when)e(constructing)i(the)g
-(histogram.)0 4740 y(F)-8 b(or)35 b(complex)f(or)g(commonly)g(used)f
-(histograms,)j(one)e(can)g(also)h(place)g(its)f(description)g(in)m(to)h
-(a)f(text)h(\014le)f(and)0 4853 y(imp)s(ort)44 b(it)g(in)m(to)i(the)e
-(binning)f(sp)s(eci\014cation)i(using)f(the)h(syn)m(tax)f('[bin)g
-(@\014lename.txt]'.)84 b(The)44 b(\014le's)g(con-)0 4966
+4039 y(sp)s(eci\014ed,)c(then)f(the)h(default)g(w)m(eigh)m(t)i(=)d(1)i
+(is)f(assumed.)39 b(The)30 b(w)m(eigh)m(ting)h(factor)g(ma)m(y)g(b)s(e)
+e(a)h(constan)m(t)i(in)m(teger)0 4152 y(or)d(\015oating)g(p)s(oin)m(t)g
+(n)m(um)m(b)s(er,)f(or)g(the)h(name)g(of)f(a)h(k)m(eyw)m(ord)g(con)m
+(taining)h(the)f(w)m(eigh)m(ting)i(v)-5 b(alue.)40 b(The)28
+b(w)m(eigh)m(ting)0 4264 y(factor)35 b(ma)m(y)f(also)h(b)s(e)e(the)h
+(name)g(of)g(a)g(table)h(column)f(in)f(whic)m(h)h(case)h(the)f(v)-5
+b(alue)34 b(in)g(that)g(column,)h(on)f(a)g(ro)m(w)0 4377
+y(b)m(y)29 b(ro)m(w)f(basis,)i(will)f(b)s(e)f(used.)39
+b(It)29 b(ma)m(y)g(also)h(b)s(e)e(an)h(expression,)g(enclosed)g(in)g
+(paren)m(thesis,)g(in)g(whic)m(h)f(case)i(the)0 4490
+y(w)m(eigh)m(ting)i(v)-5 b(alue)31 b(will)g(b)s(e)e(ev)-5
+b(aluated)32 b(for)e(eac)m(h)i(binned)d(ro)m(w)h(and)g(applied)g
+(accordingly)-8 b(.)0 4650 y(In)35 b(some)h(cases,)i(the)d(column)h(or)
+f(k)m(eyw)m(ord)h(ma)m(y)g(giv)m(e)h(the)f(recipro)s(cal)g(of)g(the)g
+(actual)h(w)m(eigh)m(t)g(v)-5 b(alue)36 b(that)g(is)0
+4763 y(needed.)49 b(In)32 b(this)h(case,)i(precede)e(the)h(w)m(eigh)m
+(t)g(k)m(eyw)m(ord)g(or)f(column)g(name)g(b)m(y)g(a)g(slash)g('/')h(to)
+g(tell)g(CFITSIO)0 4876 y(to)40 b(use)e(the)i(recipro)s(cal)g(of)f(the)
+g(v)-5 b(alue)39 b(when)f(constructing)i(the)f(histogram.)68
+b(An)38 b(expression,)j(enclosed)f(in)0 4989 y(paren)m(theses,)31
+b(ma)m(y)g(also)g(app)s(ear)f(after)h(the)f(slash,)h(to)g(indicate)g
+(the)g(recipro)s(cal)g(v)-5 b(alue)31 b(of)g(the)f(expression.)0
+5149 y(F)-8 b(or)35 b(complex)f(or)g(commonly)g(used)f(histograms,)j
+(one)e(can)g(also)h(place)g(its)f(description)g(in)m(to)h(a)f(text)h
+(\014le)f(and)0 5262 y(imp)s(ort)44 b(it)g(in)m(to)i(the)e(binning)f
+(sp)s(eci\014cation)i(using)f(the)h(syn)m(tax)f('[bin)g
+(@\014lename.txt]'.)84 b(The)44 b(\014le's)g(con-)0 5375
 y(ten)m(ts)37 b(can)e(extend)h(o)m(v)m(er)h(m)m(ultiple)f(lines,)i
 (although)e(it)g(m)m(ust)f(still)i(conform)f(to)g(the)g(no-spaces)g
-(rule)f(for)h(the)0 5079 y(min:max:binsize)h(syn)m(tax)h(and)e(eac)m(h)
+(rule)f(for)h(the)0 5488 y(min:max:binsize)h(syn)m(tax)h(and)e(eac)m(h)
 i(axis)g(sp)s(eci\014cation)g(m)m(ust)f(still)g(b)s(e)g
-(comma-separated.)62 b(An)m(y)37 b(lines)g(in)0 5192
+(comma-separated.)62 b(An)m(y)37 b(lines)g(in)0 5601
 y(the)32 b(external)h(text)g(\014le)f(that)h(b)s(egin)e(with)h(2)g
 (slash)g(c)m(haracters)h(\('//'\))h(will)e(b)s(e)g(ignored)g(and)f(ma)m
-(y)i(b)s(e)e(used)g(to)0 5305 y(add)f(commen)m(ts)h(in)m(to)g(the)g
-(\014le.)0 5465 y(Examples:)191 5714 y Ff([bini)46 b(detx,)h(dety])762
-b(-)47 b(2-D,)g(16-bit)f(integer)g(histogram)p eop end
-%%Page: 109 115
-TeXDict begin 109 114 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.109) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(8.12.)113
-b(BINNING)31 b(OR)f(HISTOGRAMMING)h(SPECIFICA)-8 b(TION)1268
-b Fj(109)1861 555 y Ff(of)48 b(DETX)e(and)h(DETY)g(columns,)e(using)
-1861 668 y(default)h(values)g(for)h(the)g(histogram)1861
-781 y(range)g(and)g(binsize)191 1007 y([bin)g(\(detx,)f(dety\)=16;)f
+(y)i(b)s(e)e(used)g(to)0 5714 y(add)f(commen)m(ts)h(in)m(to)g(the)g
+(\014le.)p eop end
+%%Page: 111 117
+TeXDict begin 111 116 bop 0 299 a Fh(8.12.)113 b(BINNING)31
+b(OR)f(HISTOGRAMMING)h(SPECIFICA)-8 b(TION)1268 b Fj(111)0
+555 y(Examples:)191 815 y Ff([bini)46 b(detx,)h(dety])762
+b(-)47 b(2-D,)g(16-bit)f(integer)g(histogram)1861 928
+y(of)i(DETX)e(and)h(DETY)g(columns,)e(using)1861 1041
+y(default)h(values)g(for)h(the)g(histogram)1861 1154
+y(range)g(and)g(binsize)191 1380 y([bin)g(\(detx,)f(dety\)=16;)f
 (/exposure])g(-)i(2-D,)g(32-bit)f(real)h(histogram)e(of)i(DETX)1861
-1120 y(and)g(DETY)g(columns)f(with)g(a)i(bin)f(size)f(=)i(16)1861
-1233 y(in)g(both)e(axes.)h(The)f(histogram)g(values)1861
-1346 y(are)h(divided)f(by)h(the)g(EXPOSURE)f(keyword)1861
-1458 y(value.)191 1684 y([bin)h(time=TSTART:TSTOP:0.1])280
+1492 y(and)g(DETY)g(columns)f(with)g(a)i(bin)f(size)f(=)i(16)1861
+1605 y(in)g(both)e(axes.)h(The)f(histogram)g(values)1861
+1718 y(are)h(divided)f(by)h(the)g(EXPOSURE)f(keyword)1861
+1831 y(value.)191 2057 y([bin)h(time=TSTART:TSTOP:0.1])280
 b(-)47 b(1-D)g(lightcurve,)e(range)h(determined)f(by)1861
-1797 y(the)i(TSTART)f(and)h(TSTOP)g(keywords,)1861 1910
-y(with)g(0.1)g(unit)g(size)f(bins.)191 2136 y([bin)h(pha,)f
+2170 y(the)i(TSTART)f(and)h(TSTOP)g(keywords,)1861 2283
+y(with)g(0.1)g(unit)g(size)f(bins.)191 2509 y([bin)h(pha,)f
 (time=8000.:8100.:0.1])90 b(-)47 b(2-D)g(image)g(using)f(default)g
-(binning)1861 2249 y(of)i(the)e(PHA)h(column)f(for)h(the)g(X)h(axis,)
-1861 2362 y(and)f(1000)g(bins)g(in)g(the)g(range)1861
-2475 y(8000.)g(to)g(8100.)f(for)h(the)g(Y)h(axis.)191
-2700 y([bin)f(@binFilter.txt])616 b(-)47 b(Use)g(the)g(contents)f(of)h
-(the)g(text)f(file)1861 2813 y(binFilter.txt)f(for)h(the)h(binning)1861
-2926 y(specifications.)p eop end
-%%Page: 110 116
-TeXDict begin 110 115 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.110) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(110)1573
-b Fh(CHAPTER)30 b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8
-b(AX)p eop end
-%%Page: 111 117
-TeXDict begin 111 116 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.111) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a
-0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.9) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(9)0
+(binning)1861 2622 y(of)i(the)e(PHA)h(column)f(for)h(the)g(X)h(axis,)
+1861 2734 y(and)f(1000)g(bins)g(in)g(the)g(range)1861
+2847 y(8000.)g(to)g(8100.)f(for)h(the)g(Y)h(axis.)191
+3073 y([bin)f(pha,)f(gti_num\(gtifind\(\)\)=1:2:1])41
+b(-)48 b(a)f(2-D)g(image,)f(where)g(PHA)h(is)g(the)1861
+3186 y(X)h(axis)e(and)h(the)g(Y)h(axis)e(is)i(an)f(expression)1861
+3299 y(which)g(evaluates)e(to)i(the)g(GTI)g(number,)1861
+3412 y(as)h(determined)d(using)h(the)1861 3525 y(GTIFIND\(\))g
+(function.)191 3751 y([bin)h(time=0:4000:2000,)c(HR\()k
+(\(LC2/LC1\).lt.1.5)c(?)k(1)h(:)f(2)h(\)=1:2:1])d(-)j(a)f(2-D)1861
+3864 y(histogram)f(which)g(determines)f(the)i(number)1861
+3976 y(of)h(samples)d(in)j(two)e(time)h(bins)g(between)f(0)h(and)1861
+4089 y(4000)g(and)g(separating)e(hardness)g(ratio,)1861
+4202 y(evaluated)h(as)h(\(LC2/LC1\),)e(between)h(less)g(than)1861
+4315 y(1.5)h(or)g(greater)f(than)h(1.5.)94 b(The)47 b(?:)1861
+4428 y(conditional)e(function)h(is)h(used)f(to)i(decide)1861
+4541 y(less)f(\(or)g(greater\))e(than)i(1.5)g(and)g(assign)1861
+4654 y(HR)h(bin)e(1)i(or)f(2.)191 4880 y([bin)g(@binFilter.txt])616
+b(-)47 b(Use)g(the)g(contents)f(of)h(the)g(text)f(file)1861
+4993 y(binFilter.txt)f(for)h(the)h(binning)1861 5106
+y(specifications.)p eop end
+%%Page: 112 118
+TeXDict begin 112 117 bop 0 299 a Fj(112)1573 b Fh(CHAPTER)30
+b(8.)112 b(EXTENDED)30 b(FILE)h(NAME)f(SYNT)-8 b(AX)p
+eop end
+%%Page: 113 119
+TeXDict begin 113 118 bop 0 1225 a Fg(Chapter)65 b(9)0
 1687 y Fm(T)-19 b(emplate)76 b(Files)0 2180 y Fj(When)38
 b(a)h(new)f(FITS)g(\014le)h(is)g(created)g(with)g(a)f(call)i(to)g
 (\014ts)p 2101 2180 28 4 v 32 w(create)p 2369 2180 V
 35 w(\014le,)g(the)f(name)g(of)g(a)g(template)h(\014le)e(ma)m(y)0
 2293 y(b)s(e)h(supplied)g(in)h(paren)m(theses)g(immediately)h(follo)m
 (wing)g(the)g(name)f(of)g(the)g(new)f(\014le)h(to)h(b)s(e)e(created.)71
 b(This)0 2406 y(template)27 b(is)e(used)g(to)h(de\014ne)f(the)h
@@ -15766,32 +12647,25 @@
 m(ords)g(in)0 2631 y(eac)m(h)25 b(HDU)g(as)g(in)f(the)g(template)i
 (FITS)d(\014le,)j(but)d(all)j(the)e(data)h(units)e(will)i(b)s(e)f
 (\014lled)g(with)f(zeros.)40 b(The)24 b(template)0 2744
 y(\014le)i(ma)m(y)h(also)g(b)s(e)e(an)h(ASCI)s(I)e(text)j(\014le,)g
 (where)f(eac)m(h)h(line)f(\(in)g(general\))i(describ)s(es)d(one)h(FITS)
 f(k)m(eyw)m(ord)i(record.)0 2857 y(The)j(format)h(of)f(the)h(ASCI)s(I)e
 (template)i(\014le)g(is)f(describ)s(ed)f(in)i(the)f(follo)m(wing)i
-(sections.)0 3009 y
-SDict begin H.S end
- 0 3009 a 0 3009 a
-SDict begin 13.6 H.A end
- 0 3009 a 0 3009
-a
-SDict begin [/View [/XYZ H.V]/Dest (section.9.1) cvn /DEST pdfmark
-end
- 0 3009 a 179 x Fe(9.1)135 b(Detailed)47 b(T)-11 b(emplate)46
-b(Line)f(F)-11 b(ormat)0 3438 y Fj(The)30 b(format)h(of)f(eac)m(h)i
-(ASCI)s(I)c(template)k(line)f(closely)h(follo)m(ws)f(the)g(format)g(of)
-f(a)h(FITS)f(k)m(eyw)m(ord)g(record:)95 3682 y Ff(KEYWORD)46
-b(=)i(KEYVALUE)d(/)j(COMMENT)0 3926 y Fj(except)22 b(that)g(free)g
-(format)f(ma)m(y)h(b)s(e)f(used)f(\(e.g.,)25 b(the)d(equals)f(sign)h
-(ma)m(y)f(app)s(ear)g(at)h(an)m(y)g(p)s(osition)f(in)g(the)h(line\))g
-(and)0 4039 y(T)-8 b(AB)34 b(c)m(haracters)g(are)g(allo)m(w)m(ed)h(and)
-e(are)g(treated)h(the)g(same)f(as)h(space)f(c)m(haracters.)51
-b(The)33 b(KEYV)-10 b(ALUE)33 b(and)0 4152 y(COMMENT)d(\014elds)g(are)h
+(sections.)0 3188 y Fe(9.1)135 b(Detailed)47 b(T)-11
+b(emplate)46 b(Line)f(F)-11 b(ormat)0 3438 y Fj(The)30
+b(format)h(of)f(eac)m(h)i(ASCI)s(I)c(template)k(line)f(closely)h(follo)
+m(ws)f(the)g(format)g(of)f(a)h(FITS)f(k)m(eyw)m(ord)g(record:)95
+3682 y Ff(KEYWORD)46 b(=)i(KEYVALUE)d(/)j(COMMENT)0 3926
+y Fj(except)22 b(that)g(free)g(format)f(ma)m(y)h(b)s(e)f(used)f
+(\(e.g.,)25 b(the)d(equals)f(sign)h(ma)m(y)f(app)s(ear)g(at)h(an)m(y)g
+(p)s(osition)f(in)g(the)h(line\))g(and)0 4039 y(T)-8
+b(AB)34 b(c)m(haracters)g(are)g(allo)m(w)m(ed)h(and)e(are)g(treated)h
+(the)g(same)f(as)h(space)f(c)m(haracters.)51 b(The)33
+b(KEYV)-10 b(ALUE)33 b(and)0 4152 y(COMMENT)d(\014elds)g(are)h
 (optional.)43 b(The)30 b(equals)h(sign)f(c)m(haracter)j(is)d(also)i
 (optional,)g(but)e(it)h(is)f(recommended)0 4264 y(that)42
 b(it)f(b)s(e)g(included)f(for)h(clarit)m(y)-8 b(.)75
 b(An)m(y)41 b(template)i(line)e(that)h(b)s(egins)f(with)f(the)i(p)s
 (ound)d('#')i(c)m(haracter)i(is)0 4377 y(ignored)30 b(b)m(y)h(the)f
 (template)i(parser)e(and)g(ma)m(y)h(b)s(e)e(use)h(to)h(insert)g(commen)
 m(ts)g(in)m(to)g(the)g(template)h(\014le)e(itself.)0
@@ -15814,36 +12688,24 @@
 5375 y(real,)28 b(complex)g(in)m(teger,)h(or)d(complex)i(real.)40
 b(In)m(teger)28 b(v)-5 b(alues)27 b(m)m(ust)f(b)s(e)g(within)g(the)h
 (allo)m(w)m(ed)i(range)e(of)g(a)g('signed)0 5488 y(long')h(v)-5
 b(ariable;)29 b(some)f(C)e(compilers)i(only)f(suppp)s(ort)e(4-b)m(yte)j
 (long)g(in)m(tegers)g(with)f(a)g(range)h(from)e(-2147483648)0
 5601 y(to)31 b(+2147483647,)k(whereas)30 b(other)h(C)f(compilers)h
 (supp)s(ort)e(8-b)m(yte)j(in)m(tegers)f(with)f(a)h(range)g(of)g(plus)e
-(or)i(min)m(us)0 5714 y(2**63.)1882 5942 y(111)p eop
+(or)i(min)m(us)0 5714 y(2**63.)1882 5942 y(113)p eop
 end
-%%Page: 112 118
-TeXDict begin 112 117 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.112) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(112)2295
-b Fh(CHAPTER)30 b(9.)71 b(TEMPLA)-8 b(TE)30 b(FILES)0
-555 y Fj(The)23 b(c)m(haracter)h(string)f(v)-5 b(alues)24
-b(need)f(not)g(b)s(e)g(enclosed)g(in)g(single)h(quote)g(c)m(haracters)g
-(unless)f(they)g(are)h(necessary)0 668 y(to)37 b(distinguish)e(the)i
-(string)f(from)f(a)i(di\013eren)m(t)g(data)f(t)m(yp)s(e)h(\(e.g.)59
-b(2.0)38 b(is)e(a)g(real)h(but)f('2.0')h(is)f(a)h(string\).)58
+%%Page: 114 120
+TeXDict begin 114 119 bop 0 299 a Fj(114)2295 b Fh(CHAPTER)30
+b(9.)71 b(TEMPLA)-8 b(TE)30 b(FILES)0 555 y Fj(The)23
+b(c)m(haracter)h(string)f(v)-5 b(alues)24 b(need)f(not)g(b)s(e)g
+(enclosed)g(in)g(single)h(quote)g(c)m(haracters)g(unless)f(they)g(are)h
+(necessary)0 668 y(to)37 b(distinguish)e(the)i(string)f(from)f(a)i
+(di\013eren)m(t)g(data)f(t)m(yp)s(e)h(\(e.g.)59 b(2.0)38
+b(is)e(a)g(real)h(but)f('2.0')h(is)f(a)h(string\).)58
 b(The)0 781 y(k)m(eyw)m(ord)38 b(has)g(an)g(unde\014ned)d(\(n)m(ull\))k
 (v)-5 b(alue)38 b(if)g(the)g(template)h(record)f(only)g(con)m(tains)h
 (blanks)e(follo)m(wing)j(the)0 894 y("=")31 b(or)f(b)s(et)m(w)m(een)h
 (the)g("=")g(and)f(the)g("/")i(commen)m(t)f(\014eld)f(delimiter.)0
 1054 y(String)c(k)m(eyw)m(ord)h(v)-5 b(alues)27 b(longer)g(than)f(68)h
 (c)m(haracters)h(\(the)f(maxim)m(um)f(length)h(that)g(will)g(\014t)f
 (in)g(a)h(single)g(FITS)0 1167 y(k)m(eyw)m(ord)41 b(record\))g(are)g(p)
@@ -15877,23 +12739,15 @@
 (Primary)e(HDU)i(is)g(created,)h(and)d(the)i(template)h(is)e(then)g
 (assumed)f(to)i(de\014ne)f(the)h(k)m(eyw)m(ords)f(starting)0
 3305 y(with)h(the)h(\014rst)e(extension)i(follo)m(wing)h(the)f(Primary)
 f(HDU.)0 3466 y(2\))35 b(XTENSION)e(marks)g(the)i(b)s(eginning)e(of)h
 (a)h(new)e(extension)i(HDU)f(de\014nition.)52 b(The)33
 b(previous)h(HDU)h(will)0 3578 y(b)s(e)30 b(closed)h(at)g(this)f(p)s
 (oin)m(t)h(and)e(pro)s(cessing)i(of)f(the)h(next)f(extension)h(b)s
-(egins.)0 3739 y
-SDict begin H.S end
- 0 3739 a 0 3739 a
-SDict begin 13.6 H.A end
- 0 3739 a 0 3739 a
-SDict begin [/View [/XYZ H.V]/Dest (section.9.2) cvn /DEST pdfmark
-end
-
-0 3739 a 179 x Fe(9.2)135 b(Auto-indexing)45 b(of)h(Keyw)l(ords)0
+(egins.)0 3918 y Fe(9.2)135 b(Auto-indexing)45 b(of)h(Keyw)l(ords)0
 4169 y Fj(If)31 b(a)h(template)g(k)m(eyw)m(ord)g(name)f(ends)g(with)g
 (a)g("#")h(c)m(haracter,)i(it)e(is)f(said)g(to)h(b)s(e)f
 ('auto-indexed'.)44 b(Eac)m(h)32 b("#")0 4282 y(c)m(haracter)i(will)f
 (b)s(e)f(replaced)i(b)m(y)e(the)h(curren)m(t)g(in)m(teger)h(index)e(v)
 -5 b(alue,)34 b(whic)m(h)f(gets)g(reset)h(=)e(1)h(at)h(the)e(start)i
 (of)0 4395 y(eac)m(h)h(new)f(HDU)g(in)g(the)g(\014le)g(\(or)g(7)h(in)e
 (the)h(sp)s(ecial)h(case)g(of)f(a)g(GR)m(OUP)h(de\014nition\).)51
@@ -15907,42 +12761,22 @@
 (the)g(TTYPE)e(k)m(eyw)m(ord)i(is)g(the)g(incremen)m(tor)g(in)0
 4846 y(b)s(oth)i(cases:)95 5111 y Ff(TTYPE#)47 b(=)g(TIME)95
 5224 y(TFORM#)g(=)g(1D)95 5337 y(TTYPE#)g(=)g(RATE)95
 5449 y(TFORM#)g(=)g(1E)0 5714 y Fj(will)26 b(create)i(TTYPE1,)e(TF)m
 (ORM1,)i(TTYPE2,)f(and)e(TF)m(ORM2)i(k)m(eyw)m(ords.)40
 b(But)26 b(if)g(the)g(template)h(lo)s(oks)f(lik)m(e,)p
 eop end
-%%Page: 113 119
-TeXDict begin 113 118 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.113) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(9.3.)72
-b(TEMPLA)-8 b(TE)30 b(P)-8 b(ARSER)30 b(DIRECTIVES)2028
-b Fj(113)95 555 y Ff(TTYPE#)47 b(=)g(TIME)95 668 y(TTYPE#)g(=)g(RATE)95
+%%Page: 115 121
+TeXDict begin 115 120 bop 0 299 a Fh(9.3.)72 b(TEMPLA)-8
+b(TE)30 b(P)-8 b(ARSER)30 b(DIRECTIVES)2028 b Fj(115)95
+555 y Ff(TTYPE#)47 b(=)g(TIME)95 668 y(TTYPE#)g(=)g(RATE)95
 781 y(TFORM#)g(=)g(1D)95 894 y(TFORM#)g(=)g(1E)0 1202
 y Fj(this)31 b(results)f(in)h(a)g(FITS)f(\014les)h(with)f(TTYPE1,)h
 (TTYPE2,)g(TF)m(ORM2,)h(and)e(TF)m(ORM2,)i(whic)m(h)f(is)g(probably)0
-1315 y(not)g(what)f(w)m(as)h(in)m(tended!)0 1509 y
-SDict begin H.S end
- 0
-1509 a 0 1509 a
-SDict begin 13.6 H.A end
- 0 1509 a 0 1509 a
-SDict begin [/View [/XYZ H.V]/Dest (section.9.3) cvn /DEST pdfmark
-end
- 0 1509 a 197 x Fe(9.3)135
+1315 y(not)g(what)f(w)m(as)h(in)m(tended!)0 1706 y Fe(9.3)135
 b(T)-11 b(emplate)46 b(P)l(arser)g(Directiv)l(es)0 1968
 y Fj(In)29 b(addition)i(to)f(the)g(template)i(lines)e(whic)m(h)g
 (de\014ne)f(individual)h(k)m(eyw)m(ords,)g(the)g(template)i(parser)d
 (recognizes)0 2081 y(3)h(sp)s(ecial)h(directiv)m(es)g(whic)m(h)f(are)g
 (eac)m(h)h(preceded)f(b)m(y)f(the)h(bac)m(kslash)h(c)m(haracter:)90
 b Ff(\\include,)45 b(\\group)p Fj(,)29 b(and)48 2194
 y Ff(\\end)p Fj(.)0 2354 y(The)37 b('include')h(directiv)m(e)i(m)m(ust)
@@ -15978,37 +12812,17 @@
 b(columns)f(in)f(a)i(GR)m(OUP)f(HDU)h(using)f(TF)m(ORMn)f(and)h(TTYPEn)
 f(\(where)g(n)h(is)g(7,)i(8,)h(....\))39 b(k)m(eyw)m(ords)0
 5441 y(or)30 b(their)h(auto-indexing)g(equiv)-5 b(alen)m(ts.)0
 5601 y(F)d(or)26 b(a)f(more)g(complicated)h(example)f(of)g(a)h
 (template)g(\014le)f(using)f(the)h(group)f(directiv)m(es,)k(lo)s(ok)d
 (at)g(the)g(sample.tpl)0 5714 y(\014le)30 b(that)h(is)g(included)e(in)i
 (the)f(CFITSIO)f(distribution.)p eop end
-%%Page: 114 120
-TeXDict begin 114 119 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.114) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(114)2295
-b Fh(CHAPTER)30 b(9.)71 b(TEMPLA)-8 b(TE)30 b(FILES)0
-464 y
-SDict begin H.S end
- 0 464 a 0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (section.9.4) cvn /DEST pdfmark
-end
- 0 464 a 91 x Fe(9.4)135
+%%Page: 116 122
+TeXDict begin 116 121 bop 0 299 a Fj(116)2295 b Fh(CHAPTER)30
+b(9.)71 b(TEMPLA)-8 b(TE)30 b(FILES)0 555 y Fe(9.4)135
 b(F)-11 b(ormal)46 b(T)-11 b(emplate)45 b(Syn)l(tax)0
 805 y Fj(The)30 b(template)i(syn)m(tax)f(can)f(formally)h(b)s(e)f
 (de\014ned)f(as)i(follo)m(ws:)191 1063 y Ff(TEMPLATE)45
 b(=)j(BLOCK)e([)i(BLOCK)e(...)h(])334 1289 y(BLOCK)f(=)i({)f(HDU)g(|)h
 (GROUP)e(})334 1515 y(GROUP)g(=)i(\\GROUP)e([)h(BLOCK)g(...)g(])g
 (\\END)430 1741 y(HDU)f(=)i(XTENSION)d([)j(LINE)f(...)f(])i({)f
 (XTENSION)f(|)h(\\GROUP)f(|)i(\\END)f(|)g(EOF)g(})382
@@ -16018,78 +12832,49 @@
 191 2418 y([)g(X)h(])238 b(-)48 b(X)f(is)g(optional)0
 2676 y Fj(A)m(t)34 b(the)f(topmost)g(lev)m(el,)i(the)e(template)i
 (de\014nes)c(1)j(or)e(more)h(template)h(blo)s(c)m(ks.)49
 b(Blo)s(c)m(ks)34 b(can)f(b)s(e)f(either)h(HDU)0 2789
 y(\(Header)27 b(Data)h(Unit\))g(or)e(a)h(GR)m(OUP)-8
 b(.)28 b(F)-8 b(or)27 b(eac)m(h)g(blo)s(c)m(k)g(the)g(parser)f(creates)
 i(1)f(\(or)g(more)f(for)h(GR)m(OUPs\))g(FITS)0 2902 y(\014le)j(HDUs.)0
-3039 y
-SDict begin H.S end
- 0 3039 a 0 3039 a
-SDict begin 13.6 H.A end
- 0 3039 a 0 3039 a
-SDict begin [/View [/XYZ H.V]/Dest (section.9.5) cvn /DEST pdfmark
-end
- 0 3039 a 196
-x Fe(9.5)135 b(Errors)0 3485 y Fj(In)24 b(general)h(the)f(\014ts)p
+3235 y Fe(9.5)135 b(Errors)0 3485 y Fj(In)24 b(general)h(the)f(\014ts)p
 692 3485 28 4 v 33 w(execute)p 1019 3485 V 34 w(template\(\))i
 (function)e(tries)h(to)g(b)s(e)f(as)g(atomic)i(as)f(p)s(ossible,)g(so)f
 (either)h(ev)m(erything)0 3598 y(is)f(done)g(or)g(nothing)f(is)h(done.)
 39 b(If)23 b(an)h(error)f(o)s(ccurs)h(during)f(parsing)g(of)h(the)g
 (template,)j(\014ts)p 3125 3598 V 33 w(execute)p 3452
 3598 V 34 w(template\(\))0 3711 y(will)k(\(try)g(to\))h(delete)g(the)f
 (top)g(lev)m(el)h(BLOCK)e(\(with)h(all)g(its)h(c)m(hildren)e(if)h(an)m
 (y\))g(in)g(whic)m(h)f(the)h(error)f(o)s(ccurred,)0 3824
 y(then)g(it)h(will)g(stop)f(reading)h(the)f(template)i(\014le)e(and)g
-(it)h(will)g(return)e(with)h(an)g(error.)0 3979 y
-SDict begin H.S end
- 0 3979
-a 0 3979 a
-SDict begin 13.6 H.A end
- 0 3979 a 0 3979 a
-SDict begin [/View [/XYZ H.V]/Dest (section.9.6) cvn /DEST pdfmark
-end
- 0 3979 a 179 x Fe(9.6)135
+(it)h(will)g(return)e(with)h(an)g(error.)0 4158 y Fe(9.6)135
 b(Examples)0 4408 y Fj(1.)54 b(This)34 b(template)i(\014le)f(will)g
 (create)h(a)f(200)h(x)e(300)i(pixel)f(image,)j(with)c(4-b)m(yte)i(in)m
 (teger)g(pixel)f(v)-5 b(alues,)36 b(in)f(the)0 4521 y(primary)29
 b(HDU:)95 4779 y Ff(SIMPLE)47 b(=)g(T)95 4891 y(BITPIX)g(=)g(32)95
 5004 y(NAXIS)g(=)g(2)239 b(/)47 b(number)f(of)h(dimensions)95
 5117 y(NAXIS1)g(=)g(100)95 b(/)47 b(length)f(of)h(first)g(axis)95
 5230 y(NAXIS2)g(=)g(200)95 b(/)47 b(length)f(of)h(second)f(axis)95
 5343 y(OBJECT)h(=)g(NGC)g(253)g(/)g(name)g(of)g(observed)f(object)0
 5601 y Fj(The)35 b(allo)m(w)m(ed)i(v)-5 b(alues)36 b(of)f(BITPIX)g(are)
 h(8,)h(16,)h(32,)g(-32,)g(or)d(-64,)j(represen)m(ting,)f(resp)s(ectiv)m
 (ely)-8 b(,)39 b(8-bit)d(in)m(teger,)0 5714 y(16-bit)c(in)m(teger,)g
 (32-bit)f(in)m(teger,)h(32-bit)g(\015oating)f(p)s(oin)m(t,)g(or)f(64)h
 (bit)g(\015oating)g(p)s(oin)m(t)f(pixels.)p eop end
-%%Page: 115 121
-TeXDict begin 115 120 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.115) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fh(9.6.)72
-b(EXAMPLES)3039 b Fj(115)0 555 y(2.)39 b(T)-8 b(o)23
-b(create)h(a)f(FITS)e(table,)26 b(the)c(template)i(\014rst)e(needs)g
-(to)i(include)e(XTENSION)g(=)g(T)-8 b(ABLE)23 b(or)f(BINT)-8
-b(ABLE)0 668 y(to)31 b(de\014ne)e(whether)g(it)h(is)g(an)f(ASCI)s(I)g
-(or)g(binary)g(table,)i(and)f(NAXIS2)g(to)g(de\014ne)f(the)h(n)m(um)m
-(b)s(er)f(of)h(ro)m(ws)f(in)h(the)0 781 y(table.)50 b(Tw)m(o)34
-b(template)g(lines)g(are)g(then)f(needed)f(to)i(de\014ne)f(the)g(name)h
-(\(TTYPEn\))e(and)h(FITS)g(data)h(format)0 894 y(\(TF)m(ORMn\))d(of)f
-(the)h(columns,)f(as)h(in)f(this)g(example:)95 1154 y
-Ff(xtension)46 b(=)h(bintable)95 1267 y(naxis2)g(=)g(40)95
+%%Page: 117 123
+TeXDict begin 117 122 bop 0 299 a Fh(9.6.)72 b(EXAMPLES)3039
+b Fj(117)0 555 y(2.)39 b(T)-8 b(o)23 b(create)h(a)f(FITS)e(table,)26
+b(the)c(template)i(\014rst)e(needs)g(to)i(include)e(XTENSION)g(=)g(T)-8
+b(ABLE)23 b(or)f(BINT)-8 b(ABLE)0 668 y(to)31 b(de\014ne)e(whether)g
+(it)h(is)g(an)f(ASCI)s(I)g(or)g(binary)g(table,)i(and)f(NAXIS2)g(to)g
+(de\014ne)f(the)h(n)m(um)m(b)s(er)f(of)h(ro)m(ws)f(in)h(the)0
+781 y(table.)50 b(Tw)m(o)34 b(template)g(lines)g(are)g(then)f(needed)f
+(to)i(de\014ne)f(the)g(name)h(\(TTYPEn\))e(and)h(FITS)g(data)h(format)0
+894 y(\(TF)m(ORMn\))d(of)f(the)h(columns,)f(as)h(in)f(this)g(example:)
+95 1154 y Ff(xtension)46 b(=)h(bintable)95 1267 y(naxis2)g(=)g(40)95
 1380 y(ttype#)g(=)g(Name)95 1492 y(tform#)g(=)g(10a)95
 1605 y(ttype#)g(=)g(Npoints)95 1718 y(tform#)g(=)g(j)95
 1831 y(ttype#)g(=)g(Rate)95 1944 y(tunit#)g(=)g(counts/s)95
 2057 y(tform#)g(=)g(e)0 2317 y Fj(The)26 b(ab)s(o)m(v)m(e)j(example)e
 (de\014nes)f(a)i(n)m(ull)f(primary)f(arra)m(y)h(follo)m(w)m(ed)i(b)m(y)
 e(a)g(40-ro)m(w)h(binary)e(table)i(extension)g(with)f(3)0
 2430 y(columns)h(called)h('Name',)h('Np)s(oin)m(ts',)f(and)f('Rate',)i
@@ -16104,421 +12889,219 @@
 (ords)g(in)0 2881 y(the)d(template.)55 b(This)34 b(example)i(also)g
 (illustrates)f(that)h(the)f(templates)h(are)f(generally)h
 (case-insensitiv)m(e)h(\(the)0 2994 y(k)m(eyw)m(ord)29
 b(names)g(and)g(TF)m(ORMn)f(v)-5 b(alues)30 b(are)f(con)m(v)m(erted)i
 (to)e(upp)s(er-case)g(in)f(the)h(FITS)g(\014le\))g(and)f(that)i(string)
 0 3107 y(k)m(eyw)m(ord)h(v)-5 b(alues)31 b(generally)g(do)f(not)h(need)
 f(to)h(b)s(e)f(enclosed)h(in)f(quotes.)p eop end
-%%Page: 116 122
-TeXDict begin 116 121 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.116) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(116)2295
-b Fh(CHAPTER)30 b(9.)71 b(TEMPLA)-8 b(TE)30 b(FILES)p
-eop end
-%%Page: 117 123
-TeXDict begin 117 122 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.117) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a
-0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.10) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(10)0
+%%Page: 118 124
+TeXDict begin 118 123 bop 0 299 a Fj(118)2295 b Fh(CHAPTER)30
+b(9.)71 b(TEMPLA)-8 b(TE)30 b(FILES)p eop end
+%%Page: 119 125
+TeXDict begin 119 124 bop 0 1225 a Fg(Chapter)65 b(10)0
 1687 y Fm(Summary)76 b(of)i(all)f(FITSIO)0 1937 y(User-In)-6
 b(terface)77 b(Subroutines)0 2429 y Fj(Error)29 b(Status)i(Routines)f
-(page)1120 2429 y
-SDict begin H.S end
- 1120 2429 a Fj(29)1211 2370 y
-SDict begin H.R end
- 1211
-2370 a 1211 2429 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.5.1) cvn H.B /ANN pdfmark end
- 1211 2429 a 382 2696 a Ff(FTVERS\()46
-b(>)h(version\))382 2809 y(FTGERR\(status,)d(>)j(errtext\))382
-2922 y(FTGMSG\()f(>)h(errmsg\))382 3035 y(FTRPRT)f(\(stream,)f(>)j
-(status\))382 3147 y(FTPMSG\(errmsg\))382 3260 y(FTPMRK)382
-3373 y(FTCMSG)382 3486 y(FTCMRK)0 3753 y Fj(FITS)30 b(File)h(Op)s(en)e
-(and)h(Close)h(Subroutines:)39 b(page)1832 3753 y
-SDict begin H.S end
- 1832
-3753 a Fj(35)1923 3695 y
-SDict begin H.R end
- 1923 3695 a 1923 3753 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.1) cvn H.B /ANN pdfmark end
- 1923
-3753 a 382 4020 a Ff(FTOPEN\(unit,filename,rwm)o(ode)o(,)j(>)47
-b(blocksize,status\))382 4133 y(FTDKOPN\(unit,filename,rw)o(mod)o(e,)42
-b(>)47 b(blocksize,status\))382 4246 y(FTNOPN\(unit,filename,rwm)o(ode)
-o(,)42 b(>)47 b(status\))382 4359 y(FTDOPN\(unit,filename,rwm)o(ode)o
-(,)42 b(>)47 b(status\))382 4472 y(FTTOPN\(unit,filename,rwm)o(ode)o(,)
-42 b(>)47 b(status\))382 4585 y(FTIOPN\(unit,filename,rwm)o(ode)o(,)42
+(page)h(29)382 2696 y Ff(FTVERS\()46 b(>)h(version\))382
+2809 y(FTGERR\(status,)d(>)j(errtext\))382 2922 y(FTGMSG\()f(>)h
+(errmsg\))382 3035 y(FTRPRT)f(\(stream,)f(>)j(status\))382
+3147 y(FTPMSG\(errmsg\))382 3260 y(FTPMRK)382 3373 y(FTCMSG)382
+3486 y(FTCMRK)0 3753 y Fj(FITS)30 b(File)h(Op)s(en)e(and)h(Close)h
+(Subroutines:)39 b(page)31 b(35)382 4020 y Ff
+(FTOPEN\(unit,filename,rwm)o(ode)o(,)42 b(>)47 b(blocksize,status\))382
+4133 y(FTDKOPN\(unit,filename,rw)o(mod)o(e,)42 b(>)47
+b(blocksize,status\))382 4246 y(FTNOPN\(unit,filename,rwm)o(ode)o(,)42
+b(>)47 b(status\))382 4359 y(FTDOPN\(unit,filename,rwm)o(ode)o(,)42
+b(>)47 b(status\))382 4472 y(FTTOPN\(unit,filename,rwm)o(ode)o(,)42
+b(>)47 b(status\))382 4585 y(FTIOPN\(unit,filename,rwm)o(ode)o(,)42
 b(>)47 b(status\))382 4698 y(FTREOPEN\(unit,)d(>)j(newunit,)f(status\))
 382 4811 y(FTINIT\(unit,filename,blo)o(cks)o(ize,)41
 b(>)48 b(status\))382 4924 y(FTDKINIT\(unit,filename,b)o(loc)o(ksiz)o
 (e,)42 b(>)47 b(status\))382 5036 y(FTTPLT\(unit,)d(filename,)i
 (tplfilename,)e(>)j(status\))382 5149 y(FTFLUS\(unit,)d(>)k(status\))
 382 5262 y(FTCLOS\(unit,)c(>)k(status\))382 5375 y(FTDELT\(unit,)c(>)k
 (status\))382 5488 y(FTGIOU\()e(>)h(iounit,)f(status\))382
 5601 y(FTFIOU\(iounit,)e(>)j(status\))0 5714 y(CFITS2Unit\(fitsfile)c
-(*ptr\))141 b(\(C)48 b(routine\))1882 5942 y Fj(117)p
+(*ptr\))141 b(\(C)48 b(routine\))1882 5942 y Fj(119)p
 eop end
-%%Page: 118 124
-TeXDict begin 118 123 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.118) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(118)281
-b Fh(CHAPTER)30 b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f
-(USER-INTERF)-10 b(A)m(CE)30 b(SUBR)m(OUTINES)382 555
-y Ff(CUnit2FITS\(int)44 b(unit\))380 b(\(C)47 b(routine\))382
-668 y(FTEXTN\(filename,)c(>)48 b(nhdu,)e(status\))382
-781 y(FTFLNM\(unit,)e(>)k(filename,)d(status\))382 894
-y(FTFLMD\(unit,)f(>)k(iomode,)e(status\))382 1007 y(FTURLT\(unit,)e(>)k
-(urltype,)d(status\))382 1120 y(FTIURL\(filename,)e(>)48
-b(filetype,)d(infile,)h(outfile,)f(extspec,)h(filter,)716
-1233 y(binspec,)f(colspec,)h(status\))382 1346 y(FTRTNM\(filename,)d(>)
-48 b(rootname,)d(status\))382 1458 y(FTEXIST\(filename,)e(>)k(exist,)f
-(status\))0 1695 y Fj(HDU-Lev)m(el)33 b(Op)s(erations:)40
-b(page)1190 1695 y
-SDict begin H.S end
- 1190 1695 a Fj(38)1281 1637 y
-SDict begin H.R end
- 1281
-1637 a 1281 1695 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.2) cvn H.B /ANN pdfmark end
- 1281 1695 a 382 1932 a Ff(FTMAHD\(unit,nhdu,)j(>)k
-(hdutype,status\))382 2045 y(FTMRHD\(unit,nmove,)c(>)k
-(hdutype,status\))382 2158 y(FTGHDN\(unit,)d(>)k(nhdu\))382
-2271 y(FTMNHD\(unit,)c(hdutype,)i(extname,)f(extver,)h(>)i(status\))382
-2384 y(FTGHDT\(unit,)c(>)k(hdutype,)d(status\))382 2497
-y(FTTHDU\(unit,)f(>)k(hdunum,)e(status\))382 2610 y(FTCRHD\(unit,)e(>)k
-(status\))382 2723 y(FTIIMG\(unit,bitpix,naxis)o(,na)o(xes,)41
-b(>)48 b(status\))382 2836 y(FTITAB\(unit,rowlen,nrows)o(,tf)o(ield)o
-(s,tt)o(ype)o(,tbc)o(ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42
-b(>)716 2949 y(status\))382 3061 y(FTIBIN\(unit,nrows,tfield)o(s,t)o
-(type)o(,tfo)o(rm,)o(tuni)o(t,ex)o(tna)o(me,v)o(arid)o(at)f(>)48
+%%Page: 120 126
+TeXDict begin 120 125 bop 0 299 a Fj(120)281 b Fh(CHAPTER)30
+b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f(USER-INTERF)-10
+b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(CUnit2FITS\(int)44
+b(unit\))380 b(\(C)47 b(routine\))382 668 y(FTEXTN\(filename,)c(>)48
+b(nhdu,)e(status\))382 781 y(FTFLNM\(unit,)e(>)k(filename,)d(status\))
+382 894 y(FTFLMD\(unit,)f(>)k(iomode,)e(status\))382
+1007 y(FTURLT\(unit,)e(>)k(urltype,)d(status\))382 1120
+y(FTIURL\(filename,)e(>)48 b(filetype,)d(infile,)h(outfile,)f(extspec,)
+h(filter,)716 1233 y(binspec,)f(colspec,)h(status\))382
+1346 y(FTRTNM\(filename,)d(>)48 b(rootname,)d(status\))382
+1458 y(FTEXIST\(filename,)e(>)k(exist,)f(status\))0 1695
+y Fj(HDU-Lev)m(el)33 b(Op)s(erations:)40 b(page)31 b(38)382
+1932 y Ff(FTMAHD\(unit,nhdu,)43 b(>)k(hdutype,status\))382
+2045 y(FTMRHD\(unit,nmove,)c(>)k(hdutype,status\))382
+2158 y(FTGHDN\(unit,)d(>)k(nhdu\))382 2271 y(FTMNHD\(unit,)c(hdutype,)i
+(extname,)f(extver,)h(>)i(status\))382 2384 y(FTGHDT\(unit,)c(>)k
+(hdutype,)d(status\))382 2497 y(FTTHDU\(unit,)f(>)k(hdunum,)e(status\))
+382 2610 y(FTCRHD\(unit,)e(>)k(status\))382 2723 y
+(FTIIMG\(unit,bitpix,naxis)o(,na)o(xes,)41 b(>)48 b(status\))382
+2836 y(FTITAB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o(ype)o(,tbc)o
+(ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42 b(>)716
+2949 y(status\))382 3061 y(FTIBIN\(unit,nrows,tfield)o(s,t)o(type)o
+(,tfo)o(rm,)o(tuni)o(t,ex)o(tna)o(me,v)o(arid)o(at)f(>)48
 b(status\))382 3174 y(FTRSIM\(unit,bitpix,naxis)o(,na)o(xes,)o(stat)o
 (us\))382 3287 y(FTDHDU\(unit,)c(>)k(hdutype,status\))382
 3400 y(FTCPFL\(iunit,ounit,previ)o(ous)o(,)42 b(current,)j(following,)g
 (>)j(status\))382 3513 y(FTCOPY\(iunit,ounit,morek)o(eys)o(,)42
 b(>)47 b(status\))382 3626 y(FTCPHD\(inunit,)d(outunit,)h(>)j(status\))
 382 3739 y(FTCPDT\(iunit,ounit,)42 b(>)48 b(status\))0
 3976 y Fj(Subroutines)29 b(to)i(sp)s(ecify)f(or)g(mo)s(dify)g(the)g
-(structure)g(of)h(the)f(CHDU:)h(page)2676 3976 y
-SDict begin H.S end
- 2676
-3976 a Fj(41)2766 3917 y
-SDict begin H.R end
- 2766 3917 a 2766 3976 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.3) cvn H.B /ANN pdfmark end
- 2766
-3976 a 382 4213 a Ff(FTRDEF\(unit,)44 b(>)k(status\))93
-b(\(DEPRECATED\))382 4326 y(FTPDEF\(unit,bitpix,naxis)o(,na)o(xes,)o
-(pcou)o(nt,)o(gcou)o(nt,)41 b(>)48 b(status\))93 b(\(DEPRECATED\))382
-4439 y(FTADEF\(unit,rowlen,tfiel)o(ds,)o(tbco)o(l,tf)o(orm)o(,nro)o(ws)
-42 b(>)47 b(status\))94 b(\(DEPRECATED\))382 4551 y
+(structure)g(of)h(the)f(CHDU:)h(page)h(41)382 4213 y
+Ff(FTRDEF\(unit,)44 b(>)k(status\))93 b(\(DEPRECATED\))382
+4326 y(FTPDEF\(unit,bitpix,naxis)o(,na)o(xes,)o(pcou)o(nt,)o(gcou)o
+(nt,)41 b(>)48 b(status\))93 b(\(DEPRECATED\))382 4439
+y(FTADEF\(unit,rowlen,tfiel)o(ds,)o(tbco)o(l,tf)o(orm)o(,nro)o(ws)42
+b(>)47 b(status\))94 b(\(DEPRECATED\))382 4551 y
 (FTBDEF\(unit,tfields,tfor)o(m,v)o(arid)o(at,n)o(row)o(s)42
 b(>)47 b(status\))94 b(\(DEPRECATED\))382 4664 y(FTDDEF\(unit,bytlen,)
 42 b(>)48 b(status\))93 b(\(DEPRECATED\))382 4777 y
 (FTPTHP\(unit,theap,)43 b(>)k(status\))0 5014 y Fj(Header)31
-b(Space)f(and)g(P)m(osition)i(Subroutines:)39 b(page)1846
-5014 y
-SDict begin H.S end
- 1846 5014 a Fj(43)1937 4956 y
-SDict begin H.R end
- 1937 4956 a 1937
-5014 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.1) cvn H.B /ANN pdfmark end
- 1937 5014 a 382 5251 a Ff(FTHDEF\(unit,morekeys,)j(>)47
-b(status\))382 5364 y(FTGHSP\(iunit,)d(>)j(keysexist,keysadd,status\))
-382 5477 y(FTGHPS\(iunit,)d(>)j(keysexist,key_no,status\))0
+b(Space)f(and)g(P)m(osition)i(Subroutines:)39 b(page)31
+b(43)382 5251 y Ff(FTHDEF\(unit,morekeys,)42 b(>)47 b(status\))382
+5364 y(FTGHSP\(iunit,)d(>)j(keysexist,keysadd,status\))382
+5477 y(FTGHPS\(iunit,)d(>)j(keysexist,key_no,status\))0
 5714 y Fj(Read)31 b(or)f(W)-8 b(rite)32 b(Standard)d(Header)i
-(Subroutines:)39 b(page)2051 5714 y
-SDict begin H.S end
- 2051 5714 a Fj(43)2142
-5655 y
-SDict begin H.R end
- 2142 5655 a 2142 5714 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.2) cvn H.B /ANN pdfmark end
- 2142 5714 a eop end
-%%Page: 119 125
-TeXDict begin 119 124 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.119) cvn /DEST pdfmark end
- -8 191 a 3764 299 a Fj(119)382
-555 y Ff(FTPHPS\(unit,bitpix,naxis)o(,na)o(xes,)41 b(>)48
-b(status\))382 668 y(FTPHPR\(unit,simple,bitpi)o(x,n)o(axis)o(,nax)o
-(es,)o(pcou)o(nt,g)o(cou)o(nt,e)o(xten)o(d,)41 b(>)48
-b(status\))382 781 y(FTGHPR\(unit,maxdim,)42 b(>)48 b
-(simple,bitpix,naxis,naxe)o(s,p)o(coun)o(t,gc)o(oun)o(t,ex)o(tend)o(,)
-716 894 y(status\))382 1007 y(FTPHTB\(unit,rowlen,nrows)o(,tf)o(ield)o
-(s,tt)o(ype)o(,tbc)o(ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42
-b(>)716 1120 y(status\))382 1233 y(FTGHTB\(unit,maxdim,)g(>)48
+(Subroutines:)39 b(page)31 b(43)p eop end
+%%Page: 121 127
+TeXDict begin 121 126 bop 3764 299 a Fj(121)382 555 y
+Ff(FTPHPS\(unit,bitpix,naxis)o(,na)o(xes,)41 b(>)48 b(status\))382
+668 y(FTPHPR\(unit,simple,bitpi)o(x,n)o(axis)o(,nax)o(es,)o(pcou)o
+(nt,g)o(cou)o(nt,e)o(xten)o(d,)41 b(>)48 b(status\))382
+781 y(FTGHPR\(unit,maxdim,)42 b(>)48 b(simple,bitpix,naxis,naxe)o(s,p)o
+(coun)o(t,gc)o(oun)o(t,ex)o(tend)o(,)716 894 y(status\))382
+1007 y(FTPHTB\(unit,rowlen,nrows)o(,tf)o(ield)o(s,tt)o(ype)o(,tbc)o
+(ol,t)o(for)o(m,tu)o(nit,)o(ext)o(name)o(,)42 b(>)716
+1120 y(status\))382 1233 y(FTGHTB\(unit,maxdim,)g(>)48
 b(rowlen,nrows,tfields,tty)o(pe,)o(tbco)o(l,tf)o(orm)o(,tun)o(it,)716
 1346 y(extname,status\))382 1458 y(FTPHBN\(unit,nrows,tfield)o(s,t)o
 (type)o(,tfo)o(rm,)o(tuni)o(t,ex)o(tna)o(me,v)o(arid)o(at)41
 b(>)48 b(status\))382 1571 y(FTGHBN\(unit,maxdim,)42
 b(>)48 b(nrows,tfields,ttype,tfor)o(m,t)o(unit)o(,ext)o(nam)o(e,va)o
 (rida)o(t,)716 1684 y(status\))0 1942 y Fj(W)-8 b(rite)32
-b(Keyw)m(ord)e(Subroutines:)39 b(page)1385 1942 y
-SDict begin H.S end
- 1385
-1942 a Fj(45)1476 1883 y
-SDict begin H.R end
- 1476 1883 a 1476 1942 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.3) cvn H.B /ANN pdfmark end
- 1476
-1942 a 382 2199 a Ff(FTPREC\(unit,card,)k(>)k(status\))382
-2312 y(FTPCOM\(unit,comment,)42 b(>)48 b(status\))382
-2425 y(FTPHIS\(unit,history,)42 b(>)48 b(status\))382
-2538 y(FTPDAT\(unit,)c(>)k(status\))382 2651 y
-(FTPKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o(men)o(t,)42
-b(>)47 b(status\))382 2764 y(FTPKY[EDFG]\(unit,keyword)o(,ke)o(yval)o
-(,dec)o(ima)o(ls,c)o(omme)o(nt,)41 b(>)48 b(status\))382
-2877 y(FTPKLS\(unit,keyword,keyv)o(al,)o(comm)o(ent,)41
-b(>)47 b(status\))382 2990 y(FTPLSW\(unit,)d(>)k(status\))382
-3103 y(FTPKYU\(unit,keyword,comm)o(ent)o(,)42 b(>)47
-b(status\))382 3216 y(FTPKN[JKLS]\(unit,keyroot)o(,st)o(artn)o(o,no)o
-(_ke)o(ys,k)o(eyva)o(ls,)o(comm)o(ents)o(,)42 b(>)47
-b(status\))382 3329 y(FTPKN[EDFG]\(unit,keyroot)o(,st)o(artn)o(o,no)o
-(_ke)o(ys,k)o(eyva)o(ls,)o(deci)o(mals)o(,co)o(mmen)o(ts,)41
+b(Keyw)m(ord)e(Subroutines:)39 b(page)31 b(45)382 2199
+y Ff(FTPREC\(unit,card,)43 b(>)k(status\))382 2312 y
+(FTPCOM\(unit,comment,)42 b(>)48 b(status\))382 2425
+y(FTPHIS\(unit,history,)42 b(>)48 b(status\))382 2538
+y(FTPDAT\(unit,)c(>)k(status\))382 2651 y(FTPKY[JKLS]\(unit,keyword)o
+(,ke)o(yval)o(,com)o(men)o(t,)42 b(>)47 b(status\))382
+2764 y(FTPKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o(ima)o(ls,c)o
+(omme)o(nt,)41 b(>)48 b(status\))382 2877 y(FTPKLS\(unit,keyword,keyv)o
+(al,)o(comm)o(ent,)41 b(>)47 b(status\))382 2990 y(FTPLSW\(unit,)d(>)k
+(status\))382 3103 y(FTPKYU\(unit,keyword,comm)o(ent)o(,)42
+b(>)47 b(status\))382 3216 y(FTPKN[JKLS]\(unit,keyroot)o(,st)o(artn)o
+(o,no)o(_ke)o(ys,k)o(eyva)o(ls,)o(comm)o(ents)o(,)42
+b(>)47 b(status\))382 3329 y(FTPKN[EDFG]\(unit,keyroot)o(,st)o(artn)o
+(o,no)o(_ke)o(ys,k)o(eyva)o(ls,)o(deci)o(mals)o(,co)o(mmen)o(ts,)41
 b(>)907 3441 y(status\))382 3554 y(FTCPKYinunit,)j(outunit,)i(innum,)g
 (outnum,)f(keyroot,)h(>)h(status\))382 3667 y
 (FTPKYT\(unit,keyword,intv)o(al,)o(dblv)o(al,c)o(omm)o(ent,)41
 b(>)48 b(status\))382 3780 y(FTPKTP\(unit,)c(filename,)i(>)h(status\))
 382 3893 y(FTPUNT\(unit,keyword,unit)o(s,)41 b(>)48 b(status\))0
-4151 y Fj(Insert)30 b(Keyw)m(ord)g(Subroutines:)39 b(page)1393
-4151 y
-SDict begin H.S end
- 1393 4151 a Fj(47)1484 4092 y
-SDict begin H.R end
- 1484 4092 a 1484
-4151 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.4) cvn H.B /ANN pdfmark end
- 1484 4151 a 382 4408 a Ff(FTIREC\(unit,key_no,card,)i(>)47
+4151 y Fj(Insert)30 b(Keyw)m(ord)g(Subroutines:)39 b(page)31
+b(47)382 4408 y Ff(FTIREC\(unit,key_no,card,)41 b(>)47
 b(status\))382 4521 y(FTIKY[JKLS]\(unit,keyword)o(,ke)o(yval)o(,com)o
 (men)o(t,)42 b(>)47 b(status\))382 4634 y(FTIKLS\(unit,keyword,keyv)o
 (al,)o(comm)o(ent,)41 b(>)47 b(status\))382 4747 y
 (FTIKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o(ima)o(ls,c)o(omme)o
 (nt,)41 b(>)48 b(status\))382 4860 y(FTIKYU\(unit,keyword,comm)o(ent)o
 (,)42 b(>)47 b(status\))0 5118 y Fj(Read)31 b(Keyw)m(ord)f
-(Subroutines:)39 b(page)1366 5118 y
-SDict begin H.S end
- 1366 5118 a Fj(47)1457
-5059 y
-SDict begin H.R end
- 1457 5059 a 1457 5118 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.5) cvn H.B /ANN pdfmark end
- 1457 5118 a 382 5375 a
-Ff(FTGREC\(unit,key_no,)j(>)48 b(card,status\))382 5488
-y(FTGKYN\(unit,key_no,)42 b(>)48 b(keyword,value,comment,st)o(atu)o
-(s\))382 5601 y(FTGCRD\(unit,keyword,)42 b(>)48 b(card,status\))382
+(Subroutines:)39 b(page)31 b(47)382 5375 y Ff(FTGREC\(unit,key_no,)42
+b(>)48 b(card,status\))382 5488 y(FTGKYN\(unit,key_no,)42
+b(>)48 b(keyword,value,comment,st)o(atu)o(s\))382 5601
+y(FTGCRD\(unit,keyword,)42 b(>)48 b(card,status\))382
 5714 y(FTGNXK\(unit,inclist,ninc)o(,ex)o(clis)o(t,ne)o(xc,)41
 b(>)48 b(card,status\))p eop end
-%%Page: 120 126
-TeXDict begin 120 125 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.120) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(120)281
-b Fh(CHAPTER)30 b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f
-(USER-INTERF)-10 b(A)m(CE)30 b(SUBR)m(OUTINES)382 555
-y Ff(FTGKEY\(unit,keyword,)42 b(>)48 b(value,comment,status\))382
-668 y(FTGKY[EDJKLS]\(unit,keywo)o(rd,)41 b(>)48 b
-(keyval,comment,status\))382 781 y(FTGKSL\(unit,keyword,)42
-b(>)48 b(length,status\))382 894 y(FTGSKY\(unit,keyword,firs)o(tch)o
-(ar,m)o(axch)o(ar,)o(>)42 b(keyval,length,comment,st)o(atus)o(\))382
-1007 y(FTGKN[EDJKLS]\(unit,keyro)o(ot,)o(star)o(tno,)o(max)o(_key)o(s,)
-g(>)47 b(keyvals,nfound,status\))382 1120 y(FTGKYT\(unit,keyword,)42
+%%Page: 122 128
+TeXDict begin 122 127 bop 0 299 a Fj(122)281 b Fh(CHAPTER)30
+b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f(USER-INTERF)-10
+b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTGKEY\(unit,keyword,)42
+b(>)48 b(value,comment,status\))382 668 y(FTGKY[EDJKLS]\(unit,keywo)o
+(rd,)41 b(>)48 b(keyval,comment,status\))382 781 y
+(FTGKSL\(unit,keyword,)42 b(>)48 b(length,status\))382
+894 y(FTGSKY\(unit,keyword,firs)o(tch)o(ar,m)o(axch)o(ar,)o(>)42
+b(keyval,length,comment,st)o(atus)o(\))382 1007 y
+(FTGKN[EDJKLS]\(unit,keyro)o(ot,)o(star)o(tno,)o(max)o(_key)o(s,)g(>)47
+b(keyvals,nfound,status\))382 1120 y(FTGKYT\(unit,keyword,)42
 b(>)48 b(intval,dblval,comment,s)o(tat)o(us\))382 1233
 y(FTGUNT\(unit,keyword,)42 b(>)48 b(units,status\))0
 1489 y Fj(Mo)s(dify)30 b(Keyw)m(ord)g(Subroutines:)39
-b(page)1445 1489 y
-SDict begin H.S end
- 1445 1489 a Fj(49)1536 1430 y
-SDict begin H.R end
- 1536
-1430 a 1536 1489 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.6) cvn H.B /ANN pdfmark end
- 1536 1489 a 382 1745 a Ff(FTMREC\(unit,key_no,card,)
-i(>)47 b(status\))382 1858 y(FTMCRD\(unit,keyword,card)o(,)42
+b(page)31 b(49)382 1745 y Ff(FTMREC\(unit,key_no,card,)41
+b(>)47 b(status\))382 1858 y(FTMCRD\(unit,keyword,card)o(,)42
 b(>)47 b(status\))382 1971 y(FTMNAM\(unit,oldkey,keywo)o(rd,)41
 b(>)48 b(status\))382 2084 y(FTMCOM\(unit,keyword,comm)o(ent)o(,)42
 b(>)47 b(status\))382 2197 y(FTMKY[JKLS]\(unit,keyword)o(,ke)o(yval)o
 (,com)o(men)o(t,)42 b(>)47 b(status\))382 2310 y
 (FTMKLS\(unit,keyword,keyv)o(al,)o(comm)o(ent,)41 b(>)47
 b(status\))382 2422 y(FTMKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o
 (ima)o(ls,c)o(omme)o(nt,)41 b(>)48 b(status\))382 2535
 y(FTMKYU\(unit,keyword,comm)o(ent)o(,)42 b(>)47 b(status\))0
 2792 y Fj(Up)s(date)30 b(Keyw)m(ord)g(Subroutines:)39
-b(page)1456 2792 y
-SDict begin H.S end
- 1456 2792 a Fj(50)1546 2733 y
-SDict begin H.R end
- 1546
-2733 a 1546 2792 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.7) cvn H.B /ANN pdfmark end
- 1546 2792 a 382 3048 a Ff(FTUCRD\(unit,keyword,card)
-o(,)j(>)47 b(status\))382 3161 y(FTUKY[JKLS]\(unit,keyword)o(,ke)o
-(yval)o(,com)o(men)o(t,)42 b(>)47 b(status\))382 3274
-y(FTUKLS\(unit,keyword,keyv)o(al,)o(comm)o(ent,)41 b(>)47
+b(page)32 b(50)382 3048 y Ff(FTUCRD\(unit,keyword,card)o(,)42
+b(>)47 b(status\))382 3161 y(FTUKY[JKLS]\(unit,keyword)o(,ke)o(yval)o
+(,com)o(men)o(t,)42 b(>)47 b(status\))382 3274 y
+(FTUKLS\(unit,keyword,keyv)o(al,)o(comm)o(ent,)41 b(>)47
 b(status\))382 3386 y(FTUKY[EDFG]\(unit,keyword)o(,ke)o(yval)o(,dec)o
 (ima)o(ls,c)o(omme)o(nt,)41 b(>)48 b(status\))382 3499
 y(FTUKYU\(unit,keyword,comm)o(ent)o(,)42 b(>)47 b(status\))0
-3756 y Fj(Delete)33 b(Keyw)m(ord)d(Subroutines:)39 b(page)1414
-3756 y
-SDict begin H.S end
- 1414 3756 a Fj(51)1505 3697 y
-SDict begin H.R end
- 1505 3697 a 1505
-3756 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.4.8) cvn H.B /ANN pdfmark end
- 1505 3756 a 382 4012 a Ff(FTDREC\(unit,key_no,)j(>)48
-b(status\))382 4125 y(FTDKEY\(unit,keyword,)42 b(>)48
-b(status\))0 4381 y Fj(De\014ne)31 b(Data)h(Scaling)f(P)m(arameters)g
-(and)f(Unde\014ned)f(Pixel)i(Flags:)42 b(page)2629 4381
-y
-SDict begin H.S end
- 2629 4381 a Fj(51)2720 4322 y
-SDict begin H.R end
- 2720 4322 a 2720 4381
-a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.5) cvn H.B /ANN pdfmark end
- 2720 4381 a 382 4637 a Ff(FTPSCL\(unit,bscale,bzero)o(,)g(>)47
-b(status\))382 4750 y(FTTSCL\(unit,colnum,tscal)o(,tz)o(ero,)41
-b(>)48 b(status\))382 4863 y(FTPNUL\(unit,blank,)43 b(>)k(status\))382
+3756 y Fj(Delete)33 b(Keyw)m(ord)d(Subroutines:)39 b(page)31
+b(51)382 4012 y Ff(FTDREC\(unit,key_no,)42 b(>)48 b(status\))382
+4125 y(FTDKEY\(unit,keyword,)42 b(>)48 b(status\))0 4381
+y Fj(De\014ne)31 b(Data)h(Scaling)f(P)m(arameters)g(and)f(Unde\014ned)f
+(Pixel)i(Flags:)42 b(page)31 b(51)382 4637 y Ff
+(FTPSCL\(unit,bscale,bzero)o(,)42 b(>)47 b(status\))382
+4750 y(FTTSCL\(unit,colnum,tscal)o(,tz)o(ero,)41 b(>)48
+b(status\))382 4863 y(FTPNUL\(unit,blank,)43 b(>)k(status\))382
 4976 y(FTSNUL\(unit,colnum,snull)41 b(>)47 b(status\))382
 5089 y(FTTNUL\(unit,colnum,tnull)41 b(>)47 b(status\))0
 5345 y Fj(FITS)30 b(Primary)f(Arra)m(y)i(or)f(IMA)m(GE)i(Extension)e
-(I/O)h(Subroutines:)39 b(page)2665 5345 y
-SDict begin H.S end
- 2665 5345 a
-Fj(52)2756 5286 y
-SDict begin H.R end
- 2756 5286 a 2756 5345 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.6) cvn H.B /ANN pdfmark end
- 2756 5345 a
-382 5601 a Ff(FTGIDT\(unit,)44 b(>)k(bitpix,status\))382
-5714 y(FTGIET\(unit,)c(>)k(bitpix,status\))p eop end
-%%Page: 121 127
-TeXDict begin 121 126 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.121) cvn /DEST pdfmark end
- -8 191 a 3764 299 a Fj(121)382
-555 y Ff(FTGIDM\(unit,)44 b(>)k(naxis,status\))382 668
-y(FTGISZ\(unit,)c(maxdim,)i(>)i(naxes,status\))382 781
-y(FTGIPR\(unit,)c(maxdim,)i(>)i(bitpix,naxis,naxes,stat)o(us\))382
-894 y(FTPPR[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o(eme)o(nts,)o
-(valu)o(es,)41 b(>)48 b(status\))382 1007 y(FTPPN[BIJKED]\(unit,group)o
-(,fp)o(ixel)o(,nel)o(eme)o(nts,)o(valu)o(es,)o(null)o(val)41
-b(>)48 b(status\))382 1120 y(FTPPRU\(unit,group,fpixel)o(,ne)o(leme)o
-(nts,)41 b(>)47 b(status\))382 1233 y(FTGPV[BIJKED]\(unit,group)o(,fp)o
-(ixel)o(,nel)o(eme)o(nts,)o(null)o(val)o(,)42 b(>)47
-b(values,anyf,status\))382 1346 y(FTGPF[BIJKED]\(unit,group)o(,fp)o
-(ixel)o(,nel)o(eme)o(nts,)41 b(>)48 b(values,flagvals,anyf,st)o(atu)o
-(s\))382 1458 y(FTPGP[BIJKED]\(unit,group)o(,fp)o(arm,)o(npar)o(m,v)o
-(alue)o(s,)42 b(>)47 b(status\))382 1571 y(FTGGP[BIJKED]\(unit,group)o
-(,fp)o(arm,)o(npar)o(m,)41 b(>)48 b(values,status\))382
-1684 y(FTP2D[BIJKED]\(unit,group)o(,di)o(m1,n)o(axis)o(1,n)o(axis)o
-(2,im)o(age)o(,)42 b(>)47 b(status\))382 1797 y
-(FTP3D[BIJKED]\(unit,group)o(,di)o(m1,d)o(im2,)o(nax)o(is1,)o(naxi)o
-(s2,)o(naxi)o(s3,c)o(ube)o(,)42 b(>)47 b(status\))382
-1910 y(FTG2D[BIJKED]\(unit,group)o(,nu)o(llva)o(l,di)o(m1,)o(naxi)o
-(s1,n)o(axi)o(s2,)41 b(>)48 b(image,anyf,status\))382
-2023 y(FTG3D[BIJKED]\(unit,group)o(,nu)o(llva)o(l,di)o(m1,)o(dim2)o
+(I/O)h(Subroutines:)39 b(page)31 b(52)382 5601 y Ff(FTGIDT\(unit,)44
+b(>)k(bitpix,status\))382 5714 y(FTGIET\(unit,)c(>)k(bitpix,status\))p
+eop end
+%%Page: 123 129
+TeXDict begin 123 128 bop 3764 299 a Fj(123)382 555 y
+Ff(FTGIDM\(unit,)44 b(>)k(naxis,status\))382 668 y(FTGISZ\(unit,)c
+(maxdim,)i(>)i(naxes,status\))382 781 y(FTGIPR\(unit,)c(maxdim,)i(>)i
+(bitpix,naxis,naxes,stat)o(us\))382 894 y(FTPPR[BIJKED]\(unit,group)o
+(,fp)o(ixel)o(,nel)o(eme)o(nts,)o(valu)o(es,)41 b(>)48
+b(status\))382 1007 y(FTPPN[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o
+(eme)o(nts,)o(valu)o(es,)o(null)o(val)41 b(>)48 b(status\))382
+1120 y(FTPPRU\(unit,group,fpixel)o(,ne)o(leme)o(nts,)41
+b(>)47 b(status\))382 1233 y(FTGPV[BIJKED]\(unit,group)o(,fp)o(ixel)o
+(,nel)o(eme)o(nts,)o(null)o(val)o(,)42 b(>)47 b(values,anyf,status\))
+382 1346 y(FTGPF[BIJKED]\(unit,group)o(,fp)o(ixel)o(,nel)o(eme)o(nts,)
+41 b(>)48 b(values,flagvals,anyf,st)o(atu)o(s\))382 1458
+y(FTPGP[BIJKED]\(unit,group)o(,fp)o(arm,)o(npar)o(m,v)o(alue)o(s,)42
+b(>)47 b(status\))382 1571 y(FTGGP[BIJKED]\(unit,group)o(,fp)o(arm,)o
+(npar)o(m,)41 b(>)48 b(values,status\))382 1684 y
+(FTP2D[BIJKED]\(unit,group)o(,di)o(m1,n)o(axis)o(1,n)o(axis)o(2,im)o
+(age)o(,)42 b(>)47 b(status\))382 1797 y(FTP3D[BIJKED]\(unit,group)o
+(,di)o(m1,d)o(im2,)o(nax)o(is1,)o(naxi)o(s2,)o(naxi)o(s3,c)o(ube)o(,)42
+b(>)47 b(status\))382 1910 y(FTG2D[BIJKED]\(unit,group)o(,nu)o(llva)o
+(l,di)o(m1,)o(naxi)o(s1,n)o(axi)o(s2,)41 b(>)48 b(image,anyf,status\))
+382 2023 y(FTG3D[BIJKED]\(unit,group)o(,nu)o(llva)o(l,di)o(m1,)o(dim2)o
 (,nax)o(is1)o(,nax)o(is2,)o(nax)o(is3,)41 b(>)1002 2136
 y(cube,anyf,status\))382 2249 y(FTPSS[BIJKED]\(unit,group)o(,na)o(xis,)
 o(naxe)o(s,f)o(pixe)o(ls,l)o(pix)o(els,)o(arra)o(y,)g(>)48
 b(status\))382 2362 y(FTGSV[BIJKED]\(unit,group)o(,na)o(xis,)o(naxe)o
 (s,f)o(pixe)o(ls,l)o(pix)o(els,)o(incs)o(,nu)o(llva)o(l,)42
 b(>)1002 2475 y(array,anyf,status\))382 2588 y
 (FTGSF[BIJKED]\(unit,group)o(,na)o(xis,)o(naxe)o(s,f)o(pixe)o(ls,l)o
 (pix)o(els,)o(incs)o(,)g(>)1002 2700 y(array,flagvals,anyf,statu)o(s\))
 0 2974 y Fj(T)-8 b(able)31 b(Column)e(Information)i(Subroutines:)39
-b(page)1842 2974 y
-SDict begin H.S end
- 1842 2974 a Fj(55)1933 2915 y
-SDict begin H.R end
- 1933
-2915 a 1933 2974 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.7.1) cvn H.B /ANN pdfmark end
- 1933 2974 a 382 3247 a Ff(FTGNRW\(unit,)44
-b(>)k(nrows,)e(status\))382 3360 y(FTGNCL\(unit,)e(>)k(ncols,)e
-(status\))382 3473 y(FTGCNO\(unit,casesen,colt)o(emp)o(late)o(,)c(>)47
+b(page)31 b(56)382 3247 y Ff(FTGNRW\(unit,)44 b(>)k(nrows,)e(status\))
+382 3360 y(FTGNCL\(unit,)e(>)k(ncols,)e(status\))382
+3473 y(FTGCNO\(unit,casesen,colt)o(emp)o(late)o(,)c(>)47
 b(colnum,status\))382 3586 y(FTGCNN\(unit,casesen,colt)o(emp)o(late)o
 (,)42 b(>)47 b(colnam,colnum,status\))382 3699 y(FTGTCL\(unit,colnum,)
 42 b(>)48 b(datacode,repeat,width,st)o(atu)o(s\))382
 3812 y(FTEQTY\(unit,colnum,)42 b(>)48 b(datacode,repeat,width,st)o(atu)
 o(s\))382 3925 y(FTGCDW\(unit,colnum,)42 b(>)48 b(dispwidth,status\))
 382 4038 y(FTGACL\(unit,colnum,)42 b(>)716 4151 y
 (ttype,tbcol,tunit,tform,)o(tsca)o(l,t)o(zero)o(,snu)o(ll,)o(tdis)o
@@ -16526,244 +13109,123 @@
 4377 y(ttype,tunit,datatype,rep)o(eat,)o(tsc)o(al,t)o(zero)o(,tn)o
 (ull,)o(tdis)o(p,s)o(tatu)o(s\))382 4489 y(FTPTDM\(unit,colnum,naxis)o
 (,na)o(xes,)f(>)48 b(status\))382 4602 y(FTGTDM\(unit,colnum,maxdi)o
 (m,)41 b(>)48 b(naxis,naxes,status\))382 4715 y
 (FTDTDM\(unit,tdimstr,coln)o(um,)o(maxd)o(im,)41 b(>)48
 b(naxis,naxes,)c(status\))382 4828 y(FTGRSZ\(unit,)g(>)k
 (nrows,status\))0 5102 y Fj(Lo)m(w-Lev)m(el)32 b(T)-8
-b(able)31 b(Access)h(Subroutines:)39 b(page)1724 5102
-y
-SDict begin H.S end
- 1724 5102 a Fj(58)1815 5043 y
-SDict begin H.R end
- 1815 5043 a 1815 5102
-a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.7.2) cvn H.B /ANN pdfmark end
- 1815 5102 a 382 5375 a Ff(FTGTBS\(unit,frow,startch)o(ar,)o(ncha)o
-(rs,)i(>)48 b(string,status\))382 5488 y(FTPTBS\(unit,frow,startch)o
-(ar,)o(ncha)o(rs,s)o(tri)o(ng,)41 b(>)48 b(status\))382
-5601 y(FTGTBB\(unit,frow,startch)o(ar,)o(ncha)o(rs,)41
-b(>)48 b(array,status\))382 5714 y(FTPTBB\(unit,frow,startch)o(ar,)o
-(ncha)o(rs,a)o(rra)o(y,)42 b(>)47 b(status\))p eop end
-%%Page: 122 128
-TeXDict begin 122 127 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.122) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(122)281
-b Fh(CHAPTER)30 b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f
-(USER-INTERF)-10 b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y
-Fj(Edit)g(Ro)m(ws)h(or)f(Columns)g(page)1148 555 y
-SDict begin H.S end
- 1148
-555 a Fj(59)1239 497 y
-SDict begin H.R end
- 1239 497 a 1239 555 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.7.3) cvn H.B /ANN pdfmark end
- 1239 555
-a 382 813 a Ff(FTIROW\(unit,frow,nrows,)41 b(>)48 b(status\))382
-926 y(FTDROW\(unit,frow,nrows,)41 b(>)48 b(status\))382
-1039 y(FTDRRG\(unit,rowrange,)42 b(>)47 b(status\))382
-1152 y(FTDRWS\(unit,rowlist,nrow)o(s,)41 b(>)48 b(status\))382
-1264 y(FTICOL\(unit,colnum,ttype)o(,tf)o(orm,)41 b(>)48
-b(status\))382 1377 y(FTICLS\(unit,colnum,ncols)o(,tt)o(ype,)o(tfor)o
-(m,)41 b(>)48 b(status\))382 1490 y(FTMVEC\(unit,colnum,newve)o(cle)o
-(n,)42 b(>)47 b(status\))382 1603 y(FTDCOL\(unit,colnum,)42
+b(able)31 b(Access)h(Subroutines:)39 b(page)31 b(58)382
+5375 y Ff(FTGTBS\(unit,frow,startch)o(ar,)o(ncha)o(rs,)41
+b(>)48 b(string,status\))382 5488 y(FTPTBS\(unit,frow,startch)o(ar,)o
+(ncha)o(rs,s)o(tri)o(ng,)41 b(>)48 b(status\))382 5601
+y(FTGTBB\(unit,frow,startch)o(ar,)o(ncha)o(rs,)41 b(>)48
+b(array,status\))382 5714 y(FTPTBB\(unit,frow,startch)o(ar,)o(ncha)o
+(rs,a)o(rra)o(y,)42 b(>)47 b(status\))p eop end
+%%Page: 124 130
+TeXDict begin 124 129 bop 0 299 a Fj(124)281 b Fh(CHAPTER)30
+b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f(USER-INTERF)-10
+b(A)m(CE)30 b(SUBR)m(OUTINES)0 555 y Fj(Edit)g(Ro)m(ws)h(or)f(Columns)g
+(page)h(59)382 813 y Ff(FTIROW\(unit,frow,nrows,)41 b(>)48
+b(status\))382 926 y(FTDROW\(unit,frow,nrows,)41 b(>)48
+b(status\))382 1039 y(FTDRRG\(unit,rowrange,)42 b(>)47
+b(status\))382 1152 y(FTDRWS\(unit,rowlist,nrow)o(s,)41
+b(>)48 b(status\))382 1264 y(FTICOL\(unit,colnum,ttype)o(,tf)o(orm,)41
+b(>)48 b(status\))382 1377 y(FTICLS\(unit,colnum,ncols)o(,tt)o(ype,)o
+(tfor)o(m,)41 b(>)48 b(status\))382 1490 y(FTMVEC\(unit,colnum,newve)o
+(cle)o(n,)42 b(>)47 b(status\))382 1603 y(FTDCOL\(unit,colnum,)42
 b(>)48 b(status\))382 1716 y(FTCPCL\(inunit,outunit,in)o(col)o(num,)o
 (outc)o(oln)o(um,c)o(reat)o(eco)o(l,)42 b(>)47 b(status\);)0
 1974 y Fj(Read)31 b(and)e(W)-8 b(rite)32 b(Column)e(Data)i(Routines)e
-(page)1825 1974 y
-SDict begin H.S end
- 1825 1974 a Fj(60)1916 1915 y
-SDict begin H.R end
- 1916
-1915 a 1916 1974 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (subsection.6.7.4) cvn H.B /ANN pdfmark end
- 1916 1974 a 382 2231 a Ff(FTPCL[SLBIJKEDCM]\(unit,c)
-o(oln)o(um,f)o(row,)o(fel)o(em,n)o(elem)o(ent)o(s,va)o(lues)o(,)42
-b(>)47 b(status\))382 2344 y(FTPCN[BIJKED]\(unit,colnu)o(m,f)o(row,)o
-(fele)o(m,n)o(elem)o(ents)o(,va)o(lues)o(,nul)o(lva)o(l)42
-b(>)47 b(status\))382 2457 y(FTPCLX\(unit,colnum,frow,)o(fbi)o(t,nb)o
-(it,l)o(ray)o(,)42 b(>)47 b(status\))382 2570 y
-(FTPCLU\(unit,colnum,frow,)o(fel)o(em,n)o(elem)o(ent)o(s,)42
-b(>)47 b(status\))382 2683 y(FTGCL\(unit,colnum,frow,f)o(ele)o(m,ne)o
-(leme)o(nts)o(,)42 b(>)47 b(values,status\))382 2796
-y(FTGCV[SBIJKEDCM]\(unit,co)o(lnu)o(m,fr)o(ow,f)o(ele)o(m,ne)o(leme)o
-(nts)o(,nul)o(lval)o(,)42 b(>)1098 2909 y(values,anyf,status\))382
-3022 y(FTGCF[SLBIJKEDCM]\(unit,c)o(oln)o(um,f)o(row,)o(fel)o(em,n)o
-(elem)o(ent)o(s,)g(>)1193 3135 y(values,flagvals,anyf,stat)o(us\))382
+(page)h(60)382 2231 y Ff(FTPCL[SLBIJKEDCM]\(unit,c)o(oln)o(um,f)o(row,)
+o(fel)o(em,n)o(elem)o(ent)o(s,va)o(lues)o(,)42 b(>)47
+b(status\))382 2344 y(FTPCN[BIJKED]\(unit,colnu)o(m,f)o(row,)o(fele)o
+(m,n)o(elem)o(ents)o(,va)o(lues)o(,nul)o(lva)o(l)42 b(>)47
+b(status\))382 2457 y(FTPCLX\(unit,colnum,frow,)o(fbi)o(t,nb)o(it,l)o
+(ray)o(,)42 b(>)47 b(status\))382 2570 y(FTPCLU\(unit,colnum,frow,)o
+(fel)o(em,n)o(elem)o(ent)o(s,)42 b(>)47 b(status\))382
+2683 y(FTGCL\(unit,colnum,frow,f)o(ele)o(m,ne)o(leme)o(nts)o(,)42
+b(>)47 b(values,status\))382 2796 y(FTGCV[SBIJKEDCM]\(unit,co)o(lnu)o
+(m,fr)o(ow,f)o(ele)o(m,ne)o(leme)o(nts)o(,nul)o(lval)o(,)42
+b(>)1098 2909 y(values,anyf,status\))382 3022 y
+(FTGCF[SLBIJKEDCM]\(unit,c)o(oln)o(um,f)o(row,)o(fel)o(em,n)o(elem)o
+(ent)o(s,)g(>)1193 3135 y(values,flagvals,anyf,stat)o(us\))382
 3247 y(FTGSV[BIJKED]\(unit,colnu)o(m,n)o(axis)o(,nax)o(es,)o(fpix)o
 (els,)o(lpi)o(xels)o(,inc)o(s,n)o(ullv)o(al,)f(>)1002
 3360 y(array,anyf,status\))382 3473 y(FTGSF[BIJKED]\(unit,colnu)o(m,n)o
 (axis)o(,nax)o(es,)o(fpix)o(els,)o(lpi)o(xels)o(,inc)o(s,)g(>)1002
 3586 y(array,flagvals,anyf,statu)o(s\))382 3699 y
 (FTGCX\(unit,colnum,frow,f)o(bit)o(,nbi)o(t,)h(>)47 b(lray,status\))382
 3812 y(FTGCX[IJD]\(unit,colnum,f)o(row)o(,nro)o(ws,f)o(bit)o(,nbi)o(t,)
 42 b(>)47 b(array,status\))382 3925 y(FTGDES\(unit,colnum,rownu)o(m,)41
 b(>)48 b(nelements,offset,status\))382 4038 y
 (FTPDES\(unit,colnum,rownu)o(m,n)o(elem)o(ents)o(,of)o(fset)o(,)42
 b(>)47 b(status\))0 4295 y Fj(Ro)m(w)31 b(Selection)h(and)d(Calculator)
-j(Routines:)41 b(page)1839 4295 y
-SDict begin H.S end
- 1839 4295 a Fj(64)1930
-4237 y
-SDict begin H.R end
- 1930 4237 a 1930 4295 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.8) cvn H.B /ANN pdfmark end
- 1930 4295 a 382 4553 a
-Ff(FTFROW\(unit,expr,firstro)o(w,)g(nrows,)47 b(>)g(n_good_rows,)d
-(row_status,)h(status\))382 4666 y(FTFFRW\(unit,)f(expr,)j(>)g(rownum,)
-f(status\))382 4779 y(FTSROW\(inunit,)e(outunit,)h(expr,)i(>)g(status)f
-(\))382 4892 y(FTCROW\(unit,datatype,exp)o(r,f)o(irst)o(row,)o(nel)o
-(emen)o(ts,n)o(ulv)o(al,)41 b(>)620 5005 y(array,anynul,status\))382
+j(Routines:)41 b(page)31 b(64)382 4553 y Ff(FTFROW\(unit,expr,firstro)o
+(w,)41 b(nrows,)47 b(>)g(n_good_rows,)d(row_status,)h(status\))382
+4666 y(FTFFRW\(unit,)f(expr,)j(>)g(rownum,)f(status\))382
+4779 y(FTSROW\(inunit,)e(outunit,)h(expr,)i(>)g(status)f(\))382
+4892 y(FTCROW\(unit,datatype,exp)o(r,f)o(irst)o(row,)o(nel)o(emen)o
+(ts,n)o(ulv)o(al,)41 b(>)620 5005 y(array,anynul,status\))382
 5118 y(FTCALC\(inunit,)j(expr,)i(outunit,)g(parName,)f(parInfo,)h(>)h
 (status\))382 5230 y(FTCALC_RNG\(inunit,)c(expr,)j(outunit,)g(parName,)
 f(parInfo,)573 5343 y(nranges,)g(firstrow,)h(lastrow,)f(>)j(status\))
 382 5456 y(FTTEXP\(unit,)c(expr,)j(>)g(datatype,)e(nelem,)h(naxis,)h
 (naxes,)f(status\))0 5714 y Fj(Celestial)32 b(Co)s(ordinate)f(System)f
-(Subroutines:)39 b(page)1906 5714 y
-SDict begin H.S end
- 1906 5714 a Fj(65)1997
-5655 y
-SDict begin H.R end
- 1997 5655 a 1997 5714 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.9) cvn H.B /ANN pdfmark end
- 1997 5714 a eop end
-%%Page: 123 129
-TeXDict begin 123 128 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.123) cvn /DEST pdfmark end
- -8 191 a 3764 299 a Fj(123)382
-555 y Ff(FTGICS\(unit,)44 b(>)k(xrval,yrval,xrpix,yrpix)o(,xin)o(c,yi)o
-(nc,)o(rot,)o(coor)o(dty)o(pe,s)o(tatu)o(s\))382 668
-y(FTGTCS\(unit,xcol,ycol,)42 b(>)716 781 y(xrval,yrval,xrpix,yrpix,)o
+(Subroutines:)39 b(page)31 b(65)p eop end
+%%Page: 125 131
+TeXDict begin 125 130 bop 3764 299 a Fj(125)382 555 y
+Ff(FTGICS\(unit,)44 b(>)k(xrval,yrval,xrpix,yrpix)o(,xin)o(c,yi)o(nc,)o
+(rot,)o(coor)o(dty)o(pe,s)o(tatu)o(s\))382 668 y
+(FTGTCS\(unit,xcol,ycol,)42 b(>)716 781 y(xrval,yrval,xrpix,yrpix,)o
 (xinc)o(,yi)o(nc,r)o(ot,c)o(oor)o(dtyp)o(e,st)o(atu)o(s\))382
 894 y(FTWLDP\(xpix,ypix,xrval,y)o(rva)o(l,xr)o(pix,)o(yrp)o(ix,x)o
 (inc,)o(yin)o(c,ro)o(t,)1241 1007 y(coordtype,)j(>)i
 (xpos,ypos,status\))382 1120 y(FTXYPX\(xpos,ypos,xrval,y)o(rva)o(l,xr)o
 (pix,)o(yrp)o(ix,x)o(inc,)o(yin)o(c,ro)o(t,)1241 1233
 y(coordtype,)e(>)i(xpix,ypix,status\))0 1490 y Fj(File)32
-b(Chec)m(ksum)d(Subroutines:)40 b(page)1364 1490 y
-SDict begin H.S end
- 1364
-1490 a Fj(67)1455 1432 y
-SDict begin H.R end
- 1455 1432 a 1455 1490 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.10) cvn H.B /ANN pdfmark end
- 1455
-1490 a 382 1748 a Ff(FTPCKS\(unit,)k(>)k(status\))382
-1861 y(FTUCKS\(unit,)c(>)k(status\))382 1974 y(FTVCKS\(unit,)c(>)k
-(dataok,hduok,status\))382 2087 y(FTGCKS\(unit,)c(>)k
-(datasum,hdusum,status\))382 2199 y(FTESUM\(sum,complement,)42
-b(>)47 b(checksum\))382 2312 y(FTDSUM\(checksum,compleme)o(nt,)41
-b(>)48 b(sum\))0 2683 y Fj(Time)30 b(and)g(Date)i(Utilit)m(y)h
-(Subroutines:)39 b(page)1674 2683 y
-SDict begin H.S end
- 1674 2683 a Fj(68)1765
-2624 y
-SDict begin H.R end
- 1765 2624 a 1765 2683 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.11) cvn H.B /ANN pdfmark end
- 1765 2683 a 382 2940 a
-Ff(FTGSDT\()46 b(>)h(day,)g(month,)f(year,)g(status)g(\))382
-3053 y(FTGSTM\(>)f(datestr,)h(timeref,)f(status\))382
+b(Chec)m(ksum)d(Subroutines:)40 b(page)31 b(67)382 1748
+y Ff(FTPCKS\(unit,)44 b(>)k(status\))382 1861 y(FTUCKS\(unit,)c(>)k
+(status\))382 1974 y(FTVCKS\(unit,)c(>)k(dataok,hduok,status\))382
+2087 y(FTGCKS\(unit,)c(>)k(datasum,hdusum,status\))382
+2199 y(FTESUM\(sum,complement,)42 b(>)47 b(checksum\))382
+2312 y(FTDSUM\(checksum,compleme)o(nt,)41 b(>)48 b(sum\))0
+2683 y Fj(Time)30 b(and)g(Date)i(Utilit)m(y)h(Subroutines:)39
+b(page)31 b(68)382 2940 y Ff(FTGSDT\()46 b(>)h(day,)g(month,)f(year,)g
+(status)g(\))382 3053 y(FTGSTM\(>)f(datestr,)h(timeref,)f(status\))382
 3166 y(FTDT2S\()h(year,)g(month,)g(day,)h(>)g(datestr,)f(status\))382
 3279 y(FTTM2S\()g(year,)g(month,)g(day,)h(hour,)f(minute,)g(second,)g
 (decimals,)764 3392 y(>)h(datestr,)f(status\))382 3505
 y(FTS2DT\(datestr,)d(>)48 b(year,)e(month,)g(day,)h(status\))382
 3618 y(FTS2TM\(datestr,)c(>)48 b(year,)e(month,)g(day,)h(hour,)f
 (minute,)g(second,)g(status\))0 3876 y Fj(General)31
-b(Utilit)m(y)i(Subroutines:)39 b(page)1378 3876 y
-SDict begin H.S end
- 1378
-3876 a Fj(69)1469 3817 y
-SDict begin H.R end
- 1469 3817 a 1469 3876 a
-SDict begin [/Color [1 0 0]/H /I/Border [0 0 1]BorderArrayPatch/Subtype
-/Link/Dest (section.6.12) cvn H.B /ANN pdfmark end
- 1469
-3876 a 382 4133 a Ff(FTGHAD\(unit,)44 b(>)k(curaddr,nextaddr\))382
-4246 y(FTUPCH\(string\))382 4359 y(FTCMPS\(str_template,stri)o(ng,)o
-(case)o(sen,)41 b(>)47 b(match,exact\))382 4472 y(FTTKEY\(keyword,)c(>)
-48 b(status\))382 4585 y(FTTREC\(card,)c(>)k(status\))382
+b(Utilit)m(y)i(Subroutines:)39 b(page)31 b(69)382 4133
+y Ff(FTGHAD\(unit,)44 b(>)k(curaddr,nextaddr\))382 4246
+y(FTUPCH\(string\))382 4359 y(FTCMPS\(str_template,stri)o(ng,)o(case)o
+(sen,)41 b(>)47 b(match,exact\))382 4472 y(FTTKEY\(keyword,)c(>)48
+b(status\))382 4585 y(FTTREC\(card,)c(>)k(status\))382
 4698 y(FTNCHK\(unit,)c(>)k(status\))382 4811 y(FTGKNM\(unit,)c(>)k
 (keyword,)d(keylength,)g(status\))382 4924 y(FTMKKY\(keyword,)e
 (value,comment,)h(>)k(card,)e(status\))382 5036 y(FTPSVC\(card,)e(>)k
 (value,comment,status\))382 5149 y(FTKEYN\(keyroot,seq_no,)42
 b(>)47 b(keyword,status\))382 5262 y(FTNKEY\(seq_no,keyroot,)42
 b(>)47 b(keyword,status\))382 5375 y(FTDTYP\(value,)d(>)j
 (dtype,status\))382 5488 y(class)f(=)i(FTGKCL\(card\))382
 5601 y(FTASFM\(tform,)c(>)j(datacode,width,decimals,st)o(atus)o(\))382
 5714 y(FTBNFM\(tform,)d(>)j(datacode,repeat,width,stat)o(us\))p
 eop end
-%%Page: 124 130
-TeXDict begin 124 129 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.124) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(124)281
-b Fh(CHAPTER)30 b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f
-(USER-INTERF)-10 b(A)m(CE)30 b(SUBR)m(OUTINES)382 555
-y Ff(FTGABC\(tfields,tform,spa)o(ce,)41 b(>)48 b(rowlen,tbcol,status\))
-382 668 y(FTGTHD\(template,)43 b(>)48 b(card,hdtype,status\))382
-781 y(FTRWRG\(rowlist,)43 b(maxrows,)j(maxranges,)f(>)i(numranges,)e
-(rangemin,)716 894 y(rangemax,)g(status\))p eop end
-%%Page: 125 131
-TeXDict begin 125 130 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.125) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a
-0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.11) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(11)0
+%%Page: 126 132
+TeXDict begin 126 131 bop 0 299 a Fj(126)281 b Fh(CHAPTER)30
+b(10.)112 b(SUMMAR)-8 b(Y)32 b(OF)e(ALL)g(FITSIO)f(USER-INTERF)-10
+b(A)m(CE)30 b(SUBR)m(OUTINES)382 555 y Ff(FTGABC\(tfields,tform,spa)o
+(ce,)41 b(>)48 b(rowlen,tbcol,status\))382 668 y(FTGTHD\(template,)43
+b(>)48 b(card,hdtype,status\))382 781 y(FTRWRG\(rowlist,)43
+b(maxrows,)j(maxranges,)f(>)i(numranges,)e(rangemin,)716
+894 y(rangemax,)g(status\))p eop end
+%%Page: 127 133
+TeXDict begin 127 132 bop 0 1225 a Fg(Chapter)65 b(11)0
 1687 y Fm(P)-6 b(arameter)77 b(De\014nitions)0 2180 y
 Ff(anyf)47 b(-)g(\(logical\))e(set)i(to)g(TRUE)g(if)g(any)g(of)g(the)g
 (returned)f(data)g(values)h(are)f(undefined)0 2293 y(array)g(-)i(\(any)
 e(datatype)g(except)g(character\))f(array)h(of)i(bytes)e(to)h(be)g
 (read)g(or)g(written.)0 2406 y(bitpix)f(-)i(\(integer\))d(bits)h(per)h
 (pixel:)f(8,)i(16,)f(32,)f(-32,)h(or)g(-64)0 2518 y(blank)f(-)i
 (\(integer\))d(value)h(used)h(for)g(undefined)e(pixels)h(in)i(integer)d
@@ -16801,31 +13263,19 @@
 (\(integer\))e(symbolic)h(code)g(of)i(the)f(binary)f(table)g(column)g
 (datatype)0 5341 y(dataok)g(-)i(\(integer\))d(was)i(the)g(data)f(unit)h
 (verification)d(successful)h(\(=1\))i(or)430 5454 y(not)f(\(=)i(-1\).)
 94 b(Equals)46 b(zero)h(if)g(the)g(DATASUM)f(keyword)f(is)j(not)f
 (present.)0 5567 y(datasum)f(-)h(\(double)f(precision\))f(32-bit)h(1's)
 h(complement)e(checksum)h(for)h(the)f(data)h(unit)0 5680
 y(datatype)f(-)h(\(character\))e(datatype)g(\(format\))h(of)h(the)g
-(binary)f(table)g(column)1882 5942 y Fj(125)p eop end
-%%Page: 126 132
-TeXDict begin 126 131 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.126) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(126)1779
-b Fh(CHAPTER)30 b(11.)112 b(P)-8 b(ARAMETER)30 b(DEFINITIONS)0
-555 y Ff(datestr)94 b(-)47 b(\(string\))f(FITS)g(date/time)f(string:)h
+(binary)f(table)g(column)1882 5942 y Fj(127)p eop end
+%%Page: 128 134
+TeXDict begin 128 133 bop 0 299 a Fj(128)1779 b Fh(CHAPTER)30
+b(11.)112 b(P)-8 b(ARAMETER)30 b(DEFINITIONS)0 555 y
+Ff(datestr)94 b(-)47 b(\(string\))f(FITS)g(date/time)f(string:)h
 ('YYYY-MM-DDThh:mm:ss.ddd')o(,)525 668 y('YYYY-MM-dd',)e(or)j
 ('dd/mm/yy')0 781 y(day)g(-)g(\(integer\))f(current)f(day)i(of)h(the)e
 (month)0 894 y(dblval)g(-)i(\(double)d(precision\))g(fractional)g(part)
 i(of)g(the)g(keyword)f(value)0 1007 y(decimals)g(-)h(\(integer\))e
 (number)h(of)i(decimal)d(places)h(to)i(be)f(displayed)0
 1120 y(dim1)g(-)g(\(integer\))e(actual)h(size)h(of)g(the)g(first)g
 (dimension)e(of)i(the)g(image)f(or)h(cube)g(array)0 1233
@@ -16881,113 +13331,88 @@
 (comment)f(string)0 5185 y(hour)i(-)g(\(integer\))e(hour)i(from)g(0)g
 (-)h(23)0 5297 y(image)e(-)i(2D)f(image)f(of)i(the)e(appropriate)f
 (datatype)0 5410 y(inclist)94 b(\(character)45 b(array\))h(list)g(of)h
 (names)g(to)g(be)g(included)f(in)h(search)0 5523 y(incs)g(-)g
 (\(integer)f(array\))g(sampling)f(interval)h(for)h(pixels)f(in)h(each)g
 (FITS)f(dimension)0 5636 y(intval)g(-)i(\(integer\))d(integer)h(part)g
 (of)h(the)g(keyword)f(value)p eop end
-%%Page: 127 133
-TeXDict begin 127 132 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.127) cvn /DEST pdfmark end
- -8 191 a 3764 299 a Fj(127)0
-555 y Ff(iounit)46 b(-)i(\(integer\))d(value)h(of)h(an)h(unused)e(I/O)h
-(unit)f(number)0 668 y(iunit)g(-)i(\(integer\))d(logical)h(unit)h
-(number)f(associated)f(with)h(the)h(input)g(FITS)f(file,)h(1-300)0
-781 y(key_no)f(-)i(\(integer\))d(sequence)g(number)h(\(starting)g(with)
-g(1\))i(of)f(the)g(keyword)e(record)0 894 y(keylength)g(-)j
-(\(integer\))d(length)h(of)h(the)g(keyword)f(name)0 1007
-y(keyroot)g(-)h(\(character\))e(root)i(string)f(for)h(the)g(keyword)e
-(name)0 1120 y(keysadd)h(-\(integer\))f(number)h(of)h(new)g(keyword)f
-(records)g(which)g(can)h(fit)g(in)g(the)g(CHU)0 1233
-y(keysexist)e(-)j(\(integer\))d(number)h(of)h(existing)f(keyword)g
-(records)f(in)j(the)f(CHU)0 1346 y(keyval)f(-)i(value)e(of)h(the)g
-(keyword)f(in)h(the)g(appropriate)e(datatype)0 1458 y(keyvals)h(-)h
-(\(array\))f(value)g(of)i(the)f(keywords)e(in)i(the)g(appropriate)e
-(datatype)0 1571 y(keyword)h(-)h(\(character*8\))d(name)j(of)g(a)h
-(keyword)0 1684 y(lray)f(-)g(\(logical)f(array\))g(array)g(of)h
-(logical)f(values)g(corresponding)e(to)k(the)e(bit)h(array)0
-1797 y(lpixels)f(-)h(\(integer)f(array\))g(the)h(last)f(included)g
-(pixel)g(in)i(each)e(dimension)0 1910 y(match)g(-)i(\(logical\))d(do)i
-(the)g(2)h(strings)d(match?)0 2023 y(maxdim)h(-)i(\(integer\))d
-(dimensioned)g(size)h(of)h(the)g(NAXES,)f(TTYPE,)g(TFORM)h(or)g(TUNIT)f
-(arrays)0 2136 y(max_keys)g(-)h(\(integer\))e(maximum)h(number)g(of)h
-(keywords)f(to)h(search)f(for)0 2249 y(minute)g(-)i(\(integer\))d
-(minute)h(of)h(an)g(hour)g(\(0)g(-)h(59\))0 2362 y(month)e(-)i
-(\(integer\))d(current)h(month)g(of)h(the)g(year)g(\(1)g(-)h(12\))0
-2475 y(morekeys)e(-)h(\(integer\))e(will)i(leave)f(space)h(in)g(the)g
-(header)f(for)h(this)f(many)h(more)g(keywords)0 2588
-y(naxes)f(-)i(\(integer)d(array\))h(size)h(of)g(each)g(dimension)e(in)i
-(the)g(FITS)g(array)0 2700 y(naxesll)f(-)h(\(integer*8)e(array\))h
-(size)h(of)g(each)g(dimension)e(in)i(the)g(FITS)g(array)0
-2813 y(naxis)f(-)i(\(integer\))d(number)h(of)h(dimensions)e(in)j(the)e
-(FITS)h(array)0 2926 y(naxis1)f(-)i(\(integer\))d(length)h(of)h(the)g
-(X/first)f(axis)g(of)i(the)f(FITS)f(array)0 3039 y(naxis2)g(-)i
-(\(integer\))d(length)h(of)h(the)g(Y/second)f(axis)g(of)h(the)g(FITS)g
-(array)0 3152 y(naxis3)f(-)i(\(integer\))d(length)h(of)h(the)g(Z/third)
-f(axis)g(of)i(the)f(FITS)f(array)0 3265 y(nbit)h(-)g(\(integer\))e
-(number)h(of)i(bits)e(in)h(the)g(field)g(to)g(read)g(or)g(write)0
-3378 y(nchars)f(-)i(\(integer\))d(number)h(of)h(characters)e(to)i(read)
-g(and)g(return)0 3491 y(ncols)f(-)i(\(integer\))d(number)h(of)h
-(columns)0 3604 y(nelements)e(-)j(\(integer\))d(number)h(of)h(data)g
-(elements)e(to)j(read)e(or)h(write)0 3717 y(nelementsll)e(-)i
-(\(integer*8\))e(number)h(of)h(data)g(elements)e(to)j(read)e(or)h
-(write)0 3830 y(nexc)142 b(\(integer\))93 b(number)46
-b(of)h(names)g(in)g(the)g(exclusion)e(list)i(\(may)f(=)i(0\))0
-3942 y(nhdu)f(-)g(\(integer\))e(absolute)h(number)g(of)h(the)g(HDU)g
-(\(1st)g(HDU)g(=)g(1\))0 4055 y(ninc)142 b(\(integer\))93
-b(number)46 b(of)h(names)g(in)g(the)g(inclusion)e(list)0
-4168 y(nmove)h(-)i(\(integer\))d(number)h(of)h(HDUs)g(to)g(move)g(\(+)g
-(or)g(-\),)g(relative)f(to)h(current)f(position)0 4281
-y(nfound)g(-)i(\(integer\))d(number)h(of)h(keywords)f(found)g
-(\(highest)g(keyword)f(number\))0 4394 y(no_keys)h(-)h(\(integer\))f
-(number)g(of)h(keywords)e(to)j(write)e(in)h(the)g(sequence)0
-4507 y(nparm)f(-)i(\(integer\))d(number)h(of)h(group)g(parameters)e(to)
-i(read)g(or)g(write)0 4620 y(nrows)f(-)i(\(integer\))d(number)h(of)h
-(rows)g(in)g(the)g(table)0 4733 y(nrowsll)f(-)h(\(integer*8\))e(number)
-h(of)h(rows)g(in)g(the)g(table)0 4846 y(nullval)f(-)h(value)g(to)g
-(represent)e(undefined)g(pixels,)h(of)h(the)g(appropriate)e(datatype)0
-4959 y(nextaddr)h(-)h(\(integer\))e(starting)h(address)g(\(in)h
-(bytes\))f(of)h(the)g(HDU)g(following)e(the)i(CHDU)0
-5072 y(offset)f(-)i(\(integer\))d(byte)h(offset)h(in)g(the)g(heap)f(to)
-h(the)g(first)g(element)f(of)h(the)g(array)0 5185 y(offsetll)f(-)h
-(\(integer*8\))e(byte)h(offset)g(in)i(the)f(heap)f(to)h(the)g(first)g
-(element)e(of)j(the)f(array)0 5297 y(oldkey)f(-)i(\(character\))c(old)j
-(name)g(of)g(keyword)f(to)h(be)g(modified)0 5410 y(ounit)f(-)i
-(\(integer\))d(logical)h(unit)h(number)f(associated)f(with)h(the)h
-(output)f(FITS)h(file)g(1-300)0 5523 y(pcount)f(-)i(\(integer\))d
-(value)h(of)h(the)g(PCOUNT)f(keyword)g(\(usually)g(=)h(0\))0
-5636 y(previous)f(-)h(\(integer\))e(if)i(not)g(equal)g(to)g(0,)g(copy)g
-(all)g(previous)e(HDUs)i(in)g(the)g(input)f(file)p eop
-end
-%%Page: 128 134
-TeXDict begin 128 133 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.128) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(128)1779
-b Fh(CHAPTER)30 b(11.)112 b(P)-8 b(ARAMETER)30 b(DEFINITIONS)0
-555 y Ff(repeat)46 b(-)i(\(integer\))d(length)h(of)h(element)f(vector)g
+%%Page: 129 135
+TeXDict begin 129 134 bop 3764 299 a Fj(129)0 555 y Ff(iounit)46
+b(-)i(\(integer\))d(value)h(of)h(an)h(unused)e(I/O)h(unit)f(number)0
+668 y(iunit)g(-)i(\(integer\))d(logical)h(unit)h(number)f(associated)f
+(with)h(the)h(input)g(FITS)f(file,)h(1-300)0 781 y(key_no)f(-)i
+(\(integer\))d(sequence)g(number)h(\(starting)g(with)g(1\))i(of)f(the)g
+(keyword)e(record)0 894 y(keylength)g(-)j(\(integer\))d(length)h(of)h
+(the)g(keyword)f(name)0 1007 y(keyroot)g(-)h(\(character\))e(root)i
+(string)f(for)h(the)g(keyword)e(name)0 1120 y(keysadd)h(-\(integer\))f
+(number)h(of)h(new)g(keyword)f(records)g(which)g(can)h(fit)g(in)g(the)g
+(CHU)0 1233 y(keysexist)e(-)j(\(integer\))d(number)h(of)h(existing)f
+(keyword)g(records)f(in)j(the)f(CHU)0 1346 y(keyval)f(-)i(value)e(of)h
+(the)g(keyword)f(in)h(the)g(appropriate)e(datatype)0
+1458 y(keyvals)h(-)h(\(array\))f(value)g(of)i(the)f(keywords)e(in)i
+(the)g(appropriate)e(datatype)0 1571 y(keyword)h(-)h(\(character*8\))d
+(name)j(of)g(a)h(keyword)0 1684 y(lray)f(-)g(\(logical)f(array\))g
+(array)g(of)h(logical)f(values)g(corresponding)e(to)k(the)e(bit)h
+(array)0 1797 y(lpixels)f(-)h(\(integer)f(array\))g(the)h(last)f
+(included)g(pixel)g(in)i(each)e(dimension)0 1910 y(match)g(-)i
+(\(logical\))d(do)i(the)g(2)h(strings)d(match?)0 2023
+y(maxdim)h(-)i(\(integer\))d(dimensioned)g(size)h(of)h(the)g(NAXES,)f
+(TTYPE,)g(TFORM)h(or)g(TUNIT)f(arrays)0 2136 y(max_keys)g(-)h
+(\(integer\))e(maximum)h(number)g(of)h(keywords)f(to)h(search)f(for)0
+2249 y(minute)g(-)i(\(integer\))d(minute)h(of)h(an)g(hour)g(\(0)g(-)h
+(59\))0 2362 y(month)e(-)i(\(integer\))d(current)h(month)g(of)h(the)g
+(year)g(\(1)g(-)h(12\))0 2475 y(morekeys)e(-)h(\(integer\))e(will)i
+(leave)f(space)h(in)g(the)g(header)f(for)h(this)f(many)h(more)g
+(keywords)0 2588 y(naxes)f(-)i(\(integer)d(array\))h(size)h(of)g(each)g
+(dimension)e(in)i(the)g(FITS)g(array)0 2700 y(naxesll)f(-)h
+(\(integer*8)e(array\))h(size)h(of)g(each)g(dimension)e(in)i(the)g
+(FITS)g(array)0 2813 y(naxis)f(-)i(\(integer\))d(number)h(of)h
+(dimensions)e(in)j(the)e(FITS)h(array)0 2926 y(naxis1)f(-)i
+(\(integer\))d(length)h(of)h(the)g(X/first)f(axis)g(of)i(the)f(FITS)f
+(array)0 3039 y(naxis2)g(-)i(\(integer\))d(length)h(of)h(the)g
+(Y/second)f(axis)g(of)h(the)g(FITS)g(array)0 3152 y(naxis3)f(-)i
+(\(integer\))d(length)h(of)h(the)g(Z/third)f(axis)g(of)i(the)f(FITS)f
+(array)0 3265 y(nbit)h(-)g(\(integer\))e(number)h(of)i(bits)e(in)h(the)
+g(field)g(to)g(read)g(or)g(write)0 3378 y(nchars)f(-)i(\(integer\))d
+(number)h(of)h(characters)e(to)i(read)g(and)g(return)0
+3491 y(ncols)f(-)i(\(integer\))d(number)h(of)h(columns)0
+3604 y(nelements)e(-)j(\(integer\))d(number)h(of)h(data)g(elements)e
+(to)j(read)e(or)h(write)0 3717 y(nelementsll)e(-)i(\(integer*8\))e
+(number)h(of)h(data)g(elements)e(to)j(read)e(or)h(write)0
+3830 y(nexc)142 b(\(integer\))93 b(number)46 b(of)h(names)g(in)g(the)g
+(exclusion)e(list)i(\(may)f(=)i(0\))0 3942 y(nhdu)f(-)g(\(integer\))e
+(absolute)h(number)g(of)h(the)g(HDU)g(\(1st)g(HDU)g(=)g(1\))0
+4055 y(ninc)142 b(\(integer\))93 b(number)46 b(of)h(names)g(in)g(the)g
+(inclusion)e(list)0 4168 y(nmove)h(-)i(\(integer\))d(number)h(of)h
+(HDUs)g(to)g(move)g(\(+)g(or)g(-\),)g(relative)f(to)h(current)f
+(position)0 4281 y(nfound)g(-)i(\(integer\))d(number)h(of)h(keywords)f
+(found)g(\(highest)g(keyword)f(number\))0 4394 y(no_keys)h(-)h
+(\(integer\))f(number)g(of)h(keywords)e(to)j(write)e(in)h(the)g
+(sequence)0 4507 y(nparm)f(-)i(\(integer\))d(number)h(of)h(group)g
+(parameters)e(to)i(read)g(or)g(write)0 4620 y(nrows)f(-)i(\(integer\))d
+(number)h(of)h(rows)g(in)g(the)g(table)0 4733 y(nrowsll)f(-)h
+(\(integer*8\))e(number)h(of)h(rows)g(in)g(the)g(table)0
+4846 y(nullval)f(-)h(value)g(to)g(represent)e(undefined)g(pixels,)h(of)
+h(the)g(appropriate)e(datatype)0 4959 y(nextaddr)h(-)h(\(integer\))e
+(starting)h(address)g(\(in)h(bytes\))f(of)h(the)g(HDU)g(following)e
+(the)i(CHDU)0 5072 y(offset)f(-)i(\(integer\))d(byte)h(offset)h(in)g
+(the)g(heap)f(to)h(the)g(first)g(element)f(of)h(the)g(array)0
+5185 y(offsetll)f(-)h(\(integer*8\))e(byte)h(offset)g(in)i(the)f(heap)f
+(to)h(the)g(first)g(element)e(of)j(the)f(array)0 5297
+y(oldkey)f(-)i(\(character\))c(old)j(name)g(of)g(keyword)f(to)h(be)g
+(modified)0 5410 y(ounit)f(-)i(\(integer\))d(logical)h(unit)h(number)f
+(associated)f(with)h(the)h(output)f(FITS)h(file)g(1-300)0
+5523 y(pcount)f(-)i(\(integer\))d(value)h(of)h(the)g(PCOUNT)f(keyword)g
+(\(usually)g(=)h(0\))0 5636 y(previous)f(-)h(\(integer\))e(if)i(not)g
+(equal)g(to)g(0,)g(copy)g(all)g(previous)e(HDUs)i(in)g(the)g(input)f
+(file)p eop end
+%%Page: 130 136
+TeXDict begin 130 135 bop 0 299 a Fj(130)1779 b Fh(CHAPTER)30
+b(11.)112 b(P)-8 b(ARAMETER)30 b(DEFINITIONS)0 555 y
+Ff(repeat)46 b(-)i(\(integer\))d(length)h(of)h(element)f(vector)g
 (\(e.g.)g(12J\);)h(ignored)f(for)g(ASCII)h(table)0 668
 y(rot)g(-)g(\(double)f(precision\))f(celestial)g(coordinate)g(rotation)
 h(angle)g(\(degrees\))0 781 y(rowlen)g(-)i(\(integer\))d(length)h(of)h
 (a)h(table)e(row,)h(in)g(characters)e(or)i(bytes)0 894
 y(rowlenll)f(-)h(\(integer*8\))e(length)h(of)h(a)g(table)g(row,)f(in)i
 (characters)d(or)i(bytes)0 1007 y(rowlist)f(-)h(\(integer)f(array\))g
 (list)h(of)g(row)g(numbers)e(to)j(be)f(deleted)f(in)h(increasing)e
@@ -17047,88 +13472,43 @@
 (\(e.g.,)g('km/s'\))0 5185 y(value)g(-)i(\(character\))d(the)h(keyword)
 g(value)h(string)0 5297 y(values)f(-)i(array)e(of)h(data)g(values)f(of)
 h(the)g(appropriate)e(datatype)0 5410 y(varidat)h(-)h(\(integer\))f
 (size)g(in)h(bytes)g(of)g(the)g('variable)e(length)h(data)h(area')525
 5523 y(following)e(the)i(binary)f(table)h(data)f(\(usually)g(=)h(0\))0
 5636 y(version)f(-)h(\(real\))f(current)g(revision)g(number)g(of)h(the)
 g(library)p eop end
-%%Page: 129 135
-TeXDict begin 129 134 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.129) cvn /DEST pdfmark end
- -8 191 a 3764 299 a Fj(129)0
-555 y Ff(width)46 b(-)i(\(integer\))d(width)h(of)i(the)f(character)e
-(string)h(field)0 668 y(xcol)h(-)g(\(integer\))e(number)h(of)i(the)f
-(column)f(containing)f(the)i(X)g(coordinate)e(values)0
-781 y(xinc)i(-)g(\(double)f(precision\))f(X)i(axis)g(coordinate)e
-(increment)g(at)i(reference)f(pixel)g(\(deg\))0 894 y(xpix)h(-)g
-(\(double)f(precision\))f(X)i(axis)g(pixel)f(location)0
-1007 y(xpos)h(-)g(\(double)f(precision\))f(X)i(axis)g(celestial)e
-(coordinate)g(\(usually)h(RA\))h(\(deg\))0 1120 y(xrpix)f(-)i(\(double)
-e(precision\))f(X)i(axis)g(reference)e(pixel)h(array)h(location)0
-1233 y(xrval)f(-)i(\(double)e(precision\))f(X)i(axis)g(coordinate)e
-(value)h(at)h(the)g(reference)e(pixel)i(\(deg\))0 1346
-y(ycol)g(-)g(\(integer\))e(number)h(of)i(the)f(column)f(containing)f
-(the)i(X)g(coordinate)e(values)0 1458 y(year)i(-)g(\(integer\))e(last)i
-(2)g(digits)g(of)g(the)g(year)f(\(00)h(-)h(99\))0 1571
-y(yinc)f(-)g(\(double)f(precision\))f(Y)i(axis)g(coordinate)e
+%%Page: 131 137
+TeXDict begin 131 136 bop 3764 299 a Fj(131)0 555 y Ff(width)46
+b(-)i(\(integer\))d(width)h(of)i(the)f(character)e(string)h(field)0
+668 y(xcol)h(-)g(\(integer\))e(number)h(of)i(the)f(column)f(containing)
+f(the)i(X)g(coordinate)e(values)0 781 y(xinc)i(-)g(\(double)f
+(precision\))f(X)i(axis)g(coordinate)e(increment)g(at)i(reference)f
+(pixel)g(\(deg\))0 894 y(xpix)h(-)g(\(double)f(precision\))f(X)i(axis)g
+(pixel)f(location)0 1007 y(xpos)h(-)g(\(double)f(precision\))f(X)i
+(axis)g(celestial)e(coordinate)g(\(usually)h(RA\))h(\(deg\))0
+1120 y(xrpix)f(-)i(\(double)e(precision\))f(X)i(axis)g(reference)e
+(pixel)h(array)h(location)0 1233 y(xrval)f(-)i(\(double)e(precision\))f
+(X)i(axis)g(coordinate)e(value)h(at)h(the)g(reference)e(pixel)i
+(\(deg\))0 1346 y(ycol)g(-)g(\(integer\))e(number)h(of)i(the)f(column)f
+(containing)f(the)i(X)g(coordinate)e(values)0 1458 y(year)i(-)g
+(\(integer\))e(last)i(2)g(digits)g(of)g(the)g(year)f(\(00)h(-)h(99\))0
+1571 y(yinc)f(-)g(\(double)f(precision\))f(Y)i(axis)g(coordinate)e
 (increment)g(at)i(reference)f(pixel)g(\(deg\))0 1684
 y(ypix)h(-)g(\(double)f(precision\))f(y)i(axis)g(pixel)f(location)0
 1797 y(ypos)h(-)g(\(double)f(precision\))f(y)i(axis)g(celestial)e
 (coordinate)g(\(usually)h(DEC\))g(\(deg\))0 1910 y(yrpix)g(-)i
 (\(double)e(precision\))f(Y)i(axis)g(reference)e(pixel)h(array)h
 (location)0 2023 y(yrval)f(-)i(\(double)e(precision\))f(Y)i(axis)g
 (coordinate)e(value)h(at)h(the)g(reference)e(pixel)i(\(deg\))p
 eop end
-%%Page: 130 136
-TeXDict begin 130 135 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.130) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(130)1779
-b Fh(CHAPTER)30 b(11.)112 b(P)-8 b(ARAMETER)30 b(DEFINITIONS)p
-eop end
-%%Page: 131 137
-TeXDict begin 131 136 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.131) cvn /DEST pdfmark end
- -8 191 a 0 464 a
-SDict begin H.S end
- 0 464 a
-0 464 a
-SDict begin 13.6 H.A end
- 0 464 a 0 464 a
-SDict begin [/View [/XYZ H.V]/Dest (chapter.12) cvn /DEST pdfmark end
- 0 464 a 761 x Fg(Chapter)65 b(12)0
+%%Page: 132 138
+TeXDict begin 132 137 bop 0 299 a Fj(132)1779 b Fh(CHAPTER)30
+b(11.)112 b(P)-8 b(ARAMETER)30 b(DEFINITIONS)p eop end
+%%Page: 133 139
+TeXDict begin 133 138 bop 0 1225 a Fg(Chapter)65 b(12)0
 1687 y Fm(FITSIO)76 b(Error)h(Status)h(Co)6 b(des)0 2180
 y Ff(Status)46 b(codes)g(in)i(the)f(range)f(-99)h(to)g(-999)94
 b(and)47 b(1)h(to)f(999)g(are)g(reserved)e(for)i(future)0
 2293 y(FITSIO)f(use.)95 2518 y(0)96 b(OK,)47 b(no)g(error)0
 2631 y(101)95 b(input)46 b(and)h(output)f(files)g(are)h(the)g(same)0
 2744 y(103)95 b(too)47 b(many)f(FITS)h(files)f(open)h(at)g(once;)f(all)
 h(internal)f(buffers)g(full)0 2857 y(104)95 b(error)46
@@ -17154,40 +13534,27 @@
 4890 y(126)95 b(parse)46 b(error)g(in)i(range)e(list)0
 5115 y(151)95 b(bad)47 b(argument)e(in)i(shared)f(memory)g(driver)0
 5228 y(152)95 b(null)46 b(pointer)g(passed)g(as)h(an)h(argument)0
 5341 y(153)95 b(no)47 b(more)f(free)h(shared)f(memory)g(handles)0
 5454 y(154)95 b(shared)46 b(memory)g(driver)g(is)h(not)g(initialized)0
 5567 y(155)95 b(IPC)47 b(error)f(returned)f(by)j(a)f(system)f(call)0
 5680 y(156)95 b(no)47 b(memory)f(in)h(shared)f(memory)g(driver)1882
-5942 y Fj(131)p eop end
-%%Page: 132 138
-TeXDict begin 132 137 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.132) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(132)1613
-b Fh(CHAPTER)30 b(12.)112 b(FITSIO)30 b(ERR)m(OR)g(ST)-8
-b(A)g(TUS)30 b(CODES)0 555 y Ff(157)95 b(resource)45
-b(deadlock)h(would)g(occur)0 668 y(158)95 b(attempt)45
-b(to)j(open/create)c(lock)j(file)g(failed)0 781 y(159)95
-b(shared)46 b(memory)g(block)g(cannot)g(be)h(resized)f(at)h(the)g
-(moment)0 1120 y(201)95 b(header)46 b(not)h(empty;)f(can't)g(write)g
-(required)g(keywords)0 1233 y(202)95 b(specified)45 b(keyword)h(name)g
-(was)h(not)g(found)g(in)g(the)g(header)0 1346 y(203)95
-b(specified)45 b(header)h(record)g(number)g(is)h(out)g(of)g(bounds)0
-1458 y(204)95 b(keyword)45 b(value)i(field)f(is)h(blank)0
-1571 y(205)95 b(keyword)45 b(value)i(string)f(is)h(missing)f(the)h
+5942 y Fj(133)p eop end
+%%Page: 134 140
+TeXDict begin 134 139 bop 0 299 a Fj(134)1613 b Fh(CHAPTER)30
+b(12.)112 b(FITSIO)30 b(ERR)m(OR)g(ST)-8 b(A)g(TUS)30
+b(CODES)0 555 y Ff(157)95 b(resource)45 b(deadlock)h(would)g(occur)0
+668 y(158)95 b(attempt)45 b(to)j(open/create)c(lock)j(file)g(failed)0
+781 y(159)95 b(shared)46 b(memory)g(block)g(cannot)g(be)h(resized)f(at)
+h(the)g(moment)0 1120 y(201)95 b(header)46 b(not)h(empty;)f(can't)g
+(write)g(required)g(keywords)0 1233 y(202)95 b(specified)45
+b(keyword)h(name)g(was)h(not)g(found)g(in)g(the)g(header)0
+1346 y(203)95 b(specified)45 b(header)h(record)g(number)g(is)h(out)g
+(of)g(bounds)0 1458 y(204)95 b(keyword)45 b(value)i(field)f(is)h(blank)
+0 1571 y(205)95 b(keyword)45 b(value)i(string)f(is)h(missing)f(the)h
 (closing)f(quote)g(character)0 1684 y(206)95 b(illegal)45
 b(indexed)h(keyword)g(name)h(\(e.g.)f('TFORM1000'\))0
 1797 y(207)95 b(illegal)45 b(character)h(in)h(keyword)f(name)g(or)i
 (header)e(record)0 1910 y(208)95 b(keyword)45 b(does)i(not)g(have)g
 (expected)e(name.)i(Keyword)e(out)i(of)g(sequence?)0
 2023 y(209)95 b(keyword)45 b(does)i(not)g(have)g(expected)e(integer)h
 (value)0 2136 y(210)95 b(could)46 b(not)h(find)g(the)f(required)g(END)h
@@ -17229,103 +13596,79 @@
 (name)h(template)e(matched)h(more)h(than)f(one)h(column)f(name)0
 5297 y(241)95 b(binary)46 b(table)g(row)h(width)f(is)i(not)e(equal)h
 (to)g(the)g(sum)g(of)g(the)g(field)f(widths)0 5410 y(251)95
 b(unrecognizable)44 b(type)i(of)h(FITS)g(extension)0
 5523 y(252)95 b(unrecognizable)44 b(FITS)i(record)0 5636
 y(253)95 b(END)47 b(keyword)e(contains)h(non-blank)f(characters)g(in)i
 (columns)f(9-80)p eop end
-%%Page: 133 139
-TeXDict begin 133 138 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.133) cvn /DEST pdfmark end
- -8 191 a 3764 299 a Fj(133)0
-555 y Ff(254)95 b(Header)46 b(fill)g(area)h(contains)f(non-blank)f
-(characters)0 668 y(255)95 b(Data)46 b(fill)h(area)g(contains)e
-(non-blank)g(on)j(non-zero)d(values)0 781 y(261)95 b(unable)46
-b(to)h(parse)f(the)h(TFORM)g(keyword)e(value)i(string)0
-894 y(262)95 b(unrecognizable)44 b(TFORM)i(datatype)f(code)0
-1007 y(263)95 b(illegal)45 b(TDIMn)i(keyword)f(value)0
-1233 y(301)95 b(illegal)45 b(HDU)i(number;)f(less)h(than)f(1)i(or)f
-(greater)f(than)h(internal)e(buffer)h(size)0 1346 y(302)95
-b(column)46 b(number)g(out)h(of)g(range)f(\(1)h(-)h(999\))0
-1458 y(304)95 b(attempt)45 b(to)j(move)e(to)h(negative)f(file)h(record)
-f(number)0 1571 y(306)95 b(attempted)45 b(to)i(read)g(or)g(write)f(a)i
-(negative)d(number)h(of)i(bytes)e(in)h(the)g(FITS)g(file)0
-1684 y(307)95 b(illegal)45 b(starting)h(row)h(number)f(for)h(table)f
-(read)h(or)g(write)f(operation)0 1797 y(308)95 b(illegal)45
-b(starting)h(element)g(number)g(for)h(table)f(read)h(or)g(write)f
-(operation)0 1910 y(309)95 b(attempted)45 b(to)i(read)g(or)g(write)f
-(character)g(string)g(in)h(non-character)d(table)i(column)0
-2023 y(310)95 b(attempted)45 b(to)i(read)g(or)g(write)f(logical)g
-(value)g(in)i(non-logical)c(table)j(column)0 2136 y(311)95
-b(illegal)45 b(ASCII)i(table)f(TFORM)h(format)f(code)g(for)h(attempted)
-e(operation)0 2249 y(312)95 b(illegal)45 b(binary)i(table)f(TFORM)g
-(format)g(code)h(for)g(attempted)e(operation)0 2362 y(314)95
-b(value)46 b(for)h(undefined)e(pixels)h(has)h(not)g(been)g(defined)0
-2475 y(317)95 b(attempted)45 b(to)i(read)g(or)g(write)f(descriptor)f
-(in)i(a)h(non-descriptor)c(field)0 2588 y(320)95 b(number)46
-b(of)h(array)f(dimensions)f(out)i(of)g(range)0 2700 y(321)95
-b(first)46 b(pixel)g(number)g(is)i(greater)d(than)i(the)g(last)g(pixel)
-f(number)0 2813 y(322)95 b(attempt)45 b(to)j(set)f(BSCALE)f(or)h
-(TSCALn)f(scaling)g(parameter)f(=)i(0)0 2926 y(323)95
-b(illegal)45 b(axis)i(length)f(less)h(than)f(1)0 3152
-y(340)h(NOT_GROUP_TABLE)d(340)142 b(Grouping)45 b(function)h(error)0
-3265 y(341)h(HDU_ALREADY_MEMBER)0 3378 y(342)g(MEMBER_NOT_FOUND)0
-3491 y(343)g(GROUP_NOT_FOUND)0 3604 y(344)g(BAD_GROUP_ID)0
-3717 y(345)g(TOO_MANY_HDUS_TRACKED)0 3830 y(346)g(HDU_ALREADY_TRACKED)0
-3942 y(347)g(BAD_OPTION)0 4055 y(348)g(IDENTICAL_POINTERS)0
-4168 y(349)g(BAD_GROUP_ATTACH)0 4281 y(350)g(BAD_GROUP_DETACH)0
-4507 y(360)g(NGP_NO_MEMORY)665 b(malloc)46 b(failed)0
-4620 y(361)h(NGP_READ_ERR)713 b(read)46 b(error)h(from)f(file)0
-4733 y(362)h(NGP_NUL_PTR)761 b(null)46 b(pointer)g(passed)g(as)h(an)g
-(argument.)1575 4846 y(Passing)f(null)g(pointer)g(as)h(a)h(name)f(of)
-1575 4959 y(template)f(file)g(raises)g(this)h(error)0
-5072 y(363)g(NGP_EMPTY_CURLINE)473 b(line)46 b(read)h(seems)f(to)h(be)h
+%%Page: 135 141
+TeXDict begin 135 140 bop 3764 299 a Fj(135)0 555 y Ff(254)95
+b(Header)46 b(fill)g(area)h(contains)f(non-blank)f(characters)0
+668 y(255)95 b(Data)46 b(fill)h(area)g(contains)e(non-blank)g(on)j
+(non-zero)d(values)0 781 y(261)95 b(unable)46 b(to)h(parse)f(the)h
+(TFORM)g(keyword)e(value)i(string)0 894 y(262)95 b(unrecognizable)44
+b(TFORM)i(datatype)f(code)0 1007 y(263)95 b(illegal)45
+b(TDIMn)i(keyword)f(value)0 1233 y(301)95 b(illegal)45
+b(HDU)i(number;)f(less)h(than)f(1)i(or)f(greater)f(than)h(internal)e
+(buffer)h(size)0 1346 y(302)95 b(column)46 b(number)g(out)h(of)g(range)
+f(\(1)h(-)h(999\))0 1458 y(304)95 b(attempt)45 b(to)j(move)e(to)h
+(negative)f(file)h(record)f(number)0 1571 y(306)95 b(attempted)45
+b(to)i(read)g(or)g(write)f(a)i(negative)d(number)h(of)i(bytes)e(in)h
+(the)g(FITS)g(file)0 1684 y(307)95 b(illegal)45 b(starting)h(row)h
+(number)f(for)h(table)f(read)h(or)g(write)f(operation)0
+1797 y(308)95 b(illegal)45 b(starting)h(element)g(number)g(for)h(table)
+f(read)h(or)g(write)f(operation)0 1910 y(309)95 b(attempted)45
+b(to)i(read)g(or)g(write)f(character)g(string)g(in)h(non-character)d
+(table)i(column)0 2023 y(310)95 b(attempted)45 b(to)i(read)g(or)g
+(write)f(logical)g(value)g(in)i(non-logical)c(table)j(column)0
+2136 y(311)95 b(illegal)45 b(ASCII)i(table)f(TFORM)h(format)f(code)g
+(for)h(attempted)e(operation)0 2249 y(312)95 b(illegal)45
+b(binary)i(table)f(TFORM)g(format)g(code)h(for)g(attempted)e(operation)
+0 2362 y(314)95 b(value)46 b(for)h(undefined)e(pixels)h(has)h(not)g
+(been)g(defined)0 2475 y(317)95 b(attempted)45 b(to)i(read)g(or)g
+(write)f(descriptor)f(in)i(a)h(non-descriptor)c(field)0
+2588 y(320)95 b(number)46 b(of)h(array)f(dimensions)f(out)i(of)g(range)
+0 2700 y(321)95 b(first)46 b(pixel)g(number)g(is)i(greater)d(than)i
+(the)g(last)g(pixel)f(number)0 2813 y(322)95 b(attempt)45
+b(to)j(set)f(BSCALE)f(or)h(TSCALn)f(scaling)g(parameter)f(=)i(0)0
+2926 y(323)95 b(illegal)45 b(axis)i(length)f(less)h(than)f(1)0
+3152 y(340)h(NOT_GROUP_TABLE)d(340)142 b(Grouping)45
+b(function)h(error)0 3265 y(341)h(HDU_ALREADY_MEMBER)0
+3378 y(342)g(MEMBER_NOT_FOUND)0 3491 y(343)g(GROUP_NOT_FOUND)0
+3604 y(344)g(BAD_GROUP_ID)0 3717 y(345)g(TOO_MANY_HDUS_TRACKED)0
+3830 y(346)g(HDU_ALREADY_TRACKED)0 3942 y(347)g(BAD_OPTION)0
+4055 y(348)g(IDENTICAL_POINTERS)0 4168 y(349)g(BAD_GROUP_ATTACH)0
+4281 y(350)g(BAD_GROUP_DETACH)0 4507 y(360)g(NGP_NO_MEMORY)665
+b(malloc)46 b(failed)0 4620 y(361)h(NGP_READ_ERR)713
+b(read)46 b(error)h(from)f(file)0 4733 y(362)h(NGP_NUL_PTR)761
+b(null)46 b(pointer)g(passed)g(as)h(an)g(argument.)1575
+4846 y(Passing)f(null)g(pointer)g(as)h(a)h(name)f(of)1575
+4959 y(template)f(file)g(raises)g(this)h(error)0 5072
+y(363)g(NGP_EMPTY_CURLINE)473 b(line)46 b(read)h(seems)f(to)h(be)h
 (empty)e(\(used)1575 5185 y(internally\))0 5297 y(364)h
 (NGP_UNREAD_QUEUE_FULL)281 b(cannot)46 b(unread)g(more)g(then)h(1)g
 (line)g(\(or)g(single)1575 5410 y(line)g(twice\))0 5523
 y(365)g(NGP_INC_NESTING)569 b(too)46 b(deep)h(include)f(file)h(nesting)
 e(\(infinite)1575 5636 y(loop,)h(template)g(includes)f(itself)i(?\))p
 eop end
-%%Page: 134 140
-TeXDict begin 134 139 bop 0 0 a
-SDict begin /product where{pop product(Distiller)search{pop pop pop
-version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
-closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
-grestore}if}{pop}ifelse}{pop}ifelse}if end
- 0 0 a -8 191 a
-SDict begin H.S end
- -8 191
-a -8 191 a
-SDict begin H.R end
- -8 191 a -8 191 a
-SDict begin [/View [/XYZ H.V]/Dest (page.134) cvn /DEST pdfmark end
- -8 191 a 0 299 a Fj(134)1613
-b Fh(CHAPTER)30 b(12.)112 b(FITSIO)30 b(ERR)m(OR)g(ST)-8
-b(A)g(TUS)30 b(CODES)0 555 y Ff(366)47 b(NGP_ERR_FOPEN)665
-b(fopen\(\))45 b(failed,)h(cannot)g(open)h(template)e(file)0
-668 y(367)i(NGP_EOF)953 b(end)46 b(of)i(file)e(encountered)f(and)i(not)
-g(expected)0 781 y(368)g(NGP_BAD_ARG)761 b(bad)46 b(arguments)g
-(passed.)g(Usually)f(means)1575 894 y(internal)h(parser)g(error.)g
-(Should)g(not)h(happen)0 1007 y(369)g(NGP_TOKEN_NOT_EXPECT)329
-b(token)46 b(not)h(expected)e(here)0 1233 y(401)95 b(error)46
-b(attempting)f(to)i(convert)f(an)h(integer)f(to)h(a)h(formatted)d
-(character)g(string)0 1346 y(402)95 b(error)46 b(attempting)f(to)i
-(convert)f(a)h(real)g(value)f(to)i(a)f(formatted)e(character)h(string)0
-1458 y(403)95 b(cannot)46 b(convert)g(a)h(quoted)f(string)g(keyword)g
-(to)h(an)g(integer)0 1571 y(404)95 b(attempted)45 b(to)i(read)g(a)g
+%%Page: 136 142
+TeXDict begin 136 141 bop 0 299 a Fj(136)1613 b Fh(CHAPTER)30
+b(12.)112 b(FITSIO)30 b(ERR)m(OR)g(ST)-8 b(A)g(TUS)30
+b(CODES)0 555 y Ff(366)47 b(NGP_ERR_FOPEN)665 b(fopen\(\))45
+b(failed,)h(cannot)g(open)h(template)e(file)0 668 y(367)i(NGP_EOF)953
+b(end)46 b(of)i(file)e(encountered)f(and)i(not)g(expected)0
+781 y(368)g(NGP_BAD_ARG)761 b(bad)46 b(arguments)g(passed.)g(Usually)f
+(means)1575 894 y(internal)h(parser)g(error.)g(Should)g(not)h(happen)0
+1007 y(369)g(NGP_TOKEN_NOT_EXPECT)329 b(token)46 b(not)h(expected)e
+(here)0 1233 y(401)95 b(error)46 b(attempting)f(to)i(convert)f(an)h
+(integer)f(to)h(a)h(formatted)d(character)g(string)0
+1346 y(402)95 b(error)46 b(attempting)f(to)i(convert)f(a)h(real)g
+(value)f(to)i(a)f(formatted)e(character)h(string)0 1458
+y(403)95 b(cannot)46 b(convert)g(a)h(quoted)f(string)g(keyword)g(to)h
+(an)g(integer)0 1571 y(404)95 b(attempted)45 b(to)i(read)g(a)g
 (non-logical)e(keyword)h(value)g(as)h(a)h(logical)e(value)0
 1684 y(405)95 b(cannot)46 b(convert)g(a)h(quoted)f(string)g(keyword)g
 (to)h(a)h(real)e(value)0 1797 y(406)95 b(cannot)46 b(convert)g(a)h
 (quoted)f(string)g(keyword)g(to)h(a)h(double)e(precision)f(value)0
 1910 y(407)95 b(error)46 b(attempting)f(to)i(read)g(character)e(string)
 h(as)h(an)h(integer)0 2023 y(408)95 b(error)46 b(attempting)f(to)i
 (read)g(character)e(string)h(as)h(a)h(real)e(value)0
```

#### ps2ascii {}

```diff
@@ -1,17 +1,17 @@
                     FITSIO User’s Guide
              ASubroutine Interface to FITS Format Files
                        for Fortran Programmers
-                               Version 3.0
-                                HEASARC
+                               Version 4.2
+                               HEASARC
                                 Code 662
                            Goddard Space Flight Center
                              Greenbelt, MD 20771
                                  USA
-                               April 2016
+                               Nov 2022
        ii
                   Contents
                   1 Introduction                                                                                               1
                   2   Creating FITSIO/CFITSIO                                                                                  3
                      2.1   Building the Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        3
                      2.2   Testing the Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .       6
                      2.3   Linking Programs with FITSIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .            7
@@ -54,20 +54,20 @@
                      6.4   FITS Header I/O Subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          43
                            6.4.1    Header Space and Position Routines . . . . . . . . . . . . . . . . . . . . . . .          43
                            6.4.2    Read or Write Standard Header Routines . . . . . . . . . . . . . . . . . . . .            43
                            6.4.3    Write Keyword Subroutines         . . . . . . . . . . . . . . . . . . . . . . . . . . .   45
                            6.4.4    Insert Keyword Subroutines        . . . . . . . . . . . . . . . . . . . . . . . . . . .   47
                            6.4.5    Read Keyword Subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . .          47
                            6.4.6    Modify Keyword Subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . .          49
-                           6.4.7    Update Keyword Subroutines          . . . . . . . . . . . . . . . . . . . . . . . . . .   50
+                           6.4.7    Update Keyword Subroutines           . . . . . . . . . . . . . . . . . . . . . . . . . .  50
                            6.4.8    Delete Keyword Subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . .          51
                      6.5   Data Scaling and Undeﬁned Pixel Parameters              . . . . . . . . . . . . . . . . . . . . .  51
                      6.6   FITS Primary Array or IMAGE Extension I/O Subroutines                   . . . . . . . . . . . . .  52
-                     6.7   FITS ASCII and Binary Table Data I/O Subroutines . . . . . . . . . . . . . . . . . .               55
-                           6.7.1    Column Information Subroutines          . . . . . . . . . . . . . . . . . . . . . . . .   55
+                     6.7   FITS ASCII and Binary Table Data I/O Subroutines . . . . . . . . . . . . . . . . . .               56
+                           6.7.1    Column Information Subroutines           . . . . . . . . . . . . . . . . . . . . . . . .  56
                            6.7.2    Low-Level Table Access Subroutines . . . . . . . . . . . . . . . . . . . . . . .          58
                            6.7.3    Edit Rows or Columns        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   59
                            6.7.4    Read and Write Column Data Routines . . . . . . . . . . . . . . . . . . . . .             60
                   CONTENTS                                                                                                      v
                       6.8   Row Selection and Calculator Routines          . . . . . . . . . . . . . . . . . . . . . . . . .   64
                       6.9   Celestial Coordinate System Subroutines          . . . . . . . . . . . . . . . . . . . . . . . .   65
                       6.10 File Checksum Subroutines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .           67
@@ -90,29 +90,29 @@
                       8.8   Image Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .      91
                       8.9   Image Transform Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        92
                       8.10 Column and Keyword Filtering Speciﬁcation             . . . . . . . . . . . . . . . . . . . . . .   94
                       8.11 Row Filtering Speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .          97
                             8.11.1 General Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .        97
                             8.11.2 Bit Masks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
                             8.11.3 Vector Columns        . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
-                            8.11.4 Good Time Interval Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
-                            8.11.5 Spatial Region Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
-                            8.11.6 Example Row Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
-                      8.12  Binning or Histogramming Speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . 107
-                  9 Template Files                                                                                           111
+                            8.11.4 Good Time Interval Filtering and Calculation . . . . . . . . . . . . . . . . . . 103
+                            8.11.5 Spatial Region Filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
+                            8.11.6 Example Row Filters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
+                      8.12  Binning or Histogramming Speciﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . 108
+                  9 Template Files                                                                                           113
                 vi                                                                                       CONTENTS
-                    9.1  Detailed Template Line Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
-                    9.2  Auto-indexing of Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
-                    9.3  Template Parser Directives     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
-                    9.4  Formal Template Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
-                    9.5  Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
-                    9.6  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
-                10 Summary of all FITSIO User-Interface Subroutines                                                117
-                11 Parameter Deﬁnitions                                                                            125
-                12 FITSIO Error Status Codes                                                                       131
+                    9.1  Detailed Template Line Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
+                    9.2  Auto-indexing of Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
+                    9.3  Template Parser Directives     . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
+                    9.4  Formal Template Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
+                    9.5  Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
+                    9.6  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
+                10 Summary of all FITSIO User-Interface Subroutines                                               119
+                11 Parameter Deﬁnitions                                                                           127
+                12 FITSIO Error Status Codes                                                                      133
        Chapter 1
        Introduction
        This document describes the Fortran-callable subroutine interface that is provided as part of the
        CFITSIO library (which is written in ANSI C). This is a companion document to the CFITSIO
        User’s Guide which should be consulted for further information about the underlying CFITSIO
        library. In the remainder of this document, the terms FITSIO and CFITSIO are interchangeable
        and refer to the same library.
@@ -255,57 +255,51 @@
                   be compatible with some, but probably not all, available Fortran compilers. To test if they are
                   compatible, compile the program testf77.f and try linking to these dll libraries. If these libraries do
                   not work with a particular Fortran compiler, then it may be necessary to modify the ﬁle ”cfortran.h”
                   to support that particular combination of C and Fortran compilers, and then rebuild the CFITSIO
                   dll library. This will require, however, some expertise in mixed language programming.
                   CFITSIO should be compatible with most current ANCI C and C++ compilers: Cray supercom-
                   puters are currently not supported.
-             6                                        CHAPTER2. CREATINGFITSIO/CFITSIO
-             2.2    Testing the Library
-             The CFITSIO library should be tested by building and running the testprog.c program that is
-             included with the release. On Unix systems type:
-                 % make testprog
-                 % testprog > testprog.lis
-                 % diff testprog.lis testprog.out
-                 % cmp testprog.fit testprog.std
-             OnVMSsystems, (assuming cc is the name of the C compiler command), type:
-                 $ cc testprog.c
-                 $ link testprog, cfitsio/lib, alpha$library:vaxcrtl/lib
-                 $ run testprog
-             The testprog program should produce a FITS ﬁle called ‘testprog.ﬁt’ that is identical to the ‘test-
-             prog.std’ FITS ﬁle included with this release. The diagnostic messages (which were piped to the ﬁle
-             testprog.lis in the Unix example) should be identical to the listing contained in the ﬁle testprog.out.
-             The ’diﬀ’ and ’cmp’ commands shown above should not report any diﬀerences in the ﬁles. (There
-             may be some minor formatting diﬀerences, such as the presence or absence of leading zeros, or 3
-             digit exponents in numbers, which can be ignored).
-             The Fortran wrappers in CFITSIO may be tested with the testf77 program. On Unix systems the
-             fortran compilation and link command may be called ’f77’ or ’g77’, depending on the system.
-                % f77 -o testf77 testf77.f -L. -lcfitsio -lnsl -lsocket
-              or
-                % f77 -f -o testf77 testf77.f -L. -lcfitsio    (under SUN O/S)
-              or
-                % f77 -o testf77 testf77.f -Wl,-L. -lcfitsio -lm -lnsl -lsocket (HP/UX)
-              or
-                % g77 -o testf77 -s testf77.f -lcfitsio -lcc_dynamic -lncurses (Mac OS-X)
-                % testf77 > testf77.lis
-                % diff testf77.lis testf77.out
-                % cmp testf77.fit testf77.std
-             On machines running SUN O/S, Fortran programs must be compiled with the ’-f’ option to force
-             double precision variables to be aligned on 8-byte boundaries to make the fortran-declared variables
-             compatible with C. A similar compiler option may be required on other platforms. Failing to use
-             this option may cause the program to crash on FITSIO routines that read or write double precision
-             variables.
-             OnWindowsplatforms, linking Fortran programs with a C library often depends on the particular
-             compilers involved. Some users have found the following commands work when using the Intel
-             Fortran compiler:
+           6                                 CHAPTER2. CREATINGFITSIO/CFITSIO
+           2.2  Testing the Library
+           The CFITSIO library should be tested by building and running the testprog.c program that is
+           included with the release. On Unix systems type:
+              % make testprog
+              % testprog > testprog.lis
+              % diff testprog.lis testprog.out
+              % cmp testprog.fit testprog.std
+           OnVMSsystems, (assuming cc is the name of the C compiler command), type:
+              $ cc testprog.c
+              $ link testprog, cfitsio/lib, alpha$library:vaxcrtl/lib
+              $ run testprog
+           The testprog program should produce a FITS ﬁle called ‘testprog.ﬁt’ that is identical to the ‘test-
+           prog.std’ FITS ﬁle included with this release. The diagnostic messages (which were piped to the ﬁle
+           testprog.lis in the Unix example) should be identical to the listing contained in the ﬁle testprog.out.
+           The ’diﬀ’ and ’cmp’ commands shown above should not report any diﬀerences in the ﬁles. (There
+           may be some minor formatting diﬀerences, such as the presence or absence of leading zeros, or 3
+           digit exponents in numbers, which can be ignored).
+           The Fortran wrappers in CFITSIO may be tested with the testf77 program. On Unix systems the
+           Fortran compiler is typically called ’gfortran’. -
+              % gfortran -o testf77 testf77.f -L. -lcfitsio -lz -lcurl
+              % testf77 > testf77.lis
+              % diff testf77.lis testf77.out
+              % cmp testf77.fit testf77.std
+           On machines running SUN O/S, Fortran programs must be compiled with the ’-f’ option to force
+           double precision variables to be aligned on 8-byte boundaries to make the fortran-declared variables
+           compatible with C. A similar compiler option may be required on other platforms. Failing to use
+           this option may cause the program to crash on FITSIO routines that read or write double precision
+           variables.
+           OnWindowsplatforms, linking Fortran programs with a C library often depends on the particular
+           compilers involved. Some users have found the following commands work when using the Intel
+           Fortran compiler:
+           ifort /libs.dll cfitsio.lib /MD testf77.f /Gm
+           or possibly,
+           ifort /libs:dll cfitsio.lib /MD /fpp /extfpp:cfortran.h,fitsio.h
+              /iface:cvf testf77.f
                   2.3.  LINKING PROGRAMS WITH FITSIO                                                                            7
-                  ifort /libs.dll cfitsio.lib /MD testf77.f /Gm
-                  or possibly,
-                  ifort /libs:dll cfitsio.lib /MD /fpp /extfpp:cfortran.h,fitsio.h
-                       /iface:cvf testf77.f
                   Also note that on some systems the output listing of the testf77 program may diﬀer slightly from
                   the testf77.std template if leading zeros are not printed by default before the decimal point when
                   using F format.
                   Afew other utility programs are included with CFITSIO:
                        speed - measures the maximum throughput (in MB per second)
                                      for writing and reading FITS files with CFITSIO
                        listhead - lists all the header keywords in any FITS file
@@ -324,19 +318,19 @@
                   only for FTP and HTTP ﬁle access). These latter 2 libraries are not needed on VMS and Windows
                   platforms, because FTP ﬁle access is not currently supported on those platforms.
                   Note that when upgrading to a newer version of CFITSIO it is usually necessary to recompile, as
                   well as relink, the programs that use CFITSIO, because the deﬁnitions in ﬁtsio.h often change.
                   2.4     Getting Started with FITSIO
                   In order to eﬀectively use the FITSIO library as quickly as possible, it is recommended that new
                   users follow these steps:
+                  1. Read the following ‘FITS Primer’ chapter for a brief overview of the structure of FITS ﬁles.
+                  This is especially important for users who have not previously dealt with the FITS table and image
+                  extensions.
+                  2. Write a simple program to read or write a FITS ﬁle using the Basic Interface routines.
            8                                 CHAPTER2. CREATINGFITSIO/CFITSIO
-           1. Read the following ‘FITS Primer’ chapter for a brief overview of the structure of FITS ﬁles.
-           This is especially important for users who have not previously dealt with the FITS table and image
-           extensions.
-           2. Write a simple program to read or write a FITS ﬁle using the Basic Interface routines.
            3. Refer to the cookbook.f program that is included with this release for examples of routines that
            perform various common FITS ﬁle operations.
            4. Read Chapters 4 and 5 to become familiar with the conventions and advanced features of the
            FITSIO interface.
            5. Scan through the more extensive set of routines that are provided in the ‘Advanced Interface’.
            Theseroutinesperformmorespecialized functionsthanare providedbytheBasic Interface routines.
            2.5  Example Program
@@ -359,18 +353,18 @@
                 call ftinit(unit,filename,blocksize,status)
            C    initialize parameters about the FITS image (300 x 200 16-bit integers)
                 simple=.true.
                 bitpix=16
                 naxis=2
                 naxes(1)=300
                 naxes(2)=200
+                extend=.true.
+           C    write the required header keywords
+                call ftphpr(unit,simple,bitpix,naxis,naxes,0,1,extend,status)
                   2.6.  LEGALSTUFF                                                                                              9
-                          extend=.true.
-                  C       write the required header keywords
-                          call ftphpr(unit,simple,bitpix,naxis,naxes,0,1,extend,status)
                   C       initialize the values in the image with a linear ramp function
                           do j=1,naxes(2)
                                do i=1,naxes(1)
                                      array(i,j)=i+j
                                end do
                           end do
                   C       write the array to the FITS file
@@ -397,61 +391,61 @@
                   ANYWARRANTYTHATTHESOFTWAREWILLCONFORMTOSPECIFICATIONS,ANY
                   IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PUR-
                   POSE,ANDFREEDOMFROMINFRINGEMENT,ANDANYWARRANTYTHATTHEDOC-
                   UMENTATIONWILLCONFORMTOTHESOFTWARE,ORANYWARRANTYTHATTHE
                   SOFTWAREWILLBEERRORFREE.INNOEVENTSHALLNASABELIABLEFORANY
                   DAMAGES,INCLUDING,BUTNOTLIMITEDTO,DIRECT,INDIRECT,SPECIALORCON-
                   SEQUENTIALDAMAGES, ARISINGOUTOF,RESULTINGFROM,ORINANYWAYCON-
-         10                           CHAPTER2. CREATINGFITSIO/CFITSIO
-         NECTEDWITHTHISSOFTWARE,WHETHERORNOTBASEDUPONWARRANTY,CON-
-         TRACT,TORT,OROTHERWISE,WHETHERORNOTINJURYWASSUSTAINEDBYPER-
-         SONSORPROPERTYOROTHERWISE,ANDWHETHERORNOTLOSSWASSUSTAINED
-         FROM, OR AROSE OUT OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SER-
-         VICES PROVIDED HEREUNDER.”
-         2.7  Acknowledgments
-         The development of many of the powerful features in CFITSIO was made possible through collab-
-         orations with many people or organizations from around the world. The following, in particular,
-         have made especially signiﬁcant contributions:
-         Programmers from the Integral Science Data Center, Switzerland (namely, Jurek Borkowski, Bruce
-         O’Neel, and Don Jennings), designed the concept for the plug-in I/O drivers that was introduced
-         with CFITSIO 2.0. The use of ‘drivers’ greatly simpliﬁed the low-level I/O, which in turn made
-         other new features in CFITSIO (e.g., support for compressed FITS ﬁles and support for IRAF
-         format image ﬁles) much easier to implement. Jurek Borkowski wrote the Shared Memory driver,
-         andBruceO’Neel wrote the drivers for accessing FITS ﬁles over the network using the FTP, HTTP,
-         and ROOT protocols.
-         The ISDC also provided the template parsing routines (written by Jurek Borkowski) and the
-         hierarchical grouping routines (written by Don Jennings). The ISDC DAL (Data Access Layer)
-         routines are layered on top of CFITSIO and make extensive use of these features.
-         UweLammers(XMM/ESA/ESTEC,TheNetherlands)designedthehigh-performancelexical pars-
-         ing algorithm that is used to do on-the-ﬂy ﬁltering of FITS tables. This algorithm essentially
-         pre-compiles the user-supplied selection expression into a form that can be rapidly evaluated for
-         each row. Peter Wilson (RSTX, NASA/GSFC) then wrote the parsing routines used by CFITSIO
-         based on Lammers’ design, combined with other techniques such as the CFITSIO iterator routine
-         to further enhance the data processing throughput. This eﬀort also beneﬁted from a much earlier
-         lexical parsing routine that was developed by Kent Blackburn (NASA/GSFC). More recently, Craig
-         Markwardt (NASA/GSFC) implemented additional functions (median, average, stddev) and other
-         enhancements to the lexical parser.
-         The CFITSIO iterator function is loosely based on similar ideas developed for the XMM Data
-         Access Layer.
-         Peter Wilson (RSTX, NASA/GSFC) wrote the complete set of Fortran-callable wrappers for all the
-         CFITSIO routines, which in turn rely on the CFORTRAN macro developed by Burkhard Burow.
-         The syntax used by CFITSIO for ﬁltering or binning input FITS ﬁles is based on ideas developed
-         for the AXAF Science Center Data Model by Jonathan McDowell, Antonella Fruscione, Aneta
-         Siemiginowska and Bill Joye. See http://heasarc.gsfc.nasa.gov/docs/journal/axaf7.html for further
-         description of the AXAF Data Model.
-         The ﬁle decompression code were taken directly from the gzip (GNU zip) program developed by
-         Jean-loup Gailly and others.
-         Doug Mink, SAO, provided the routines for converting IRAF format images into FITS format.
+                  NECTEDWITHTHISSOFTWARE,WHETHERORNOTBASEDUPONWARRANTY,CON-
+                  TRACT,TORT,OROTHERWISE,WHETHERORNOTINJURYWASSUSTAINEDBYPER-
+                  SONSORPROPERTYOROTHERWISE,ANDWHETHERORNOTLOSSWASSUSTAINED
+                  FROM, OR AROSE OUT OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SER-
+                  VICES PROVIDED HEREUNDER.”
+           10                                CHAPTER2. CREATINGFITSIO/CFITSIO
+           2.7  Acknowledgments
+           The development of many of the powerful features in CFITSIO was made possible through collab-
+           orations with many people or organizations from around the world. The following, in particular,
+           have made especially signiﬁcant contributions:
+           Programmers from the Integral Science Data Center, Switzerland (namely, Jurek Borkowski, Bruce
+           O’Neel, and Don Jennings), designed the concept for the plug-in I/O drivers that was introduced
+           with CFITSIO 2.0. The use of ‘drivers’ greatly simpliﬁed the low-level I/O, which in turn made
+           other new features in CFITSIO (e.g., support for compressed FITS ﬁles and support for IRAF
+           format image ﬁles) much easier to implement. Jurek Borkowski wrote the Shared Memory driver,
+           andBruceO’Neel wrote the drivers for accessing FITS ﬁles over the network using the FTP, HTTP,
+           and ROOT protocols.
+           The ISDC also provided the template parsing routines (written by Jurek Borkowski) and the
+           hierarchical grouping routines (written by Don Jennings). The ISDC DAL (Data Access Layer)
+           routines are layered on top of CFITSIO and make extensive use of these features.
+           UweLammers(XMM/ESA/ESTEC,TheNetherlands)designedthehigh-performancelexical pars-
+           ing algorithm that is used to do on-the-ﬂy ﬁltering of FITS tables. This algorithm essentially
+           pre-compiles the user-supplied selection expression into a form that can be rapidly evaluated for
+           each row. Peter Wilson (RSTX, NASA/GSFC) then wrote the parsing routines used by CFITSIO
+           based on Lammers’ design, combined with other techniques such as the CFITSIO iterator routine
+           to further enhance the data processing throughput. This eﬀort also beneﬁted from a much earlier
+           lexical parsing routine that was developed by Kent Blackburn (NASA/GSFC). More recently, Craig
+           Markwardt (NASA/GSFC) implemented additional functions (median, average, stddev) and other
+           enhancements to the lexical parser.
+           The CFITSIO iterator function is loosely based on similar ideas developed for the XMM Data
+           Access Layer.
+           Peter Wilson (RSTX, NASA/GSFC) wrote the complete set of Fortran-callable wrappers for all the
+           CFITSIO routines, which in turn rely on the CFORTRAN macro developed by Burkhard Burow.
+           The syntax used by CFITSIO for ﬁltering or binning input FITS ﬁles is based on ideas developed
+           for the AXAF Science Center Data Model by Jonathan McDowell, Antonella Fruscione, Aneta
+           Siemiginowska and Bill Joye. See http://heasarc.gsfc.nasa.gov/docs/journal/axaf7.html for further
+           description of the AXAF Data Model.
+           The ﬁle decompression code were taken directly from the gzip (GNU zip) program developed by
+           Jean-loup Gailly and others.
+           Doug Mink, SAO, provided the routines for converting IRAF format images into FITS format.
+           Martin Reinecke (Max Planck Institute, Garching)) provided the modiﬁcations to cfortran.h that
+           are necessary to support 64-bit integer values when calling C routines from fortran programs. The
+           cfortran.h macros were originally developed by Burkhard Burow (CERN).
+           Julian Taylor (ESO, Garching) provided the fast byte-swapping algorithms that use the SSE2 and
+           SSSE3 machine instructions available on x86 64 CPUs.
+           In addition, many other people have made valuable contributions to the development of CFITSIO.
                   2.7.  ACKNOWLEDGMENTS                                                                                        11
-                  Martin Reinecke (Max Planck Institute, Garching)) provided the modiﬁcations to cfortran.h that
-                  are necessary to support 64-bit integer values when calling C routines from fortran programs. The
-                  cfortran.h macros were originally developed by Burkhard Burow (CERN).
-                  Julian Taylor (ESO, Garching) provided the fast byte-swapping algorithms that use the SSE2 and
-                  SSSE3 machine instructions available on x86 64 CPUs.
-                  In addition, many other people have made valuable contributions to the development of CFITSIO.
                   These include (with apologies to others that may have inadvertently been omitted):
                   Steve Allen, Carl Akerlof, Keith Arnaud, Morten Krabbe Barfoed, Kent Blackburn, G Bodammer,
                   Romke Bontekoe, Lucio Chiappetti, Keith Costorf, Robin Corbet, John Davis, Richard Fink, Ning
                   Gan, Emily Greene, Joe Harrington, Cheng Ho, Phil Hodge, Jim Ingham, Yoshitaka Ishisaki, Diab
                   Jerius, Mark Levine, Todd Karakaskian, Edward King, Scott Koch, Claire Larkin, Rob Managan,
                   Eric Mandel, John Mattox, Carsten Meyer, Emi Miyata, Stefan Mochnacki, Mike Noble, Oliver
                   Oberdorf, Clive Page, Arvind Parmar, Jeﬀ Pedelty, Tim Pearson, Maren Purves, Scott Randall,
@@ -549,15 +543,15 @@
            on a platform that supports large ﬁles, then it can read and write FITS ﬁles that contain up to
            2**31 2880-byte FITS records, or approximately 6 terabytes in size. It is still required that the
            value of the NAXISn and PCOUNT keywords in each extension be within the range of a signed 4-
            byte integer (max value = 2,147,483,648). Thus, each dimension of an image (given by the NAXISn
            keywords), the total width of a table (NAXIS1 keyword), the number of rows in a table (NAXIS2
            keyword), and the total size of the variable-length array heap in binary tables (PCOUNT keyword)
            must be less than this limit.
-                                             15
+                                            15
            16                      CHAPTER4. FITSIOCONVENTIONSANDGUIDELINES
            Currently, support for large ﬁles within CFITSIO has been tested on the Linux, Solaris, and IBM
            AIX operating systems.
            4.2  Multiple Access to the Same FITS File
            CFITSIO supports simultaneous read and write access to multiple HDUs in the same FITS ﬁle.
            Thus, one can open the same FITS ﬁle twice within a single program and move to 2 diﬀerent
            HDUsin the ﬁle, and then read and write data or keywords to the 2 extensions just as if one were
@@ -745,15 +739,15 @@
            modiﬁcation. This does not work for double precision values on VAX/VMS machines, however,
            where there is no easy way to bypass the default interpretation of the IEEE special values. This
            is also not supported when reading ﬂoating-point images that have been compressed with the
            FITS tiled image compression convention that is discussed in section 5.6; the pixels values in tile
            compressed images are represented by scaled integers, and a reserved integer value (not a NaN) is
            used to represent undeﬁned pixels.
             4.11. WHEN THE FINAL SIZE OF THE FITS HDU IS UNKNOWN                  21
-            4.11  When the Final Size of the FITS HDU is Unknown
+            4.11   When the Final Size of the FITS HDU is Unknown
             It is not required to know the total size of a FITS data array or table before beginning to write the
             data to the FITS ﬁle. In the case of the primary array or an image extension, one should initially
             create the array with the size of the highest dimension (largest NAXISn keyword) set to a dummy
             value, such as 1. Then after all the data have been written and the true dimensions are known, then
             the NAXISn value should be updated using the ﬁts update key routine before moving to another
             extension or closing the FITS ﬁle.
             Whenwriting to FITS tables, CFITSIO automatically keeps track of the highest row number that
@@ -771,15 +765,15 @@
             to 30. The one exception to this automatic updating of the NAXIS2 keyword is if the application
             program directly modiﬁes the value of NAXIS2 (up or down) itself just before closing the table. In
             this case, CFITSIO does not update NAXIS2 again, since it assumes that the application program
             must have had a good reason for changing the value directly. This is not recommended, however,
             and is only provided for backward compatibility with software that initially creates a table with
             a large number of rows, than decreases the NAXIS2 value to the actual smaller value just before
             closing the table.
-            4.12  Local FITS Conventions supported by FITSIO
+            4.12   Local FITS Conventions supported by FITSIO
             CFITSIO supports several local FITS conventions which are not deﬁned in the oﬃcial FITS stan-
             dard and which are not necessarily recognized or supported by other FITS software packages.
             Programmers should be cautious about using these features, especially if the FITS ﬁles that are
             produced are expected to be processed by other software systems which do not use the CFITSIO
             interface.
             4.12.1 Support for Long String Keyword Values.
             Thelength of a standard FITS string keyword is limited to 68 characters because it must ﬁt entirely
@@ -823,51 +817,51 @@
              uses the TDIMn keyword. For example, if TFORMn = ’60A’ and TDIMn = ’(12,5)’ then that
              column will be interpreted as containing an array of 5 strings, each 12 characters long.
              FITSIO also supports a local convention for the format of the TFORMn keyword value of the
              form ’rAw’ where ’r’ is an integer specifying the total width in characters of the column, and
              ’w’ is an integer specifying the (ﬁxed) length of an individual unit string within the vector. For
              example, TFORM1 = ’120A10’ would indicate that the binary table column is 120 characters
              wide and consists of 12 10-character length strings. This convention is recognized by the FITSIO
-           4.12. LOCAL FITS CONVENTIONS SUPPORTED BY FITSIO                      23
-           subroutines that read or write strings in binary tables. The Binary Table deﬁnition document
-           speciﬁes that other optional characters may follow the datatype code in the TFORM keyword, so
-           this local convention is in compliance with the FITS standard, although other FITS readers are
-           not required to recognize this convention.
-           4.12.3  Keyword Units Strings
-           One deﬁciency of the current FITS Standard is that it does not deﬁne a speciﬁc convention for
-           recording the physical units of a keyword value. The TUNITn keyword can be used to specify the
-           physical units of the values in a table column, but there is no analogous convention for keyword
-           values. The comment ﬁeld of the keyword is often used for this purpose, but the units are usually
-           not speciﬁed in a well deﬁned format that FITS readers can easily recognize and extract.
-           To solve this deﬁciency, FITSIO uses a local convention in which the keyword units are enclosed in
-           squarebrackets as theﬁrsttoken in thekeyword commentﬁeld; morespeciﬁcally, theopeningsquare
-           bracket immediately follows the slash ’/’ comment ﬁeld delimiter and a single space character. The
-           following examples illustrate keywords that use this convention:
-           EXPOSURE=            1800.0 / [s] elapsed exposure time
-           V_HELIO =             16.23 / [km s**(-1)] heliocentric velocity
-           LAMBDA =              5400. / [angstrom] central wavelength
-           FLUX   = 4.9033487787637465E-30 / [J/cm**2/s] average flux
-           In general, the units named in the IAU(1988) Style Guide are recommended, with the main excep-
-           tion that the preferred unit for angle is ’deg’ for degrees.
-           TheFTPUNTandFTGUNTsubroutinesinFITSIOwriteandread,respectively, thekeywordunit
-           strings in an existing keyword.
-           4.12.4  HIERARCHConvention for Extended Keyword Names
-           CFITSIO supports the HIERARCH keyword convention which allows keyword names that are
-           longer than 8 characters. This convention was developed at the European Southern Observatory
-           (ESO) and allows characters consisting of digits 0-9, upper case letters A-Z, the dash ’-’ and the
-           underscore ’ ’. The components of hierarchical keywords are separated by a single ASCII space
-           charater. For instance:
-           HIERARCH ESO INS FOCU POS = -0.00002500 / Focus position
-           Basically, this convention uses the FITS keyword ’HIERARCH’ to indicate that this convention
-           is being used, then the actual keyword name (’ESO INS FOCU POS’ in this example) begins in
-           column 10. The equals sign marks the end of the keyword name and is followed by the usual
-           value and comment ﬁelds just as in standard FITS keywords. Further details of this convention
-           are described at http://ﬁts.gsfc.nasa.gov/registry/hierarch keyword.html and in Section 4.4 of the
-           ESO Data Interface Control Document that is linked to from http://archive.eso.org/cms/tools-
-           documentation/eso-data-interface-control.html.
+            4.12. LOCAL FITS CONVENTIONS SUPPORTED BY FITSIO                     23
+            subroutines that read or write strings in binary tables. The Binary Table deﬁnition document
+            speciﬁes that other optional characters may follow the datatype code in the TFORM keyword, so
+            this local convention is in compliance with the FITS standard, although other FITS readers are
+            not required to recognize this convention.
+            4.12.3 Keyword Units Strings
+            One deﬁciency of the current FITS Standard is that it does not deﬁne a speciﬁc convention for
+            recording the physical units of a keyword value. The TUNITn keyword can be used to specify the
+            physical units of the values in a table column, but there is no analogous convention for keyword
+            values. The comment ﬁeld of the keyword is often used for this purpose, but the units are usually
+            not speciﬁed in a well deﬁned format that FITS readers can easily recognize and extract.
+            To solve this deﬁciency, FITSIO uses a local convention in which the keyword units are enclosed in
+            squarebrackets as theﬁrsttoken in thekeyword commentﬁeld; morespeciﬁcally, theopeningsquare
+            bracket immediately follows the slash ’/’ comment ﬁeld delimiter and a single space character. The
+            following examples illustrate keywords that use this convention:
+            EXPOSURE=            1800.0 / [s] elapsed exposure time
+            V_HELIO =            16.23 / [km s**(-1)] heliocentric velocity
+            LAMBDA =             5400. / [angstrom] central wavelength
+            FLUX   = 4.9033487787637465E-30 / [J/cm**2/s] average flux
+            In general, the units named in the IAU(1988) Style Guide are recommended, with the main excep-
+            tion that the preferred unit for angle is ’deg’ for degrees.
+            TheFTPUNTandFTGUNTsubroutinesinFITSIOwriteandread,respectively, thekeywordunit
+            strings in an existing keyword.
+            4.12.4 HIERARCHConvention for Extended Keyword Names
+            CFITSIO supports the HIERARCH keyword convention which allows keyword names that are
+            longer than 8 characters. This convention was developed at the European Southern Observatory
+            (ESO) and allows characters consisting of digits 0-9, upper case letters A-Z, the dash ’-’ and the
+            underscore ’ ’. The components of hierarchical keywords are separated by a single ASCII space
+            charater. For instance:
+            HIERARCH ESO INS FOCU POS = -0.00002500 / Focus position
+            Basically, this convention uses the FITS keyword ’HIERARCH’ to indicate that this convention
+            is being used, then the actual keyword name (’ESO INS FOCU POS’ in this example) begins in
+            column 10. The equals sign marks the end of the keyword name and is followed by the usual
+            value and comment ﬁelds just as in standard FITS keywords. Further details of this convention
+            are described at http://ﬁts.gsfc.nasa.gov/registry/hierarch keyword.html and in Section 4.4 of the
+            ESO Data Interface Control Document that is linked to from http://archive.eso.org/cms/tools-
+            documentation/eso-data-interface-control.html.
              24                           CHAPTER4. FITSIOCONVENTIONSANDGUIDELINES
              This convention allows a broader range of keyword names than is allowed by the FITS Standard.
              Here are more examples of such keywords:
              HIERARCH LONGKEYWORD = 47.5 / Keyword has > 8 characters
              HIERARCH LONG-KEY_WORD2 = 52.3 / Long keyword with hyphen, underscore and digit
              HIERARCH EARTH IS A STAR = F / Keyword contains embedded spaces
              CFITSIO will transparently read and write these keywords, so application programs do not in
@@ -892,21 +886,21 @@
              that it is running on. To get a general idea of what data I/O speeds are possible on a particular
              machine, build the speed.c program that is distributed with CFITSIO (type ’make speed’ in the
              CFITSIO directory). This diagnostic program measures the speed of writing and reading back a
              test FITS image, a binary table, and an ASCII table.
              The following 2 sections provide some background on how CFITSIO internally manages the data
              I/O and describes some strategies that may be used to optimize the processing speed of software
              that uses CFITSIO.
-             4.13.1  Background Information: How CFITSIO Manages Data I/O
+             4.13.1   Background Information: How CFITSIO Manages Data I/O
              ManyCFITSIOoperationsinvolvetransferringonlyasmallnumberofbytestoorfromtheFITSﬁle
              (e.g, reading a keyword, or writing a row in a table); it would be very ineﬃcient to physically read
              or write such small blocks of data directly in the FITS ﬁle on disk, therefore CFITSIO maintains
              a set of internal Input–Output (IO) buﬀers in RAM memory that each contain one FITS block
              (2880 bytes) of data. Whenever CFITSIO needs to access data in the FITS ﬁle, it ﬁrst transfers the
-           4.13. OPTIMIZING CODE FOR MAXIMUM PROCESSING SPEED                 25
+           4.13. OPTIMIZING CODE FOR MAXIMUM PROCESSING SPEED                  25
            FITS block containing those bytes into one of the IO buﬀers in memory. The next time CFITSIO
            needs to access bytes in the same block it can then go to the fast IO buﬀer rather than using a
            much slower system disk access routine. The number of available IO buﬀers is determined by the
            NIOBUF parameter (in ﬁtsio2.h) and is currently set to 40.
            WheneverCFITSIOreadsorwritesdatait ﬁrstchecks to see if that block of the FITS ﬁle is already
            loaded into one of the IO buﬀers. If not, and if there is an empty IO buﬀer available, then it will
            load that block into the IO buﬀer (when reading a FITS ﬁle) or will initialize a new block (when
@@ -982,15 +976,15 @@
              way until the entire ﬁle has been processed. By using this procedure of accessing all the columns of
              a table in parallel rather than sequentially, each block of the FITS ﬁle will only be read or written
              once.
              The optimal number of rows to read or write at one time in a given table depends on the width of
              the table row, on the number of I/O buﬀers that have been allocated in FITSIO, and also on the
              number of other FITS ﬁles that are open at the same time (since one I/O buﬀer is always reserved
              for each open FITS ﬁle). Fortunately, a FITSIO routine is available that will return the optimal
-           4.13. OPTIMIZING CODE FOR MAXIMUM PROCESSING SPEED                 27
+           4.13. OPTIMIZING CODE FOR MAXIMUM PROCESSING SPEED                  27
            number of rows for a given table: call ftgrsz(unit, nrows, status). It is not critical to use exactly
            the value of nrows returned by this routine, as long as one does not exceed it. Using a very small
            value however can also lead to poor performance because of the overhead from the larger number
            of subroutine calls.
            The optimal number of rows returned by ftgrsz is valid only as long as the application program
            is only reading or writing data in the speciﬁed table. Any other calls to access data in the table
            header would cause additional blocks of data to be loaded into the I/O buﬀers displacing data from
@@ -1048,39 +1042,40 @@
        andit makes the code more system dependent (e.g., do the bytes need to be swapped before writing
        to the FITS ﬁle?).
        12. Finally, external factors such as the type of magnetic disk controller (SCSI or IDE), the size
        of the disk cache, the average seek speed of the disk, the amount of disk fragmentation, and the
        amount of RAM available on the system can all have a signiﬁcant impact on overall I/O eﬃciency.
        For critical applications, a system administrator should review the proposed system hardware to
        identify any potential I/O bottlenecks.
-              Chapter 5
-              Basic Interface Routines
-              This section deﬁnes a basic set of subroutines that can be used to perform the most common types
-              of read and write operations on FITS ﬁles. New users should start with these subroutines and then,
-              as needed, explore the more advance routines described in the following chapter to perform more
-              complex or specialized operations.
-              Aright arrow symbol (>) is used to separate the input parameters from the output parameters in
-              the deﬁnition of each routine. This symbol is not actually part of the calling sequence. Note that
-              the status parameter is both an input and an output parameter and must be initialized = 0 prior
-              to calling the FITSIO subroutines.
-              Refer to Chapter 9 for the deﬁnition of all the parameters used by these interface routines.
-              5.1     FITSIO Error Status Routines
-              1 Returnthe current version number of the ﬁtsio library. The version number will be incremented
-                    with each new release of CFITSIO.
+               Chapter 5
+               Basic Interface Routines
+               This section deﬁnes a basic set of subroutines that can be used to perform the most common types
+               of read and write operations on FITS ﬁles. New users should start with these subroutines and then,
+               as needed, explore the more advance routines described in the following chapter to perform more
+               complex or specialized operations.
+               Aright arrow symbol (>) is used to separate the input parameters from the output parameters in
+               the deﬁnition of each routine. This symbol is not actually part of the calling sequence. Note that
+               the status parameter is both an input and an output parameter and must be initialized = 0 prior
+               to calling the FITSIO subroutines.
+               Refer to Chapter 9 for the deﬁnition of all the parameters used by these interface routines.
+               5.1    FITSIO Error Status Routines
+               1 Returnthe current version number of the ﬁtsio library. The version number will be incremented
+                    with each new release of CFITSIO. The 3 ﬁelds of the version string M.xx.yy are converted
+                    to a ﬂoat as: M + .01*xx + .0001*yy.
                        FTVERS( > version)
-              2 Return the descriptive text string corresponding to a FITSIO error status code.   The 30-
+               2 Return the descriptive text string corresponding to a FITSIO error status code.  The 30-
                     character length string contains a brief description of the cause of the error.
                        FTGERR(status, > errtext)
-              3 Return the top (oldest) 80-character error message from the internal FITSIO stack of error
+               3 Return the top (oldest) 80-character error message from the internal FITSIO stack of error
                     messages and shift any remaining messages on the stack up one level. Any FITSIO error will
                     generate one or more messages on the stack. Call this routine repeatedly to get each message
                     in sequence. The error stack is empty when a blank string is returned.
                        FTGMSG( > errmsg)
                                                            29
-           30                               CHAPTER5. BASICINTERFACEROUTINES
+           30                              CHAPTER5. BASICINTERFACEROUTINES
            4 The FTPMRK routine puts an invisible marker on the CFITSIO error stack. The FTCMRK
                routine can then be used to delete any more recent error messages on the stack, back to
                the position of the marker. This preserves any older error messages on the stack. FTCMSG
                simply clears the entire error message stack. These routines are called without any arguments.
                   FTPMRK
                   FTCMRK
                   FTCMSG
@@ -1140,15 +1135,15 @@
                         integers.
                              FTIIMG(unit,bitpix,naxis,naxes, > status)
                              FTIIMGLL(unit,bitpix,naxis,naxesll, > status)
                   8 Insert a new ASCII TABLE extension immediately following the CHDU. Any following exten-
                         sions will be shifted down to make room for the new extension. If there are no other following
                         extensions then the new table extension will simply be appended to the end of the ﬁle. The
                         new extension will become the CHDU. The FTITABLL routine is identical to the FTITAB
-           32                               CHAPTER5. BASICINTERFACEROUTINES
+           32                              CHAPTER5. BASICINTERFACEROUTINES
                routine except that the 2nd and 3rd parameters (that give the size of the table) are 64-bit
                integers rather than 32-bit integers. Under normal circumstances, the nrows and nrowsll
                paramenters should have a value of 0; CFITSIO will automatically update the number of
                rows as data is written to the table.
                   FTITAB(unit,rowlen,nrows,tfields,ttype,tbcol,tform,tunit,extname, >
                         status)
                   FTITABLL(unit,rowlenll,nrowsll,tfields,ttype,tbcol,tform,tunit,extname, >
@@ -1247,15 +1242,15 @@
            2 Openanexisting FITS ﬁle with readonly or readwrite access and move to a following extension,
                if one was speciﬁed as part of the ﬁlename. (e.g., ’ﬁlename.ﬁts+2’ or ’ﬁlename.ﬁts[2]’ will
                move to the 3rd HDU in the ﬁle). Note that this routine diﬀers from FTOPEN in that it
                does not have the redundant blocksize argument.
                   FTNOPN(unit,filename,rwmode, > status)
            3 Reopen a FITS ﬁle that was previously opened with FTOPEN, FTNOPN, or FTINIT. The
                newunit number may then be treated as a separate ﬁle, and one may simultaneously read
-                                             35
+                                            35
        36              CHAPTER6. ADVANCEDINTERFACESUBROUTINES
           or write to 2 (or more) diﬀerent extensions in the same ﬁle. The FTOPEN and FTNOPN
           routines (above) automatically detects cases where a previously opened ﬁle is being opened
           again, and then internally call FTREOPEN, so programs should rarely need to explicitly call
           this routine.
            FTREOPEN(unit, > newunit, status)
        4 Openandinitialize a new empty FITS ﬁle. The FTDKINIT routine simply creates the speciﬁed
@@ -1722,48 +1717,48 @@
                   3 Modify (overwrite) the name of an existing keyword in the CHU preserving the current value
                         and comment ﬁelds.
                              FTMNAM(unit,oldkey,keyword, > status)
                   4 Modify (overwrite) the comment ﬁeld of an existing keyword in the CHU
                              FTMCOM(unit,keyword,comment, > status)
               50                            CHAPTER6. ADVANCEDINTERFACESUBROUTINES
               5 Modifythevalue andcomment ﬁelds of an existing keyword in the CHU. The FTMKLS subrou-
-                  tine works the same as the FTMKYS subroutine, except it also supports long string values
-                  greater than 68 characters in length. Optionally, one may modify only the value ﬁeld and
-                  leave the comment ﬁeld unchanged by setting the input COMMENT parameter equal to the
-                  ampersand character (&). The E and D versions of this routine have the added feature that
-                  if the ’decimals’ parameter is negative, then the ’G’ display format rather then the ’E’ format
-                  will be used when constructing the keyword value, taking the absolute value of ’decimals’ for
-                  the precision. This will suppress trailing zeros, and will use a ﬁxed format rather than an
-                  exponential format, depending on the magnitude of the value.
+                   tine works the same as the FTMKYS subroutine, except it also supports long string values
+                   greater than 68 characters in length. Optionally, one may modify only the value ﬁeld and
+                   leave the comment ﬁeld unchanged by setting the input COMMENT parameter equal to the
+                   ampersand character (&). The E and D versions of this routine have the added feature that
+                   if the ’decimals’ parameter is negative, then the ’G’ display format rather then the ’E’ format
+                   will be used when constructing the keyword value, taking the absolute value of ’decimals’ for
+                   the precision. This will suppress trailing zeros, and will use a ﬁxed format rather than an
+                   exponential format, depending on the magnitude of the value.
                       FTMKY[JKLS](unit,keyword,keyval,comment, > status)
                       FTMKLS(unit,keyword,keyval,comment, > status)
                       FTMKY[EDFG](unit,keyword,keyval,decimals,comment, > status)
               6 Modifythevalueofanexisting keywordtobeundeﬁned,ornull. Thevaluestringofthekeyword
-                  is set to blank. Optionally, one may leave the comment ﬁeld unchanged by setting the input
-                  COMMENTparameter equal to the ampersand character (&).
+                   is set to blank. Optionally, one may leave the comment ﬁeld unchanged by setting the input
+                   COMMENTparameter equal to the ampersand character (&).
                       FTMKYU(unit,keyword,comment, > status)
               6.4.7  Update Keyword Subroutines
               1 Update an 80-character record in the CHU. If the speciﬁed keyword already exists then that
-                  header record will be replaced with the input CARD string. If it does not exist then the
-                  new record will be added to the header. The FTUKLS subroutine works the same as the
-                  FTUKYSsubroutine, except it also supports long string values greater than 68 characters in
-                  length.
+                   header record will be replaced with the input CARD string. If it does not exist then the
+                   new record will be added to the header. The FTUKLS subroutine works the same as the
+                   FTUKYSsubroutine, except it also supports long string values greater than 68 characters in
+                   length.
                       FTUCRD(unit,keyword,card, > status)
               2 Update the value and comment ﬁelds of a keyword in the CHU. The speciﬁed keyword is
-                  modiﬁed if it already exists (by calling FTMKYx) otherwise a new keyword is created by
-                  calling FTPKYx. The E and D versions of this routine have the added feature that if the
-                  ’decimals’ parameter is negative, then the ’G’ display format rather then the ’E’ format will
-                  be used when constructing the keyword value, taking the absolute value of ’decimals’ for
-                  the precision. This will suppress trailing zeros, and will use a ﬁxed format rather than an
-                  exponential format, depending on the magnitude of the value.
+                   modiﬁed if it already exists (by calling FTMKYx) otherwise a new keyword is created by
+                   calling FTPKYx. The E and D versions of this routine have the added feature that if the
+                   ’decimals’ parameter is negative, then the ’G’ display format rather then the ’E’ format will
+                   be used when constructing the keyword value, taking the absolute value of ’decimals’ for
+                   the precision. This will suppress trailing zeros, and will use a ﬁxed format rather than an
+                   exponential format, depending on the magnitude of the value.
                       FTUKY[JKLS](unit,keyword,keyval,comment, > status)
                       FTUKLS(unit,keyword,keyval,comment, > status)
                       FTUKY[EDFG](unit,keyword,keyval,decimals,comment, > status)
               3 Updatethevalueofanexisting keyword to be undeﬁned,or null, or insert a new undeﬁned-value
-                  keyword if it doesn’t already exist. The value string of the keyword is left blank in this case.
+                   keyword if it doesn’t already exist. The value string of the keyword is left blank in this case.
                       FTUKYU(unit,keyword,comment, > status)
                   6.5.  DATA SCALING AND UNDEFINED PIXEL PARAMETERS                                                            51
                   6.4.8    Delete Keyword Subroutines
                   1 Delete an existing keyword record. The space previously occupied by the keyword is reclaimed
                         by moving all the following header records up one row in the header. The ﬁrst routine deletes
                         a keyword at a speciﬁed position in the header (the ﬁrst keyword is at position 1), whereas
                         the second routine deletes a speciﬁcally named keyword. Wild card characters, as described
@@ -1853,27 +1848,35 @@
                              FTGISZ(unit, maxdim, > naxes,status)
                              FTGISZLL(unit, maxdim, > naxesll,status)
                   4 Get the parameters that deﬁne the type and size of the image. This routine simply combines
                         calls to the above 3 routines. The FTGIPRLL routine returns an array of 64-bit integers
                         instead of 32-bit integers.
                              FTGIPR(unit, maxdim, > bitpix, naxis, naxes, int *status)
                              FTGIPRLL(unit, maxdim, > bitpix, naxis, naxesll, int *status)
-                  5 Put elements into the data array
+                  5 Putelements into the data array. The FTPPR[]LL routines accept 64-bit integers for fpixel and
+                        nelements.
                              FTPPR[BIJKED](unit,group,fpixel,nelements,values, > status)
+                             FTPPR[BIJKED]LL(unit,group,fpixelll,nelementsll,values, > status)
                   6 Put elements into the data array, substituting the appropriate FITS null value for all elements
-                        which are equal to the value of NULLVAL. For integer FITS arrays, the null value deﬁned by
-                        the previous call to FTPNUL will be substituted; for ﬂoating point FITS arrays (BITPIX =
-                        -32 or -64) then the special IEEE NaN (Not-a-Number) value will be substituted.
+                        which are equal to the value of NULLVAL. For integer FITS arrays, the null value deﬁned
+                        by the previous call to FTPNUL will be substituted; for ﬂoating point FITS arrays (BITPIX
+                        = -32 or -64) then the special IEEE NaN (Not-a-Number) value will be substituted. The
+                        FTPPN[]LL routines accept 64-bit integers for fpixel and nelements.
                              FTPPN[BIJKED](unit,group,fpixel,nelements,values,nullval > status)
-                  7 Set data array elements as undeﬁned
-                             FTPPRU(unit,group,fpixel,nelements, > status)
+                             FTPPN[BIJKED]LL(unit,group,fpixelll,nelementsll,values,nullval > status)
        54              CHAPTER6. ADVANCEDINTERFACESUBROUTINES
+       7 Set data array elements as undeﬁned. FTPPRULL accepts 64-bit integers for fpixel and nele-
+          ments.
+           FTPPRU(unit,group,fpixel,nelements, > status)
+           FTPPRULL(unit,group,fpixelll,nelementsll, > status)
        8 Get elements from the data array. Undeﬁned array elements will be returned with a value =
           nullval, unless nullval = 0 in which case no checks for undeﬁned pixels will be performed.
+          FTGPV[]LL accepts 64-bit integers for fpixel and nelements.
            FTGPV[BIJKED](unit,group,fpixel,nelements,nullval, > values,anyf,status)
+           FTGPV[BIJKED]LL(unit,group,fpixelll,nelementsll,nullval, > values,anyf,status)
        9 Get elements and nullﬂags from data array. Any undeﬁned array elements will have the corre-
           sponding ﬂagvals element set equal to .TRUE.
            FTGPF[BIJKED](unit,group,fpixel,nelements, > values,flagvals,anyf,status)
        10 Put values into group parameters
            FTPGP[BIJKED](unit,group,fparm,nparm,values, > status)
        11 Get values from group parameters
            FTGGP[BIJKED](unit,group,fparm,nparm, > values,status)
@@ -1887,20 +1890,20 @@
        XanYdirections. This has the eﬀect of taking a contiguous set of pixel value in the FITS array
        and writing them to a non-contiguous array in program memory (i.e., there are now some blank
        pixels around the edge of the image in the program array).
        11 Put 2-D image into the data array
            FTP2D[BIJKED](unit,group,dim1,naxis1,naxis2,image, > status)
        12 Put 3-D cube into the data array
            FTP3D[BIJKED](unit,group,dim1,dim2,naxis1,naxis2,naxis3,cube, > status)
-       13 Get 2-D image from the data array. Undeﬁned pixels in the array will be set equal to the value
-          of ’nullval’, unless nullval=0 in which case no testing for undeﬁned pixels will be performed.
-           FTG2D[BIJKED](unit,group,nullval,dim1,naxis1,naxis2, > image,anyf,status)
-       14 Get 3-D cube from the data array. Undeﬁned pixels in the array will be set equal to the value
-          of ’nullval’, unless nullval=0 in which case no testing for undeﬁned pixels will be performed.
-                  6.7.  FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES                                                       55
+                  6.6.  FITS PRIMARY ARRAY OR IMAGE EXTENSION I/O SUBROUTINES                                                  55
+                  13 Get 2-D image from the data array. Undeﬁned pixels in the array will be set equal to the value
+                        of ’nullval’, unless nullval=0 in which case no testing for undeﬁned pixels will be performed.
+                             FTG2D[BIJKED](unit,group,nullval,dim1,naxis1,naxis2, > image,anyf,status)
+                  14 Get 3-D cube from the data array. Undeﬁned pixels in the array will be set equal to the value
+                        of ’nullval’, unless nullval=0 in which case no testing for undeﬁned pixels will be performed.
                              FTG3D[BIJKED](unit,group,nullval,dim1,dim2,naxis1,naxis2,naxis3, >
                                               cube,anyf,status)
                   The following subroutines transfer a rectangular subset of the pixels in a FITS N-dimensional
                   image to or from an array which has been declared in the calling program. The fpixels and lpixels
                   parameters are integer arrays which specify the starting and ending pixels in each dimension of the
                   FITS image that are to be read or written. (Note that these are the starting and ending pixels
                   in the FITS image, not in the declared array). The array parameter is treated simply as a large
@@ -1920,64 +1923,64 @@
                         will be performed.
                              FTGSV[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs,nullval, >
                                               array,anyf,status)
                   17 Get an arbitrary data subsection from the data array. Any Undeﬁned pixels in the array will
                         have the corresponding ’ﬂagvals’ element set equal to .TRUE.
                              FTGSF[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs, >
                                               array,flagvals,anyf,status)
-                  6.7     FITS ASCII and Binary Table Data I/O Subroutines
-                  6.7.1    Column Information Subroutines
-                  1 Get the number of rows or columns in the current FITS table. The number of rows is given
-                        by the NAXIS2 keyword and the number of columns is given by the TFIELDS keyword in
-                        the header of the table. The FTGNRWLL routine is identical to FTGNRW except that the
-                        number of rows is returned as a 64-bit integer rather than a 32-bit integer.
-       56              CHAPTER6. ADVANCEDINTERFACESUBROUTINES
-           FTGNRW(unit, > nrows, status)
-           FTGNRWLL(unit, > nrowsll, status)
-           FTGNCL(unit, > ncols, status)
-       2 Getthetable columnnumber(andname)ofthecolumnwhosenamematches aninputtemplate
-          name. ThetablecolumnnamesaredeﬁnedbytheTTYPEnkeywordsintheFITSheader. Ifa
-          column does not have a TTYPEn keyword, then these routines assume that the name consists
-          of all blank characters. These 2 subroutines perform the same function except that FTGCNO
-          only returns the number of the matching column whereas FTGCNN also returns the name of
-          the column. If CASESEN = .true. then the column name match will be case-sensitive.
-          The input column name template (COLTEMPLATE) is (1) either the exact name of the
-          column to be searched for, or (2) it may contain wild cards characters (*, ?, or #), or (3)
-          it may contain the number of the desired column (where the number is expressed as ASCII
-          digits). The ﬁrst 2 wild cards behave similarly to UNIX ﬁlename matching: the ’*’ character
-          matches any sequence of characters (including zero characters) and the ’?’ character matches
-          any single character. The # wildcard will match any consecutive string of decimal digits
-          (0-9). As an example, the template strings ’AB?DE’, ’AB*E’, and ’AB*CDE’ will all match
-          the string ’ABCDE’. If more than one column name in the table matches the template string,
-          then the ﬁrst match is returned and the status value will be set to 237 as a warning that a
-          unique match was not found. To ﬁnd the other cases that match the template, simply call
-          the subroutine again leaving the input status value equal to 237 and the next matching name
-          will then be returned. Repeat this process until a status = 219 (column name not found) is
-          returned. If these subroutines fail to match the template to any of the columns in the table,
-          they lastly check if the template can be interpreted as a simple positive integer (e.g., ’7’, or
-          ’512’) and if so, they return that column number. If no matches are found then a status =
-          219 error is returned.
-          Note that the FITS Standard recommends that only letters, digits, and the underscore char-
-          acter be used in column names (with no embedded spaces in the name). Trailing blank
-          characters are not signiﬁcant.
-           FTGCNO(unit,casesen,coltemplate, > colnum,status)
-           FTGCNN(unit,casesen,coltemplate, > colname,colnum,status)
-       3 Get the datatype of a column in an ASCII or binary table. This routine returns an integer
-          code value corresponding to the datatype of the column. (See the FTBNFM and FTASFM
-          subroutines in the Utilities section of this document for a list of the code values). The vector
-          repeat count (which is alway 1 for ASCII table columns) is also returned. If the speciﬁed
-          column has an ASCII character datatype (code = 16) then the width of a unit string in the
-          column is also returned. Note that this routine supports the local convention for specifying
-          arrays of strings within a binary table character column, using the syntax TFORM = ’rAw’
-          where ’r’ is the total number of characters (= the width of the column) and ’w’ is the width
-          of a unit string within the column. Thus if the column has TFORM = ’60A12’ then this
-          routine will return datacode = 16, repeat = 60, and width = 12. (The TDIMn keyword may
-          also be used to specify the unit string length; The pair of keywords TFORMn = ’60A’ and
-          TDIMn=’(12,5)’ would have the same eﬀect as TFORMn = ’60A12’).
+              56                            CHAPTER6. ADVANCEDINTERFACESUBROUTINES
+              6.7   FITS ASCII and Binary Table Data I/O Subroutines
+              6.7.1  Column Information Subroutines
+              1 Get the number of rows or columns in the current FITS table. The number of rows is given
+                   by the NAXIS2 keyword and the number of columns is given by the TFIELDS keyword in
+                   the header of the table. The FTGNRWLL routine is identical to FTGNRW except that the
+                   number of rows is returned as a 64-bit integer rather than a 32-bit integer.
+                      FTGNRW(unit, > nrows, status)
+                      FTGNRWLL(unit, > nrowsll, status)
+                      FTGNCL(unit, > ncols, status)
+              2 Getthetable columnnumber(andname)ofthecolumnwhosenamematches aninputtemplate
+                   name. ThetablecolumnnamesaredeﬁnedbytheTTYPEnkeywordsintheFITSheader. Ifa
+                   column does not have a TTYPEn keyword, then these routines assume that the name consists
+                   of all blank characters. These 2 subroutines perform the same function except that FTGCNO
+                   only returns the number of the matching column whereas FTGCNN also returns the name of
+                   the column. If CASESEN = .true. then the column name match will be case-sensitive.
+                   The input column name template (COLTEMPLATE) is (1) either the exact name of the
+                   column to be searched for, or (2) it may contain wild cards characters (*, ?, or #), or (3)
+                   it may contain the number of the desired column (where the number is expressed as ASCII
+                   digits). The ﬁrst 2 wild cards behave similarly to UNIX ﬁlename matching: the ’*’ character
+                   matches any sequence of characters (including zero characters) and the ’?’ character matches
+                   any single character. The # wildcard will match any consecutive string of decimal digits
+                   (0-9). As an example, the template strings ’AB?DE’, ’AB*E’, and ’AB*CDE’ will all match
+                   the string ’ABCDE’. If more than one column name in the table matches the template string,
+                   then the ﬁrst match is returned and the status value will be set to 237 as a warning that a
+                   unique match was not found. To ﬁnd the other cases that match the template, simply call
+                   the subroutine again leaving the input status value equal to 237 and the next matching name
+                   will then be returned. Repeat this process until a status = 219 (column name not found) is
+                   returned. If these subroutines fail to match the template to any of the columns in the table,
+                   they lastly check if the template can be interpreted as a simple positive integer (e.g., ’7’, or
+                   ’512’) and if so, they return that column number. If no matches are found then a status =
+                   219 error is returned.
+                   Note that the FITS Standard recommends that only letters, digits, and the underscore char-
+                   acter be used in column names (with no embedded spaces in the name). Trailing blank
+                   characters are not signiﬁcant.
+                      FTGCNO(unit,casesen,coltemplate, > colnum,status)
+                      FTGCNN(unit,casesen,coltemplate, > colname,colnum,status)
+              3 Get the datatype of a column in an ASCII or binary table. This routine returns an integer
+                   code value corresponding to the datatype of the column. (See the FTBNFM and FTASFM
+                   subroutines in the Utilities section of this document for a list of the code values). The vector
                   6.7.  FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES                                                       57
+                        repeat count (which is alway 1 for ASCII table columns) is also returned. If the speciﬁed
+                        column has an ASCII character datatype (code = 16) then the width of a unit string in the
+                        column is also returned. Note that this routine supports the local convention for specifying
+                        arrays of strings within a binary table character column, using the syntax TFORM = ’rAw’
+                        where ’r’ is the total number of characters (= the width of the column) and ’w’ is the width
+                        of a unit string within the column. Thus if the column has TFORM = ’60A12’ then this
+                        routine will return datacode = 16, repeat = 60, and width = 12. (The TDIMn keyword may
+                        also be used to specify the unit string length; The pair of keywords TFORMn = ’60A’ and
+                        TDIMn=’(12,5)’ would have the same eﬀect as TFORMn = ’60A12’).
                         The second routine, FTEQTY is similar except that in the case of scaled integer columns it
                         returns the ’equivalent’ data type that is needed to store the scaled values, and not necessarily
                         the physical data type of the unscaled values as stored in the FITS table. For example if
                         a ’1I’ column in a binary table has TSCALn = 1 and TZEROn = 32768, then this column
                         eﬀectively contains unsigned short integer values, and thus the returned value of typecode will
                         be the code for an unsigned short integer, not a signed short integer. Similarly, if a column
                         has TTYPEn = ’1I’ and TSCALn = 0.12, then the returned typecode will be the code for a
@@ -1999,53 +2002,53 @@
                         ’n’ is an integer expressing the width of the ﬁeld in characters. For example, if TFORM =
                         ’160A8’ then FTGBCL will return DATATYPE=’A8’ and REPEAT=20. All the returned
                         parameters are scalar quantities.
                              FTGBCL(unit,colnum, >
                                       ttype,tunit,datatype,repeat,tscal,tzero,tnull,tdisp,status)
                   7 Put (append) a TDIMn keyword whose value has the form ’(l,m,n...)’ where l, m, n... are the
                         dimensions of a multidimensional array column in a binary table.
-                             FTPTDM(unit,colnum,naxis,naxes, > status)
-                  8 Return the number of and size of the dimensions of a table column. Normally this information
-                        is given by the TDIMn keyword, but if this keyword is not present then this routine returns
-                        NAXIS = 1 and NAXES(1) equal to the repeat count in the TFORM keyword.
               58                            CHAPTER6. ADVANCEDINTERFACESUBROUTINES
+                      FTPTDM(unit,colnum,naxis,naxes, > status)
+              8 Return the number of and size of the dimensions of a table column. Normally this information
+                   is given by the TDIMn keyword, but if this keyword is not present then this routine returns
+                   NAXIS = 1 and NAXES(1) equal to the repeat count in the TFORM keyword.
                       FTGTDM(unit,colnum,maxdim, > naxis,naxes,status)
               9 Decode the input TDIMn keyword string (e.g. ’(100,200)’) and return the number of and size
-                  of the dimensions of a binary table column. If the input tdimstr character string is null, then
-                  this routine returns naxis = 1 and naxes[0] equal to the repeat count in the TFORM keyword.
-                  This routine is called by FTGTDM.
+                   of the dimensions of a binary table column. If the input tdimstr character string is null, then
+                   this routine returns naxis = 1 and naxes[0] equal to the repeat count in the TFORM keyword.
+                   This routine is called by FTGTDM.
                       FTDTDM(unit,tdimstr,colnum,maxdim, > naxis,naxes, status)
               10 Return the optimal number of rows to read or write at one time for maximum I/O eﬃciency.
-                  Refer to the “Optimizing Code” section in Chapter 5 for more discussion on how to use this
-                  routine.
+                   Refer to the “Optimizing Code” section in Chapter 5 for more discussion on how to use this
+                   routine.
                       FTGRSZ(unit, > nrows,status)
               6.7.2  Low-Level Table Access Subroutines
               The following subroutines provide low-level access to the data in ASCII or binary tables and are
               mainly useful as an eﬃcient way to copy all or part of a table from one location to another. These
               routines simply read or write the speciﬁed number of consecutive bytes in an ASCII or binary table,
               without regard for column boundaries or the row length in the table. The ﬁrst two subroutines
               read or write consecutive bytes in a table to or from a character string variable, while the last two
               subroutines read or write consecutive bytes to or from a variable declared as a numeric data type
               (e.g., INTEGER, INTEGER*2, REAL, DOUBLE PRECISION). These routines do not perform
               any machine dependent data conversion or byte swapping, except that conversion to/from ASCII
               format is performed by the FTGTBS and FTPTBS routines on machines which do not use ASCII
               character codes in the internal data representations (e.g., on IBM mainframe computers).
               1 Readaconsecutive string of characters from an ASCII table into a character variable (spanning
-                  columns and multiple rows if necessary) This routine should not be used with binary tables
-                  because of complications related to passing string variables between C and Fortran.
+                   columns and multiple rows if necessary) This routine should not be used with binary tables
+                   because of complications related to passing string variables between C and Fortran.
                       FTGTBS(unit,frow,startchar,nchars, > string,status)
               2 Write a consecutive string of characters to an ASCII table from a character variable (spanning
-                  columns and multiple rows if necessary) This routine should not be used with binary tables
-                  because of complications related to passing string variables between C and Fortran.
-                      FTPTBS(unit,frow,startchar,nchars,string, > status)
-              3 Readaconsecutive array of bytes from an ASCII or binary table into a numeric variable (span-
-                  ning columns and multiple rows if necessary). The array parameter may be declared as any
-                  numerical datatype as long as the array is at least ’nchars’ bytes long, e.g., if nchars = 17,
-                  then declare the array as INTEGER*4 ARRAY(5).
+                   columns and multiple rows if necessary) This routine should not be used with binary tables
+                   because of complications related to passing string variables between C and Fortran.
                   6.7.  FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES                                                       59
+                             FTPTBS(unit,frow,startchar,nchars,string, > status)
+                  3 Readaconsecutive array of bytes from an ASCII or binary table into a numeric variable (span-
+                        ning columns and multiple rows if necessary). The array parameter may be declared as any
+                        numerical datatype as long as the array is at least ’nchars’ bytes long, e.g., if nchars = 17,
+                        then declare the array as INTEGER*4 ARRAY(5).
                              FTGTBB(unit,frow,startchar,nchars, > array,status)
                   4 Write a consecutive array of bytes to an ASCII or binary table from a numeric variable (span-
                         ning columns and multiple rows if necessary) The array parameter may be declared as any
                         numerical datatype as long as the array is at least ’nchars’ bytes long, e.g., if nchars = 17,
                         then declare the array as INTEGER*4 ARRAY(5).
                              FTPTBB(unit,frow,startchar,nchars,array, > status)
                   6.7.3    Edit Rows or Columns
@@ -2067,56 +2070,56 @@
                   3 Delete a list of rows from an ASCII or binary table (in the CDU). In the ﬁrst routine, ’rowrange’
                         is a character string listing the rows or row ranges to delete (e.g., ’2-4, 5, 8-9’). In the second
                         routine, ’rowlist’ is an integer array of row numbers to be deleted from the table. nrows is
                         the number of row numbers in the list. The ﬁrst row in the table is 1 not 0. The list of row
                         numbers must be sorted in ascending order.
                              FTDRRG(unit,rowrange, > status)
                              FTDRWS(unit,rowlist,nrows, > status)
-                  4 Insert a blank column (or columns) into an existing ASCII or binary table (in the CDU).
-                        COLNUM speciﬁes the column number that the (ﬁrst) new column should occupy in the
-                        table. NCOLS speciﬁes how many columns are to be inserted. Any existing columns from
-                        this position and higher are moved over to allow room for the new column(s). The index
-                        number on all the following keywords will be incremented if necessary to reﬂect the new
               60                            CHAPTER6. ADVANCEDINTERFACESUBROUTINES
-                  position of the column(s) in the table: TBCOLn, TFORMn, TTYPEn, TUNITn, TNULLn,
-                  TSCALn,TZEROn,TDISPn,TDIMn,TLMINn,TLMAXn,TDMINn,TDMAXn,TCTYPn,
-                  TCRPXn, TCRVLn, TCDLTn, TCROTn, and TCUNIn.
+              4 Insert a blank column (or columns) into an existing ASCII or binary table (in the CDU).
+                   COLNUM speciﬁes the column number that the (ﬁrst) new column should occupy in the
+                   table. NCOLS speciﬁes how many columns are to be inserted. Any existing columns from
+                   this position and higher are moved over to allow room for the new column(s). The index
+                   number on all the following keywords will be incremented if necessary to reﬂect the new
+                   position of the column(s) in the table: TBCOLn, TFORMn, TTYPEn, TUNITn, TNULLn,
+                   TSCALn,TZEROn,TDISPn,TDIMn,TLMINn,TLMAXn,TDMINn,TDMAXn,TCTYPn,
+                   TCRPXn, TCRVLn, TCDLTn, TCROTn, and TCUNIn.
                       FTICOL(unit,colnum,ttype,tform, > status)
                       FTICLS(unit,colnum,ncols,ttype,tform, > status)
               5 Modify the vector length of a binary table column (e.g., change a column from TFORMn =
-                  ’1E’ to ’20E’). The vector length may be increased or decreased from the current value.
+                   ’1E’ to ’20E’). The vector length may be increased or decreased from the current value.
                       FTMVEC(unit,colnum,newveclen, > status)
               6 Delete a column from an existing ASCII or binary table (in the CDU). The index number of all
-                  the keywords listed above (for FTICOL) will be decremented if necessary to reﬂect the new
-                  position of the column(s) in the table. Those index keywords that refer to the deleted column
-                  will also be deleted. Note that the physical size of the FITS ﬁle will not be reduced by this
-                  operation, and the empty FITS blocks if any at the end of the ﬁle will be padded with zeros.
+                   the keywords listed above (for FTICOL) will be decremented if necessary to reﬂect the new
+                   position of the column(s) in the table. Those index keywords that refer to the deleted column
+                   will also be deleted. Note that the physical size of the FITS ﬁle will not be reduced by this
+                   operation, and the empty FITS blocks if any at the end of the ﬁle will be padded with zeros.
                       FTDCOL(unit,colnum, > status)
               7 Copy a column from one HDU to another (or to the same HDU). If createcol = TRUE, then a
-                  newcolumnwillbeinsertedintheoutputtable, atposition‘outcolumn’, otherwisetheexisting
-                  output column will be overwritten (in which case it must have a compatible datatype). Note
-                  that the ﬁrst column in a table is at colnum = 1.
+                   newcolumnwillbeinsertedintheoutputtable, atposition‘outcolumn’, otherwisetheexisting
+                   output column will be overwritten (in which case it must have a compatible datatype). Note
+                   that the ﬁrst column in a table is at colnum = 1.
                       FTCPCL(inunit,outunit,incolnum,outcolnum,createcol, > status);
               6.7.4  Read and Write Column Data Routines
               Thesesubroutinesputorget data values in the current ASCIIor Binary table extension. Automatic
               datatypeconversionisperformedfornumericaldatatypes(B,I,J,E,D)ifthedatatypeofthecolumn
               (deﬁned by the TFORM keyword) diﬀers from the data type of the calling subroutine. The data
               values are also scaled by the TSCALn and TZEROn header values as they are being written to or
               read from the FITS array. The fttscl subroutine MUST be used to deﬁne the scaling parameters
               when writing data to the table or to override the default scaling values given in the header when
               reading from the table. Note that it is *not* necessary to insert rows in a table before writing data
               to those rows (indeed, it would be ineﬃcient to do so). Instead, one may simply write data to any
               row of the table, whether that row of data already exists or not.
               In the case of binary tables with vector elements, the ’felem’ parameter deﬁnes the starting pixel
               within the element vector. This parameter is ignored with ASCII tables. Similarly, in the case
-              of binary tables the ’nelements’ parameter speciﬁes the total number of vector values read or
-              written (continuing on subsequent rows if required) and not the number of table elements. Two
-              sets of subroutines are provided to get the column data which diﬀer in the way undeﬁned pixels
-              are handled. The ﬁrst set of routines (FTGCV) simply return an array of data elements in which
                   6.7.  FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES                                                       61
+                  of binary tables the ’nelements’ parameter speciﬁes the total number of vector values read or
+                  written (continuing on subsequent rows if required) and not the number of table elements. Two
+                  sets of subroutines are provided to get the column data which diﬀer in the way undeﬁned pixels
+                  are handled. The ﬁrst set of routines (FTGCV) simply return an array of data elements in which
                   undeﬁned pixels are set equal to a value speciﬁed by the user in the ’nullval’ parameter. An
                   additional feature of these subroutines is that if the user sets nullval = 0, then no checks for
                   undeﬁned pixels will be performed, thus increasing the speed of the program. The second set of
                   routines (FTGCF) returns the data element array and in addition a logical array of ﬂags which
                   deﬁnes whether the corresponding data pixel is undeﬁned.
                   Any column, regardless of it’s intrinsic datatype, may be read as a string. It should be noted
                   however that reading a numeric column as a string is 10 - 100 times slower than reading the same
@@ -2146,18 +2149,18 @@
                         the null value deﬁned by the previous call to FTSNUL will be substituted; For integer FITS
                         columns, in a binary table the null value deﬁned by the previous call to FTTNUL will be
                         substituted; For ﬂoating point FITS columns a special IEEE NaN (Not-a-Number) value will
                         be substituted.
                         Thealternate version of these routines, whose names end in ’LL’ after the datatype character,
                         support large tables with more then 2*31 rows. When calling these routines, the frow and
                         felem parameters *must* be 64-bit integer*8 variables, instead of normal 4-byte integers.
-                             FTPCN[SBIJKED](unit,colnum,frow,felem,nelements,values,nullval > status)
-                             FTPCN[SBIJKED]LL(unit,colnum,(I*8) frow,(I*8) felem,nelements,values,
-                                        nullval > status)
        62              CHAPTER6. ADVANCEDINTERFACESUBROUTINES
+           FTPCN[SBIJKED](unit,colnum,frow,felem,nelements,values,nullval > status)
+           FTPCN[SBIJKED]LL(unit,colnum,(I*8) frow,(I*8) felem,nelements,values,
+                nullval > status)
        3 Put bit values into a binary byte (’B’) or bit (’X’) table column (in the CDU). LRAY is an
           array of logical values corresponding to the sequence of bits to be written. If LRAY is true
           then the corresponding bit is set to 1, otherwise the bit is set to 0. Note that in the case of
           ’X’ columns, FITSIO will write to all 8 bits of each byte whether they are formally valid or
           not. Thus if the column is deﬁned as ’4X’, and one calls FTPCLX with fbit=1 and nbit=8,
           then all 8 bits will be written into the ﬁrst byte (as opposed to writing the ﬁrst 4 bits into
           the ﬁrst row and then the next 4 bits into the next row), even though the last 4 bits of each
@@ -2186,16 +2189,16 @@
           will have the corresponding ﬂagvals element set equal to .TRUE. The ANYF parameter is
           set to true if any of the returned elements are undeﬁned. (The SPP FSGCFS routine has an
           additional integer argument after the VALUES character string which speciﬁes the size of the
           1st dimension of this 2-D CHAR array).
           Thealternate version of these routines, whose names end in ’LL’ after the datatype character,
           support large tables with more then 2*31 rows. When calling these routines, the frow and
           felem parameters *must* be 64-bit integer*8 variables, instead of normal 4-byte integers.
-           FTGCF[SLBIJKEDCM](unit,colnum,frow,felem,nelements, >
                   6.7.  FITS ASCII AND BINARY TABLE DATA I/O SUBROUTINES                                                       63
+                             FTGCF[SLBIJKEDCM](unit,colnum,frow,felem,nelements, >
                                                     values,flagvals,anyf,status)
                              FTGCF[BIJKED]LL(unit,colnum, (I*8) frow, (I*8) felem,nelements, >
                                                     values,flagvals,anyf,status)
                   7 Get an arbitrary data subsection from an N-dimensional array in a binary table vector column.
                         Undeﬁned pixels in the array will be set equal to the value of ’nullval’, unless nullval=0 in
                         which case no testing for undeﬁned pixels will be performed. The ﬁrst and last rows in the
                         table to be read are speciﬁed by fpixels(naxis+1) and lpixels(naxis+1), and hence are treated
@@ -2336,101 +2339,101 @@
           WCS keyword values, but will also return with status = 506, to warn the calling program
           that approximations have been made. It is then up to the calling program to decide whether
           the approximations are suﬃciently accurate for the particular application, or whether more
           precise WCS transformations must be performed using new-style WCS keywords directly.
            FTGICS(unit, > xrval,yrval,xrpix,yrpix,xinc,yinc,rot,coordtype,status)
            6.10. FILE CHECKSUM SUBROUTINES                                 67
            2 Get the values of all the standard FITS celestial coordinate system keywords from the header
-              of a FITS table where the X and Y (or RA and DEC coordinates are stored in 2 separate
-              columns of the table. These values may then be passed to the subroutines that perform the
-              coordinate transformations.
+               of a FITS table where the X and Y (or RA and DEC coordinates are stored in 2 separate
+               columns of the table. These values may then be passed to the subroutines that perform the
+               coordinate transformations.
                  FTGTCS(unit,xcol,ycol, >
                        xrval,yrval,xrpix,yrpix,xinc,yinc,rot,coordtype,status)
            3 Calculate the celestial coordinate corresponding to the input X and Y pixel location in the
-              image.
+               image.
                  FTWLDP(xpix,ypix,xrval,yrval,xrpix,yrpix,xinc,yinc,rot,
                                 coordtype, > xpos,ypos,status)
            4 Calculate the X and Y pixel location corresponding to the input celestial coordinate in the
-              image.
+               image.
                  FTXYPX(xpos,ypos,xrval,yrval,xrpix,yrpix,xinc,yinc,rot,
                                 coordtype, > xpix,ypix,status)
            6.10  File Checksum Subroutines
            The following routines either compute or validate the checksums for the CHDU. The DATASUM
            keyword is used to store the numerical value of the 32-bit, 1’s complement checksum for the data
            unit alone. If there is no data unit then the value is set to zero. The numerical value is stored as an
            ASCIIstringof digits, enclosed in quotes, because the value may be too large to represent as a 32-bit
            signed integer. The CHECKSUM keyword is used to store the ASCII encoded COMPLEMENT of
            the checksum for the entire HDU. Storing the complement, rather than the actual checksum, forces
            the checksum for the whole HDU to equal zero. If the ﬁle has been modiﬁed since the checksums
            were computed, then the HDU checksum will usually not equal zero. These checksum keyword
            conventions are based on a paper by Rob Seaman published in the proceedings of the ADASS IV
            conference in Baltimore in November 1994 and a later revision in June 1995.
            1 Compute and write the DATASUM and CHECKSUM keyword values for the CHDU into the
-              current header. The DATASUM value is the 32-bit checksum for the data unit, expressed as a
-              decimal integer enclosed in single quotes. The CHECKSUM keyword value is a 16-character
-              string which is the ASCII-encoded value for the complement of the checksum for the whole
-              HDU. If these keywords already exist, their values will be updated only if necessary (i.e., if
-              the ﬁle has been modiﬁed since the original keyword values were computed).
+               current header. The DATASUM value is the 32-bit checksum for the data unit, expressed as a
+               decimal integer enclosed in single quotes. The CHECKSUM keyword value is a 16-character
+               string which is the ASCII-encoded value for the complement of the checksum for the whole
+               HDU. If these keywords already exist, their values will be updated only if necessary (i.e., if
+               the ﬁle has been modiﬁed since the original keyword values were computed).
                  FTPCKS(unit, > status)
            2 Update the CHECKSUMkeyword value in the CHDU, assuming that the DATASUM keyword
-              exists and already has the correct value. This routine calculates the new checksum for the
-              current header unit, adds it to the data unit checksum, encodes the value into an ASCII
-              string, and writes the string to the CHECKSUM keyword.
-           68                     CHAPTER6. ADVANCEDINTERFACESUBROUTINES
+               exists and already has the correct value. This routine calculates the new checksum for the
+               current header unit, adds it to the data unit checksum, encodes the value into an ASCII
+               string, and writes the string to the CHECKSUM keyword.
+           68                      CHAPTER6. ADVANCEDINTERFACESUBROUTINES
                  FTUCKS(unit, > status)
            3 Verify the CHDU by computing the checksums and comparing them with the keywords. The
-              data unit is veriﬁed correctly if the computed checksum equals the value of the DATASUM
-              keyword. The checksum for the entire HDU (header plus data unit) is correct if it equals
-              zero. The output DATAOK and HDUOK parameters in this subroutine are integers which
-              will have a value = 1 if the data or HDU is veriﬁed correctly, a value = 0 if the DATASUM or
-              CHECKSUMkeywordis not present, or value = -1 if the computed checksum is not correct.
+               data unit is veriﬁed correctly if the computed checksum equals the value of the DATASUM
+               keyword. The checksum for the entire HDU (header plus data unit) is correct if it equals
+               zero. The output DATAOK and HDUOK parameters in this subroutine are integers which
+               will have a value = 1 if the data or HDU is veriﬁed correctly, a value = 0 if the DATASUM or
+               CHECKSUMkeywordis not present, or value = -1 if the computed checksum is not correct.
                  FTVCKS(unit, > dataok,hduok,status)
            4 Computeandreturnthe checksum values for the CHDU (as double precision variables) without
-              creating or modifying the CHECKSUM and DATASUM keywords. This routine is used
-              internally by FTVCKS, but may be useful in other situations as well.
+               creating or modifying the CHECKSUM and DATASUM keywords. This routine is used
+               internally by FTVCKS, but may be useful in other situations as well.
                  FTGCKS(unit, > datasum,hdusum,status)
            5 Encode a checksum value (stored in a double precision variable) into a 16-character string. If
-              COMPLEMENT=.true. then the 32-bit sum value will be complemented before encoding.
+               COMPLEMENT=.true. then the 32-bit sum value will be complemented before encoding.
                  FTESUM(sum,complement, > checksum)
            6 Decode a 16 character checksum string into a double precision value. If COMPLEMENT =
-              .true. then the 32-bit sum value will be complemented after decoding.
+               .true. then the 32-bit sum value will be complemented after decoding.
                  FTDSUM(checksum,complement, > sum)
            6.11   Date and Time Utility Routines
            The following routines help to construct or parse the FITS date/time strings. Starting in the year
            2000, the FITS DATE keyword values (and the values of other ‘DATE-’ keywords) must have the
            form ’YYYY-MM-DD’ (date only) or ’YYYY-MM-DDThh:mm:ss.ddd...’ (date and time) where
            the number of decimal places in the seconds value is optional. These times are in UTC. The older
            ’dd/mm/yy’ date format may not be used for dates after 01 January 2000.
            1 Get the current system date. The returned year has 4 digits (1999, 2000, etc.)
                  FTGSDT( > day, month, year, status )
            2 Get the current system date and time string (’YYYY-MM-DDThh:mm:ss’). The time will be
-              in UTC/GMTifavailable, as indicated by a returned timeref value = 0. If the returned value
-              of timeref = 1 then this indicates that it was not possible to convert the local time to UTC,
-              and thus the local time was returned.
+               in UTC/GMTifavailable, as indicated by a returned timeref value = 0. If the returned value
+               of timeref = 1 then this indicates that it was not possible to convert the local time to UTC,
+               and thus the local time was returned.
            6.12. GENERAL UTILITY SUBROUTINES                               69
                  FTGSTM(> datestr, timeref, status)
            3 Construct a date string from the input date values. If the year is between 1900 and 1998, inclu-
-              sive, then the returned date string will have the old FITS format (’dd/mm/yy’), otherwise
-              the date string will have the new FITS format (’YYYY-MM-DD’). Use FTTM2S instead to
-              always return a date string using the new FITS format.
+               sive, then the returned date string will have the old FITS format (’dd/mm/yy’), otherwise
+               the date string will have the new FITS format (’YYYY-MM-DD’). Use FTTM2S instead to
+               always return a date string using the new FITS format.
                  FTDT2S( year, month, day, > datestr, status)
            4 Construct a new-format date + time string (’YYYY-MM-DDThh:mm:ss.ddd...’). If the year,
-              month, and day values all = 0 then only the time is encoded with format ’hh:mm:ss.ddd...’.
-              The decimals parameter speciﬁes how many decimal places of fractional seconds to include
-              in the string. If ‘decimals’ is negative, then only the date will be return (’YYYY-MM-DD’).
+               month, and day values all = 0 then only the time is encoded with format ’hh:mm:ss.ddd...’.
+               The decimals parameter speciﬁes how many decimal places of fractional seconds to include
+               in the string. If ‘decimals’ is negative, then only the date will be return (’YYYY-MM-DD’).
                  FTTM2S( year, month, day, hour, minute, second, decimals,
                         > datestr, status)
            5 Return the date as read from the input string, where the string may be in either the old
-              (’dd/mm/yy’) or new (’YYYY-MM-DDThh:mm:ss’ or ’YYYY-MM-DD’) FITS format.
+               (’dd/mm/yy’) or new (’YYYY-MM-DDThh:mm:ss’ or ’YYYY-MM-DD’) FITS format.
                  FTS2DT(datestr, > year, month, day, status)
            6 Return the date and time as read from the input string, where the string may be in either the
-              old or new FITS format. The returned hours, minutes, and seconds values will be set to zero
-              if the input string does not include the time (’dd/mm/yy’ or ’YYYY-MM-DD’) . Similarly,
-              the returned year, month, and date values will be set to zero if the date is not included in
-              the input string (’hh:mm:ss.ddd...’).
+               old or new FITS format. The returned hours, minutes, and seconds values will be set to zero
+               if the input string does not include the time (’dd/mm/yy’ or ’YYYY-MM-DD’) . Similarly,
+               the returned year, month, and date values will be set to zero if the date is not included in
+               the input string (’hh:mm:ss.ddd...’).
                  FTS2TM(datestr, > year, month, day, hour, minute, second, status)
            6.12  General Utility Subroutines
            The following utility subroutines may be useful for certain applications:
            1 Return the starting byte address of the CHDU and the next HDU.
                  FTGHAD(iunit, > curaddr, nextaddr)
            2 Convert a character string to uppercase (operates in place).
                  FTUPCH(string)
@@ -2612,15 +2615,15 @@
                    # the following template line deletes the DATE keyword
                    - DATE
                    # the following template line modifies the NAME keyword to OBJECT
                    - NAME OBJECT
              18 Parse the input string containing a list of rows or row ranges, and return integer arrays con-
                   taining the ﬁrst and last row in each range. For example, if rowlist = ”3-5, 6, 8-9” then it will
                   return numranges = 3, rangemin = 3, 6, 8 and rangemax = 5, 6, 9. At most, ’maxranges’
-       6.12. GENERAL UTILITY SUBROUTINES          75
+       6.12. GENERAL UTILITY SUBROUTINES         75
           number of ranges will be returned. ’maxrows’ is the maximum number of rows in the table;
           any rows or ranges larger than this will be ignored. The rows must be speciﬁed in increasing
           order, and the ranges must not overlap. A minus sign may be use to specify all the rows to
           the upper or lower bound, so ”50-” means all the rows from 50 to the end of the table, and
           ”-” means all the rows in the table, from 1 - maxrows.
          FTRWRG(rowlist, maxrows, maxranges, >
              numranges, rangemin, rangemax, status)
@@ -2687,15 +2690,15 @@
                by the application program.
              • Table rows may be selected, or ﬁltered out, on the ﬂy when the table is opened by CFITSIO,
                based on an arbitrary user-speciﬁed expression. Only rows for which the expression evaluates
                to ’TRUE’ are retained in the copy of the table that is opened by the application program.
              • Histogram images may be created on the ﬂy by binning the values in table columns, resulting
                in a virtual N-dimensional FITS image. The application program then only sees the FITS
                image (in the primary array) instead of the original FITS table.
-                                             79
+                                            79
        80                 CHAPTER8. EXTENDEDFILENAMESYNTAX
        The latter 3 features in particular add very powerful data processing capabilities directly into
        CFITSIO, and hence into every task that uses CFITSIO to read or write FITS ﬁles. For example,
        these features transform a very simple program that just copies an input FITS ﬁle to a new output
        ﬁle (like the ‘ﬁtscopy’ program that is distributed with CFITSIO) into a multipurpose FITS ﬁle
        processing tool. By appending fairly simple qualiﬁers onto the name of the input FITS ﬁle, the user
        can perform quite complex table editing operations (e.g., create new columns, or ﬁlter out rows
@@ -3253,24 +3256,24 @@
              ation may be speciﬁed by separating them with commas or semi-colons.
                 • Copy only a speciﬁed list of columns columns to the ﬁltered input ﬁle. The list of column
                   name should be separated by commas or semi-colons. Wild card characters may be used
                   in the column names to match multiple columns. If the expression contains both a list of
                   columns to be included and columns to be deleted, then all the columns in the original table
                   except the explicitly deleted columns will appear in the ﬁltered table (i.e., there is no need
                   to explicitly list the columns to be included if any columns are being deleted).
-           8.10. COLUMN AND KEYWORD FILTERING SPECIFICATION                   95
-             • Delete a column or keyword by listing the name preceded by a minus sign or an exclamation
+           8.10. COLUMN AND KEYWORD FILTERING SPECIFICATION                    95
+              • Delete a column or keyword by listing the name preceded by a minus sign or an exclamation
                mark(!), e.g., ’-TIME’ will delete the TIME column if it exists, otherwise the TIME keyword.
                An error is returned if neither a column nor keyword with this name exists. Note that the
                exclamation point, ’!’, is a special UNIX character, so if it is used on the command line rather
                than entered at a task prompt, it must be preceded by a backslash to force the UNIX shell
                to ignore it.
-             • Rename an existing column or keyword with the syntax ’NewName == OldName’. An error
+              • Rename an existing column or keyword with the syntax ’NewName == OldName’. An error
                is returned if neither a column nor keyword with this name exists.
-             • Append a new column or keyword to the table. To create a column, give the new name,
+              • Append a new column or keyword to the table. To create a column, give the new name,
                optionally followed by the datatype in parentheses, followed by a single equals sign and an
                expression to be used to compute the value (e.g., ’newcol(1J) = 0’ will create a new 32-bit
                integer column called ’newcol’ ﬁlled with zeros). The datatype is speciﬁed using the same
                syntax that is allowed for the value of the FITS TFORMn keyword (e.g., ’I’, ’J’, ’E’, ’D’, etc.
                for binary tables, and ’I8’, F12.3’, ’E20.12’, etc. for ASCII tables). If the datatype is not
                speciﬁed then an appropriate datatype will be chosen depending on the form of the expression
                (maybeacharacterstring, logical, bit, long integer, or double column). An appropriate vector
@@ -3288,15 +3291,15 @@
                   #HISTORY = ’This is a history keyword’
                Note that the equal sign and the quote characters will be removed, so that the resulting
                header keywords in these cases will look like this:
                   COMMENT This is a comment keyword
                   HISTORY This is a history keyword
                These two special keywords are always appended to the end of the header and will not aﬀect
                any previously existing COMMENT or HISTORY keywords.
-             • Recompute (overwrite) the values in an existing column or keyword by giving the name
+              • Recompute (overwrite) the values in an existing column or keyword by giving the name
                followed by an equals sign and an arithmetic expression.
            Theexpression that is used when appending or recomputing columns or keywords can be arbitrarily
            complex and may be a function of other header keyword values and other columns (in the same
              96                                  CHAPTER8. EXTENDEDFILENAMESYNTAX
              row). The full syntax and available functions for the expression are described below in the row
              ﬁlter speciﬁcation section.
              If the expression contains both a list of columns to be included and columns to be deleted, then all
@@ -3332,27 +3335,27 @@
                                                 keyword for this column. The use of the
                                                 ’&’ character for the keyword comment
                                                 string means preserve the existing
                                                 comment string for that keyword. The
                                                 final ’*’ preserves all the columns
                                                 in the input table in the virtual
                                                 output table.
-             8.11. ROW FILTERING SPECIFICATION                                               97
+             8.11. ROW FILTERING SPECIFICATION                                                97
              8.11    Row Filtering Speciﬁcation
              Whenentering the name of a FITS table that is to be opened by a program, an optional row ﬁlter
              may be speciﬁed to select a subset of the rows in the table. A temporary new FITS ﬁle is created
              on the ﬂy which contains only those rows for which the row ﬁlter expression evaluates to true. (The
              primary array and any other extensions in the input ﬁle are also copied to the temporary ﬁle). The
              original FITS ﬁle is closed and the new virtual ﬁle is opened by the application program. The row
              ﬁlter expression is enclosed in square brackets following the ﬁle name and extension name (e.g.,
              ’ﬁle.ﬁts[events][GRADE==50]’ selects only those rows where the GRADE column value equals 50).
              When dealing with tables where each row has an associated time and/or 2D spatial position, the
              row ﬁlter expression can also be used to select rows based on the times in a Good Time Intervals
              (GTI) extension, or on spatial position as given in a SAO-style region ﬁle.
-             8.11.1  General Syntax
+             8.11.1   General Syntax
              The row ﬁltering expression can be an arbitrarily complex series of operations performed on con-
              stants, keyword values, and column data taken from the speciﬁed FITS TABLE extension. The
              expression must evaluate to a boolean value for each row of the table, where a value of FALSE
              means that the row will be excluded.
              For complex or commonly used ﬁlters, one can place the expression into a text ﬁle and import it
              into the row ﬁlter using the syntax ’[@ﬁlename.txt]’. The expression can be arbitrarily complex
              and extend over multiple lines of the ﬁle. Any lines in the external text ﬁle that begin with 2 slash
@@ -3400,28 +3403,30 @@
                 "arc cosine"         arccos(x) "arc sine"            arcsin(x)
                 "arc tangent"        arctan(x) "arc tangent"         arctan2(y,x)
                 "hyperbolic cos"     cosh(x)   "hyperbolic sin"      sinh(x)
                 "hyperbolic tan"     tanh(x)   "round to nearest int" round(x)
                 "round down to int" floor(x)   "round up to int"     ceil(x)
                 "exponential"        exp(x)    "square root"         sqrt(x)
                 "natural log"        log(x)    "common log"          log10(x)
+                "error function"     erf(x)    "complement of erf"   erfc(x)
+                "gamma function"     gamma(x)
                 "modulus"            x % y
                 "bitwise AND"        x & y     "bitwise OR"          x | y
                 "bitwise XOR"        x ^^ y    (bitwise operators are 32-bit int only)
                 "random # [0.0,1.0)" random()
                 "random Gaussian"    randomn() "random Poisson"      randomp(x)
                 "minimum"            min(x,y)  "maximum"             max(x,y)
                 "cumulative sum"     accum(x)  "sequential difference" seqdiff(x)
                 "if-then-else"       b?x:y
                 "angular separation" angsep(ra1,dec1,ra2,de2) (all in degrees)
                 "substring"          strmid(s,p,n) "string search"   strstr(s,r)
              The bitwise operators for AND, OR and XOR operate upon 32-bit integer expressions only.
+             8.11. ROW FILTERING SPECIFICATION                                               99
              Three diﬀerent random number functions are provided: random(), with no arguments, produces a
              uniform random deviate between 0 and 1; randomn(), also with no arguments, produces a normal
-             8.11. ROW FILTERING SPECIFICATION                                               99
              (Gaussian) random deviate with zero mean and unit standard deviation; randomp(x) produces a
              Poisson random deviate whose expected number of counts is X. X may be any positive real number
              of expected counts, including fractional values, but the return value is an integer.
              Whentherandomfunctions are used in a vector expression, by default the same random value will
              be used when evaluating each element of the vector. If diﬀerent random numbers are desired, then
              the name of a vector column should be supplied as the single argument to the random function
              (e.g., ”ﬂux + 0.1 * random(ﬂux)”, where ”ﬂux” is the name of a vector column). This will create
@@ -3452,16 +3457,16 @@
              The following type casting operators are available, where the enclosing parentheses are required
              and taken from the C language usage. Also, the integer to real casts values to double precision:
                              "real to integer"    (int) x     (INT) x
                              "integer to real"    (float) i   (FLOAT) i
              In addition, several constants are built in for use in numerical expressions:
                      #pi              3.1415...      #e             2.7182...
                      #deg             #pi/180        #row           current row number
-                     #null         undefined value   #snull         undefined string
              100                                 CHAPTER8. EXTENDEDFILENAMESYNTAX
+                     #null         undefined value   #snull         undefined string
              A string constant must be enclosed in quotes as in ’Crab’. The ”null” constants are useful for
              conditionally setting table values to a NULL, or undeﬁned, value (eg., ”col1==-99 ? #NULL :
              col1”).
              Integer constants may be speciﬁed using the following notation,
                         13245   decimal integer
                         0x12f3 hexidecimal integer
                         0o1373 octal integer
@@ -3473,34 +3478,37 @@
              also an integer or real:
                                  near(value_1, value_2, tolerance)
              WhenaNULL,orundeﬁned,valueisencounteredintheFITStable, the expression will evaluate to
              NULLunless the undeﬁned value is not actually required for evaluation, e.g. ”TRUE .or. NULL”
              evaluates to TRUE. The following two functions allow some NULL detection and handling:
                       "a null value?"              ISNULL(x)
                       "define a value for null"    DEFNULL(x,y)
-             The former returns a boolean value of TRUE if the argument x is NULL. The later ”deﬁnes” a
-             value to be substituted for NULL values; it returns the value of x if x is not NULL, otherwise it
-             returns the value of y.
+                      "declare certain value null" SETNULL(x,y)
+             ISNULL(x)returns a boolean value of TRUE if the argument x is NULL. DEFNULL(x,y) ”deﬁnes”
+             a value to be substituted for NULL values; it returns the value of x if x is not NULL, otherwise it
+             returns the value of y. SETNULL(x,y) allows NULL values to be inserted into a variable; if x==y,
+             a NULL value is returned; otherwise y is returned (x and y must be numerical, and x must be a
+             scalar).
              8.11.2  Bit Masks
              Bit masks can be used to select out rows from bit columns (TFORMn = #X) in FITS ﬁles. To
              represent the mask, binary, octal, and hex formats are allowed:
                               binary:   b0110xx1010000101xxxx0001
                               octal:    o720x1 -> (b111010000xxx001)
                               hex:      h0FxD -> (b00001111xxxx1101)
-             In all the representations, an x or X is allowed in the mask as a wild card. Note that the x represents
-             a diﬀerent number of wild card bits in each representation. All representations are case insensitive.
-             Although bitmasks may be of arbitrary length and contain a wildcard, they may only be used
-             in logical expressions, unlike integer constants (see above) which may be used in any arithmetic
-             expression.
-               8.11. ROW FILTERING SPECIFICATION                                                          101
+               8.11. ROW FILTERING SPECIFICATION                                                         101
+               In all the representations, an x or X is allowed in the mask as a wild card. Note that the x represents
+               a diﬀerent number of wild card bits in each representation. All representations are case insensitive.
+               Although bitmasks may be of arbitrary length and contain a wildcard, they may only be used
+               in logical expressions, unlike integer constants (see above) which may be used in any arithmetic
+               expression.
                To construct the boolean expression using the mask as the boolean equal operator described above
                on a bit table column. For example, if you had a 7 bit column named ﬂags in a FITS table and
                wanted all rows having the bit pattern 0010011, the selection expression would be:
                                                flags == b0010011
-                    or
+                   or
                                                flags .eq. b10011
                It is also possible to test if a range of bits is less than, less than equal, greater than and greater
                than equal to a particular boolean value:
                                                flags <= bxxx010xx
                                                flags .gt. bxxx100xx
                                                flags .le. b1xxxxxxx
                Notice the use of the x bit value to limit the range of bits being compared.
@@ -3509,160 +3517,219 @@
                Bit wise AND, OR and NOT operations are also possible on two or more bit ﬁelds using the
                ’&’(AND), ’|’(OR), and the ’!’(NOT) operators. All of these operators result in a bit ﬁeld which
                can then be used with the equal operator. For example:
                                              (!flags) == b1101100
                                              (flags & b1000001) == bx000001
                Bit ﬁelds can be appended as well using the ’+’ operator. Strings can be concatenated this way,
                too.
-               8.11.3    Vector Columns
+               8.11.3   Vector Columns
                Vector columns can also be used in building the expression. No special syntax is required if one
                wants to operate on all elements of the vector.  Simply use the column name as for a scalar
                column. Vector columns can be freely intermixed with scalar columns or constants in virtually all
                expressions. The result will be of the same dimension as the vector. Two vectors in an expression,
                though, need to have the same number of elements and have the same dimensions. The only places
                a vector column cannot be used (for now, anyway) are the SAO region functions and the NEAR
                boolean function.
-               Arithmetic and logical operations are all performed on an element by element basis. Comparing two
-               vector columns, eg ”COL1 == COL2”, thus results in another vector of boolean values indicating
-               which elements of the two vectors are equal.
-               Eight functions are available that operate on a vector and return a scalar result:
-               102                                        CHAPTER8. EXTENDEDFILENAMESYNTAX
-                    "minimum"         MIN(V)             "maximum"                   MAX(V)
-                    "average"         AVERAGE(V)         "median"                    MEDIAN(V)
-                    "summation"       SUM(V)             "standard deviation"        STDDEV(V)
-                    "# of values" NELEM(V)               "# of non-null values" NVALID(V)
-               where V represents the name of a vector column or a manually constructed vector using curly
-               brackets as described below. The ﬁrst 6 of these functions ignore any null values in the vector when
-               computing the result. The STDDEV() function computes the sample standard deviation, i.e. it is
-               proportional to 1/SQRT(N-1) instead of 1/SQRT(N), where N is NVALID(V).
-               The SUM function literally sums all the elements in x, returning a scalar value. If x is a boolean
-               vector, SUM returns the number of TRUE elements. The NELEM function returns the number
-               of elements in vector x whereas NVALID return the number of non-null elements in the vector.
-               (NELEMalso operates on bit and string columns, returning their column widths.) As an example,
-               to test whether all elements of two vectors satisfy a given logical comparison, one can use the
-               expression
-                                SUM( COL1 > COL2 ) == NELEM( COL1 )
-               which will return TRUE if all elements of COL1 are greater than their corresponding elements in
-               COL2.
-               To specify a single element of a vector, give the column name followed by a comma-separated list
-               of coordinates enclosed in square brackets. For example, if a vector column named PHAS exists in
+             102                                 CHAPTER8. EXTENDEDFILENAMESYNTAX
+             Arithmetic and logical operations are all performed on an element by element basis. Comparing two
+             vector columns, eg ”COL1 == COL2”, thus results in another vector of boolean values indicating
+             which elements of the two vectors are equal.
+             Several functions are available that operate on a vector. All but the last two return a scalar result:
+                 "minimum"      MIN(V)          "maximum"               MAX(V)
+                 "average"      AVERAGE(V)      "median"                MEDIAN(V)
+                 "summation"    SUM(V)          "standard deviation"    STDDEV(V)
+                 "# of values" NELEM(V)         "# of non-null values" NVALID(V)
+                 "# axes"       NAXIS(V)        "axis dimension"        NAXES(V,n)
+                 "axis pos’n"   AXISELEM(V,n)   "vector element pos’n" ELEMENTNUM(V)
+                                                "promote to array"      ARRAY(X,d)
+             where V represents the name of a vector column or a manually constructed vector using curly
+             brackets as described below. The ﬁrst 6 of these functions ignore any null values in the vector when
+             computing the result. The STDDEV() function computes the sample standard deviation, i.e. it is
+             proportional to 1/SQRT(N-1) instead of 1/SQRT(N), where N is NVALID(V).
+             TheNAXIS(V)functionreturns the number of axes of the vector, for example a 2D array would be
+             NAXIS(V) == 2. The NAXES(V,n) function returns the dimension of axis n, for example a 4x2
+             array would have NAXES(V,1) == 4. The ELEMENTNUM(V) and AXISELEM(V,n) functions
+             return vectors of the same size as the input vector V. ELEMENTNUM(V) returns the vector
+             element position for each element in the vector, starting from 1 in each row. The AXISELEM(V,n)
+             function is similar but returns the element position of axis n only.
+             The SUM function literally sums all the elements in x, returning a scalar value. If x is a boolean
+             vector, SUM returns the number of TRUE elements. The NELEM function returns the number
+             of elements in vector x whereas NVALID return the number of non-null elements in the vector.
+             (NELEMalso operates on bit and string columns, returning their column widths.) As an example,
+             to test whether all elements of two vectors satisfy a given logical comparison, one can use the
+             expression
+                           SUM( COL1 > COL2 ) == NELEM( COL1 )
+             which will return TRUE if all elements of COL1 are greater than their corresponding elements in
+             COL2.
+             The ARRAY(X,d) function promotes scalar value X to a vector (or array) table element. X may
+             be any scalar-valued item, including a column, an expression, or a constant value. The resulting
+             vector or array will have the same scalar value replicated into each element position. This may
+             be a useful way to construct large arrays without using the cumbersome {vector} notation. The
+             dimensions of the new array are given by the second argument, d. d can either be a single constant
+             integer value, or a vector of up to ﬁve dimensions of the form {Nx,Ny,...}. Thus, ARRAY(TIME,4)
+             would promote TIME to be a 4-vector, and ARRAY(0, {2,3,1}) would construct an array of all 0’s
+             with dimensions 2×3×1.
+             To specify a single element of a vector, give the column name followed by a comma-separated list
+             of coordinates enclosed in square brackets. For example, if a vector column named PHAS exists in
+               8.11. ROW FILTERING SPECIFICATION                                                             103
                the table as a one dimensional, 256 component list of numbers from which you wanted to select the
                57th component for use in the expression, then PHAS[57] would do the trick. Higher dimensional
                arrays of data may appear in a column. But in order to interpret them, the TDIMn keyword
                must appear in the header. Assuming that a (4,4,4,4) array is packed into each row of a column
                namedARRAY4D,the(1,2,3,4) component element of each row is accessed by ARRAY4D[1,2,3,4].
                Arrays up to dimension 5 are currently supported. Each vector index can itself be an expression,
                although it must evaluate to an integer value within the bounds of the vector. Vector columns
                which contain spaces or arithmetic operators must have their names enclosed in ”$” characters as
                with $ARRAY-4D$[1,2,3,4].
-               A more C-like syntax for specifying vector indices is also available.  The element used in the
+               A more C-like syntax for specifying vector indices is also available.   The element used in the
                preceding example alternatively could be speciﬁed with the syntax ARRAY4D[4][3][2][1]. Note the
                reverse order of indices (as in C), as well as the fact that the values are still ones-based (as in
                Fortran – adopted to avoid ambiguity for 1D vectors). With this syntax, one does not need to
                specify all of the indices. To extract a 3D slice of this 4D array, use ARRAY4D[4].
                Variable-length vector columns are not supported.
                Vectors can be manually constructed within the expression using a comma-separated list of elements
                surrounded by curly braces (’{}’). For example, ’{1,3,6,1}’ is a 4-element vector containing the
                values 1, 3, 6, and 1. The vector can contain only boolean, integer, and real values (or expressions).
                Theelements will be promoted to the highest datatype present. Any elements which are themselves
                vectors, will be expanded out with each of its elements becoming an element in the constructed
                vector.
-             8.11. ROW FILTERING SPECIFICATION                                              103
-             8.11.4  Good Time Interval Filtering
-             A common ﬁltering method involves selecting rows which have a time value which lies within
-             what is called a Good Time Interval or GTI. The time intervals are deﬁned in a separate FITS
-             table extension which contains 2 columns giving the start and stop time of each good interval.
-             The ﬁltering operation accepts only those rows of the input table which have an associated time
-             which falls within one of the time intervals deﬁned in the GTI extension. A high level function,
-             gtiﬁlter(a,b,c,d), is available which evaluates each row of the input table and returns TRUE or
-             FALSE depending whether the row is inside or outside the good time interval. The syntax is
-                   gtifilter( [ "gtifile" [, expr [, "STARTCOL", "STOPCOL" ] ] ] )
-             whereeach”[]”demarksoptionalparameters. NotethatthequotesaroundthegtiﬁleandSTART/STOP
-             column are required. Either single or double quotes may be used. In cases where this expression
-             is entered on the Unix command line, enclose the entire expression in double quotes, and then use
-             single quotes within the expression to enclose the ’gtiﬁle’ and other terms. It is also usually possible
-             to do the reverse, and enclose the whole expression in single quotes and then use double quotes
-             within the expression. The gtiﬁle, if speciﬁed, can be blank (””) which will mean to use the ﬁrst
-             extension with the name ”*GTI*” in the current ﬁle, a plain extension speciﬁer (eg, ”+2”, ”[2]”,
-             or ”[STDGTI]”) which will be used to select an extension in the current ﬁle, or a regular ﬁlename
-             with or without an extension speciﬁer which in the latter case will mean to use the ﬁrst extension
-             with an extension name ”*GTI*”. Expr can be any arithmetic expression, including simply the
-             time column name. A vector time expression will produce a vector boolean result. STARTCOL
-             and STOPCOLare the names of the START/STOP columns in the GTI extension. If one of them
-             is speciﬁed, they both must be.
-             In its simplest form, no parameters need to be provided – default values will be used. The expression
-             ”gtiﬁlter()” is equivalent to
-                    gtifilter( "", TIME, "*START*", "*STOP*" )
-             This will search the current ﬁle for a GTI extension, ﬁlter the TIME column in the current table,
-             using START/STOP times taken from columns in the GTI extension with names containing the
-             strings ”START” and ”STOP”. The wildcards (’*’) allow slight variations in naming conventions
-             such as ”TSTART” or ”STARTTIME”. The same default values apply for unspeciﬁed parame-
-             ters when the ﬁrst one or two parameters are speciﬁed. The function automatically searches for
-             TIMEZERO/I/F keywords in the current and GTI extensions, applying a relative time oﬀset, if
-             necessary.
-             8.11.5  Spatial Region Filtering
+               8.11.4    Good Time Interval Filtering and Calculation
+               There are two functions for ﬁltering and calculating based on Good Time Intervals, or GTIs. GTIs
+               are commonly used to express fragmented time ranges that are not easy to express with a single
+               start and stop time. The time intervals are deﬁned in a FITS table extension which contains 2
+               columns giving the start and stop time of each good interval.
+               Acommon ﬁltering method involves selecting rows which have a time value which lies within any
+               GTI. The gtiﬁlter() ﬁltering operation accepts only those rows of the input table which have an
+               associated time which falls within one of the time intervals deﬁned in a separate GTI extension.
+               gtiﬁlter(a,b,c,d) evaluates each row of the input table and returns TRUE or FALSE depending
+               whether the row is inside or outside the good time interval. The syntax is
+                      gtifilter( [ "gtifile" [, expr [, "STARTCOL", "STOPCOL" ] ] ] )
+                    or
+                      gtifilter( [ ’gtifile’ [, expr [, ’STARTCOL’, ’STOPCOL’ ] ] ] )
+               whereeach”[]”demarksoptionalparameters. NotethatthequotesaroundthegtiﬁleandSTART/STOP
+               column are required. Either single or double quotes may be used. In cases where this expression
+               is entered on the Unix command line, enclose the entire expression in double quotes, and then use
+               single quotes within the expression to enclose the ’gtiﬁle’ and other terms. It is also usually possible
+               to do the reverse, and enclose the whole expression in single quotes and then use double quotes
+               within the expression. The gtiﬁle, if speciﬁed, can be blank (””) which will mean to use the ﬁrst
+       104                CHAPTER8. EXTENDEDFILENAMESYNTAX
+       extension with the name ”*GTI*” in the current ﬁle, a plain extension speciﬁer (eg, ”+2”, ”[2]”,
+       or ”[STDGTI]”) which will be used to select an extension in the current ﬁle, or a regular ﬁlename
+       with or without an extension speciﬁer which in the latter case will mean to use the ﬁrst extension
+       with an extension name ”*GTI*”. Expr can be any arithmetic expression, including simply the
+       time column name. A vector time expression will produce a vector boolean result. STARTCOL
+       and STOPCOLare the names of the START/STOP columns in the GTI extension. If one of them
+       is speciﬁed, they both must be.
+       In its simplest form, no parameters need to be provided – default values will be used. The expression
+       ”gtiﬁlter()” is equivalent to
+           gtifilter( "", TIME, "*START*", "*STOP*" )
+       This will search the current ﬁle for a GTI extension, ﬁlter the TIME column in the current table,
+       using START/STOP times taken from columns in the GTI extension with names containing the
+       strings ”START” and ”STOP”. The wildcards (’*’) allow slight variations in naming conventions
+       such as ”TSTART” or ”STARTTIME”. The same default values apply for unspeciﬁed parame-
+       ters when the ﬁrst one or two parameters are speciﬁed. The function automatically searches for
+       TIMEZERO/I/F keywords in the current and GTI extensions, applying a relative time oﬀset, if
+       necessary.
+       The related function, gtiﬁnd(a,b,c,d), is similar to gtiﬁlter() but instead of returning true/false,
+       gtiﬁnd() returns the GTI number that brackets the requested time sample. gtiﬁnd() returns the
+       row number in the GTI table that matches the time sample, or -1 if the time sample is not within
+       any GTI. gtiﬁnd() is particularly useful when entries in a table must be categorized by which GTI
+       the fall within. For example, if events in an event list must be separated by good time interval.
+       Theresults of gtiﬁnd() can be used with histogram binning techniques to bin an event list by which
+       GTI.
+          gtifind( "gtifile" , expr [, "STARTCOL", "STOPCOL" ] )
+       The requirements for specifying the gtiﬁle are the same as for gtiﬁlter() as described above. Like
+       gtiﬁlter(), the expr is the time-like expression and is optional (defaulting to TIME). The start and
+       stop columns default to START and STOP.
+       The function, gtioverlap(a,b,c,d,e), computes the overlap between a user-requested time range and
+       the entries in a GTI. The cases of no overlap, partial overlap, or overlap of many GTIs within the
+       user requested range are handled. gtioverlap() is very useful for calculating exposure times and
+       fractional exposures of individual time bins, say for a light curve. The syntax of gtioverlap() is
+          gtioverlap( "gtifile" , startExpr, stopExpr [, "STARTCOL", "STOPCOL" ] )
+         or
+          gtioverlap( ’gtifile’ , startExpr, stopExpr [, ’STARTCOL’, ’STOPCOL’ ] )
+       The requirements for specifying the gtiﬁle are the same as for gtiﬁlter() as described above. Unlike
+       gtiﬁlter(), the startExpr and stopExpr are not optional. startExpr provides a start of the user
+       requested time interval. startExpr is typically TIME, but can be any valid expression. Likewise,
+             8.11. ROW FILTERING SPECIFICATION                                               105
+             stopExpr provides the stop of the user requested time interval, and can be an expression. For
+             example, for a light curve with a TIME column and time bin size of 1.0 seconds, the expression
+                   gtioverlap(’gtifile’,TIME,TIME+1.0)
+             would calculate the amount of overlap exposure time between each one second time bin and the
+             GTI in ’gtiﬁle’. In this case the time bin is assumed to begin at the time speciﬁed by TIME and
+             end 1 second later. Neither startExpr nor stopExpr are required to be constant, and a light curve
+             is not required to have a constant bin size. For tables, the overlap is calculated for each entry in
+             the table.
+             It is also possible to calculate a single overlap value, which would typically be placed in a keyword.
+             For example, a way to to compute the total overlap exposure of a ﬁle whose TIME column is
+             bounded by the keywords TSTART and TSTOP, overlapping with the speciﬁed GTI, would be
+                   #EXPOSURE = gtioverlap(’gtifile’,#TSTART,#TSTOP)
+             The#EXPOSUREsyntax with a leading + ensures that the requested values are treated as keywords.
+             Otherwise, a column named EXPOSURE will be created with the (constant) exposure value in
+             each entry.
+             8.11.5   Spatial Region Filtering
              Another common ﬁltering method selects rows based on whether the spatial position associated
              with each row is located within a given 2-dimensional region. The syntax for this high-level ﬁlter
              is
                     regfilter( "regfilename" [ , Xexpr, Yexpr [ , "wcs cols" ] ] )
-       104                CHAPTER8. EXTENDEDFILENAMESYNTAX
-       whereeach ”[]” demarks optional parameters. The region ﬁle name is required and must be enclosed
-       in quotes. The remaining parameters are optional. There are 2 supported formats for the region
-       ﬁle: ASCII ﬁle or FITS binary table. The region ﬁle contains a list of one or more geometric
-       shapes (circle, ellipse, box, etc.) which deﬁnes a region on the celestial sphere or an area within a
-       particular 2D image. The region ﬁle is typically generated using an image display program such
-       as fv/POW (distribute by the HEASARC), or ds9 (distributed by the Smithsonian Astrophysical
-       Observatory). Users should refer to the documentation provided with these programs for more
-       details on the syntax used in the region ﬁles. The FITS region ﬁle format is deﬁned in a document
-       available from the FITS Support Oﬃce at http://ﬁts.gsfc.nasa.gov/ registry/ region.html
-       In its simplest form, (e.g., regﬁlter(”region.reg”) ) the coordinates in the default ’X’ and ’Y’ columns
-       will be used to determine if each row is inside or outside the area speciﬁed in the region ﬁle.
-       Alternate position column names, or expressions, may be entered if needed, as in
-           regfilter("region.reg", XPOS, YPOS)
-       Region ﬁltering can be applied most unambiguously if the positions in the region ﬁle and in the
-       table to be ﬁltered are both give in terms of absolute celestial coordinate units. In this case the
-       locations and sizes of the geometric shapes in the region ﬁle are speciﬁed in angular units on the sky
-       (e.g., positions given in R.A. and Dec. and sizes in arcseconds or arcminutes). Similarly, each row
-       of the ﬁltered table will have a celestial coordinate associated with it. This association is usually
-       implemented using a set of so-called ’World Coordinate System’ (or WCS) FITS keywords that
-       deﬁne the coordinate transformation that must be applied to the values in the ’X’ and ’Y’ columns
-       to calculate the coordinate.
-       Alternatively, one can perform spatial ﬁltering using unitless ’pixel’ coordinates for the regions and
-       row positions. In this case the user must be careful to ensure that the positions in the 2 ﬁles are
-       self-consistent. A typical problem is that the region ﬁle may be generated using a binned image,
-       but the unbinned coordinates are given in the event table. The ROSAT events ﬁles, for example,
-       have X and Y pixel coordinates that range from 1 - 15360. These coordinates are typically binned
-       by a factor of 32 to produce a 480x480 pixel image. If one then uses a region ﬁle generated from
-       this image (in image pixel units) to ﬁlter the ROSAT events ﬁle, then the X and Y column values
-       must be converted to corresponding pixel units as in:
-           regfilter("rosat.reg", X/32.+.5, Y/32.+.5)
-       Note that this binning conversion is not necessary if the region ﬁle is speciﬁed using celestial
-       coordinate units instead of pixel units because CFITSIO is then able to directly compare the
-       celestial coordinate of each row in the table with the celestial coordinates in the region ﬁle without
-       having to know anything about how the image may have been binned.
-       The last ”wcs cols” parameter should rarely be needed. If supplied, this string contains the names
-       of the 2 columns (space or comma separated) which have the associated WCS keywords. If not
-       supplied, the ﬁlter will scan the X and Y expressions for column names. If only one is found in
-       each expression, those columns will be used, otherwise an error will be returned.
-       These region shapes are supported (names are case insensitive):
-             8.11. ROW FILTERING SPECIFICATION                                              105
+             whereeach ”[]” demarks optional parameters. The region ﬁle name is required and must be enclosed
+             in quotes. The remaining parameters are optional. There are 2 supported formats for the region
+             ﬁle: ASCII ﬁle or FITS binary table. The region ﬁle contains a list of one or more geometric
+             shapes (circle, ellipse, box, etc.) which deﬁnes a region on the celestial sphere or an area within a
+             particular 2D image. The region ﬁle is typically generated using an image display program such
+             as fv/POW (distribute by the HEASARC), or ds9 (distributed by the Smithsonian Astrophysical
+             Observatory). Users should refer to the documentation provided with these programs for more
+             details on the syntax used in the region ﬁles. The FITS region ﬁle format is deﬁned in a document
+             available from the FITS Support Oﬃce at http://ﬁts.gsfc.nasa.gov/ registry/ region.html
+             In its simplest form, (e.g., regﬁlter(”region.reg”) ) the coordinates in the default ’X’ and ’Y’ columns
+             will be used to determine if each row is inside or outside the area speciﬁed in the region ﬁle.
+             Alternate position column names, or expressions, may be entered if needed, as in
+                     regfilter("region.reg", XPOS, YPOS)
+             106                                 CHAPTER8. EXTENDEDFILENAMESYNTAX
+             Region ﬁltering can be applied most unambiguously if the positions in the region ﬁle and in the
+             table to be ﬁltered are both give in terms of absolute celestial coordinate units. In this case the
+             locations and sizes of the geometric shapes in the region ﬁle are speciﬁed in angular units on the sky
+             (e.g., positions given in R.A. and Dec. and sizes in arcseconds or arcminutes). Similarly, each row
+             of the ﬁltered table will have a celestial coordinate associated with it. This association is usually
+             implemented using a set of so-called ’World Coordinate System’ (or WCS) FITS keywords that
+             deﬁne the coordinate transformation that must be applied to the values in the ’X’ and ’Y’ columns
+             to calculate the coordinate.
+             Alternatively, one can perform spatial ﬁltering using unitless ’pixel’ coordinates for the regions and
+             row positions. In this case the user must be careful to ensure that the positions in the 2 ﬁles are
+             self-consistent. A typical problem is that the region ﬁle may be generated using a binned image,
+             but the unbinned coordinates are given in the event table. The ROSAT events ﬁles, for example,
+             have X and Y pixel coordinates that range from 1 - 15360. These coordinates are typically binned
+             by a factor of 32 to produce a 480x480 pixel image. If one then uses a region ﬁle generated from
+             this image (in image pixel units) to ﬁlter the ROSAT events ﬁle, then the X and Y column values
+             must be converted to corresponding pixel units as in:
+                     regfilter("rosat.reg", X/32.+.5, Y/32.+.5)
+             Note that this binning conversion is not necessary if the region ﬁle is speciﬁed using celestial
+             coordinate units instead of pixel units because CFITSIO is then able to directly compare the
+             celestial coordinate of each row in the table with the celestial coordinates in the region ﬁle without
+             having to know anything about how the image may have been binned.
+             The last ”wcs cols” parameter should rarely be needed. If supplied, this string contains the names
+             of the 2 columns (space or comma separated) which have the associated WCS keywords. If not
+             supplied, the ﬁlter will scan the X and Y expressions for column names. If only one is found in
+             each expression, those columns will be used, otherwise an error will be returned.
+             These region shapes are supported (names are case insensitive):
                     Point         ( X1, Y1 )               <- One pixel square region
                     Line          ( X1, Y1, X2, Y2 )       <- One pixel wide region
                     Polygon       ( X1, Y1, X2, Y2, ... ) <- Rest are interiors with
                     Rectangle     ( X1, Y1, X2, Y2, A )       | boundaries considered
                     Box           ( Xc, Yc, Wdth, Hght, A )   V within the region
                     Diamond       ( Xc, Yc, Wdth, Hght, A )
                     Circle        ( Xc, Yc, R )
                     Annulus       ( Xc, Yc, Rin, Rout )
                     Ellipse       ( Xc, Yc, Rx, Ry, A )
                     Elliptannulus ( Xc, Yc, Rinx, Riny, Routx, Routy, Ain, Aout )
                     Sector        ( Xc, Yc, Amin, Amax )
              where (Xc,Yc) is the coordinate of the shape’s center; (X#,Y#) are the coordinates of the shape’s
              edges; Rxxx are the shapes’ various Radii or semi-major/minor axes; and Axxx are the angles of
              rotation (or bounding angles for Sector) in degrees. For rotated shapes, the rotation angle can be
+             8.11. ROW FILTERING SPECIFICATION                                               107
              left oﬀ, indicating no rotation. Common alternate names for the regions can also be used: rotbox
              =box; rotrectangle = rectangle; (rot)rhombus = (rot)diamond; and pie = sector. When a shape’s
              name is preceded by a minus sign, ’-’, the deﬁned region is instead the area *outside* its boundary
              (ie, the region is inverted). All the shapes within a single region ﬁle are OR’d together to create
              the region, and the order is signiﬁcant. The overall way of looking at region ﬁles is that if the ﬁrst
              region is an excluded region then a dummy included region of the whole detector is inserted in the
              front. Then each region speciﬁcation as it is processed overrides any selections inside of that region
@@ -3681,27 +3748,27 @@
                  "point in a rectangular region"
                           box(xcntr,ycntr,xfll_wdth,yfll_wdth,rotation,Xcolumn,Ycolumn)
                  where
                     (xcntr,ycntr) are the (x,y) position of the center of the region
                     (xhlf_wdth,yhlf_wdth) are the (x,y) half widths of the region
                     (xfll_wdth,yfll_wdth) are the (x,y) full widths of the region
                     (radius) is half the diameter of the circle
-             106                                 CHAPTER8. EXTENDEDFILENAMESYNTAX
                     (rotation) is the angle(degrees) that the region is rotated with
                           respect to (xcntr,ycntr)
                     (Xcoord,Ycoord) are the (x,y) coordinates to test, usually column
                           names
                     NOTE: each parameter can itself be an expression, not merely a
                           column name or constant.
-             8.11.6  Example Row Filters
-                 [ binary && mag <= 5.0]        - Extract all binary stars brighter
-                                                  than fifth magnitude (note that
-                                                  the initial space is necessary to
-                                                  prevent it from being treated as a
-                                                  binning specification)
+             8.11.6   Example Row Filters
+                 [ binary && mag <= 5.0]         - Extract all binary stars brighter
+                                                   than fifth magnitude (note that
+                                                   the initial space is necessary to
+                                                   prevent it from being treated as a
+                                                   binning specification)
+             108                                 CHAPTER8. EXTENDEDFILENAMESYNTAX
                  [#row >= 125 && #row <= 175]   - Extract row numbers 125 through 175
                  [IMAGE[4,5] .gt. 100]          - Extract all rows that have the
                                                   (4,5) component of the IMAGE column
                                                   greater than 100
                  [abs(sin(theta * #deg)) < 0.5] - Extract all rows having the
                                                   absolute value of the sine of theta
                                                   less than a half where the angles
@@ -3718,26 +3785,26 @@
                                                   contained within the text file
                                                   rowFilter.txt
                  [gtifilter()]                  - Search the current file for a GTI
                   extension, filter the TIME
                   column in the current table, using
                   START/STOP times taken from
                   columns in the GTI extension
-                 8.12.   BINNING OR HISTOGRAMMING SPECIFICATION                                                        107
-                      [regfilter("pow.reg")]                  - Extract rows which have a coordinate
-                                                                 (as given in the X and Y columns)
-                                                                 within the spatial region specified
-                                                                 in the pow.reg region file.
-                      [regfilter("pow.reg", Xs, Ys)] - Same as above, except that the
-                                                                 Xs and Ys columns will be used to
-                                                                 determine the coordinate of each
-                                                                 row in the table.
-                 8.12       Binning or Histogramming Speciﬁcation
-                 Theoptional binning speciﬁer is enclosed in square brackets and can be distinguished from a general
-                 row ﬁlter speciﬁcation by the fact that it begins with the keyword ’bin’ not immediately followed
+                 [regfilter("pow.reg")]         - Extract rows which have a coordinate
+                                                  (as given in the X and Y columns)
+                                                  within the spatial region specified
+                                                  in the pow.reg region file.
+                 [regfilter("pow.reg", Xs, Ys)] - Same as above, except that the
+                                                  Xs and Ys columns will be used to
+                                                  determine the coordinate of each
+                                                  row in the table.
+             8.12     Binning or Histogramming Speciﬁcation
+             Theoptional binning speciﬁer is enclosed in square brackets and can be distinguished from a general
+             row ﬁlter speciﬁcation by the fact that it begins with the keyword ’bin’ not immediately followed
+                 8.12.   BINNING OR HISTOGRAMMING SPECIFICATION                                                        109
                  by an equals sign. When binning is speciﬁed, a temporary N-dimensional FITS primary array
                  is created by computing the histogram of the values in the speciﬁed columns of a FITS table
                  extension. After the histogram is computed the input FITS ﬁle containing the table is then closed
                  and the temporary FITS primary array is opened and passed to the application program. Thus,
                  the application program never sees the original FITS table and only sees the image in the new
                  temporary ﬁle (which has no additional extensions). Obviously, the application program must be
                  expecting to open a FITS image and not a FITS table in this case.
@@ -3753,79 +3820,108 @@
                  in which up to 4 columns, each corresponding to an axis of the image, are listed. The column
                  names are case insensitive, and the column number may be given instead of the name, preceded by
                  a pound sign (e.g., [bin #4=1:512]). If the column name is not speciﬁed, then CFITSIO will ﬁrst
                  try to use the ’preferred column’ as speciﬁed by the CPREF keyword if it exists (e.g., ’CPREF
                  = ’DETX,DETY’), otherwise column names ’X’, ’Y’, ’Z’, and ’T’ will be assumed for each of
                  the 4 axes, respectively. In cases where the column name could be confused with an arithmetic
                  expression, enclose the column name in parentheses to force the name to be interpreted literally.
-                 Each column name may be followed by an equals sign and then the lower and upper range of the
-                 histogram, and the size of the histogram bins, separated by colons. Spaces are allowed before and
-                 after the equals sign but not within the ’min:max:binsize’ string. The min, max and binsize values
-                 may be integer or ﬂoating point numbers, or they may be the names of keywords in the header of
-                 the table. If the latter, then the value of that keyword is substituted into the expression.
-               108                                       CHAPTER8. EXTENDEDFILENAMESYNTAX
-               Default values for the min, max and binsize quantities will be used if not explicitly given in the
-               binning expression as shown in these examples:
-                    [bin x = :512:2] - use default minimum value
-                    [bin x = 1::2]       - use default maximum value
-                    [bin x = 1:512]      - use default bin size
-                    [bin x = 1:]         - use default maximum value and bin size
-                    [bin x = :512]       - use default minimum value and bin size
-                    [bin x = 2]          - use default minimum and maximum values
-                    [bin x]              - use default minimum, maximum and bin size
-                    [bin 4]              - default 2-D image, bin size = 4 in both axes
-                    [bin]                - default 2-D image
+                 In addition to binning by a FITS column, any arbitrary calculator expression may be speciﬁed as
+                 well. Usage of this form would appear as:
+                  [bin Xcol(arbitrary expression)=min:max:binsize, ... ]
+                 Thecolumnnamemuststill bespeciﬁed, and is used to label coordinate axes of the resulting image.
+                 The expression appears immediately after the name, enclosed in parentheses. The expression may
+                 use any combination of columns, keywords, functions and constants and allowed by the CFITSIO
+                 calculator.
+                 The column name (and optional expression) may be followed by an equals sign and then the lower
+                 and upper range of the histogram, and the size of the histogram bins, separated by colons. Spaces
+                 are allowed before and after the equals sign but not within the ’min:max:binsize’ string. The min,
+                 max and binsize values may be integer or ﬂoating point numbers, or they may be the names of
+                 keywords in the header of the table. If the latter, then the value of that keyword is substituted
+                 into the expression.
+                 Default values for the min, max and binsize quantities will be used if not explicitly given in the
+                 binning expression as shown in these examples:
+                      [bin x = :512:2] - use default minimum value
+               110                                      CHAPTER8. EXTENDEDFILENAMESYNTAX
+                    [bin x = 1::2]      - use default maximum value
+                    [bin x = 1:512]     - use default bin size
+                    [bin x = 1:]        - use default maximum value and bin size
+                    [bin x = :512]      - use default minimum value and bin size
+                    [bin x = 2]         - use default minimum and maximum values
+                    [bin x]             - use default minimum, maximum and bin size
+                    [bin 4]             - default 2-D image, bin size = 4 in both axes
+                    [bin]               - default 2-D image
                CFITSIO will use the value of the TLMINn, TLMAXn, and TDBINn keywords, if they exist, for
                the default min, max, and binsize, respectively. If they do not exist then CFITSIO will use the
                actual minimum and maximum values in the column for the histogram min and max values. The
                default binsize will be set to 1, or (max - min) / 10., whichever is smaller, so that the histogram
                will have at least 10 bins along each axis.
+               Please note that if explicit min and max values (or TLMINn/TLMAXn keywords) are not present,
+               then CFITSIO must check every value of the binned quantity in advance to determine the binning
+               limits. This is especially relevant for binning expressions, which must be evaluated multiple times
+               to determine the limits of the expression. Thus, it is always advisable to specify min and max
+               limits where possible.
                A shortcut notation is allowed if all the columns/axes have the same binning speciﬁcation. In
                this case all the column names may be listed within parentheses, followed by the (single) binning
                speciﬁcation, as in:
                     [bin (X,Y)=1:512:2]
                     [bin (X,Y) = 5]
                The optional weighting factor is the last item in the binning speciﬁer and, if present, is separated
                from the list of columns by a semi-colon. As the histogram is accumulated, this weight is used
                to incremented the value of the appropriated bin in the histogram. If the weighting factor is not
-               speciﬁed, then the default weight = 1 is assumed. The weighting factor may be a constant integer or
-               ﬂoating point number, or the name of a keyword containing the weighting value. Or the weighting
-               factor may be the name of a table column in which case the value in that column, on a row by row
-               basis, will be used.
+               speciﬁed, then the default weight = 1 is assumed. The weighting factor may be a constant integer
+               or ﬂoating point number, or the name of a keyword containing the weighting value. The weighting
+               factor may also be the name of a table column in which case the value in that column, on a row
+               by row basis, will be used. It may also be an expression, enclosed in parenthesis, in which case the
+               weighting value will be evaluated for each binned row and applied accordingly.
                In some cases, the column or keyword may give the reciprocal of the actual weight value that is
                needed. In this case, precede the weight keyword or column name by a slash ’/’ to tell CFITSIO
-               to use the reciprocal of the value when constructing the histogram.
+               to use the reciprocal of the value when constructing the histogram. An expression, enclosed in
+               parentheses, may also appear after the slash, to indicate the reciprocal value of the expression.
                For complex or commonly used histograms, one can also place its description into a text ﬁle and
-               import it into the binning speciﬁcation using the syntax ’[bin @ﬁlename.txt]’.   The ﬁle’s con-
+               import it into the binning speciﬁcation using the syntax ’[bin @ﬁlename.txt]’.  The ﬁle’s con-
                tents can extend over multiple lines, although it must still conform to the no-spaces rule for the
                min:max:binsize syntax and each axis speciﬁcation must still be comma-separated. Any lines in
                the external text ﬁle that begin with 2 slash characters (’//’) will be ignored and may be used to
                add comments into the ﬁle.
-               Examples:
-                    [bini detx, dety]                     - 2-D, 16-bit integer histogram
-                 8.12.   BINNING OR HISTOGRAMMING SPECIFICATION                                                        109
-                                                                   of DETX and DETY columns, using
-                                                                   default values for the histogram
-                                                                   range and binsize
+                 8.12.   BINNING OR HISTOGRAMMING SPECIFICATION                                                        111
+                 Examples:
+                      [bini detx, dety]                          - 2-D, 16-bit integer histogram
+                                                                    of DETX and DETY columns, using
+                                                                    default values for the histogram
+                                                                    range and binsize
                       [bin (detx, dety)=16; /exposure] - 2-D, 32-bit real histogram of DETX
-                                                                   and DETY columns with a bin size = 16
-                                                                   in both axes. The histogram values
-                                                                   are divided by the EXPOSURE keyword
-                                                                   value.
+                                                                    and DETY columns with a bin size = 16
+                                                                    in both axes. The histogram values
+                                                                    are divided by the EXPOSURE keyword
+                                                                    value.
                       [bin time=TSTART:TSTOP:0.1]                - 1-D lightcurve, range determined by
-                                                                   the TSTART and TSTOP keywords,
-                                                                   with 0.1 unit size bins.
+                                                                    the TSTART and TSTOP keywords,
+                                                                    with 0.1 unit size bins.
                       [bin pha, time=8000.:8100.:0.1] - 2-D image using default binning
-                                                                   of the PHA column for the X axis,
-                                                                   and 1000 bins in the range
-                                                                   8000. to 8100. for the Y axis.
+                                                                    of the PHA column for the X axis,
+                                                                    and 1000 bins in the range
+                                                                    8000. to 8100. for the Y axis.
+                      [bin pha, gti_num(gtifind())=1:2:1] - a 2-D image, where PHA is the
+                                                                    X axis and the Y axis is an expression
+                                                                    which evaluates to the GTI number,
+                                                                    as determined using the
+                                                                    GTIFIND() function.
+                      [bin time=0:4000:2000, HR( (LC2/LC1).lt.1.5 ? 1 : 2 )=1:2:1] - a 2-D
+                                                                    histogram which determines the number
+                                                                    of samples in two time bins between 0 and
+                                                                    4000 and separating hardness ratio,
+                                                                    evaluated as (LC2/LC1), between less than
+                                                                    1.5 or greater than 1.5. The ?:
+                                                                    conditional function is used to decide
+                                                                    less (or greater) than 1.5 and assign
+                                                                    HR bin 1 or 2.
                       [bin @binFilter.txt]                       - Use the contents of the text file
-                                                                   binFilter.txt for the binning
-                                                                   specifications.
-       110                CHAPTER8. EXTENDEDFILENAMESYNTAX
+                                                                    binFilter.txt for the binning
+                                                                    specifications.
+       112                CHAPTER8. EXTENDEDFILENAMESYNTAX
            Chapter 9
            Template Files
            When a new FITS ﬁle is created with a call to ﬁts create ﬁle, the name of a template ﬁle may
            be supplied in parentheses immediately following the name of the new ﬁle to be created. This
            template is used to deﬁne the structure of one or more HDUs in the new ﬁle. The template ﬁle may
            be another FITS ﬁle, in which case the newly created ﬁle will have exactly the same keywords in
            each HDUasinthetemplate FITSﬁle, butall the data units will be ﬁlled with zeros. The template
@@ -3846,16 +3942,16 @@
            line are all blank, then the entire line is treated as a FITS comment keyword (with a blank keyword
            name) and is copied verbatim into the FITS header.
            The KEYVALUE ﬁeld may have any allowed FITS data type: character string, logical, integer,
            real, complex integer, or complex real. Integer values must be within the allowed range of a ’signed
            long’ variable; some C compilers only suppport 4-byte long integers with a range from -2147483648
            to +2147483647, whereas other C compilers support 8-byte integers with a range of plus or minus
            2**63.
-                                            111
-           112                                        CHAPTER9. TEMPLATEFILES
+                                            113
+           114                                        CHAPTER9. TEMPLATEFILES
            Thecharacter string values need not be enclosed in single quote characters unless they are necessary
            to distinguish the string from a diﬀerent data type (e.g. 2.0 is a real but ’2.0’ is a string). The
            keyword has an undeﬁned (null) value if the template record only contains blanks following the
            ”=” or between the ”=” and the ”/” comment ﬁeld delimiter.
            String keyword values longer than 68 characters (the maximum length that will ﬁt in a single FITS
            keyword record) are permitted using the CFITSIO long string convention. They can either be
            speciﬁed as a single long line in the template, or by using multiple lines where the continuing lines
@@ -3884,15 +3980,15 @@
            subtle, as illustrated in the following examples in which the TTYPE keyword is the incrementor in
            both cases:
              TTYPE# = TIME
              TFORM# = 1D
              TTYPE# = RATE
              TFORM# = 1E
            will create TTYPE1, TFORM1, TTYPE2, and TFORM2 keywords. But if the template looks like,
-                  9.3.  TEMPLATEPARSERDIRECTIVES                                                                             113
+                  9.3.  TEMPLATEPARSERDIRECTIVES                                                                             115
                     TTYPE# = TIME
                     TTYPE# = RATE
                     TFORM# = 1D
                     TFORM# = 1E
                   this results in a FITS ﬁles with TTYPE1, TTYPE2, TFORM2, and TFORM2, which is probably
                   not what was intended!
                   9.3     Template Parser Directives
@@ -3918,15 +4014,15 @@
                   2) GROUP HDU (has 1 member, which is bintable in HDU number 3)
                   3) bintable (member of GROUP in HDU number 2)
                   Technically speaking, the GROUP HDU is a BINTABLE with 6 columns. Applications can deﬁne
                   additional columns in a GROUP HDU usingTFORMnandTTYPEn(wherenis7,8, ....) keywords
                   or their auto-indexing equivalents.
                   For a more complicated example of a template ﬁle using the group directives, look at the sample.tpl
                   ﬁle that is included in the CFITSIO distribution.
-           114                                        CHAPTER9. TEMPLATEFILES
+           116                                        CHAPTER9. TEMPLATEFILES
            9.4  Formal Template Syntax
            The template syntax can formally be deﬁned as follows:
               TEMPLATE = BLOCK [ BLOCK ... ]
                  BLOCK = { HDU | GROUP }
                  GROUP = \GROUP [ BLOCK ... ] \END
                    HDU = XTENSION [ LINE ... ] { XTENSION | \GROUP | \END | EOF }
                   LINE = [ KEYWORD [ = ] ] [ VALUE ] [ / COMMENT ]
@@ -3942,21 +4038,21 @@
            will (try to) delete the top level BLOCK (with all its children if any) in which the error occurred,
            then it will stop reading the template ﬁle and it will return with an error.
            9.6  Examples
            1. This template ﬁle will create a 200 x 300 pixel image, with 4-byte integer pixel values, in the
            primary HDU:
              SIMPLE = T
              BITPIX = 32
-             NAXIS = 2   / number of dimensions
+             NAXIS = 2  / number of dimensions
              NAXIS1 = 100 / length of first axis
              NAXIS2 = 200 / length of second axis
              OBJECT = NGC 253 / name of observed object
            The allowed values of BITPIX are 8, 16, 32, -32, or -64, representing, respectively, 8-bit integer,
            16-bit integer, 32-bit integer, 32-bit ﬂoating point, or 64 bit ﬂoating point pixels.
-                  9.6.  EXAMPLES                                                                                             115
+                  9.6.  EXAMPLES                                                                                             117
                   2. To create a FITS table, the template ﬁrst needs to include XTENSION = TABLE or BINTABLE
                   to deﬁne whether it is an ASCII or binary table, and NAXIS2 to deﬁne the number of rows in the
                   table. Two template lines are then needed to deﬁne the name (TTYPEn) and FITS data format
                   (TFORMn) of the columns, as in this example:
                     xtension = bintable
                     naxis2 = 40
                     ttype# = Name
@@ -3970,15 +4066,15 @@
                   columns called ’Name’, ’Npoints’, and ’Rate’, with data formats of ’10A’ (ASCII character string),
                   ’1J’ (integer) and ’1E’ (ﬂoating point), respectively. Note that the other required FITS keywords
                   (BITPIX, NAXIS, NAXIS1, PCOUNT, GCOUNT, TFIELDS, and END) do not need to be ex-
                   plicitly deﬁned in the template because their values can be inferred from the other keywords in
                   the template. This example also illustrates that the templates are generally case-insensitive (the
                   keyword names and TFORMn values are converted to upper-case in the FITS ﬁle) and that string
                   keyword values generally do not need to be enclosed in quotes.
-       116                        CHAPTER9. TEMPLATEFILES
+       118                        CHAPTER9. TEMPLATEFILES
              Chapter 10
              Summary of all FITSIO
              User-Interface Subroutines
              Error Status Routines page 29
                      FTVERS( > version)
                      FTGERR(status, > errtext)
                      FTGMSG( > errmsg)
@@ -4000,16 +4096,16 @@
                      FTTPLT(unit, filename, tplfilename, > status)
                      FTFLUS(unit, > status)
                      FTCLOS(unit, > status)
                      FTDELT(unit, > status)
                      FTGIOU( > iounit, status)
                      FTFIOU(iounit, > status)
              CFITS2Unit(fitsfile *ptr)   (C routine)
-                                                     117
-             118      CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
+                                                     119
+             120      CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
                      CUnit2FITS(int unit)        (C routine)
                      FTEXTN(filename, > nhdu, status)
                      FTFLNM(unit, > filename, status)
                      FTFLMD(unit, > iomode, status)
                      FTURLT(unit, > urltype, status)
                      FTIURL(filename, > filetype, infile, outfile, extspec, filter,
                             binspec, colspec, status)
@@ -4041,15 +4137,15 @@
                      FTDDEF(unit,bytlen, > status) (DEPRECATED)
                      FTPTHP(unit,theap, > status)
              Header Space and Position Subroutines: page 43
                      FTHDEF(unit,morekeys, > status)
                      FTGHSP(iunit, > keysexist,keysadd,status)
                      FTGHPS(iunit, > keysexist,key_no,status)
              Read or Write Standard Header Subroutines: page 43
-                                                 119
+                                                 121
            FTPHPS(unit,bitpix,naxis,naxes, > status)
            FTPHPR(unit,simple,bitpix,naxis,naxes,pcount,gcount,extend, > status)
            FTGHPR(unit,maxdim, > simple,bitpix,naxis,naxes,pcount,gcount,extend,
                status)
            FTPHTB(unit,rowlen,nrows,tfields,ttype,tbcol,tform,tunit,extname, >
                status)
            FTGHTB(unit,maxdim, > rowlen,nrows,tfields,ttype,tbcol,tform,tunit,
@@ -4081,15 +4177,15 @@
            FTIKY[EDFG](unit,keyword,keyval,decimals,comment, > status)
            FTIKYU(unit,keyword,comment, > status)
        Read Keyword Subroutines: page 47
            FTGREC(unit,key_no, > card,status)
            FTGKYN(unit,key_no, > keyword,value,comment,status)
            FTGCRD(unit,keyword, > card,status)
            FTGNXK(unit,inclist,ninc,exclist,nexc, > card,status)
-       120  CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
+       122  CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
            FTGKEY(unit,keyword, > value,comment,status)
            FTGKY[EDJKLS](unit,keyword, > keyval,comment,status)
            FTGKSL(unit,keyword, > length,status)
            FTGSKY(unit,keyword,firstchar,maxchar,> keyval,length,comment,status)
            FTGKN[EDJKLS](unit,keyroot,startno,max_keys, > keyvals,nfound,status)
            FTGKYT(unit,keyword, > intval,dblval,comment,status)
            FTGUNT(unit,keyword, > units,status)
@@ -4116,15 +4212,15 @@
            FTTSCL(unit,colnum,tscal,tzero, > status)
            FTPNUL(unit,blank, > status)
            FTSNUL(unit,colnum,snull > status)
            FTTNUL(unit,colnum,tnull > status)
        FITS Primary Array or IMAGE Extension I/O Subroutines: page 52
            FTGIDT(unit, > bitpix,status)
            FTGIET(unit, > bitpix,status)
-                                                 121
+                                                 123
            FTGIDM(unit, > naxis,status)
            FTGISZ(unit, maxdim, > naxes,status)
            FTGIPR(unit, maxdim, > bitpix,naxis,naxes,status)
            FTPPR[BIJKED](unit,group,fpixel,nelements,values, > status)
            FTPPN[BIJKED](unit,group,fpixel,nelements,values,nullval > status)
            FTPPRU(unit,group,fpixel,nelements, > status)
            FTGPV[BIJKED](unit,group,fpixel,nelements,nullval, > values,anyf,status)
@@ -4137,15 +4233,15 @@
            FTG3D[BIJKED](unit,group,nullval,dim1,dim2,naxis1,naxis2,naxis3, >
                   cube,anyf,status)
            FTPSS[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,array, > status)
            FTGSV[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs,nullval, >
                   array,anyf,status)
            FTGSF[BIJKED](unit,group,naxis,naxes,fpixels,lpixels,incs, >
                   array,flagvals,anyf,status)
-       Table Column Information Subroutines: page 55
+       Table Column Information Subroutines: page 56
            FTGNRW(unit, > nrows, status)
            FTGNCL(unit, > ncols, status)
            FTGCNO(unit,casesen,coltemplate, > colnum,status)
            FTGCNN(unit,casesen,coltemplate, > colnam,colnum,status)
            FTGTCL(unit,colnum, > datacode,repeat,width,status)
            FTEQTY(unit,colnum, > datacode,repeat,width,status)
            FTGCDW(unit,colnum, > dispwidth,status)
@@ -4158,15 +4254,15 @@
            FTDTDM(unit,tdimstr,colnum,maxdim, > naxis,naxes, status)
            FTGRSZ(unit, > nrows,status)
        Low-Level Table Access Subroutines: page 58
            FTGTBS(unit,frow,startchar,nchars, > string,status)
            FTPTBS(unit,frow,startchar,nchars,string, > status)
            FTGTBB(unit,frow,startchar,nchars, > array,status)
            FTPTBB(unit,frow,startchar,nchars,array, > status)
-       122  CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
+       124  CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
        Edit Rows or Columns page 59
            FTIROW(unit,frow,nrows, > status)
            FTDROW(unit,frow,nrows, > status)
            FTDRRG(unit,rowrange, > status)
            FTDRWS(unit,rowlist,nrows, > status)
            FTICOL(unit,colnum,ttype,tform, > status)
            FTICLS(unit,colnum,ncols,ttype,tform, > status)
@@ -4178,15 +4274,15 @@
            FTPCN[BIJKED](unit,colnum,frow,felem,nelements,values,nullval > status)
            FTPCLX(unit,colnum,frow,fbit,nbit,lray, > status)
            FTPCLU(unit,colnum,frow,felem,nelements, > status)
            FTGCL(unit,colnum,frow,felem,nelements, > values,status)
            FTGCV[SBIJKEDCM](unit,colnum,frow,felem,nelements,nullval, >
                    values,anyf,status)
            FTGCF[SLBIJKEDCM](unit,colnum,frow,felem,nelements, >
-                     values,flagvals,anyf,status)
+                    values,flagvals,anyf,status)
            FTGSV[BIJKED](unit,colnum,naxis,naxes,fpixels,lpixels,incs,nullval, >
                   array,anyf,status)
            FTGSF[BIJKED](unit,colnum,naxis,naxes,fpixels,lpixels,incs, >
                   array,flagvals,anyf,status)
            FTGCX(unit,colnum,frow,fbit,nbit, > lray,status)
            FTGCX[IJD](unit,colnum,frow,nrows,fbit,nbit, > array,status)
            FTGDES(unit,colnum,rownum, > nelements,offset,status)
@@ -4198,15 +4294,15 @@
            FTCROW(unit,datatype,expr,firstrow,nelements,nulval, >
               array,anynul,status)
            FTCALC(inunit, expr, outunit, parName, parInfo, > status)
            FTCALC_RNG(inunit, expr, outunit, parName, parInfo,
               nranges, firstrow, lastrow, > status)
            FTTEXP(unit, expr, > datatype, nelem, naxis, naxes, status)
        Celestial Coordinate System Subroutines: page 65
-                                                 123
+                                                 125
            FTGICS(unit, > xrval,yrval,xrpix,yrpix,xinc,yinc,rot,coordtype,status)
            FTGTCS(unit,xcol,ycol, >
                xrval,yrval,xrpix,yrpix,xinc,yinc,rot,coordtype,status)
            FTWLDP(xpix,ypix,xrval,yrval,xrpix,yrpix,xinc,yinc,rot,
                      coordtype, > xpos,ypos,status)
            FTXYPX(xpos,ypos,xrval,yrval,xrpix,yrpix,xinc,yinc,rot,
                      coordtype, > xpix,ypix,status)
@@ -4237,55 +4333,55 @@
            FTPSVC(card, > value,comment,status)
            FTKEYN(keyroot,seq_no, > keyword,status)
            FTNKEY(seq_no,keyroot, > keyword,status)
            FTDTYP(value, > dtype,status)
            class = FTGKCL(card)
            FTASFM(tform, > datacode,width,decimals,status)
            FTBNFM(tform, > datacode,repeat,width,status)
-       124  CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
+       126  CHAPTER10. SUMMARYOFALLFITSIOUSER-INTERFACESUBROUTINES
            FTGABC(tfields,tform,space, > rowlen,tbcol,status)
            FTGTHD(template, > card,hdtype,status)
            FTRWRG(rowlist, maxrows, maxranges, > numranges, rangemin,
                rangemax, status)
        Chapter 11
        Parameter Deﬁnitions
        anyf - (logical) set to TRUE if any of the returned data values are undefined
        array - (any datatype except character) array of bytes to be read or written.
        bitpix - (integer) bits per pixel: 8, 16, 32, -32, or -64
        blank - (integer) value used for undefined pixels in integer primary array
        blank - (integer*8) value used for undefined pixels in integer primary array
        blocksize - (integer) 2880-byte logical record blocking factor
-             (if 0 < blocksize < 11) or the actual block size in bytes
-             (if 10 < blocksize < 28800). As of version 3.3 of FITSIO,
-             blocksizes greater than 2880 are no longer supported.
+            (if 0 < blocksize < 11) or the actual block size in bytes
+            (if 10 < blocksize < 28800). As of version 3.3 of FITSIO,
+            blocksizes greater than 2880 are no longer supported.
        bscale - (double precision) scaling factor for the primary array
        bytlen - (integer) length of the data unit, in bytes
        bzero - (double precision) zero point for primary array scaling
        card - (character*80) header record to be read or written
        casesen - (logical) will string matching be case sensitive?
        checksum - (character*16) encoded checksum string
        colname - (character) ASCII name of the column
        colnum - (integer) number of the column (first column = 1)
        coltemplate - (character) template string to be matched to column names
        comment - (character) the keyword comment field
        comments - (character array) keyword comment fields
        compid - (integer) the type of computer that the program is running on
        complement - (logical) should the checksum be complemented?
        coordtype - (character) type of coordinate projection (-SIN, -TAN, -ARC,
-             -NCP, -GLS, -MER, or -AIT)
+            -NCP, -GLS, -MER, or -AIT)
        cube - 3D data cube of the appropriate datatype
        curaddr - (integer) starting address (in bytes) of the CHDU
        current - (integer) if not equal to 0, copy the current HDU
        datacode - (integer) symbolic code of the binary table column datatype
        dataok - (integer) was the data unit verification successful (=1) or
             not (= -1). Equals zero if the DATASUM keyword is not present.
        datasum - (double precision) 32-bit 1’s complement checksum for the data unit
        datatype - (character) datatype (format) of the binary table column
-                            125
-             126                                     CHAPTER11. PARAMETERDEFINITIONS
+                            127
+             128                                     CHAPTER11. PARAMETERDEFINITIONS
              datestr - (string) FITS date/time string: ’YYYY-MM-DDThh:mm:ss.ddd’,
                         ’YYYY-MM-dd’, or ’dd/mm/yy’
              day - (integer) current day of the month
              dblval - (double precision) fractional part of the keyword value
              decimals - (integer) number of decimal places to be displayed
              dim1 - (integer) actual size of the first dimension of the image or cube array
              dim2 - (integer) actual size of the second dimension of the cube array
@@ -4324,15 +4420,15 @@
                                 2 = binary table, -1 = any HDU type or unknown type
              history - (character) the HISTORY keyword comment string
              hour - (integer) hour from 0 - 23
              image - 2D image of the appropriate datatype
              inclist (character array) list of names to be included in search
              incs - (integer array) sampling interval for pixels in each FITS dimension
              intval - (integer) integer part of the keyword value
-                                                                                            127
+                                                                                            129
              iounit - (integer) value of an unused I/O unit number
              iunit - (integer) logical unit number associated with the input FITS file, 1-300
              key_no - (integer) sequence number (starting with 1) of the keyword record
              keylength - (integer) length of the keyword name
              keyroot - (character) root string for the keyword name
              keysadd -(integer) number of new keyword records which can fit in the CHU
              keysexist - (integer) number of existing keyword records in the CHU
@@ -4371,15 +4467,15 @@
              nextaddr - (integer) starting address (in bytes) of the HDU following the CHDU
              offset - (integer) byte offset in the heap to the first element of the array
              offsetll - (integer*8) byte offset in the heap to the first element of the array
              oldkey - (character) old name of keyword to be modified
              ounit - (integer) logical unit number associated with the output FITS file 1-300
              pcount - (integer) value of the PCOUNT keyword (usually = 0)
              previous - (integer) if not equal to 0, copy all previous HDUs in the input file
-             128                                     CHAPTER11. PARAMETERDEFINITIONS
+             130                                     CHAPTER11. PARAMETERDEFINITIONS
              repeat - (integer) length of element vector (e.g. 12J); ignored for ASCII table
              rot - (double precision) celestial coordinate rotation angle (degrees)
              rowlen - (integer) length of a table row, in characters or bytes
              rowlenll - (integer*8) length of a table row, in characters or bytes
              rowlist - (integer array) list of row numbers to be deleted in increasing order
              rownum - (integer) number of the row (first row = 1)
              rowrange- (string) list of rows or row ranges to be deleted
@@ -4418,30 +4514,30 @@
              unit - (integer) logical unit number associated with the FITS file (1-300)
              units - (character) the keyword units string (e.g., ’km/s’)
              value - (character) the keyword value string
              values - array of data values of the appropriate datatype
              varidat - (integer) size in bytes of the ’variable length data area’
                         following the binary table data (usually = 0)
              version - (real) current revision number of the library
-                                                 129
+                                                 131
        width - (integer) width of the character string field
        xcol - (integer) number of the column containing the X coordinate values
        xinc - (double precision) X axis coordinate increment at reference pixel (deg)
        xpix - (double precision) X axis pixel location
        xpos - (double precision) X axis celestial coordinate (usually RA) (deg)
        xrpix - (double precision) X axis reference pixel array location
        xrval - (double precision) X axis coordinate value at the reference pixel (deg)
        ycol - (integer) number of the column containing the X coordinate values
        year - (integer) last 2 digits of the year (00 - 99)
        yinc - (double precision) Y axis coordinate increment at reference pixel (deg)
        ypix - (double precision) y axis pixel location
        ypos - (double precision) y axis celestial coordinate (usually DEC) (deg)
        yrpix - (double precision) Y axis reference pixel array location
        yrval - (double precision) Y axis coordinate value at the reference pixel (deg)
-       130                   CHAPTER11. PARAMETERDEFINITIONS
+       132                  CHAPTER11. PARAMETERDEFINITIONS
              Chapter 12
              FITSIO Error Status Codes
              Status codes in the range -99 to -999 and 1 to 999 are reserved for future
              FITSIO use.
                0  OK, no error
              101 input and output files are the same
              103 too many FITS files open at once; all internal buffers full
@@ -4465,16 +4561,16 @@
              126 parse error in range list
              151 bad argument in shared memory driver
              152 null pointer passed as an argument
              153 no more free shared memory handles
              154 shared memory driver is not initialized
              155 IPC error returned by a system call
              156 no memory in shared memory driver
-                                                     131
-       132                 CHAPTER12. FITSIOERRORSTATUSCODES
+                                                     133
+       134                 CHAPTER12. FITSIOERRORSTATUSCODES
        157 resource deadlock would occur
        158 attempt to open/create lock file failed
        159 shared memory block cannot be resized at the moment
        201 header not empty; can’t write required keywords
        202 specified keyword name was not found in the header
        203 specified header record number is out of bounds
        204 keyword value field is blank
@@ -4511,15 +4607,15 @@
        235 this operation only allowed for ASCII or BINARY table extension
        236 column is too wide to fit within the specified width of the ASCII table
        237 the specified column name template matched more than one column name
        241 binary table row width is not equal to the sum of the field widths
        251 unrecognizable type of FITS extension
        252 unrecognizable FITS record
        253 END keyword contains non-blank characters in columns 9-80
-                                                                                            133
+                                                                                            135
              254 Header fill area contains non-blank characters
              255 Data fill area contains non-blank on non-zero values
              261 unable to parse the TFORM keyword value string
              262 unrecognizable TFORM datatype code
              263 illegal TDIMn keyword value
              301 illegal HDU number; less than 1 or greater than internal buffer size
              302 column number out of range (1 - 999)
@@ -4555,15 +4651,15 @@
                                               template file raises this error
              363 NGP_EMPTY_CURLINE          line read seems to be empty (used
                                               internally)
              364 NGP_UNREAD_QUEUE_FULL      cannot unread more then 1 line (or single
                                               line twice)
              365 NGP_INC_NESTING            too deep include file nesting (infinite
                                               loop, template includes itself ?)
-             134                                  CHAPTER12. FITSIOERRORSTATUSCODES
+             136                                  CHAPTER12. FITSIOERRORSTATUSCODES
              366 NGP_ERR_FOPEN              fopen() failed, cannot open template file
              367 NGP_EOF                    end of file encountered and not expected
              368 NGP_BAD_ARG                bad arguments passed. Usually means
                                               internal parser error. Should not happen
              369 NGP_TOKEN_NOT_EXPECT       token not expected here
              401 error attempting to convert an integer to a formatted character string
              402 error attempting to convert a real value to a formatted character string
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/fitsio.tex` & `fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.tex`

 * *Files 1% similar despite different names*

```diff
@@ -28,30 +28,30 @@
 \end{center}
 \begin{center}
 {\LARGE \bf for Fortran Programmers}\\
 \end{center}
 \medskip
 \medskip
 \begin{center}
-{\Large Version 3.0\\}
+{\Large Version 4.2\\}
 \end{center}
 \bigskip
 \vskip 2.5cm
 \begin{center}
 {HEASARC\\
 Code 662\\
 Goddard Space Flight Center\\
 Greenbelt, MD 20771\\
 USA}
 \end{center}
 
 \vfill
 \bigskip
 \begin{center}
-{\Large April 2016\\}
+{\Large Nov 2022\\}
 \end{center}
 \vfill
 \end{titlepage}
 
 \clearpage
 
 \tableofcontents
@@ -315,26 +315,20 @@
 contained in the file testprog.out.  The 'diff' and 'cmp' commands
 shown above should not report any differences in the files.  (There
 may be some minor formatting differences, such as the presence or
 absence of leading zeros, or 3 digit exponents in numbers,
 which can be ignored).
 
 The Fortran wrappers in CFITSIO may be tested with the testf77
-program.  On Unix systems the fortran compilation and link command
-may be called 'f77' or 'g77', depending on the system.
+program.  On Unix systems the Fortran compiler is typically
+called 'gfortran'.
+-
 
 \begin{verbatim}
-   % f77 -o testf77 testf77.f -L. -lcfitsio -lnsl -lsocket
- or
-   % f77 -f -o testf77 testf77.f -L. -lcfitsio    (under SUN O/S)
- or
-   % f77 -o testf77 testf77.f -Wl,-L. -lcfitsio -lm -lnsl -lsocket (HP/UX)
- or
-   % g77 -o testf77 -s testf77.f -lcfitsio -lcc_dynamic -lncurses (Mac OS-X)
-
+   % gfortran -o testf77 testf77.f -L. -lcfitsio -lz -lcurl
    % testf77 > testf77.lis
    % diff testf77.lis testf77.out
    % cmp testf77.fit testf77.std
 \end{verbatim}
 On machines running SUN O/S, Fortran programs must be compiled with the
 '-f' option to force double precision variables to be aligned on 8-byte
 boundaries to make the fortran-declared variables compatible with C.  A
@@ -1557,15 +1551,16 @@
 
 \section{FITSIO Error Status Routines \label{FTVERS}}
 
 
 \begin{description}
 \item[1 ] Return the current version number of the fitsio library.
     The version number will be incremented with each new
-   release of CFITSIO.
+   release of CFITSIO. The 3 fields of the version string M.xx.yy
+   are converted to a float as: M + .01*xx + .0001*yy.
 \end{description}
 
 \begin{verbatim}
         FTVERS( > version)
 \end{verbatim}
 
 \begin{description}
@@ -3303,50 +3298,58 @@
 
 \begin{verbatim}
         FTGIPR(unit, maxdim, > bitpix, naxis, naxes, int *status)
         FTGIPRLL(unit, maxdim, > bitpix, naxis, naxesll, int *status)
 \end{verbatim}
 
 \begin{description}
-\item[5 ]Put elements into the data array
+\item[5 ]Put elements into the data array.  The FTPPR[]LL routines
+      accept 64-bit integers for fpixel and nelements.
 \end{description}
 
 \begin{verbatim}
         FTPPR[BIJKED](unit,group,fpixel,nelements,values, > status)
+        FTPPR[BIJKED]LL(unit,group,fpixelll,nelementsll,values, > status)
 \end{verbatim}
 
 \begin{description}
 \item[6 ]Put elements into the data array, substituting the appropriate FITS null
    value for all elements which are equal to the value of NULLVAL.  For
    integer FITS arrays, the null value defined by the previous call to FTPNUL
    will be substituted;  for floating point FITS arrays (BITPIX = -32
    or -64) then the special IEEE NaN (Not-a-Number) value will be
-  substituted.
+  substituted.  The FTPPN[]LL routines accept 64-bit integers for 
+  fpixel and nelements.
 \end{description}
 
 \begin{verbatim}
         FTPPN[BIJKED](unit,group,fpixel,nelements,values,nullval > status)
+        FTPPN[BIJKED]LL(unit,group,fpixelll,nelementsll,values,nullval > status)
 \end{verbatim}
 
 \begin{description}
-\item[7 ]Set data array elements as undefined
+\item[7 ]Set data array elements as undefined.  FTPPRULL accepts 64-bit integers
+         for fpixel and nelements.
 \end{description}
 
 \begin{verbatim}
         FTPPRU(unit,group,fpixel,nelements, > status)
+        FTPPRULL(unit,group,fpixelll,nelementsll, > status)
 \end{verbatim}
 
 \begin{description}
 \item[8 ] Get elements from the data array.  Undefined array elements will be
     returned with a value = nullval, unless nullval = 0 in which case no
-   checks for undefined pixels will be performed.
+   checks for undefined pixels will be performed.  FTGPV[]LL accepts
+   64-bit integers for fpixel and nelements.
 \end{description}
 
 \begin{verbatim}
         FTGPV[BIJKED](unit,group,fpixel,nelements,nullval, > values,anyf,status)
+        FTGPV[BIJKED]LL(unit,group,fpixelll,nelementsll,nullval, > values,anyf,status)
 \end{verbatim}
 
 \begin{description}
 \item[9 ] Get elements and nullflags from data array.
     Any undefined array elements will have the corresponding flagvals element
    set equal to .TRUE.
 \end{description}
@@ -6166,14 +6169,16 @@
     "arc cosine"         arccos(x)  "arc sine"             arcsin(x)
     "arc tangent"        arctan(x)  "arc tangent"          arctan2(y,x)
     "hyperbolic cos"     cosh(x)    "hyperbolic sin"       sinh(x)
     "hyperbolic tan"     tanh(x)    "round to nearest int" round(x)
     "round down to int"  floor(x)   "round up to int"      ceil(x)
     "exponential"        exp(x)     "square root"          sqrt(x)
     "natural log"        log(x)     "common log"           log10(x)
+    "error function"     erf(x)     "complement of erf"    erfc(x)
+    "gamma function"     gamma(x)
     "modulus"            x % y      
     "bitwise AND"        x & y      "bitwise OR"           x | y
     "bitwise XOR"        x ^^ y     (bitwise operators are 32-bit int only)
     "random # [0.0,1.0)" random()
     "random Gaussian"    randomn()  "random Poisson"       randomp(x)
     "minimum"            min(x,y)   "maximum"              max(x,y)
     "cumulative sum"     accum(x)   "sequential difference" seqdiff(x)
@@ -6290,21 +6295,23 @@
     not   actually   required  for  evaluation,  e.g. "TRUE  .or.  NULL"
     evaluates to TRUE. The  following  two  functions  allow  some  NULL
     detection  and  handling:
 
 \begin{verbatim}
          "a null value?"              ISNULL(x)
          "define a value for null"    DEFNULL(x,y)
+         "declare certain value null" SETNULL(x,y)
 \end{verbatim}
-    The former
-    returns a boolean value of TRUE if the  argument  x  is  NULL.   The
-    later  "defines"  a  value  to  be  substituted  for NULL values; it
+    ISNULL(x)
+    returns a boolean value of TRUE if the  argument  x  is  NULL. DEFNULL(x,y)
+    "defines"  a  value  to  be  substituted  for NULL values; it
     returns the value of x if x is not NULL, otherwise  it  returns  the
-    value of y.
-
+    value of y.  SETNULL(x,y) allows NULL values to be inserted into
+    a variable; if x==y, a NULL value is returned; otherwise y is returned
+    (x and y must be numerical, and x must be a scalar).
 
 \subsection{Bit Masks}
 
     Bit  masks can be used to select out rows from bit columns (TFORMn =
     \#X) in FITS files. To represent the mask,  binary,  octal,  and  hex
     formats are allowed:
 
@@ -6382,30 +6389,43 @@
     function.
 
     Arithmetic and logical operations are all performed on an element by
     element basis.  Comparing two vector columns,  eg  "COL1  ==  COL2",
     thus  results  in  another vector of boolean values indicating which
     elements of the two vectors are equal.
 
-    Eight functions are available that operate on a vector and return a
-    scalar result:
+    Several functions are available that operate on a vector.  All but
+    the last two return a scalar result:
 
 \begin{verbatim}
     "minimum"      MIN(V)          "maximum"               MAX(V)
     "average"      AVERAGE(V)      "median"                MEDIAN(V)
     "summation"    SUM(V)          "standard deviation"    STDDEV(V)
     "# of values"  NELEM(V)        "# of non-null values"  NVALID(V)
+    "# axes"       NAXIS(V)        "axis dimension"        NAXES(V,n)
+    "axis pos'n"   AXISELEM(V,n)   "vector element pos'n"  ELEMENTNUM(V)
+                                   "promote to array"      ARRAY(X,d)
 \end{verbatim}
     where V represents the name of a vector column or a manually
     constructed vector using curly brackets as described below.  The
     first 6 of these functions ignore any null values in the vector when
     computing the result.  The STDDEV() function computes the sample
     standard deviation, i.e. it is proportional to 1/SQRT(N-1) instead
     of 1/SQRT(N), where N is NVALID(V).
 
+    The NAXIS(V) function returns the number of axes of the vector,
+    for example a 2D array would be NAXIS(V) == 2.  The NAXES(V,n)
+    function returns the dimension of axis n, for example a 4x2 array
+    would have NAXES(V,1) == 4.  The ELEMENTNUM(V) and AXISELEM(V,n)
+    functions return vectors of the same size as the input vector V.
+    ELEMENTNUM(V) returns the vector element position for each element
+    in the vector, starting from 1 in each row.  The AXISELEM(V,n)
+    function is similar but returns the element position of axis n
+    only.
+
     The SUM function literally sums all  the elements in x,  returning a
     scalar value.   If x  is  a  boolean  vector, SUM returns the number
     of TRUE elements. The NELEM function  returns the number of elements
     in vector x whereas NVALID return the number of non-null elements in
     the  vector.   (NELEM  also  operates  on  bit  and string  columns,
     returning their column widths.)  As an example, to  test whether all
     elements of two vectors satisfy a  given logical comparison, one can
@@ -6414,14 +6434,26 @@
 \begin{verbatim}
               SUM( COL1 > COL2 ) == NELEM( COL1 )
 \end{verbatim}
 
     which will return TRUE if all elements  of  COL1  are  greater  than
     their corresponding elements in COL2.
 
+    The ARRAY(X,d) function promotes scalar value X to a vector (or
+    array) table element.  X may be any scalar-valued item, including
+    a column, an expression, or a constant value.  The resulting
+    vector or array will have the same scalar value replicated into
+    each element position.  This may be a useful way to construct
+    large arrays without using the cumbersome \{vector\} notation. The
+    dimensions of the new array are given by the second argument, d.
+    d can either be a single constant integer value, or a vector of up
+    to five dimensions of the form \{Nx,Ny,...\}.  Thus, ARRAY(TIME,4)
+    would promote TIME to be a 4-vector, and ARRAY(0, \{2,3,1\}) would
+    construct an array of all 0's with dimensions $2\times 3\times 1$.
+
     To  specify  a  single  element  of  a  vector, give the column name
     followed by  a  comma-separated  list  of  coordinates  enclosed  in
     square  brackets.  For example, if a vector column named PHAS exists
     in the table as a one dimensional, 256  component  list  of  numbers
     from  which  you  wanted to select the 57th component for use in the
     expression, then PHAS[57] would do the  trick.   Higher  dimensional
     arrays  of  data  may appear in a column.  But in order to interpret
@@ -6452,30 +6484,36 @@
     1, 3, 6, and 1.  The  vector can contain  only boolean, integer, and
     real values (or expressions).  The elements will  be promoted to the
     highest  datatype   present.  Any   elements   which  are themselves
     vectors, will be expanded out with  each of its elements becoming an
     element in the constructed vector.
 
 
-\subsection{Good Time Interval Filtering}
+\subsection{Good Time Interval Filtering and Calculation}
 
-    A common filtering method involves selecting rows which have a time
-    value which lies within what is called a Good Time Interval or GTI.
-    The time intervals are defined in a separate FITS table extension
-    which contains 2 columns giving the start and stop time of each
-    good interval.  The filtering operation accepts only those rows of
-    the input table which have an associated time which falls within
-    one of the time intervals defined in the GTI extension. A high
-    level function, gtifilter(a,b,c,d), is available which evaluates
-    each row of the input table  and returns TRUE  or FALSE depending
-    whether the row is inside or outside the  good time interval.  The
+    There are two functions for filtering and calculating based
+    on Good Time Intervals, or GTIs.  GTIs are commonly used to
+    express fragmented time ranges that are not easy to express with a
+    single start and stop time.  The time intervals are defined in a
+    FITS table extension which contains 2 columns giving the
+    start and stop time of each good interval.
+
+    A common filtering method involves selecting rows which have a
+    time value which lies within any GTI.  The gtifilter() filtering
+    operation accepts only those rows of the input table which have an
+    associated time which falls within one of the time intervals
+    defined in a separate GTI extension.  gtifilter(a,b,c,d) evaluates
+    each row of the input table and returns TRUE or FALSE depending
+    whether the row is inside or outside the good time interval.  The
     syntax is
 
 \begin{verbatim}
       gtifilter( [ "gtifile" [, expr [, "STARTCOL", "STOPCOL" ] ] ] )
+    or
+      gtifilter( [ 'gtifile' [, expr [, 'STARTCOL', 'STOPCOL' ] ] ] )
 \end{verbatim}
     where  each "[]" demarks optional parameters.  Note that  the quotes
     around the gtifile and START/STOP column are required.  Either single
     or double quotes may be used.  In cases where this expression is
     entered on the Unix command line, enclose the entire expression in
     double quotes, and then use single quotes within the expression to
     enclose the 'gtifile' and other terms.  It is also usually possible
@@ -6505,14 +6543,85 @@
     "START"  and "STOP".  The wildcards ('*') allow slight variations in
     naming conventions  such  as  "TSTART"  or  "STARTTIME".   The  same
     default  values  apply for unspecified parameters when the first one
     or  two  parameters  are  specified.   The  function   automatically
     searches   for   TIMEZERO/I/F   keywords  in  the  current  and  GTI
     extensions, applying a relative time offset, if necessary.
 
+    The related function, gtifind(a,b,c,d), is similar to gtifilter()
+    but instead of returning true/false, gtifind() returns the GTI
+    number that brackets the requested time sample.  gtifind() returns
+    the row number in the GTI table that matches the time sample, or
+    -1 if the time sample is not within any GTI.  gtifind() is
+    particularly useful when entries in a table must be categorized by
+    which GTI the fall within.  For example, if events in an event
+    list must be separated by good time interval.  The results of
+    gtifind() can be used with histogram binning techniques to bin an
+    event list by which GTI.
+    
+\begin{verbatim}
+      gtifind( "gtifile" , expr [, "STARTCOL", "STOPCOL" ] )
+\end{verbatim}
+
+    The requirements for specifying the gtifile are the same as for
+    gtifilter() as described above.  Like gtifilter(), the expr is
+    the time-like expression and is optional (defaulting to TIME).
+    The start and stop columns default to START and STOP.
+
+    The function, gtioverlap(a,b,c,d,e), computes the overlap
+    between a user-requested time range and the entries in a GTI.  The
+    cases of no overlap, partial overlap, or overlap of many GTIs
+    within the user requested range are handled.  gtioverlap() is very
+    useful for calculating exposure times and fractional exposures of
+    individual time bins, say for a light curve.  The syntax of
+    gtioverlap() is
+
+\begin{verbatim}
+      gtioverlap( "gtifile" , startExpr, stopExpr [, "STARTCOL", "STOPCOL" ] )
+    or
+      gtioverlap( 'gtifile' , startExpr, stopExpr [, 'STARTCOL', 'STOPCOL' ] )
+\end{verbatim}
+
+    The requirements for specifying the gtifile are the same as for
+    gtifilter() as described above.  Unlike gtifilter(), the startExpr
+    and stopExpr are not optional.  startExpr provides a start of the
+    user requested time interval.  startExpr is typically TIME, but
+    can be any valid expression.  Likewise, stopExpr provides the stop
+    of the user requested time interval, and can be an expression.
+    For example, for a light curve with a TIME column and time bin
+    size of 1.0 seconds, the expression
+
+\begin{verbatim}
+      gtioverlap('gtifile',TIME,TIME+1.0)
+\end{verbatim}
+
+    would calculate the amount of overlap exposure time between each
+    one second time bin and the GTI in 'gtifile'.  In this case the
+    time bin is assumed to begin at the time specified by TIME and end
+    1 second later.  Neither startExpr nor stopExpr are required to be
+    constant, and a light curve is not required to have a constant bin
+    size.  For tables, the overlap is calculated for each entry in the
+    table.
+
+    It is also possible to calculate a single overlap value, which
+    would typically be placed in a keyword.  For example, a way to to
+    compute the total overlap exposure of a file whose TIME column is
+    bounded by the keywords TSTART and TSTOP, overlapping with the
+    specified GTI, would be
+
+\begin{verbatim}
+      #EXPOSURE = gtioverlap('gtifile',#TSTART,#TSTOP)
+\end{verbatim}
+
+    The \verb+#EXPOSURE+ syntax with a leading \+#+ ensures that the 
+    requested values are treated as keywords.  Otherwise, a column
+    named EXPOSURE will be created with the (constant) exposure value
+    in each entry.  
+
+
 
 \subsection{Spatial Region Filtering}
 
     Another common  filtering method selects rows based on whether the
     spatial position associated with each row is located within a given
     2-dimensional region.  The syntax for this high-level filter is
 
@@ -6746,21 +6855,36 @@
 CFITSIO will first try to use the 'preferred column' as specified by
 the CPREF keyword if it exists (e.g., 'CPREF = 'DETX,DETY'), otherwise
 column names 'X', 'Y', 'Z', and 'T' will be assumed for each of the 4
 axes, respectively.  In cases where the column name could be confused
 with an arithmetic expression, enclose the column name in parentheses to
 force the name to be interpreted literally.
 
-Each column name may be followed by an equals sign and then the lower
-and upper range of the histogram, and the size of the histogram bins,
-separated by colons.  Spaces are allowed before and after the equals
-sign but not within the 'min:max:binsize' string.  The min, max and
-binsize values may be integer or floating point numbers, or they may be
-the names of keywords in the header of the table.  If the latter, then
-the value of that keyword is substituted into the expression.
+In addition to binning by a FITS column, any arbitrary calculator
+expression may be specified as well.  Usage of this form would appear
+as:
+
+\begin{verbatim}
+ [bin  Xcol(arbitrary expression)=min:max:binsize, ... ]
+\end{verbatim}
+
+The column name must still be specified, and is used to label
+coordinate axes of the resulting image.  The expression appears
+immediately after the name, enclosed in parentheses.  The expression
+may use any combination of columns, keywords, functions and constants
+and allowed by the CFITSIO calculator.
+
+The column name (and optional expression) may be followed by an equals
+sign and then the lower and upper range of the histogram, and the size
+of the histogram bins, separated by colons.  Spaces are allowed before
+and after the equals sign but not within the 'min:max:binsize' string.
+The min, max and binsize values may be integer or floating point
+numbers, or they may be the names of keywords in the header of the
+table.  If the latter, then the value of that keyword is substituted
+into the expression.
 
 Default values for the min, max and binsize quantities will be
 used if not explicitly given in the binning expression as shown
 in these examples:
 
 \begin{verbatim}
     [bin x = :512:2]  - use default minimum value
@@ -6776,14 +6900,21 @@
 CFITSIO  will use the value of the TLMINn, TLMAXn, and TDBINn keywords,
 if they exist, for the default min, max, and binsize, respectively.  If
 they do not exist then CFITSIO will use the actual minimum and maximum
 values in the column for the histogram min and max values.  The default
 binsize will be set to 1, or (max - min) / 10., whichever is smaller,
 so that the histogram will have at least 10 bins along each axis.
 
+Please note that if explicit min and max values (or TLMINn/TLMAXn keywords)
+are not present, then CFITSIO must check every value of the binned quantity
+in advance to determine the binning limits.  This is especially relevant 
+for binning expressions, which must be evaluated multiple times to determine
+the limits of the expression.  Thus, it is always advisable to specify 
+min and max limits where possible.
+
 A shortcut notation is allowed if all the columns/axes have the same
 binning specification.  In this case all the column names may be listed
 within parentheses, followed by the (single) binning specification, as
 in:
 
 \begin{verbatim}
     [bin (X,Y)=1:512:2]
@@ -6793,21 +6924,26 @@
 The optional weighting factor is the last item in the binning specifier
 and, if present, is separated from the list of columns by a
 semi-colon.  As the histogram is accumulated, this weight is used to
 incremented the value of the appropriated bin in the histogram.  If the
 weighting factor is not specified, then the default weight = 1 is
 assumed.  The weighting factor may be a constant integer or floating
 point number, or the name of a keyword containing the weighting value.
-Or the weighting factor may be the name of a table column in which case
+The weighting factor may also be the name of a table column in which case
 the value in that column, on a row by row basis, will be used.
+It may also be an expression, enclosed in parenthesis, in which case
+the weighting value will be evaluated for each binned row and applied
+accordingly.
 
 In some cases, the column or keyword may give the reciprocal of the
 actual weight value that is needed.  In this case, precede the weight
 keyword or column name by a slash '/' to tell CFITSIO to use the
-reciprocal of the value when constructing the histogram.
+reciprocal of the value when constructing the histogram.  An expression,
+enclosed in parentheses, may also appear after the slash, to
+indicate the reciprocal value of the expression.
 
 For  complex or commonly  used  histograms, one  can also  place its
 description  into  a  text  file and  import   it  into  the binning
 specification  using the  syntax '[bin  @filename.txt]'.  The file's
 contents  can extend over   multiple lines, although  it must still
 conform to the  no-spaces rule  for the min:max:binsize syntax and each
 axis specification must still be comma-separated.  Any lines in the
@@ -6834,14 +6970,30 @@
                                        with 0.1 unit size bins.
 
     [bin pha, time=8000.:8100.:0.1]  - 2-D image using default binning
                                        of the PHA column for the X axis,
                                        and 1000 bins in the range
                                        8000. to 8100. for the Y axis.
 
+    [bin pha, gti_num(gtifind())=1:2:1] - a 2-D image, where PHA is the
+                                       X axis and the Y axis is an expression
+                                       which evaluates to the GTI number, 
+                                       as determined using the
+                                       GTIFIND() function.
+
+    [bin time=0:4000:2000, HR( (LC2/LC1).lt.1.5 ? 1 : 2 )=1:2:1] - a 2-D
+                                       histogram which determines the number
+                                       of samples in two time bins between 0 and
+                                       4000 and separating hardness ratio, 
+                                       evaluated as (LC2/LC1), between less than
+                                       1.5 or greater than 1.5.  The ?: 
+                                       conditional function is used to decide
+                                       less (or greater) than 1.5 and assign
+                                       HR bin 1 or 2.
+
     [bin @binFilter.txt]             - Use the contents of the text file
                                        binFilter.txt for the binning
                                        specifications.
 
 \end{verbatim}
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/fitsio.toc` & `fitsio-1.2.0/cfitsio-4.2.0/docs/fitsio.toc`

 * *Files 23% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-\contentsline {chapter}{\numberline {1}Introduction }{1}{chapter.1}
-\contentsline {chapter}{\numberline {2} Creating FITSIO/CFITSIO }{3}{chapter.2}
-\contentsline {section}{\numberline {2.1}Building the Library}{3}{section.2.1}
-\contentsline {section}{\numberline {2.2}Testing the Library}{6}{section.2.2}
-\contentsline {section}{\numberline {2.3}Linking Programs with FITSIO}{7}{section.2.3}
-\contentsline {section}{\numberline {2.4}Getting Started with FITSIO}{7}{section.2.4}
-\contentsline {section}{\numberline {2.5}Example Program}{8}{section.2.5}
-\contentsline {section}{\numberline {2.6}Legal Stuff}{9}{section.2.6}
-\contentsline {section}{\numberline {2.7}Acknowledgments}{10}{section.2.7}
-\contentsline {chapter}{\numberline {3} A FITS Primer }{13}{chapter.3}
-\contentsline {chapter}{\numberline {4}FITSIO Conventions and Guidelines }{15}{chapter.4}
-\contentsline {section}{\numberline {4.1}CFITSIO Size Limitations}{15}{section.4.1}
-\contentsline {section}{\numberline {4.2}Multiple Access to the Same FITS File}{16}{section.4.2}
-\contentsline {section}{\numberline {4.3}Current Header Data Unit (CHDU)}{16}{section.4.3}
-\contentsline {section}{\numberline {4.4}Subroutine Names}{16}{section.4.4}
-\contentsline {section}{\numberline {4.5}Subroutine Families and Datatypes}{17}{section.4.5}
-\contentsline {section}{\numberline {4.6}Implicit Data Type Conversion}{17}{section.4.6}
-\contentsline {section}{\numberline {4.7}Data Scaling}{18}{section.4.7}
-\contentsline {section}{\numberline {4.8}Error Status Values and the Error Message Stack}{18}{section.4.8}
-\contentsline {section}{\numberline {4.9}Variable-Length Array Facility in Binary Tables}{19}{section.4.9}
-\contentsline {section}{\numberline {4.10}Support for IEEE Special Values}{20}{section.4.10}
-\contentsline {section}{\numberline {4.11}When the Final Size of the FITS HDU is Unknown}{21}{section.4.11}
-\contentsline {section}{\numberline {4.12}Local FITS Conventions supported by FITSIO}{21}{section.4.12}
-\contentsline {subsection}{\numberline {4.12.1}Support for Long String Keyword Values.}{21}{subsection.4.12.1}
-\contentsline {subsection}{\numberline {4.12.2}Arrays of Fixed-Length Strings in Binary Tables}{22}{subsection.4.12.2}
-\contentsline {subsection}{\numberline {4.12.3}Keyword Units Strings}{23}{subsection.4.12.3}
-\contentsline {subsection}{\numberline {4.12.4}HIERARCH Convention for Extended Keyword Names}{23}{subsection.4.12.4}
-\contentsline {section}{\numberline {4.13}Optimizing Code for Maximum Processing Speed}{24}{section.4.13}
-\contentsline {subsection}{\numberline {4.13.1}Background Information: How CFITSIO Manages Data I/O}{24}{subsection.4.13.1}
-\contentsline {subsection}{\numberline {4.13.2}Optimization Strategies}{25}{subsection.4.13.2}
-\contentsline {chapter}{\numberline {5} Basic Interface Routines }{29}{chapter.5}
-\contentsline {section}{\numberline {5.1}FITSIO Error Status Routines }{29}{section.5.1}
-\contentsline {section}{\numberline {5.2}File I/O Routines}{30}{section.5.2}
-\contentsline {section}{\numberline {5.3}Keyword I/O Routines}{32}{section.5.3}
-\contentsline {section}{\numberline {5.4}Data I/O Routines}{33}{section.5.4}
-\contentsline {chapter}{\numberline {6} Advanced Interface Subroutines }{35}{chapter.6}
-\contentsline {section}{\numberline {6.1}FITS File Open and Close Subroutines: }{35}{section.6.1}
-\contentsline {section}{\numberline {6.2}HDU-Level Operations }{38}{section.6.2}
-\contentsline {section}{\numberline {6.3}Define or Redefine the structure of the CHDU }{41}{section.6.3}
-\contentsline {section}{\numberline {6.4}FITS Header I/O Subroutines}{43}{section.6.4}
-\contentsline {subsection}{\numberline {6.4.1}Header Space and Position Routines }{43}{subsection.6.4.1}
-\contentsline {subsection}{\numberline {6.4.2}Read or Write Standard Header Routines }{43}{subsection.6.4.2}
-\contentsline {subsection}{\numberline {6.4.3}Write Keyword Subroutines }{45}{subsection.6.4.3}
-\contentsline {subsection}{\numberline {6.4.4}Insert Keyword Subroutines }{47}{subsection.6.4.4}
-\contentsline {subsection}{\numberline {6.4.5}Read Keyword Subroutines }{47}{subsection.6.4.5}
-\contentsline {subsection}{\numberline {6.4.6}Modify Keyword Subroutines }{49}{subsection.6.4.6}
-\contentsline {subsection}{\numberline {6.4.7}Update Keyword Subroutines }{50}{subsection.6.4.7}
-\contentsline {subsection}{\numberline {6.4.8}Delete Keyword Subroutines }{51}{subsection.6.4.8}
-\contentsline {section}{\numberline {6.5}Data Scaling and Undefined Pixel Parameters }{51}{section.6.5}
-\contentsline {section}{\numberline {6.6}FITS Primary Array or IMAGE Extension I/O Subroutines }{52}{section.6.6}
-\contentsline {section}{\numberline {6.7}FITS ASCII and Binary Table Data I/O Subroutines}{55}{section.6.7}
-\contentsline {subsection}{\numberline {6.7.1}Column Information Subroutines }{55}{subsection.6.7.1}
-\contentsline {subsection}{\numberline {6.7.2}Low-Level Table Access Subroutines }{58}{subsection.6.7.2}
-\contentsline {subsection}{\numberline {6.7.3}Edit Rows or Columns }{59}{subsection.6.7.3}
-\contentsline {subsection}{\numberline {6.7.4}Read and Write Column Data Routines }{60}{subsection.6.7.4}
-\contentsline {section}{\numberline {6.8}Row Selection and Calculator Routines }{64}{section.6.8}
-\contentsline {section}{\numberline {6.9}Celestial Coordinate System Subroutines }{65}{section.6.9}
-\contentsline {section}{\numberline {6.10}File Checksum Subroutines }{67}{section.6.10}
-\contentsline {section}{\numberline {6.11} Date and Time Utility Routines }{68}{section.6.11}
-\contentsline {section}{\numberline {6.12}General Utility Subroutines }{69}{section.6.12}
-\contentsline {chapter}{\numberline {7} The CFITSIO Iterator Function }{77}{chapter.7}
-\contentsline {chapter}{\numberline {8} Extended File Name Syntax }{79}{chapter.8}
-\contentsline {section}{\numberline {8.1}Overview}{79}{section.8.1}
-\contentsline {section}{\numberline {8.2}Filetype}{82}{section.8.2}
-\contentsline {subsection}{\numberline {8.2.1}Notes about HTTP proxy servers}{82}{subsection.8.2.1}
-\contentsline {subsection}{\numberline {8.2.2}Notes about the stream filetype driver}{83}{subsection.8.2.2}
-\contentsline {subsection}{\numberline {8.2.3}Notes about the gsiftp filetype}{84}{subsection.8.2.3}
-\contentsline {subsection}{\numberline {8.2.4}Notes about the root filetype}{84}{subsection.8.2.4}
-\contentsline {subsection}{\numberline {8.2.5}Notes about the shmem filetype:}{86}{subsection.8.2.5}
-\contentsline {section}{\numberline {8.3}Base Filename}{86}{section.8.3}
-\contentsline {section}{\numberline {8.4}Output File Name when Opening an Existing File}{88}{section.8.4}
-\contentsline {section}{\numberline {8.5}Template File Name when Creating a New File}{90}{section.8.5}
-\contentsline {section}{\numberline {8.6}Image Tile-Compression Specification}{90}{section.8.6}
-\contentsline {section}{\numberline {8.7}HDU Location Specification}{90}{section.8.7}
-\contentsline {section}{\numberline {8.8}Image Section}{91}{section.8.8}
-\contentsline {section}{\numberline {8.9}Image Transform Filters}{92}{section.8.9}
-\contentsline {section}{\numberline {8.10}Column and Keyword Filtering Specification}{94}{section.8.10}
-\contentsline {section}{\numberline {8.11}Row Filtering Specification}{97}{section.8.11}
-\contentsline {subsection}{\numberline {8.11.1}General Syntax}{97}{subsection.8.11.1}
-\contentsline {subsection}{\numberline {8.11.2}Bit Masks}{100}{subsection.8.11.2}
-\contentsline {subsection}{\numberline {8.11.3}Vector Columns}{101}{subsection.8.11.3}
-\contentsline {subsection}{\numberline {8.11.4}Good Time Interval Filtering}{103}{subsection.8.11.4}
-\contentsline {subsection}{\numberline {8.11.5}Spatial Region Filtering}{103}{subsection.8.11.5}
-\contentsline {subsection}{\numberline {8.11.6}Example Row Filters}{106}{subsection.8.11.6}
-\contentsline {section}{\numberline {8.12} Binning or Histogramming Specification}{107}{section.8.12}
-\contentsline {chapter}{\numberline {9}Template Files }{111}{chapter.9}
-\contentsline {section}{\numberline {9.1}Detailed Template Line Format}{111}{section.9.1}
-\contentsline {section}{\numberline {9.2}Auto-indexing of Keywords}{112}{section.9.2}
-\contentsline {section}{\numberline {9.3}Template Parser Directives}{113}{section.9.3}
-\contentsline {section}{\numberline {9.4}Formal Template Syntax}{114}{section.9.4}
-\contentsline {section}{\numberline {9.5}Errors}{114}{section.9.5}
-\contentsline {section}{\numberline {9.6}Examples}{114}{section.9.6}
-\contentsline {chapter}{\numberline {10} Summary of all FITSIO User-Interface Subroutines }{117}{chapter.10}
-\contentsline {chapter}{\numberline {11} Parameter Definitions }{125}{chapter.11}
-\contentsline {chapter}{\numberline {12} FITSIO Error Status Codes }{131}{chapter.12}
+\contentsline {chapter}{\numberline {1}Introduction }{1}
+\contentsline {chapter}{\numberline {2} Creating FITSIO/CFITSIO }{3}
+\contentsline {section}{\numberline {2.1}Building the Library}{3}
+\contentsline {section}{\numberline {2.2}Testing the Library}{6}
+\contentsline {section}{\numberline {2.3}Linking Programs with FITSIO}{7}
+\contentsline {section}{\numberline {2.4}Getting Started with FITSIO}{7}
+\contentsline {section}{\numberline {2.5}Example Program}{8}
+\contentsline {section}{\numberline {2.6}Legal Stuff}{9}
+\contentsline {section}{\numberline {2.7}Acknowledgments}{10}
+\contentsline {chapter}{\numberline {3} A FITS Primer }{13}
+\contentsline {chapter}{\numberline {4}FITSIO Conventions and Guidelines }{15}
+\contentsline {section}{\numberline {4.1}CFITSIO Size Limitations}{15}
+\contentsline {section}{\numberline {4.2}Multiple Access to the Same FITS File}{16}
+\contentsline {section}{\numberline {4.3}Current Header Data Unit (CHDU)}{16}
+\contentsline {section}{\numberline {4.4}Subroutine Names}{16}
+\contentsline {section}{\numberline {4.5}Subroutine Families and Datatypes}{17}
+\contentsline {section}{\numberline {4.6}Implicit Data Type Conversion}{17}
+\contentsline {section}{\numberline {4.7}Data Scaling}{18}
+\contentsline {section}{\numberline {4.8}Error Status Values and the Error Message Stack}{18}
+\contentsline {section}{\numberline {4.9}Variable-Length Array Facility in Binary Tables}{19}
+\contentsline {section}{\numberline {4.10}Support for IEEE Special Values}{20}
+\contentsline {section}{\numberline {4.11}When the Final Size of the FITS HDU is Unknown}{21}
+\contentsline {section}{\numberline {4.12}Local FITS Conventions supported by FITSIO}{21}
+\contentsline {subsection}{\numberline {4.12.1}Support for Long String Keyword Values.}{21}
+\contentsline {subsection}{\numberline {4.12.2}Arrays of Fixed-Length Strings in Binary Tables}{22}
+\contentsline {subsection}{\numberline {4.12.3}Keyword Units Strings}{23}
+\contentsline {subsection}{\numberline {4.12.4}HIERARCH Convention for Extended Keyword Names}{23}
+\contentsline {section}{\numberline {4.13}Optimizing Code for Maximum Processing Speed}{24}
+\contentsline {subsection}{\numberline {4.13.1}Background Information: How CFITSIO Manages Data I/O}{24}
+\contentsline {subsection}{\numberline {4.13.2}Optimization Strategies}{25}
+\contentsline {chapter}{\numberline {5} Basic Interface Routines }{29}
+\contentsline {section}{\numberline {5.1}FITSIO Error Status Routines }{29}
+\contentsline {section}{\numberline {5.2}File I/O Routines}{30}
+\contentsline {section}{\numberline {5.3}Keyword I/O Routines}{32}
+\contentsline {section}{\numberline {5.4}Data I/O Routines}{33}
+\contentsline {chapter}{\numberline {6} Advanced Interface Subroutines }{35}
+\contentsline {section}{\numberline {6.1}FITS File Open and Close Subroutines: }{35}
+\contentsline {section}{\numberline {6.2}HDU-Level Operations }{38}
+\contentsline {section}{\numberline {6.3}Define or Redefine the structure of the CHDU }{41}
+\contentsline {section}{\numberline {6.4}FITS Header I/O Subroutines}{43}
+\contentsline {subsection}{\numberline {6.4.1}Header Space and Position Routines }{43}
+\contentsline {subsection}{\numberline {6.4.2}Read or Write Standard Header Routines }{43}
+\contentsline {subsection}{\numberline {6.4.3}Write Keyword Subroutines }{45}
+\contentsline {subsection}{\numberline {6.4.4}Insert Keyword Subroutines }{47}
+\contentsline {subsection}{\numberline {6.4.5}Read Keyword Subroutines }{47}
+\contentsline {subsection}{\numberline {6.4.6}Modify Keyword Subroutines }{49}
+\contentsline {subsection}{\numberline {6.4.7}Update Keyword Subroutines }{50}
+\contentsline {subsection}{\numberline {6.4.8}Delete Keyword Subroutines }{51}
+\contentsline {section}{\numberline {6.5}Data Scaling and Undefined Pixel Parameters }{51}
+\contentsline {section}{\numberline {6.6}FITS Primary Array or IMAGE Extension I/O Subroutines }{52}
+\contentsline {section}{\numberline {6.7}FITS ASCII and Binary Table Data I/O Subroutines}{56}
+\contentsline {subsection}{\numberline {6.7.1}Column Information Subroutines }{56}
+\contentsline {subsection}{\numberline {6.7.2}Low-Level Table Access Subroutines }{58}
+\contentsline {subsection}{\numberline {6.7.3}Edit Rows or Columns }{59}
+\contentsline {subsection}{\numberline {6.7.4}Read and Write Column Data Routines }{60}
+\contentsline {section}{\numberline {6.8}Row Selection and Calculator Routines }{64}
+\contentsline {section}{\numberline {6.9}Celestial Coordinate System Subroutines }{65}
+\contentsline {section}{\numberline {6.10}File Checksum Subroutines }{67}
+\contentsline {section}{\numberline {6.11} Date and Time Utility Routines }{68}
+\contentsline {section}{\numberline {6.12}General Utility Subroutines }{69}
+\contentsline {chapter}{\numberline {7} The CFITSIO Iterator Function }{77}
+\contentsline {chapter}{\numberline {8} Extended File Name Syntax }{79}
+\contentsline {section}{\numberline {8.1}Overview}{79}
+\contentsline {section}{\numberline {8.2}Filetype}{82}
+\contentsline {subsection}{\numberline {8.2.1}Notes about HTTP proxy servers}{82}
+\contentsline {subsection}{\numberline {8.2.2}Notes about the stream filetype driver}{83}
+\contentsline {subsection}{\numberline {8.2.3}Notes about the gsiftp filetype}{84}
+\contentsline {subsection}{\numberline {8.2.4}Notes about the root filetype}{84}
+\contentsline {subsection}{\numberline {8.2.5}Notes about the shmem filetype:}{86}
+\contentsline {section}{\numberline {8.3}Base Filename}{86}
+\contentsline {section}{\numberline {8.4}Output File Name when Opening an Existing File}{88}
+\contentsline {section}{\numberline {8.5}Template File Name when Creating a New File}{90}
+\contentsline {section}{\numberline {8.6}Image Tile-Compression Specification}{90}
+\contentsline {section}{\numberline {8.7}HDU Location Specification}{90}
+\contentsline {section}{\numberline {8.8}Image Section}{91}
+\contentsline {section}{\numberline {8.9}Image Transform Filters}{92}
+\contentsline {section}{\numberline {8.10}Column and Keyword Filtering Specification}{94}
+\contentsline {section}{\numberline {8.11}Row Filtering Specification}{97}
+\contentsline {subsection}{\numberline {8.11.1}General Syntax}{97}
+\contentsline {subsection}{\numberline {8.11.2}Bit Masks}{100}
+\contentsline {subsection}{\numberline {8.11.3}Vector Columns}{101}
+\contentsline {subsection}{\numberline {8.11.4}Good Time Interval Filtering and Calculation}{103}
+\contentsline {subsection}{\numberline {8.11.5}Spatial Region Filtering}{105}
+\contentsline {subsection}{\numberline {8.11.6}Example Row Filters}{107}
+\contentsline {section}{\numberline {8.12} Binning or Histogramming Specification}{108}
+\contentsline {chapter}{\numberline {9}Template Files }{113}
+\contentsline {section}{\numberline {9.1}Detailed Template Line Format}{113}
+\contentsline {section}{\numberline {9.2}Auto-indexing of Keywords}{114}
+\contentsline {section}{\numberline {9.3}Template Parser Directives}{115}
+\contentsline {section}{\numberline {9.4}Formal Template Syntax}{116}
+\contentsline {section}{\numberline {9.5}Errors}{116}
+\contentsline {section}{\numberline {9.6}Examples}{116}
+\contentsline {chapter}{\numberline {10} Summary of all FITSIO User-Interface Subroutines }{119}
+\contentsline {chapter}{\numberline {11} Parameter Definitions }{127}
+\contentsline {chapter}{\numberline {12} FITSIO Error Status Codes }{133}
```

### Comparing `fitsio-1.1.9/cfitsio3490/docs/quick.pdf` & `fitsio-1.2.0/cfitsio-4.2.0/docs/quick.pdf`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/docs/quick.ps` & `fitsio-1.2.0/cfitsio-4.2.0/docs/quick.ps`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/docs/quick.tex` & `fitsio-1.2.0/cfitsio-4.2.0/docs/quick.tex`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/docs/quick.toc` & `fitsio-1.2.0/cfitsio-4.2.0/docs/quick.toc`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/drvrfile.c` & `fitsio-1.2.0/cfitsio-4.2.0/drvrfile.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/drvrgsiftp.c` & `fitsio-1.2.0/cfitsio-4.2.0/drvrgsiftp.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/drvrgsiftp.h` & `fitsio-1.2.0/cfitsio-4.2.0/drvrgsiftp.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/drvrmem.c` & `fitsio-1.2.0/cfitsio-4.2.0/drvrmem.c`

 * *Files 1% similar despite different names*

```diff
@@ -1233,14 +1233,45 @@
     memTable[hdl].currentpos += nbytes;
     memTable[hdl].fitsfilesize =
                maxvalue(memTable[hdl].fitsfilesize,
                         memTable[hdl].currentpos);
     return(0);
 }
 
+/*--------------------------------------------------------------------------*/
+int mem_zuncompress_and_write(int hdl, void *buffer, long nbytes)
+/*
+  uncompress input buffer, length nbytes and write bytes to current
+  position in file.  output buffer needs to be at position 0 to start.
+*/
+{
+  size_t newsize;
+  int status = 0;
+
+  if (memTable[hdl].currentpos != 0) {
+      ffpmsg("cannot append uncompressed data (mem_uncompress_and_write)");
+      return(WRITE_ERROR);
+  }
+
+  uncompress2mem_from_mem(buffer, nbytes,
+			  memTable[hdl].memaddrptr,
+			  memTable[hdl].memsizeptr,
+			  memTable[hdl].mem_realloc, 
+			  &newsize, &status);
+  
+  if (status) {
+    ffpmsg("unabled to uncompress memory file (mem_uncompress_and_write)");
+    return(WRITE_ERROR);
+  }
+
+  memTable[hdl].currentpos += newsize;
+  memTable[hdl].fitsfilesize = newsize;
+  return(0);
+}
+
 
 #if HAVE_BZIP2
 void bzip2uncompress2mem(char *filename, FILE *diskfile, int hdl,
                         size_t* filesize, int* status) {
     BZFILE* b;
     int  bzerror;
     char buf[8192];
```

### Comparing `fitsio-1.1.9/cfitsio3490/drvrnet.c` & `fitsio-1.2.0/cfitsio-4.2.0/drvrnet.c`

 * *Files 4% similar despite different names*

```diff
@@ -238,15 +238,16 @@
 static int NET_RecvRaw(int sock, void *buffer, int length);
 static int NET_ParseUrl(const char *url, char *proto, char *host, int *port, 
 		 char *fn);
 static int CreateSocketAddress(struct sockaddr_in *sockaddrPtr,
 			       char *host,int port);
 static int ftp_status(FILE *ftp, char *statusstr);
 static int http_open_network(char *url, FILE **httpfile, char *contentencoding,
-			  int *contentlength);
+			     char *contenttype, 
+			     int *contentlength);
 static int https_open_network(char *filename, curlmembuf* buffer);
 static int ftp_open_network(char *url, FILE **ftpfile, FILE **command, 
 			    int *sock);
 static int ftps_open_network(char *filename, curlmembuf* buffer);
 static int ftp_file_exist(char *url);
 static int root_send_buffer(int sock, int op, char *buffer, int buflen);
 static int root_recv_buffer(int sock, int *op, char *buffer,int buflen);
@@ -280,15 +281,15 @@
 /* This creates a memory file handle with a copy of the URL in filename. The 
    file is uncompressed if necessary */
 
 int http_open(char *filename, int rwmode, int *handle)
 {
 
   FILE *httpfile;
-  char contentencoding[SHORTLEN];
+  char contentencoding[SHORTLEN], contenttype[SHORTLEN];
   char errorstr[MAXLEN];
   char recbuf[MAXLEN];
   long len;
   int contentlength;
   int status;
   char firstchar;
 
@@ -314,16 +315,16 @@
     goto error;
   }
 
   (void) signal(SIGALRM, signal_handler);
   
   /* Open the network connection */
 
-  if (http_open_network(filename,&httpfile,contentencoding,
-			       &contentlength)) {
+  if (http_open_network(filename,&httpfile, contentencoding, 
+			contenttype, &contentlength)) {
       alarm(0);
       ffpmsg("Unable to open http file (http_open):");
       ffpmsg(filename);
       goto error;
   } 
 
   closehttpfile++;
@@ -338,14 +339,20 @@
 
   /* Now, what do we do with the file */
   /* Check to see what the first character is */
   firstchar = fgetc(httpfile);
   ungetc(firstchar,httpfile);
   if (!strcmp(contentencoding,"x-gzip") || 
       !strcmp(contentencoding,"x-compress") ||
+      !strcmp(contenttype, "application/x-gzip") ||
+      !strcmp(contenttype, "application/gzip") ||
+      !strcmp(contenttype, "application/gzip-compressed") ||
+      !strcmp(contenttype, "application/gzipped") ||
+      !strcmp(contenttype, "application/x-compress") ||
+      !strcmp(contenttype, "application/x-compressed") ||
       strstr(filename,".gz") || 
       strstr(filename,".Z") ||
       ('\037' == firstchar)) {
     /* do the compress dance, which is the same as the gzip dance */
     /* Using the cfitsio routine */
 
     status = 0;
@@ -408,15 +415,15 @@
    file must be compressed and is copied (still compressed) to disk first. 
    The compressed disk file is then uncompressed into memory (READONLY).
 */
 
 int http_compress_open(char *url, int rwmode, int *handle)
 {
   FILE *httpfile;
-  char contentencoding[SHORTLEN];
+  char contentencoding[SHORTLEN], contenttype[SHORTLEN];
   char errorstr[MAXLEN];
   char recbuf[MAXLEN];
   long len;
   int contentlength;
   int ii, flen, status;
   char firstchar;
 
@@ -450,30 +457,36 @@
     goto error;
   }
 
   signal(SIGALRM, signal_handler);
   
   /* Open the http connectin */
   alarm(net_timeout);
-  if ((status = http_open_network(url,&httpfile,contentencoding,
-			       &contentlength))) {
+  if ((status = http_open_network(url,&httpfile, contentencoding, 
+				  contenttype, &contentlength))) {
     alarm(0);
     ffpmsg("Unable to open http file (http_compress_open)");
     ffpmsg(url);
     goto error;
   }
 
   closehttpfile++;
 
   /* Better be compressed */
 
   firstchar = fgetc(httpfile);
   ungetc(firstchar,httpfile);
   if (!strcmp(contentencoding,"x-gzip") || 
       !strcmp(contentencoding,"x-compress") ||
+      !strcmp(contenttype, "application/x-gzip") ||
+      !strcmp(contenttype, "application/gzip") ||
+      !strcmp(contenttype, "application/gzip-compressed") ||
+      !strcmp(contenttype, "application/gzipped") ||
+      !strcmp(contenttype, "application/x-compress") ||
+      !strcmp(contenttype, "application/x-compressed") ||
       ('\037' == firstchar)) {
 
     if (*netoutfile == '!')
     {
        /* user wants to clobber file, if it already exists */
        for (ii = 0; ii < flen; ii++)
            netoutfile[ii] = netoutfile[ii + 1];  /* remove '!' */
@@ -567,15 +580,15 @@
 /* This creates a file handle with a copy of the URL in filename.  The http
    file is copied to disk first.  If it's compressed then it is
    uncompressed when copying to the disk */
 
 int http_file_open(char *url, int rwmode, int *handle)
 {
   FILE *httpfile;
-  char contentencoding[SHORTLEN];
+  char contentencoding[SHORTLEN], contenttype[SHORTLEN];
   char errorstr[MAXLEN];
   char recbuf[MAXLEN];
   long len;
   int contentlength;
   int ii, flen, status;
   char firstchar;
 
@@ -609,16 +622,16 @@
     goto error;
   }
 
   signal(SIGALRM, signal_handler);
   
   /* Open the network connection */
   alarm(net_timeout);
-  if ((status = http_open_network(url,&httpfile,contentencoding,
-			       &contentlength))) {
+  if ((status = http_open_network(url,&httpfile, contentencoding,
+				  contenttype, &contentlength))) {
     alarm(0);
     ffpmsg("Unable to open http file (http_file_open)");
     ffpmsg(url);
     goto error;
   }
 
   closehttpfile++;
@@ -632,14 +645,20 @@
      status = file_remove(netoutfile);
   }
 
   firstchar = fgetc(httpfile);
   ungetc(firstchar,httpfile);
   if (!strcmp(contentencoding,"x-gzip") || 
       !strcmp(contentencoding,"x-compress") ||
+      !strcmp(contenttype, "application/x-gzip") ||
+      !strcmp(contenttype, "application/gzip") ||
+      !strcmp(contenttype, "application/gzip-compressed") ||
+      !strcmp(contenttype, "application/gzipped") ||
+      !strcmp(contenttype, "application/x-compress") ||
+      !strcmp(contenttype, "application/x-compressed") ||
       ('\037' == firstchar)) {
 
     /* to make this more cfitsioish we use the file driver calls to create
        the disk file */
 
     /* Create the output file */
     if ((status =  file_create(netoutfile,handle))) {
@@ -739,15 +758,15 @@
      read the file from
    contentencoding is the mime type of the file, returned if the http server
      returns it
    contentlength is the length of the file, returned if the http server returns
      it
 */
 static int http_open_network(char *url, FILE **httpfile, char *contentencoding,
-			  int *contentlength)
+			     char *contenttype, int *contentlength)
 {
 
   int status;
   int sock;
   int tmpint;
   char recbuf[MAXLEN];
   char tmpstr[MAXLEN];
@@ -883,14 +902,15 @@
     fclose(*httpfile);
     *httpfile=0;
     return (FILE_NOT_OPENED);
   }
 
   *contentlength = 0;
   contentencoding[0] = '\0';
+  contenttype[0] = '\0';
 
   /* Our choices are 200, ok, 302, temporary redirect, or 301 perm redirect */
   sscanf(recbuf,"%s %d",tmpstr,&status);
   if (status != 200){
     if (status == 301 || status == 302) {
       /* got a redirect */
 
@@ -934,15 +954,16 @@
 	     scratchstr2 += 7;
 	     strcpy(turl, scratchstr2);
 	     fclose (*httpfile);
              *httpfile=0;
 
              /* note the recursive call to itself */
 	     return 
-	        http_open_network(turl,httpfile,contentencoding,contentlength);
+	       http_open_network(turl,httpfile, contentencoding, 
+				 contenttype, contentlength);
           }
 
           /* It was not a HTTP to HTTP redirection, so see if it HTTP to FTP */
 	  scratchstr2 = strstr(scratchstr,"ftp://");
           if (scratchstr2 != NULL) {
 	     /* Ok, we found the HTTP redirection is to a FTP URL. */
 	     /* skip the "ftp://" characters */
@@ -1026,14 +1047,31 @@
            fclose(*httpfile);
            *httpfile=0;
            return URL_PARSE_ERROR;
         }
 	strcpy(contentencoding,scratchstr);
       }
     }
+
+    /* Did we get the content-type header ? */
+    if (!strcmp(tmpstr,"Content-Type:")) {
+      if (NULL != (scratchstr = strstr(recbuf,":"))) {
+	/* Found the : */
+	scratchstr++; /* skip the : */
+	scratchstr++; /* skip the extra space */
+        if (strlen(scratchstr) > SHORTLEN-1) 
+        {
+           ffpmsg("Error: content-type string too long (http_open_network)");
+           fclose(*httpfile);
+           *httpfile=0;
+           return URL_PARSE_ERROR;
+        }
+	strcpy(contenttype,scratchstr);
+      }
+    }
   }
   
   /* we're done, so return */
   return 0;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -1085,21 +1123,41 @@
   if ((status = mem_create(filename, handle)))
   {
      ffpmsg("Unable to create memory file (https_open)");
      free(inmem.memory);
      return (FILE_NOT_OPENED);
   }
   
-  if (inmem.size % 2880)
-  {
-     snprintf(errStr,MAXLEN,"Content-Length not a multiple of 2880 (https_open) %u",
-         inmem.size);
-     ffpmsg(errStr);
+  /* Check for gzip magic number */
+  if (inmem.size >= 2 &&
+      (unsigned char) inmem.memory[0] == 0x1f && 
+      (unsigned char) inmem.memory[1] == 0x8b) {
+    LONGLONG fitsfilesize = 0;
+    
+    /* Uncompress from memory to memfile */
+    status = mem_zuncompress_and_write(*handle, inmem.memory, inmem.size);
+    mem_size(*handle, &fitsfilesize);
+
+    if ((fitsfilesize > 0) && (fitsfilesize % 2880)) {
+      snprintf(errStr,MAXLEN,"Uncompressed file length not a multiple of 2880 (https_open) %lld",
+	       fitsfilesize);
+      ffpmsg(errStr);
+    }
+
+  } else {
+
+    if (inmem.size % 2880) {
+      snprintf(errStr,MAXLEN,"Content-Length not a multiple of 2880 (https_open) %zu",
+	       inmem.size);
+      ffpmsg(errStr);
+    }
+
+    /* Straight copy of data */
+    status = mem_write(*handle, inmem.memory, inmem.size);
   }
-  status = mem_write(*handle, inmem.memory, inmem.size);
   if (status)
   {
      ffpmsg("Error copying https file into memory (https_open)");
      ffpmsg(filename);
      free(inmem.memory);
      mem_close_free(*handle);
      return (FILE_NOT_OPENED);
@@ -1174,15 +1232,15 @@
     free(inmem.memory);
     return (FILE_NOT_OPENED);
   }
     
   if (inmem.size % 2880)
   {
     snprintf(errStr, MAXLEN,
-	    "Content-Length not a multiple of 2880 (https_file_open) %d",
+	    "Content-Length not a multiple of 2880 (https_file_open) %zu",
 	    inmem.size);
     ffpmsg(errStr);
   }
    
   if (file_write(*handle, inmem.memory, inmem.size))
   {
      ffpmsg("Error copying https file to disk file (https_file_open)");
@@ -1411,15 +1469,15 @@
      }
      fclose(compressedFile);
   }
   else
   {
      if (inmem.size % 2880)
      {
-        snprintf(errStr,MAXLEN,"Content-Length not a multiple of 2880 (ftps_open) %u",
+        snprintf(errStr,MAXLEN,"Content-Length not a multiple of 2880 (ftps_open) %zu",
             inmem.size);
         ffpmsg(errStr);
      }
      status = mem_write(*handle, inmem.memory, inmem.size);
      if (status)
      {
         ffpmsg("Error copying https file into memory (ftps_open)");
@@ -1563,15 +1621,15 @@
      fclose(compressedInFile);
   }
   else
   {
      if (inmem.size % 2880)
      {
        snprintf(errStr, MAXLEN,
-	       "Content-Length not a multiple of 2880 (ftps_file_open) %d",
+	       "Content-Length not a multiple of 2880 (ftps_file_open) %zu",
 	       inmem.size);
        ffpmsg(errStr);
      }
 
      if (file_write(*handle, inmem.memory, inmem.size))
      {
         ffpmsg("Error copying ftps file to disk file (ftps_file_open)");
@@ -1866,15 +1924,15 @@
      ffpmsg("does not have SSL support, and therefore can't perform https or ftps transfers.");
      return (FILE_NOT_OPENED);    
   }
   curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, verifyHost);
   
   curl_easy_setopt(curl, CURLOPT_VERBOSE, (long)curl_verbose);
   curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curlToMemCallback);
-  snprintf(agentStr,MAXLEN,"User-Agent: FITSIO/HEASARC/%-8.3f",ffvers(&version)); 
+  snprintf(agentStr,MAXLEN,"FITSIO/HEASARC/%-8.3f",ffvers(&version)); 
   curl_easy_setopt(curl, CURLOPT_USERAGENT,agentStr);
   
   buffer->memory = 0; /* malloc/realloc will grow this in the callback function */
   buffer->size = 0;
   curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)buffer);
   curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curlErrBuf);
   curlErrBuf[0]=0;
@@ -3353,15 +3411,15 @@
 {
 
 /* Small helper functions to set the netoutfile static string */
 /* Called by cfileio after parsing the output file off of the input file url */
 
   char newinfile[MAXLEN];
   FILE *httpfile=0;
-  char contentencoding[MAXLEN];
+  char contentencoding[MAXLEN], contenttype[MAXLEN];
   int contentlength;
   int foundfile = 0;
   int status=0;
 
   /* set defaults  */
   strcpy(urltype,"http://");
 
@@ -3407,16 +3465,16 @@
     if (strlen(infile) + 3 > MAXLEN-1)
     {
        return URL_PARSE_ERROR;
     }  
     strcpy(newinfile,infile);
     strcat(newinfile,".gz");
 
-    status = http_open_network(newinfile,&httpfile,contentencoding,
-			   &contentlength);
+    status = http_open_network(newinfile,&httpfile, contentencoding,
+			       contenttype, &contentlength);
     if (!status) {
       if (!strcmp(contentencoding, "ftp://")) {
           /* this is a signal from http_open_network that indicates that */
           /* the http server returned a 301 or 302 redirect to a FTP URL. */
           /* Check that the file exists, because redirect many not be reliable */
 	   
           if (ftp_file_exist(newinfile)>0) { 
@@ -3481,16 +3539,16 @@
     
     if (strlen(infile+2) > MAXLEN-1)
     {
        return URL_PARSE_ERROR;
     }  
     strcpy(newinfile,infile);
     strcat(newinfile,".Z");
-    if (!http_open_network(newinfile,&httpfile,contentencoding,
-			   &contentlength)) {
+    if (!http_open_network(newinfile,&httpfile, contentencoding,
+			   contenttype, &contentlength)) {
 
       if (!strcmp(contentencoding, "ftp://")) {
           /* this is a signal from http_open_network that indicates that */
           /* the http server returned a 301 or 302 redirect to a FTP URL. */
           /* Check that the file exists, because redirect many not be reliable */
 	   
           if (ftp_file_exist(newinfile)>0) { 
@@ -3538,16 +3596,16 @@
     }
   }  /* end of case where infile does not contain .gz or .Z */
 
   if (!foundfile) {
     /* look for the base file.name */
       
     strcpy(newinfile,infile);
-    if (!http_open_network(newinfile,&httpfile,contentencoding,
-			   &contentlength)) {
+    if (!http_open_network(newinfile,&httpfile, contentencoding,
+			   contenttype, &contentlength)) {
 
       if (!strcmp(contentencoding, "ftp://")) {
           /* this is a signal from http_open_network that indicates that */
           /* the http server returned a 301 or 302 redirect to a FTP URL. */
           /* Check that the file exists, because redirect many not be reliable */
 	   
           if (ftp_file_exist(newinfile)>0) {
```

#### html2text {}

```diff
@@ -99,16 +99,16 @@
 [NMAXFILES]; /* allocate diskfile handle tables */ /* static prototypes */
 static int NET_TcpConnect(char *hostname, int port); static int NET_SendRaw(int
 sock, const void *buf, int length, int opt); static int NET_RecvRaw(int sock,
 void *buffer, int length); static int NET_ParseUrl(const char *url, char
 *proto, char *host, int *port, char *fn); static int CreateSocketAddress(struct
 sockaddr_in *sockaddrPtr, char *host,int port); static int ftp_status(FILE
 *ftp, char *statusstr); static int http_open_network(char *url, FILE
-**httpfile, char *contentencoding, int *contentlength); static int
-https_open_network(char *filename, curlmembuf* buffer); static int
+**httpfile, char *contentencoding, char *contenttype, int *contentlength);
+static int https_open_network(char *filename, curlmembuf* buffer); static int
 ftp_open_network(char *url, FILE **ftpfile, FILE **command, int *sock); static
 int ftps_open_network(char *filename, curlmembuf* buffer); static int
 ftp_file_exist(char *url); static int root_send_buffer(int sock, int op, char
 *buffer, int buflen); static int root_recv_buffer(int sock, int *op, char
 *buffer,int buflen); static int root_openfile(char *filename, char *rwmode, int
 *sock); static int encode64(unsigned s_len, char *src, unsigned d_len, char
 *dst); static int ssl_get_with_curl(char *url, curlmembuf* buffer, char*
@@ -120,75 +120,83 @@
 static int closefile; static int closeoutfile; static int closecommandfile;
 static int closeftpfile; static FILE *diskfile; static FILE *outfile; static
 int curl_verbose=0; static int show_fits_download_progress=0; static unsigned
 int net_timeout = 360; /* in seconds */ /*-------------------------------------
 -------------------------------------*/ /* This creates a memory file handle
 with a copy of the URL in filename. The file is uncompressed if necessary */
 int http_open(char *filename, int rwmode, int *handle) { FILE *httpfile; char
-contentencoding[SHORTLEN]; char errorstr[MAXLEN]; char recbuf[MAXLEN]; long
-len; int contentlength; int status; char firstchar; closehttpfile = 0;
-closememfile = 0; /* don't do r/w files */ if (rwmode != 0) { ffpmsg("Can't
-open http:// type file with READWRITE access"); ffpmsg(" Specify an outfile for
-r/w access (http_open)"); goto error; } /* do the signal handler bits */ if
-(setjmp(env) != 0) { /* feels like the second time */ /* this means something
-bad happened */ ffpmsg("Timeout (http_open)"); snprintf(errorstr, MAXLEN,
-"Download timeout exceeded: %d seconds",net_timeout); ffpmsg(errorstr); ffpmsg
-(" (multiplied x10 for files requiring uncompression)"); ffpmsg(" Timeout may
-be adjusted with fits_set_timeout"); goto error; } (void) signal(SIGALRM,
-signal_handler); /* Open the network connection */ if (http_open_network
-(filename,&httpfile,contentencoding, &contentlength)) { alarm(0); ffpmsg
-("Unable to open http file (http_open):"); ffpmsg(filename); goto error; }
-closehttpfile++; /* Create the memory file */ if ((status = mem_create
-(filename,handle))) { ffpmsg("Unable to create memory file (http_open)"); goto
-error; } closememfile++; /* Now, what do we do with the file */ /* Check to see
-what the first character is */ firstchar = fgetc(httpfile); ungetc
-(firstchar,httpfile); if (!strcmp(contentencoding,"x-gzip") || !strcmp
-(contentencoding,"x-compress") || strstr(filename,".gz") || strstr
-(filename,".Z") || ('\037' == firstchar)) { /* do the compress dance, which is
-the same as the gzip dance */ /* Using the cfitsio routine */ status = 0; /
-* Ok, this is a tough case, let's be arbritary and say 10*net_timeout, Given
-the choices for nettimeout above they'll probaby ^C before, but it's always
-worth a shot*/ alarm(net_timeout*10); status = mem_uncompress2mem(filename,
-httpfile, *handle); alarm(0); if (status) { ffpmsg("Error writing compressed
-memory file (http_open)"); ffpmsg(filename); goto error; } } else { /* It's not
-compressed, bad choice, but we'll copy it anyway */ if (contentlength % 2880)
-{ snprintf(errorstr,MAXLEN,"Content-Length not a multiple of 2880 (http_open)
-%d", contentlength); ffpmsg(errorstr); } /* write a memory file */ alarm
+contentencoding[SHORTLEN], contenttype[SHORTLEN]; char errorstr[MAXLEN]; char
+recbuf[MAXLEN]; long len; int contentlength; int status; char firstchar;
+closehttpfile = 0; closememfile = 0; /* don't do r/w files */ if (rwmode != 0)
+{ ffpmsg("Can't open http:// type file with READWRITE access"); ffpmsg("
+Specify an outfile for r/w access (http_open)"); goto error; } /* do the signal
+handler bits */ if (setjmp(env) != 0) { /* feels like the second time */ /
+* this means something bad happened */ ffpmsg("Timeout (http_open)"); snprintf
+(errorstr, MAXLEN, "Download timeout exceeded: %d seconds",net_timeout); ffpmsg
+(errorstr); ffpmsg(" (multiplied x10 for files requiring uncompression)");
+ffpmsg(" Timeout may be adjusted with fits_set_timeout"); goto error; } (void)
+signal(SIGALRM, signal_handler); /* Open the network connection */ if
+(http_open_network(filename,&httpfile, contentencoding, contenttype,
+&contentlength)) { alarm(0); ffpmsg("Unable to open http file (http_open):");
+ffpmsg(filename); goto error; } closehttpfile++; /* Create the memory file */
+if ((status = mem_create(filename,handle))) { ffpmsg("Unable to create memory
+file (http_open)"); goto error; } closememfile++; /* Now, what do we do with
+the file */ /* Check to see what the first character is */ firstchar = fgetc
+(httpfile); ungetc(firstchar,httpfile); if (!strcmp(contentencoding,"x-gzip")
+|| !strcmp(contentencoding,"x-compress") || !strcmp(contenttype, "application/
+x-gzip") || !strcmp(contenttype, "application/gzip") || !strcmp(contenttype,
+"application/gzip-compressed") || !strcmp(contenttype, "application/gzipped")
+|| !strcmp(contenttype, "application/x-compress") || !strcmp(contenttype,
+"application/x-compressed") || strstr(filename,".gz") || strstr(filename,".Z")
+|| ('\037' == firstchar)) { /* do the compress dance, which is the same as the
+gzip dance */ /* Using the cfitsio routine */ status = 0; /* Ok, this is a
+tough case, let's be arbritary and say 10*net_timeout, Given the choices for
+nettimeout above they'll probaby ^C before, but it's always worth a shot*/
+alarm(net_timeout*10); status = mem_uncompress2mem(filename, httpfile,
+*handle); alarm(0); if (status) { ffpmsg("Error writing compressed memory file
+(http_open)"); ffpmsg(filename); goto error; } } else { /* It's not compressed,
+bad choice, but we'll copy it anyway */ if (contentlength % 2880) { snprintf
+(errorstr,MAXLEN,"Content-Length not a multiple of 2880 (http_open) %d",
+contentlength); ffpmsg(errorstr); } /* write a memory file */ alarm
 (net_timeout); while(0 != (len = fread(recbuf,1,MAXLEN,httpfile))) { alarm(0);
 /* cancel alarm */ status = mem_write(*handle,recbuf,len); if (status) { ffpmsg
 ("Error copying http file into memory (http_open)"); ffpmsg(filename); goto
 error; } alarm(net_timeout); /* rearm the alarm */ } } fclose(httpfile); signal
 (SIGALRM, SIG_DFL); alarm(0); return mem_seek(*handle,0); error: alarm(0); /
 * clear it */ if (closehttpfile) { fclose(httpfile); } if (closememfile)
 { mem_close_free(*handle); } signal(SIGALRM, SIG_DFL); return
 (FILE_NOT_OPENED); } /*--------------------------------------------------------
 ------------------*/ /* This creates a memory file handle with a copy of the
 URL in filename. The file must be compressed and is copied (still compressed)
 to disk first. The compressed disk file is then uncompressed into memory
 (READONLY). */ int http_compress_open(char *url, int rwmode, int *handle)
-{ FILE *httpfile; char contentencoding[SHORTLEN]; char errorstr[MAXLEN]; char
-recbuf[MAXLEN]; long len; int contentlength; int ii, flen, status; char
-firstchar; closehttpfile = 0; closediskfile = 0; closefdiskfile = 0;
-closememfile = 0; flen = strlen(netoutfile); if (!flen) { /* cfileio made a
-mistake, should set the netoufile first otherwise we don't know where to write
-the output file */ ffpmsg ("Output file not set, shouldn't have happened
-(http_compress_open)"); goto error; } if (rwmode != 0) { ffpmsg("Can't open
-compressed http:// type file with READWRITE access"); ffpmsg(" Specify an
-UNCOMPRESSED outfile (http_compress_open)"); goto error; } /* do the signal
-handler bits */ if (setjmp(env) != 0) { /* feels like the second time */ /
-* this means something bad happened */ ffpmsg("Timeout (http_open)"); snprintf
+{ FILE *httpfile; char contentencoding[SHORTLEN], contenttype[SHORTLEN]; char
+errorstr[MAXLEN]; char recbuf[MAXLEN]; long len; int contentlength; int ii,
+flen, status; char firstchar; closehttpfile = 0; closediskfile = 0;
+closefdiskfile = 0; closememfile = 0; flen = strlen(netoutfile); if (!flen) { /
+* cfileio made a mistake, should set the netoufile first otherwise we don't
+know where to write the output file */ ffpmsg ("Output file not set, shouldn't
+have happened (http_compress_open)"); goto error; } if (rwmode != 0) { ffpmsg
+("Can't open compressed http:// type file with READWRITE access"); ffpmsg("
+Specify an UNCOMPRESSED outfile (http_compress_open)"); goto error; } /* do the
+signal handler bits */ if (setjmp(env) != 0) { /* feels like the second time */
+/* this means something bad happened */ ffpmsg("Timeout (http_open)"); snprintf
 (errorstr, MAXLEN, "Download timeout exceeded: %d seconds",net_timeout); ffpmsg
 (errorstr); ffpmsg(" Timeout may be adjusted with fits_set_timeout"); goto
 error; } signal(SIGALRM, signal_handler); /* Open the http connectin */ alarm
-(net_timeout); if ((status = http_open_network(url,&httpfile,contentencoding,
-&contentlength))) { alarm(0); ffpmsg("Unable to open http file
+(net_timeout); if ((status = http_open_network(url,&httpfile, contentencoding,
+contenttype, &contentlength))) { alarm(0); ffpmsg("Unable to open http file
 (http_compress_open)"); ffpmsg(url); goto error; } closehttpfile++; /* Better
 be compressed */ firstchar = fgetc(httpfile); ungetc(firstchar,httpfile); if
 (!strcmp(contentencoding,"x-gzip") || !strcmp(contentencoding,"x-compress") ||
-('\037' == firstchar)) { if (*netoutfile == '!') { /* user wants to clobber
+!strcmp(contenttype, "application/x-gzip") || !strcmp(contenttype,
+"application/gzip") || !strcmp(contenttype, "application/gzip-compressed") ||
+!strcmp(contenttype, "application/gzipped") || !strcmp(contenttype,
+"application/x-compress") || !strcmp(contenttype, "application/x-compressed")
+|| ('\037' == firstchar)) { if (*netoutfile == '!') { /* user wants to clobber
 file, if it already exists */ for (ii = 0; ii < flen; ii++) netoutfile[ii] =
 netoutfile[ii + 1]; /* remove '!' */ status = file_remove(netoutfile); } /
 * Create the new file */ if ((status = file_create(netoutfile,handle)))
 { ffpmsg("Unable to create output disk file (http_compress_open):"); ffpmsg
 (netoutfile); goto error; } closediskfile++; /* write a file */ alarm
 (net_timeout); while(0 != (len = fread(recbuf,1,MAXLEN,httpfile))) { alarm(0);
 status = file_write(*handle,recbuf,len); if (status) { ffpmsg("Error writing
@@ -209,52 +217,56 @@
 (closehttpfile) { fclose(httpfile); } if (closefdiskfile) { fclose(diskfile); }
 if (closememfile) { mem_close_free(*handle); } if (closediskfile) { file_close
 (*handle); } signal(SIGALRM, SIG_DFL); return (FILE_NOT_OPENED); } /*----------
 ----------------------------------------------------------------*/ /* This
 creates a file handle with a copy of the URL in filename. The http file is
 copied to disk first. If it's compressed then it is uncompressed when copying
 to the disk */ int http_file_open(char *url, int rwmode, int *handle) { FILE
-*httpfile; char contentencoding[SHORTLEN]; char errorstr[MAXLEN]; char recbuf
-[MAXLEN]; long len; int contentlength; int ii, flen, status; char firstchar; /
-* Check if output file is actually a memory file */ if (!strncmp(netoutfile,
-"mem:", 4) ) { /* allow the memory file to be opened with write access */
-return( http_open(url, READONLY, handle) ); } closehttpfile = 0; closefile = 0;
-closeoutfile = 0; flen = strlen(netoutfile); if (!flen) { /* cfileio made a
-mistake, we need to know where to write the file */ ffpmsg("Output file not
-set, shouldn't have happened (http_file_open)"); return (FILE_NOT_OPENED); } /
-* do the signal handler bits */ if (setjmp(env) != 0) { /* feels like the
-second time */ /* this means something bad happened */ ffpmsg("Timeout
-(http_open)"); snprintf(errorstr, MAXLEN, "Download timeout exceeded: %d
-seconds",net_timeout); ffpmsg(errorstr); ffpmsg(" (multiplied x10 for files
+*httpfile; char contentencoding[SHORTLEN], contenttype[SHORTLEN]; char errorstr
+[MAXLEN]; char recbuf[MAXLEN]; long len; int contentlength; int ii, flen,
+status; char firstchar; /* Check if output file is actually a memory file */ if
+(!strncmp(netoutfile, "mem:", 4) ) { /* allow the memory file to be opened with
+write access */ return( http_open(url, READONLY, handle) ); } closehttpfile =
+0; closefile = 0; closeoutfile = 0; flen = strlen(netoutfile); if (!flen) { /
+* cfileio made a mistake, we need to know where to write the file */ ffpmsg
+("Output file not set, shouldn't have happened (http_file_open)"); return
+(FILE_NOT_OPENED); } /* do the signal handler bits */ if (setjmp(env) != 0) { /
+* feels like the second time */ /* this means something bad happened */ ffpmsg
+("Timeout (http_open)"); snprintf(errorstr, MAXLEN, "Download timeout exceeded:
+%d seconds",net_timeout); ffpmsg(errorstr); ffpmsg(" (multiplied x10 for files
 requiring uncompression)"); ffpmsg(" Timeout may be adjusted with
 fits_set_timeout"); goto error; } signal(SIGALRM, signal_handler); /* Open the
 network connection */ alarm(net_timeout); if ((status = http_open_network
-(url,&httpfile,contentencoding, &contentlength))) { alarm(0); ffpmsg("Unable to
-open http file (http_file_open)"); ffpmsg(url); goto error; } closehttpfile++;
-if (*netoutfile == '!') { /* user wants to clobber disk file, if it already
-exists */ for (ii = 0; ii < flen; ii++) netoutfile[ii] = netoutfile[ii + 1]; /
-* remove '!' */ status = file_remove(netoutfile); } firstchar = fgetc
-(httpfile); ungetc(firstchar,httpfile); if (!strcmp(contentencoding,"x-gzip")
-|| !strcmp(contentencoding,"x-compress") || ('\037' == firstchar)) { /* to make
-this more cfitsioish we use the file driver calls to create the disk file */ /
+(url,&httpfile, contentencoding, contenttype, &contentlength))) { alarm(0);
+ffpmsg("Unable to open http file (http_file_open)"); ffpmsg(url); goto error; }
+closehttpfile++; if (*netoutfile == '!') { /* user wants to clobber disk file,
+if it already exists */ for (ii = 0; ii < flen; ii++) netoutfile[ii] =
+netoutfile[ii + 1]; /* remove '!' */ status = file_remove(netoutfile); }
+firstchar = fgetc(httpfile); ungetc(firstchar,httpfile); if (!strcmp
+(contentencoding,"x-gzip") || !strcmp(contentencoding,"x-compress") || !strcmp
+(contenttype, "application/x-gzip") || !strcmp(contenttype, "application/gzip")
+|| !strcmp(contenttype, "application/gzip-compressed") || !strcmp(contenttype,
+"application/gzipped") || !strcmp(contenttype, "application/x-compress") ||
+!strcmp(contenttype, "application/x-compressed") || ('\037' == firstchar)) { /
+* to make this more cfitsioish we use the file driver calls to create the disk
+file */ /* Create the output file */ if ((status = file_create
+(netoutfile,handle))) { ffpmsg("Unable to create output file
+(http_file_open)"); ffpmsg(netoutfile); goto error; } file_close(*handle); if
+(NULL == (outfile = fopen(netoutfile,"w"))) { ffpmsg("Unable to reopen the
+output file (http_file_open)"); ffpmsg(netoutfile); goto error; }
+closeoutfile++; status = 0; /* Ok, this is a tough case, let's be arbritary and
+say 10*net_timeout, Given the choices for nettimeout above they'll probaby ^C
+before, but it's always worth a shot*/ alarm(net_timeout*10); status =
+uncompress2file(url,httpfile,outfile,&status); alarm(0); if (status) { ffpmsg
+("Error uncompressing http file to disk file (http_file_open)"); ffpmsg(url);
+ffpmsg(netoutfile); goto error; } fclose(outfile); closeoutfile--; } else { /
 * Create the output file */ if ((status = file_create(netoutfile,handle)))
 { ffpmsg("Unable to create output file (http_file_open)"); ffpmsg(netoutfile);
-goto error; } file_close(*handle); if (NULL == (outfile = fopen
-(netoutfile,"w"))) { ffpmsg("Unable to reopen the output file
-(http_file_open)"); ffpmsg(netoutfile); goto error; } closeoutfile++; status =
-0; /* Ok, this is a tough case, let's be arbritary and say 10*net_timeout,
-Given the choices for nettimeout above they'll probaby ^C before, but it's
-always worth a shot*/ alarm(net_timeout*10); status = uncompress2file
-(url,httpfile,outfile,&status); alarm(0); if (status) { ffpmsg("Error
-uncompressing http file to disk file (http_file_open)"); ffpmsg(url); ffpmsg
-(netoutfile); goto error; } fclose(outfile); closeoutfile--; } else { /* Create
-the output file */ if ((status = file_create(netoutfile,handle))) { ffpmsg
-("Unable to create output file (http_file_open)"); ffpmsg(netoutfile); goto
-error; } /* Give a warning message. This could just be bad padding at the end
-so don't treat it like an error. */ closefile++; if (contentlength % 2880)
+goto error; } /* Give a warning message. This could just be bad padding at the
+end so don't treat it like an error. */ closefile++; if (contentlength % 2880)
 { snprintf(errorstr, MAXLEN, "Content-Length not a multiple of 2880
 (http_file_open) %d", contentlength); ffpmsg(errorstr); } /* write a file */
 alarm(net_timeout); while(0 != (len = fread(recbuf,1,MAXLEN,httpfile))) { alarm
 (0); status = file_write(*handle,recbuf,len); if (status) { ffpmsg("Error
 copying http file to disk file (http_file_open)"); ffpmsg(url); ffpmsg
 (netoutfile); goto error; } } file_close(*handle); closefile--; } fclose
 (httpfile); closehttpfile--; signal(SIGALRM, SIG_DFL); alarm(0); return
@@ -263,28 +275,28 @@
 (closefile) { file_close(*handle); } signal(SIGALRM, SIG_DFL); return
 (FILE_NOT_OPENED); } /*--------------------------------------------------------
 ------------------*/ /* This is the guts of the code to get a file via http.
 url is the input url httpfile is set to be the file connected to the socket
 which you can read the file from contentencoding is the mime type of the file,
 returned if the http server returns it contentlength is the length of the file,
 returned if the http server returns it */ static int http_open_network(char
-*url, FILE **httpfile, char *contentencoding, int *contentlength) { int status;
-int sock; int tmpint; char recbuf[MAXLEN]; char tmpstr[MAXLEN]; char tmpstr1
-[SHORTLEN]; char tmpstr2[MAXLEN]; char errorstr[MAXLEN]; char proto[SHORTLEN];
-char host[SHORTLEN]; char userpass[MAXLEN]; char fn[MAXLEN]; char turl[MAXLEN];
-char *scratchstr; char *scratchstr2; char *saveptr; int port; float version;
-char pproto[SHORTLEN]; char phost[SHORTLEN]; /* address of the proxy server */
-int pport; /* port number of the proxy server */ char pfn[MAXLEN]; char *proxy;
-/* URL of the proxy server */ /* Parse the URL apart again */ strcpy
-(turl,"http://"); strncat(turl,url,MAXLEN - 8); if (NET_ParseUrl
-(turl,proto,host,&port,fn)) { snprintf(errorstr,MAXLEN,"URL Parse Error
-(http_open) %s",url); ffpmsg(errorstr); return (FILE_NOT_OPENED); } /* Do we
-have a user:password combo ? */ strcpy(userpass, url); if ((scratchstr = strchr
-(userpass, '@')) != NULL) { *scratchstr = '\0'; } else { strcpy(userpass, "");
-} /* Ph. Prugniel 2003/04/03 Are we using a proxy? We use a proxy if the
+*url, FILE **httpfile, char *contentencoding, char *contenttype, int
+*contentlength) { int status; int sock; int tmpint; char recbuf[MAXLEN]; char
+tmpstr[MAXLEN]; char tmpstr1[SHORTLEN]; char tmpstr2[MAXLEN]; char errorstr
+[MAXLEN]; char proto[SHORTLEN]; char host[SHORTLEN]; char userpass[MAXLEN];
+char fn[MAXLEN]; char turl[MAXLEN]; char *scratchstr; char *scratchstr2; char
+*saveptr; int port; float version; char pproto[SHORTLEN]; char phost[SHORTLEN];
+/* address of the proxy server */ int pport; /* port number of the proxy server
+*/ char pfn[MAXLEN]; char *proxy; /* URL of the proxy server */ /* Parse the
+URL apart again */ strcpy(turl,"http://"); strncat(turl,url,MAXLEN - 8); if
+(NET_ParseUrl(turl,proto,host,&port,fn)) { snprintf(errorstr,MAXLEN,"URL Parse
+Error (http_open) %s",url); ffpmsg(errorstr); return (FILE_NOT_OPENED); } /* Do
+we have a user:password combo ? */ strcpy(userpass, url); if ((scratchstr =
+strchr(userpass, '@')) != NULL) { *scratchstr = '\0'; } else { strcpy(userpass,
+""); } /* Ph. Prugniel 2003/04/03 Are we using a proxy? We use a proxy if the
 environment variable "http_proxy" is set to an address, eg. http://
 wwwcache.nottingham.ac.uk:3128 ("http_proxy" is also used by wget) */ proxy =
 getenv("http_proxy"); /* Connect to the remote host */ if (proxy) { if
 (NET_ParseUrl(proxy,pproto,phost,&pport,pfn)) { snprintf(errorstr,MAXLEN,"URL
 Parse Error (http_open) %s",proxy); ffpmsg(errorstr); return (FILE_NOT_OPENED);
 } sock = NET_TcpConnect(phost,pport); } else { sock = NET_TcpConnect
 (host,port); } if (sock < 0) { if (proxy) { ffpmsg("Couldn't connect to host
@@ -309,34 +321,34 @@
 snprintf(tmpstr1,SHORTLEN,"Host: %s:%-d\r\n\r\n",host,port); if (strlen(tmpstr)
 + strlen(tmpstr1) > MAXLEN - 1) { fclose(*httpfile); *httpfile=0; return
 (FILE_NOT_OPENED); } strcat(tmpstr,tmpstr1); status = NET_SendRaw
 (sock,tmpstr,strlen(tmpstr),NET_DEFAULT); /* read the header */ if (!(fgets
 (recbuf,MAXLEN,*httpfile))) { snprintf (errorstr,MAXLEN,"http header short
 (http_open_network) %s",recbuf); ffpmsg(errorstr); fclose(*httpfile);
 *httpfile=0; return (FILE_NOT_OPENED); } *contentlength = 0; contentencoding[0]
-= '\0'; /* Our choices are 200, ok, 302, temporary redirect, or 301 perm
-redirect */ sscanf(recbuf,"%s %d",tmpstr,&status); if (status != 200){ if
-(status == 301 || status == 302) { /* got a redirect */ /* if (status == 302)
-{ ffpmsg("Note: Web server replied with a temporary redirect from"); } else
-{ ffpmsg("Note: Web server replied with a redirect from"); } ffpmsg(turl); */ /
-* now, let's not write the most sophisticated parser here */ while (fgets
-(recbuf,MAXLEN,*httpfile)) { scratchstr = strstr(recbuf,"Location: "); if
-(scratchstr != NULL) { /* Ok, we found the Location line which gives the
-redirected URL */ /* skip the "Location: " charactrers */ scratchstr += 10; /
-* strip off any end-of-line characters */ tmpint = strlen(scratchstr); if
-(scratchstr[tmpint-1] == '\r') scratchstr[tmpint-1] = '\0'; tmpint = strlen
-(scratchstr); if (scratchstr[tmpint-1] == '\n') scratchstr[tmpint-1] = '\0';
-tmpint = strlen(scratchstr); if (scratchstr[tmpint-1] == '\r') scratchstr
-[tmpint-1] = '\0'; /* ffpmsg("to:"); ffpmsg(scratchstr); ffpmsg(" "); */
-scratchstr2 = strstr(scratchstr,"http://"); if (scratchstr2 != NULL) { /* Ok,
-we found the HTTP redirection is to another HTTP URL. */ /* We can handle this
-case directly, here */ /* skip the "http://" characters */ scratchstr2 += 7;
-strcpy(turl, scratchstr2); fclose (*httpfile); *httpfile=0; /* note the
-recursive call to itself */ return http_open_network
-(turl,httpfile,contentencoding,contentlength); } /* It was not a HTTP to HTTP
+= '\0'; contenttype[0] = '\0'; /* Our choices are 200, ok, 302, temporary
+redirect, or 301 perm redirect */ sscanf(recbuf,"%s %d",tmpstr,&status); if
+(status != 200){ if (status == 301 || status == 302) { /* got a redirect */ /
+* if (status == 302) { ffpmsg("Note: Web server replied with a temporary
+redirect from"); } else { ffpmsg("Note: Web server replied with a redirect
+from"); } ffpmsg(turl); */ /* now, let's not write the most sophisticated
+parser here */ while (fgets(recbuf,MAXLEN,*httpfile)) { scratchstr = strstr
+(recbuf,"Location: "); if (scratchstr != NULL) { /* Ok, we found the Location
+line which gives the redirected URL */ /* skip the "Location: " charactrers */
+scratchstr += 10; /* strip off any end-of-line characters */ tmpint = strlen
+(scratchstr); if (scratchstr[tmpint-1] == '\r') scratchstr[tmpint-1] = '\0';
+tmpint = strlen(scratchstr); if (scratchstr[tmpint-1] == '\n') scratchstr
+[tmpint-1] = '\0'; tmpint = strlen(scratchstr); if (scratchstr[tmpint-1] ==
+'\r') scratchstr[tmpint-1] = '\0'; /* ffpmsg("to:"); ffpmsg(scratchstr); ffpmsg
+(" "); */ scratchstr2 = strstr(scratchstr,"http://"); if (scratchstr2 != NULL)
+{ /* Ok, we found the HTTP redirection is to another HTTP URL. */ /* We can
+handle this case directly, here */ /* skip the "http://" characters */
+scratchstr2 += 7; strcpy(turl, scratchstr2); fclose (*httpfile); *httpfile=0; /
+* note the recursive call to itself */ return http_open_network(turl,httpfile,
+contentencoding, contenttype, contentlength); } /* It was not a HTTP to HTTP
 redirection, so see if it HTTP to FTP */ scratchstr2 = strstr(scratchstr,"ftp:/
 /"); if (scratchstr2 != NULL) { /* Ok, we found the HTTP redirection is to a
 FTP URL. */ /* skip the "ftp://" characters */ scratchstr2 += 6; /* return the
 new URL string, and set contentencoding to "ftp" as a flag to the
 http_checkfile routine */ if (strlen(scratchstr2) > FLEN_FILENAME-1) { ffpmsg
 ("Error: redirected url string too long (http_open_network)"); fclose
 (*httpfile); *httpfile=0; return URL_PARSE_ERROR; } strcpy(url, scratchstr2);
@@ -359,62 +371,75 @@
 * Did we get a content-length header ? */ if (!strcmp(tmpstr,"Content-Length:
 ")) { *contentlength = tmpint; } /* Did we get the content-encoding header ? */
 if (!strcmp(tmpstr,"Content-Encoding:")) { if (NULL != (scratchstr = strstr
 (recbuf,":"))) { /* Found the : */ scratchstr++; /* skip the : */ scratchstr++;
 /* skip the extra space */ if (strlen(scratchstr) > SHORTLEN-1) { ffpmsg
 ("Error: content-encoding string too long (http_open_network)"); fclose
 (*httpfile); *httpfile=0; return URL_PARSE_ERROR; } strcpy
-(contentencoding,scratchstr); } } } /* we're done, so return */ return 0; } /*-
--------------------------------------------------------------------------*/ /
-* This creates a memory file handle with a copy of the URL in filename. The
-curl library called from https_open_network will perform file uncompression if
-necessary. */ int https_open(char *filename, int rwmode, int *handle)
-{ curlmembuf inmem; char errStr[MAXLEN]; int status=0; /* don't do r/w files */
-if (rwmode != 0) { ffpmsg("Can't open https:// type file with READWRITE
-access"); ffpmsg(" Specify an outfile for r/w access (https_open)"); return
-(FILE_NOT_OPENED); } inmem.memory=0; inmem.size=0; if (setjmp(env) != 0)
-{ alarm(0); signal(SIGALRM, SIG_DFL); ffpmsg("Timeout (https_open)"); snprintf
-(errStr, MAXLEN, "Download timeout exceeded: %d seconds",net_timeout); ffpmsg
-(errStr); ffpmsg(" Timeout may be adjusted with fits_set_timeout"); free
-(inmem.memory); return (FILE_NOT_OPENED); } signal(SIGALRM, signal_handler);
-alarm(net_timeout); if (https_open_network(filename, &inmem)) { alarm(0);
-signal(SIGALRM, SIG_DFL); ffpmsg("Unable to read https file into memory
-(https_open)"); free(inmem.memory); return (FILE_NOT_OPENED); } alarm(0);
-signal(SIGALRM, SIG_DFL); /* We now have the file transfered from the https
-server into the inmem.memory buffer. Now transfer that into a FITS memory file.
-*/ if ((status = mem_create(filename, handle))) { ffpmsg("Unable to create
-memory file (https_open)"); free(inmem.memory); return (FILE_NOT_OPENED); } if
-(inmem.size % 2880) { snprintf(errStr,MAXLEN,"Content-Length not a multiple of
-2880 (https_open) %u", inmem.size); ffpmsg(errStr); } status = mem_write
-(*handle, inmem.memory, inmem.size); if (status) { ffpmsg("Error copying https
-file into memory (https_open)"); ffpmsg(filename); free(inmem.memory);
-mem_close_free(*handle); return (FILE_NOT_OPENED); } free(inmem.memory); return
-mem_seek(*handle, 0); } /*-----------------------------------------------------
----------------------*/ int https_file_open(char *filename, int rwmode, int
-*handle) { int ii, flen; char errStr[MAXLEN]; curlmembuf inmem; /* Check if
-output file is actually a memory file */ if (!strncmp(netoutfile, "mem:", 4) )
-{ /* allow the memory file to be opened with write access */ return( https_open
-(filename, READONLY, handle) ); } flen = strlen(netoutfile); if (!flen) { /
-* cfileio made a mistake, we need to know where to write the file */ ffpmsg
-("Output file not set, shouldn't have happened (https_file_open)"); return
-(FILE_NOT_OPENED); } inmem.memory=0; inmem.size=0; if (setjmp(env) != 0)
-{ alarm(0); signal(SIGALRM, SIG_DFL); ffpmsg("Timeout (https_file_open)");
-snprintf(errStr, MAXLEN, "Download timeout exceeded: %d seconds",net_timeout);
-ffpmsg(errStr); ffpmsg(" Timeout may be adjusted with fits_set_timeout"); free
-(inmem.memory); return (FILE_NOT_OPENED); } signal(SIGALRM, signal_handler);
-alarm(net_timeout); if (https_open_network(filename, &inmem)) { alarm(0);
-signal(SIGALRM, SIG_DFL); ffpmsg("Unable to read https file into memory
-(https_file_open)"); free(inmem.memory); return (FILE_NOT_OPENED); } alarm(0);
-signal(SIGALRM, SIG_DFL); if (*netoutfile == '!') { /* user wants to clobber
-disk file, if it already exists */ for (ii = 0; ii < flen; ii++) netoutfile[ii]
-= netoutfile[ii + 1]; /* remove '!' */ file_remove(netoutfile); } /* Create the
-output file */ if (file_create(netoutfile,handle)) { ffpmsg("Unable to create
-output file (https_file_open)"); ffpmsg(netoutfile); free(inmem.memory); return
+(contentencoding,scratchstr); } } /* Did we get the content-type header ? */ if
+(!strcmp(tmpstr,"Content-Type:")) { if (NULL != (scratchstr = strstr(recbuf,":
+"))) { /* Found the : */ scratchstr++; /* skip the : */ scratchstr++; /* skip
+the extra space */ if (strlen(scratchstr) > SHORTLEN-1) { ffpmsg("Error:
+content-type string too long (http_open_network)"); fclose(*httpfile);
+*httpfile=0; return URL_PARSE_ERROR; } strcpy(contenttype,scratchstr); } } } /
+* we're done, so return */ return 0; } /*--------------------------------------
+------------------------------------*/ /* This creates a memory file handle
+with a copy of the URL in filename. The curl library called from
+https_open_network will perform file uncompression if necessary. */ int
+https_open(char *filename, int rwmode, int *handle) { curlmembuf inmem; char
+errStr[MAXLEN]; int status=0; /* don't do r/w files */ if (rwmode != 0)
+{ ffpmsg("Can't open https:// type file with READWRITE access"); ffpmsg("
+Specify an outfile for r/w access (https_open)"); return (FILE_NOT_OPENED); }
+inmem.memory=0; inmem.size=0; if (setjmp(env) != 0) { alarm(0); signal(SIGALRM,
+SIG_DFL); ffpmsg("Timeout (https_open)"); snprintf(errStr, MAXLEN, "Download
+timeout exceeded: %d seconds",net_timeout); ffpmsg(errStr); ffpmsg(" Timeout
+may be adjusted with fits_set_timeout"); free(inmem.memory); return
+(FILE_NOT_OPENED); } signal(SIGALRM, signal_handler); alarm(net_timeout); if
+(https_open_network(filename, &inmem)) { alarm(0); signal(SIGALRM, SIG_DFL);
+ffpmsg("Unable to read https file into memory (https_open)"); free
+(inmem.memory); return (FILE_NOT_OPENED); } alarm(0); signal(SIGALRM, SIG_DFL);
+/* We now have the file transfered from the https server into the inmem.memory
+buffer. Now transfer that into a FITS memory file. */ if ((status = mem_create
+(filename, handle))) { ffpmsg("Unable to create memory file (https_open)");
+free(inmem.memory); return (FILE_NOT_OPENED); } /* Check for gzip magic number
+*/ if (inmem.size >= 2 && (unsigned char) inmem.memory[0] == 0x1f && (unsigned
+char) inmem.memory[1] == 0x8b) { LONGLONG fitsfilesize = 0; /* Uncompress from
+memory to memfile */ status = mem_zuncompress_and_write(*handle, inmem.memory,
+inmem.size); mem_size(*handle, &fitsfilesize); if ((fitsfilesize > 0) &&
+(fitsfilesize % 2880)) { snprintf(errStr,MAXLEN,"Uncompressed file length not a
+multiple of 2880 (https_open) %lld", fitsfilesize); ffpmsg(errStr); } } else
+{ if (inmem.size % 2880) { snprintf(errStr,MAXLEN,"Content-Length not a
+multiple of 2880 (https_open) %zu", inmem.size); ffpmsg(errStr); } /* Straight
+copy of data */ status = mem_write(*handle, inmem.memory, inmem.size); } if
+(status) { ffpmsg("Error copying https file into memory (https_open)"); ffpmsg
+(filename); free(inmem.memory); mem_close_free(*handle); return
+(FILE_NOT_OPENED); } free(inmem.memory); return mem_seek(*handle, 0); } /*-----
+---------------------------------------------------------------------*/ int
+https_file_open(char *filename, int rwmode, int *handle) { int ii, flen; char
+errStr[MAXLEN]; curlmembuf inmem; /* Check if output file is actually a memory
+file */ if (!strncmp(netoutfile, "mem:", 4) ) { /* allow the memory file to be
+opened with write access */ return( https_open(filename, READONLY, handle) ); }
+flen = strlen(netoutfile); if (!flen) { /* cfileio made a mistake, we need to
+know where to write the file */ ffpmsg("Output file not set, shouldn't have
+happened (https_file_open)"); return (FILE_NOT_OPENED); } inmem.memory=0;
+inmem.size=0; if (setjmp(env) != 0) { alarm(0); signal(SIGALRM, SIG_DFL);
+ffpmsg("Timeout (https_file_open)"); snprintf(errStr, MAXLEN, "Download timeout
+exceeded: %d seconds",net_timeout); ffpmsg(errStr); ffpmsg(" Timeout may be
+adjusted with fits_set_timeout"); free(inmem.memory); return (FILE_NOT_OPENED);
+} signal(SIGALRM, signal_handler); alarm(net_timeout); if (https_open_network
+(filename, &inmem)) { alarm(0); signal(SIGALRM, SIG_DFL); ffpmsg("Unable to
+read https file into memory (https_file_open)"); free(inmem.memory); return
+(FILE_NOT_OPENED); } alarm(0); signal(SIGALRM, SIG_DFL); if (*netoutfile ==
+'!') { /* user wants to clobber disk file, if it already exists */ for (ii = 0;
+ii < flen; ii++) netoutfile[ii] = netoutfile[ii + 1]; /* remove '!' */
+file_remove(netoutfile); } /* Create the output file */ if (file_create
+(netoutfile,handle)) { ffpmsg("Unable to create output file
+(https_file_open)"); ffpmsg(netoutfile); free(inmem.memory); return
 (FILE_NOT_OPENED); } if (inmem.size % 2880) { snprintf(errStr, MAXLEN,
-"Content-Length not a multiple of 2880 (https_file_open) %d", inmem.size);
+"Content-Length not a multiple of 2880 (https_file_open) %zu", inmem.size);
 ffpmsg(errStr); } if (file_write(*handle, inmem.memory, inmem.size)) { ffpmsg
 ("Error copying https file to disk file (https_file_open)"); ffpmsg(filename);
 ffpmsg(netoutfile); free(inmem.memory); file_close(*handle); return
 (FILE_NOT_OPENED); } free(inmem.memory); file_close(*handle); return file_open
 (netoutfile, rwmode, handle); } /*---------------------------------------------
 -----------------------------*/ /* Callback function curl library uses during
 https connection to transfer server file into memory */ size_t
@@ -482,15 +507,15 @@
 (inmem.memory, inmem.size, "r"); #endif if (!compressedFile) { ffpmsg("Error
 creating file in memory (ftps_open)"); free(inmem.memory); return
 (FILE_NOT_OPENED); } if(mem_uncompress2mem
 (localFilename,compressedFile,*handle)) { ffpmsg("Error writing compressed
 memory file (ftps_open)"); ffpmsg(filename); fclose(compressedFile); free
 (inmem.memory); return(FILE_NOT_OPENED); } fclose(compressedFile); } else { if
 (inmem.size % 2880) { snprintf(errStr,MAXLEN,"Content-Length not a multiple of
-2880 (ftps_open) %u", inmem.size); ffpmsg(errStr); } status = mem_write
+2880 (ftps_open) %zu", inmem.size); ffpmsg(errStr); } status = mem_write
 (*handle, inmem.memory, inmem.size); if (status) { ffpmsg("Error copying https
 file into memory (ftps_open)"); ffpmsg(filename); free(inmem.memory);
 mem_close_free(*handle); return (FILE_NOT_OPENED); } } free(inmem.memory);
 return mem_seek(*handle, 0); } /*----------------------------------------------
 ----------------------------*/ int ftps_file_open(char *filename, int rwmode,
 int *handle) { int ii, flen, status=0; char errStr[MAXLEN]; char localFilename
 [MAXLEN]; /* may have .gz or .Z appended */ unsigned char
@@ -530,15 +555,15 @@
 (inmem.memory, inmem.size, "r"); #endif if (!compressedInFile) { ffpmsg("Error
 creating compressed file in memory (ftps_file_open)"); free(inmem.memory);
 fclose(outfile); return(FILE_NOT_OPENED); } if (uncompress2file(filename,
 compressedInFile, outfile, &status)) { ffpmsg("Unable to uncompress the output
 file (ftps_file_open)"); ffpmsg(filename); ffpmsg(netoutfile); fclose(outfile);
 fclose(compressedInFile); free(inmem.memory); return(FILE_NOT_OPENED); } fclose
 (outfile); fclose(compressedInFile); } else { if (inmem.size % 2880) { snprintf
-(errStr, MAXLEN, "Content-Length not a multiple of 2880 (ftps_file_open) %d",
+(errStr, MAXLEN, "Content-Length not a multiple of 2880 (ftps_file_open) %zu",
 inmem.size); ffpmsg(errStr); } if (file_write(*handle, inmem.memory,
 inmem.size)) { ffpmsg("Error copying ftps file to disk file (ftps_file_open)");
 ffpmsg(filename); ffpmsg(netoutfile); free(inmem.memory); file_close(*handle);
 return (FILE_NOT_OPENED); } file_close(*handle); } free(inmem.memory); return
 file_open(netoutfile, rwmode, handle); } /*------------------------------------
 --------------------------------------*/ int ftps_compress_open(char *filename,
 int rwmode, int *handle) { int ii, flen, status=0; char errStr[MAXLEN]; char
@@ -635,18 +660,18 @@
 point. It is not thread-safe to call it here. */ curl = curl_easy_init(); res =
 curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, verifyPeer); if (res !=
 CURLE_OK) { ffpmsg("ERROR: CFITSIO was built with a libcurl library that ");
 ffpmsg("does not have SSL support, and therefore can't perform https or ftps
 transfers."); return (FILE_NOT_OPENED); } curl_easy_setopt(curl,
 CURLOPT_SSL_VERIFYHOST, verifyHost); curl_easy_setopt(curl, CURLOPT_VERBOSE,
 (long)curl_verbose); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION,
-curlToMemCallback); snprintf(agentStr,MAXLEN,"User-Agent: FITSIO/HEASARC/%-
-8.3f",ffvers(&version)); curl_easy_setopt(curl, CURLOPT_USERAGENT,agentStr);
-buffer->memory = 0; /* malloc/realloc will grow this in the callback function
-*/ buffer->size = 0; curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)buffer);
+curlToMemCallback); snprintf(agentStr,MAXLEN,"FITSIO/HEASARC/%-8.3f",ffvers
+(&version)); curl_easy_setopt(curl, CURLOPT_USERAGENT,agentStr); buffer->memory
+= 0; /* malloc/realloc will grow this in the callback function */ buffer->size
+= 0; curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)buffer);
 curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curlErrBuf); curlErrBuf[0]=0; /
 * This is needed for easy_perform to return an error whenever http server
 returns an error >= 400, ie. if it can't find the requested file. */
 curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1L); /* This turns on automatic
 decompression for all recognized types. */ curl_easy_setopt(curl,
 CURLOPT_ENCODING, ""); /* tmpUrl should be large enough to accomodate original
 url + ".gz" */ tmpUrl = (char *)malloc(strlen(url)+4); strcpy(tmpUrl, url); if
@@ -1111,193 +1136,194 @@
 of the string, or have a / */ } /* Now the rest is a fn */ if (*urlcopy) { if
 (strlen(urlcopy) > MAXLEN-1) { free(urlcopyorig); return 1; } strcpy
 (fn,urlcopy); } free(urlcopyorig); return 0; } /*------------------------------
 --------------------------------------------*/ int http_checkfile (char
 *urltype, char *infile, char *outfile1) { /* Small helper functions to set the
 netoutfile static string */ /* Called by cfileio after parsing the output file
 off of the input file url */ char newinfile[MAXLEN]; FILE *httpfile=0; char
-contentencoding[MAXLEN]; int contentlength; int foundfile = 0; int status=0; /
-* set defaults */ strcpy(urltype,"http://"); if (strlen(outfile1)) { /* don't
-copy the "file://" prefix, if present. */ if (!strncmp(outfile1, "file://", 7)
-) { strcpy(netoutfile,outfile1+7); } else { strcpy(netoutfile,outfile1); } } if
-(strstr(infile, "?")) { /* Special case where infile name contains a "?". */ /
-* This is probably a CGI string; no point in testing if it exists */ /* so just
-set urltype and netoutfile if necessary, then return */ if (strlen(outfile1))
-{ /* was an outfile specified? */ strcpy(urltype,"httpfile://"); /* don't copy
-the "file://" prefix, if present. */ if (!strncmp(outfile1, "file://", 7) )
-{ strcpy(netoutfile,outfile1+7); } else { strcpy(netoutfile,outfile1); } }
-return 0; /* case where infile name contains "?" */ } /* If the specified
-infile file name does not contain a .gz or .Z suffix, then first test if a .gz
-compressed version of the file exists, and if not then test if a .Z version of
-the file exists. (because it will be much faster to read the compressed file).
-If the compressed files do not exist, then finally just open the infile name
-exactly as specified. */ if (!strstr(infile,".gz") && (!strstr(infile,".Z")))
-{ /* The infile string does not contain the name of a compressed file. */ /
-* Fisrt, look for a .gz compressed version of the file. */ if (strlen(infile) +
-3 > MAXLEN-1) { return URL_PARSE_ERROR; } strcpy(newinfile,infile); strcat
-(newinfile,".gz"); status = http_open_network
-(newinfile,&httpfile,contentencoding, &contentlength); if (!status) { if
-(!strcmp(contentencoding, "ftp://")) { /* this is a signal from
-http_open_network that indicates that */ /* the http server returned a 301 or
-302 redirect to a FTP URL. */ /* Check that the file exists, because redirect
-many not be reliable */ if (ftp_file_exist(newinfile)>0) { /* The ftp .gz
-compressed file is there, all is good! */ strcpy(urltype, "ftp://"); if (strlen
-(newinfile) > FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy
-(infile,newinfile); if (strlen(outfile1)) { /* there is an output file; might
-need to modify the urltype */ if (!strncmp(outfile1, "mem:", 4) ) { /* copy the
-file to memory, with READ and WRITE access In this case, it makes no difference
-whether the ftp file and or the output file are compressed or not. */ strcpy
-(urltype, "ftpmem://"); /* use special driver */ } else { /* input file is
-compressed */ if (strstr(outfile1,".gz") || (strstr(outfile1,".Z"))) { strcpy
-(urltype,"ftpcompress://"); } else { strcpy(urltype,"ftpfile://"); } } } return
-0; /* found the .gz compressed ftp file */ } /* fall through to here if ftp
+contentencoding[MAXLEN], contenttype[MAXLEN]; int contentlength; int foundfile
+= 0; int status=0; /* set defaults */ strcpy(urltype,"http://"); if (strlen
+(outfile1)) { /* don't copy the "file://" prefix, if present. */ if (!strncmp
+(outfile1, "file://", 7) ) { strcpy(netoutfile,outfile1+7); } else { strcpy
+(netoutfile,outfile1); } } if (strstr(infile, "?")) { /* Special case where
+infile name contains a "?". */ /* This is probably a CGI string; no point in
+testing if it exists */ /* so just set urltype and netoutfile if necessary,
+then return */ if (strlen(outfile1)) { /* was an outfile specified? */ strcpy
+(urltype,"httpfile://"); /* don't copy the "file://" prefix, if present. */ if
+(!strncmp(outfile1, "file://", 7) ) { strcpy(netoutfile,outfile1+7); } else
+{ strcpy(netoutfile,outfile1); } } return 0; /* case where infile name contains
+"?" */ } /* If the specified infile file name does not contain a .gz or .Z
+suffix, then first test if a .gz compressed version of the file exists, and if
+not then test if a .Z version of the file exists. (because it will be much
+faster to read the compressed file). If the compressed files do not exist, then
+finally just open the infile name exactly as specified. */ if (!strstr
+(infile,".gz") && (!strstr(infile,".Z"))) { /* The infile string does not
+contain the name of a compressed file. */ /* Fisrt, look for a .gz compressed
+version of the file. */ if (strlen(infile) + 3 > MAXLEN-1) { return
+URL_PARSE_ERROR; } strcpy(newinfile,infile); strcat(newinfile,".gz"); status =
+http_open_network(newinfile,&httpfile, contentencoding, contenttype,
+&contentlength); if (!status) { if (!strcmp(contentencoding, "ftp://")) { /
+* this is a signal from http_open_network that indicates that */ /* the http
+server returned a 301 or 302 redirect to a FTP URL. */ /* Check that the file
+exists, because redirect many not be reliable */ if (ftp_file_exist
+(newinfile)>0) { /* The ftp .gz compressed file is there, all is good! */
+strcpy(urltype, "ftp://"); if (strlen(newinfile) > FLEN_FILENAME-1) { return
+URL_PARSE_ERROR; } strcpy(infile,newinfile); if (strlen(outfile1)) { /* there
+is an output file; might need to modify the urltype */ if (!strncmp(outfile1,
+"mem:", 4) ) { /* copy the file to memory, with READ and WRITE access In this
+case, it makes no difference whether the ftp file and or the output file are
+compressed or not. */ strcpy(urltype, "ftpmem://"); /* use special driver */ }
+else { /* input file is compressed */ if (strstr(outfile1,".gz") || (strstr
+(outfile1,".Z"))) { strcpy(urltype,"ftpcompress://"); } else { strcpy
+(urltype,"ftpfile://"); } } } return 0; /* found the .gz compressed ftp file */
+} /* fall through to here if ftp redirect does not exist */ } else if (!strcmp
+(contentencoding, "https://")) { /* the http server returned a 301 or 302
+redirect to an HTTPS URL. */ https_checkfile(urltype, infile, outfile1); /* For
+https we're not testing for compressed extensions at this stage. It will all be
+done in https_open_network. Therefore leave infile alone and do immediate
+return. */ return 0; } else { /* found the http .gz compressed file */ if
+(httpfile) fclose(httpfile); foundfile = 1; if (strlen(newinfile) >
+FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy(infile,newinfile); } } else
+if (status != FILE_NOT_OPENED) { /* Some other error occured aside from not
+finding file, such as a url parsing error. Don't continue trying with other
+extensions. */ return status; } if (!foundfile) { /* did not find .gz
+compressed version of the file, so look for .Z file. */ if (strlen(infile+2) >
+MAXLEN-1) { return URL_PARSE_ERROR; } strcpy(newinfile,infile); strcat
+(newinfile,".Z"); if (!http_open_network(newinfile,&httpfile, contentencoding,
+contenttype, &contentlength)) { if (!strcmp(contentencoding, "ftp://")) { /
+* this is a signal from http_open_network that indicates that */ /* the http
+server returned a 301 or 302 redirect to a FTP URL. */ /* Check that the file
+exists, because redirect many not be reliable */ if (ftp_file_exist
+(newinfile)>0) { /* The ftp .Z compressed file is there, all is good! */ strcpy
+(urltype, "ftp://"); if (strlen(newinfile) > FLEN_FILENAME-1) { return
+URL_PARSE_ERROR; } strcpy(infile,newinfile); if (strlen(outfile1)) { /* there
+is an output file; might need to modify the urltype */ if (!strncmp(outfile1,
+"mem:", 4) ) { /* copy the file to memory, with READ and WRITE access In this
+case, it makes no difference whether the ftp file and or the output file are
+compressed or not. */ strcpy(urltype, "ftpmem://"); /* use special driver */ }
+else { /* input file is compressed */ if (strstr(outfile1,".gz") || (strstr
+(outfile1,".Z"))) { strcpy(urltype,"ftpcompress://"); } else { strcpy
+(urltype,"ftpfile://"); } } } return 0; /* found the .Z compressed ftp file */
+} /* fall through to here if ftp redirect does not exist */ } else { /* found
+the http .Z compressed file */ if (httpfile) fclose(httpfile); foundfile = 1;
+if (strlen(newinfile) > FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy
+(infile,newinfile); } } } } /* end of case where infile does not contain .gz or
+.Z */ if (!foundfile) { /* look for the base file.name */ strcpy
+(newinfile,infile); if (!http_open_network(newinfile,&httpfile,
+contentencoding, contenttype, &contentlength)) { if (!strcmp(contentencoding,
+"ftp://")) { /* this is a signal from http_open_network that indicates that */
+/* the http server returned a 301 or 302 redirect to a FTP URL. */ /* Check
+that the file exists, because redirect many not be reliable */ if
+(ftp_file_exist(newinfile)>0) { /* The ftp file is there, all is good! */
+strcpy(urltype, "ftp://"); if (strlen(newinfile) > FLEN_FILENAME-1) { return
+URL_PARSE_ERROR; } strcpy(infile,newinfile); if (strlen(outfile1)) { /* there
+is an output file; might need to modify the urltype */ if (!strncmp(outfile1,
+"mem:", 4) ) { /* copy the file to memory, with READ and WRITE access In this
+case, it makes no difference whether the ftp file and or the output file are
+compressed or not. */ strcpy(urltype, "ftpmem://"); /* use special driver */
+return 0; } else { /* input file is not compressed */ strcpy(urltype,"ftpfile:/
+/"); } } return 0; /* found the ftp file */ } /* fall through to here if ftp
 redirect does not exist */ } else if (!strcmp(contentencoding, "https://")) { /
 * the http server returned a 301 or 302 redirect to an HTTPS URL. */
 https_checkfile(urltype, infile, outfile1); /* For https we're not testing for
 compressed extensions at this stage. It will all be done in https_open_network.
 Therefore leave infile alone and do immediate return. */ return 0; } else { /
-* found the http .gz compressed file */ if (httpfile) fclose(httpfile);
-foundfile = 1; if (strlen(newinfile) > FLEN_FILENAME-1) { return
-URL_PARSE_ERROR; } strcpy(infile,newinfile); } } else if (status !=
-FILE_NOT_OPENED) { /* Some other error occured aside from not finding file,
-such as a url parsing error. Don't continue trying with other extensions. */
-return status; } if (!foundfile) { /* did not find .gz compressed version of
-the file, so look for .Z file. */ if (strlen(infile+2) > MAXLEN-1) { return
-URL_PARSE_ERROR; } strcpy(newinfile,infile); strcat(newinfile,".Z"); if
-(!http_open_network(newinfile,&httpfile,contentencoding, &contentlength)) { if
-(!strcmp(contentencoding, "ftp://")) { /* this is a signal from
-http_open_network that indicates that */ /* the http server returned a 301 or
-302 redirect to a FTP URL. */ /* Check that the file exists, because redirect
-many not be reliable */ if (ftp_file_exist(newinfile)>0) { /* The ftp .Z
-compressed file is there, all is good! */ strcpy(urltype, "ftp://"); if (strlen
-(newinfile) > FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy
-(infile,newinfile); if (strlen(outfile1)) { /* there is an output file; might
-need to modify the urltype */ if (!strncmp(outfile1, "mem:", 4) ) { /* copy the
-file to memory, with READ and WRITE access In this case, it makes no difference
-whether the ftp file and or the output file are compressed or not. */ strcpy
-(urltype, "ftpmem://"); /* use special driver */ } else { /* input file is
-compressed */ if (strstr(outfile1,".gz") || (strstr(outfile1,".Z"))) { strcpy
-(urltype,"ftpcompress://"); } else { strcpy(urltype,"ftpfile://"); } } } return
-0; /* found the .Z compressed ftp file */ } /* fall through to here if ftp
-redirect does not exist */ } else { /* found the http .Z compressed file */ if
-(httpfile) fclose(httpfile); foundfile = 1; if (strlen(newinfile) >
-FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy(infile,newinfile); } } } }
-/* end of case where infile does not contain .gz or .Z */ if (!foundfile) { /
-* look for the base file.name */ strcpy(newinfile,infile); if
-(!http_open_network(newinfile,&httpfile,contentencoding, &contentlength)) { if
-(!strcmp(contentencoding, "ftp://")) { /* this is a signal from
-http_open_network that indicates that */ /* the http server returned a 301 or
-302 redirect to a FTP URL. */ /* Check that the file exists, because redirect
-many not be reliable */ if (ftp_file_exist(newinfile)>0) { /* The ftp file is
-there, all is good! */ strcpy(urltype, "ftp://"); if (strlen(newinfile) >
-FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy(infile,newinfile); if
-(strlen(outfile1)) { /* there is an output file; might need to modify the
-urltype */ if (!strncmp(outfile1, "mem:", 4) ) { /* copy the file to memory,
-with READ and WRITE access In this case, it makes no difference whether the ftp
-file and or the output file are compressed or not. */ strcpy(urltype, "ftpmem:/
-/"); /* use special driver */ return 0; } else { /* input file is not
-compressed */ strcpy(urltype,"ftpfile://"); } } return 0; /* found the ftp file
-*/ } /* fall through to here if ftp redirect does not exist */ } else if
-(!strcmp(contentencoding, "https://")) { /* the http server returned a 301 or
-302 redirect to an HTTPS URL. */ https_checkfile(urltype, infile, outfile1); /
-* For https we're not testing for compressed extensions at this stage. It will
-all be done in https_open_network. Therefore leave infile alone and do
-immediate return. */ return 0; } else { /* found the base named file */ if
-(httpfile) fclose(httpfile); foundfile = 1; if (strlen(newinfile) >
-FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy(infile,newinfile); } } } if
-(!foundfile) { return (FILE_NOT_OPENED); } if (strlen(outfile1)) { /* there is
-an output file */ if (!strncmp(outfile1, "mem:", 4) ) { /* copy the file to
-memory, with READ and WRITE access In this case, it makes no difference whether
-the http file and or the output file are compressed or not. */ strcpy(urltype,
-"httpmem://"); /* use special driver */ return 0; } if (strstr(infile, "?"))
-{ /* file name contains a '?' so probably a cgi string; */ strcpy
-(urltype,"httpfile://"); return 0; } if (strstr(infile,".gz") || (strstr
-(infile,".Z"))) { /* It's compressed */ if (strstr(outfile1,".gz") || (strstr
-(outfile1,".Z"))) { strcpy(urltype,"httpcompress://"); } else { strcpy
-(urltype,"httpfile://"); } } else { strcpy(urltype,"httpfile://"); } } return
+* found the base named file */ if (httpfile) fclose(httpfile); foundfile = 1;
+if (strlen(newinfile) > FLEN_FILENAME-1) { return URL_PARSE_ERROR; } strcpy
+(infile,newinfile); } } } if (!foundfile) { return (FILE_NOT_OPENED); } if
+(strlen(outfile1)) { /* there is an output file */ if (!strncmp(outfile1, "mem:
+", 4) ) { /* copy the file to memory, with READ and WRITE access In this case,
+it makes no difference whether the http file and or the output file are
+compressed or not. */ strcpy(urltype, "httpmem://"); /* use special driver */
+return 0; } if (strstr(infile, "?")) { /* file name contains a '?' so probably
+a cgi string; */ strcpy(urltype,"httpfile://"); return 0; } if (strstr
+(infile,".gz") || (strstr(infile,".Z"))) { /* It's compressed */ if (strstr
+(outfile1,".gz") || (strstr(outfile1,".Z"))) { strcpy(urltype,"httpcompress://
+"); } else { strcpy(urltype,"httpfile://"); } } else { strcpy
+(urltype,"httpfile://"); } } return 0; } /*------------------------------------
+--------------------------------------*/ int https_checkfile (char *urltype,
+char *infile, char *outfile1) { /* set default */ strcpy(urltype,"https://");
+if (strlen(outfile1)) { /* don't copy the "file://" prefix, if present. */ if
+(!strncmp(outfile1, "file://", 7) ) { strcpy(netoutfile,outfile1+7); } else
+{ strcpy(netoutfile,outfile1); } if (!strncmp(outfile1, "mem:", 4)) strcpy
+(urltype,"httpsmem://"); else strcpy(urltype,"httpsfile://"); } return 0; } /*-
+-------------------------------------------------------------------------*/ int
+ftps_checkfile (char *urltype, char *infile, char *outfile1) { strcpy
+(urltype,"ftps://"); if (strlen(outfile1)) { /* don't copy the "file://
+" prefix, if present. */ if (!strncmp(outfile1, "file://", 7) ) { strcpy
+(netoutfile,outfile1+7); } else { strcpy(netoutfile,outfile1); } if (!strncmp
+(outfile1, "mem:", 4)) strcpy(urltype,"ftpsmem://"); else { if (strstr
+(outfile1,".gz") || strstr(outfile1,".Z")) { /* Note that for Curl dependent
+handlers, we can't check at this point if infile will have a .gz or .Z
+appended. If it does not, the ftpscompress 'open' handler will fail.*/ strcpy
+(urltype,"ftpscompress://"); } else strcpy(urltype,"ftpsfile://"); } } return
 0; } /*------------------------------------------------------------------------
---*/ int https_checkfile (char *urltype, char *infile, char *outfile1) { /* set
-default */ strcpy(urltype,"https://"); if (strlen(outfile1)) { /* don't copy
-the "file://" prefix, if present. */ if (!strncmp(outfile1, "file://", 7) )
-{ strcpy(netoutfile,outfile1+7); } else { strcpy(netoutfile,outfile1); } if
-(!strncmp(outfile1, "mem:", 4)) strcpy(urltype,"httpsmem://"); else strcpy
-(urltype,"httpsfile://"); } return 0; } /*-------------------------------------
--------------------------------------*/ int ftps_checkfile (char *urltype, char
-*infile, char *outfile1) { strcpy(urltype,"ftps://"); if (strlen(outfile1)) { /
-* don't copy the "file://" prefix, if present. */ if (!strncmp(outfile1, "file:
-//", 7) ) { strcpy(netoutfile,outfile1+7); } else { strcpy
-(netoutfile,outfile1); } if (!strncmp(outfile1, "mem:", 4)) strcpy
-(urltype,"ftpsmem://"); else { if (strstr(outfile1,".gz") || strstr
-(outfile1,".Z")) { /* Note that for Curl dependent handlers, we can't check at
-this point if infile will have a .gz or .Z appended. If it does not, the
-ftpscompress 'open' handler will fail.*/ strcpy(urltype,"ftpscompress://"); }
-else strcpy(urltype,"ftpsfile://"); } } return 0; } /*-------------------------
--------------------------------------------------*/ int ftp_checkfile (char
-*urltype, char *infile, char *outfile1) { char newinfile[MAXLEN]; FILE
-*ftpfile; FILE *command; int sock; int foundfile = 0; int status=0; /* Small
-helper functions to set the netoutfile static string */ /* default to ftp:// if
-no outfile specified */ strcpy(urltype,"ftp://"); if (!strstr(infile,".gz") &&
-(!strstr(infile,".Z"))) { /* The infile string does not contain the name of a
-compressed file. */ /* Fisrt, look for a .gz compressed version of the file. */
-if (strlen(infile)+3 > MAXLEN-1) { return URL_PARSE_ERROR; } strcpy
-(newinfile,infile); strcat(newinfile,".gz"); /* look for .gz version of the
-file */ status = ftp_file_exist(newinfile); if (status > 0) { foundfile = 1; if
-(strlen(newinfile) > FLEN_FILENAME-1) return URL_PARSE_ERROR; strcpy
-(infile,newinfile); } else if (status < 0) { /* Server is demanding an SSL
-connection. Change urltype and exit. */ ftps_checkfile(urltype, infile,
-outfile1); return 0; } if (!foundfile) { if (strlen(infile)+2 > MAXLEN-1)
-{ return URL_PARSE_ERROR; } strcpy(newinfile,infile); strcat(newinfile,".Z"); /
-* look for .Z version of the file */ if (ftp_file_exist(newinfile)) { foundfile
-= 1; if (strlen(newinfile) > FLEN_FILENAME-1) return URL_PARSE_ERROR; strcpy
-(infile,newinfile); } } } if (!foundfile) { strcpy(newinfile,infile); /* look
-for the base file */ status = ftp_file_exist(newinfile); if (status > 0)
-{ foundfile = 1; if (strlen(newinfile) > FLEN_FILENAME-1) return
+--*/ int ftp_checkfile (char *urltype, char *infile, char *outfile1) { char
+newinfile[MAXLEN]; FILE *ftpfile; FILE *command; int sock; int foundfile = 0;
+int status=0; /* Small helper functions to set the netoutfile static string */
+/* default to ftp:// if no outfile specified */ strcpy(urltype,"ftp://"); if
+(!strstr(infile,".gz") && (!strstr(infile,".Z"))) { /* The infile string does
+not contain the name of a compressed file. */ /* Fisrt, look for a .gz
+compressed version of the file. */ if (strlen(infile)+3 > MAXLEN-1) { return
+URL_PARSE_ERROR; } strcpy(newinfile,infile); strcat(newinfile,".gz"); /* look
+for .gz version of the file */ status = ftp_file_exist(newinfile); if (status >
+0) { foundfile = 1; if (strlen(newinfile) > FLEN_FILENAME-1) return
 URL_PARSE_ERROR; strcpy(infile,newinfile); } else if (status < 0) { /* Server
 is demanding an SSL connection. Change urltype and exit. */ ftps_checkfile
-(urltype, infile, outfile1); return 0; } } if (!foundfile) { return
-(FILE_NOT_OPENED); } if (strlen(outfile1)) { /* there is an output file; might
-need to modify the urltype */ /* don't copy the "file://" prefix, if present.
-*/ if (!strncmp(outfile1, "file://", 7) ) strcpy(netoutfile,outfile1+7); else
-strcpy(netoutfile,outfile1); if (!strncmp(outfile1, "mem:", 4) ) { /* copy the
-file to memory, with READ and WRITE access In this case, it makes no difference
-whether the ftp file and or the output file are compressed or not. */ strcpy
-(urltype, "ftpmem://"); /* use special driver */ return 0; } if (strstr
-(infile,".gz") || (strstr(infile,".Z"))) { /* input file is compressed */ if
-(strstr(outfile1,".gz") || (strstr(outfile1,".Z"))) { strcpy
-(urltype,"ftpcompress://"); } else { strcpy(urltype,"ftpfile://"); } } else
-{ strcpy(urltype,"ftpfile://"); } } return 0; } /*-----------------------------
----------------------------------------------*/ /* A small helper function to
-wait for a particular status on the ftp connectino */ static int ftp_status
-(FILE *ftp, char *statusstr) { /* read through until we find a string beginning
-with statusstr */ /* This needs a timeout */ /* Modified 2/19 to return the
-numerical value of the returned status when it differs from the requested
-status. */ char recbuf[MAXLEN], errorstr[SHORTLEN]; int len, ftpcode=0; len =
-strlen(statusstr); while (1) { if (!(fgets(recbuf,MAXLEN,ftp))) { snprintf
-(errorstr,SHORTLEN,"ERROR: ftp_status wants %s but fgets returned
-0",statusstr); ffpmsg(errorstr); return 1; /* error reading */ } recbuf[len] =
-'\0'; /* make it short */ if (!strcmp(recbuf,statusstr)) { return 0; /* we're
-ok */ } if (recbuf[0] > '3') { /* oh well, some sort of error. */ snprintf
-(errorstr,SHORTLEN,"ERROR ftp_status wants %s but got %s", statusstr, recbuf);
-ffpmsg(errorstr); /* Return the numerical code, if string can be converted to
-int. But must not return 0 from here. */ ftpcode = atoi(recbuf); return ftpcode
-? ftpcode : 1; } snprintf(errorstr,SHORTLEN,"ERROR ftp_status wants %s but got
-unexpected %s", statusstr, recbuf); ffpmsg(errorstr); } } /* *-----------------
------------------------------------------------------ * * CreateSocketAddress -
-- * * This function initializes a sockaddr structure for a host and port. * *
-Results: * 1 if the host was valid, 0 if the host could not be converted to *
-an IP address. * * Side effects: * Fills in the *sockaddrPtr structure. * *----
------------------------------------------------------------------- */ static
-int CreateSocketAddress( struct sockaddr_in *sockaddrPtr, /* Socket address */
-char *host, /* Host. NULL implies INADDR_ANY */ int port) /* Port number */
-{ struct hostent *hostent; /* Host database entry */ struct in_addr addr; /
-* For 64/32 bit madness */ char localhost[MAXLEN]; strcpy(localhost,host);
-memset((void *) sockaddrPtr, '\0', sizeof(struct sockaddr_in)); sockaddrPtr-
->sin_family = AF_INET; sockaddrPtr->sin_port = htons((unsigned short) (port &
-0xFFFF)); if (host == NULL) { addr.s_addr = INADDR_ANY; } else { addr.s_addr =
-inet_addr(localhost); if (addr.s_addr == 0xFFFFFFFF) { hostent = gethostbyname
+(urltype, infile, outfile1); return 0; } if (!foundfile) { if (strlen(infile)+2
+> MAXLEN-1) { return URL_PARSE_ERROR; } strcpy(newinfile,infile); strcat
+(newinfile,".Z"); /* look for .Z version of the file */ if (ftp_file_exist
+(newinfile)) { foundfile = 1; if (strlen(newinfile) > FLEN_FILENAME-1) return
+URL_PARSE_ERROR; strcpy(infile,newinfile); } } } if (!foundfile) { strcpy
+(newinfile,infile); /* look for the base file */ status = ftp_file_exist
+(newinfile); if (status > 0) { foundfile = 1; if (strlen(newinfile) >
+FLEN_FILENAME-1) return URL_PARSE_ERROR; strcpy(infile,newinfile); } else if
+(status < 0) { /* Server is demanding an SSL connection. Change urltype and
+exit. */ ftps_checkfile(urltype, infile, outfile1); return 0; } } if
+(!foundfile) { return (FILE_NOT_OPENED); } if (strlen(outfile1)) { /* there is
+an output file; might need to modify the urltype */ /* don't copy the "file://
+" prefix, if present. */ if (!strncmp(outfile1, "file://", 7) ) strcpy
+(netoutfile,outfile1+7); else strcpy(netoutfile,outfile1); if (!strncmp
+(outfile1, "mem:", 4) ) { /* copy the file to memory, with READ and WRITE
+access In this case, it makes no difference whether the ftp file and or the
+output file are compressed or not. */ strcpy(urltype, "ftpmem://"); /* use
+special driver */ return 0; } if (strstr(infile,".gz") || (strstr
+(infile,".Z"))) { /* input file is compressed */ if (strstr(outfile1,".gz") ||
+(strstr(outfile1,".Z"))) { strcpy(urltype,"ftpcompress://"); } else { strcpy
+(urltype,"ftpfile://"); } } else { strcpy(urltype,"ftpfile://"); } } return 0;
+} /*--------------------------------------------------------------------------
+*/ /* A small helper function to wait for a particular status on the ftp
+connectino */ static int ftp_status(FILE *ftp, char *statusstr) { /* read
+through until we find a string beginning with statusstr */ /* This needs a
+timeout */ /* Modified 2/19 to return the numerical value of the returned
+status when it differs from the requested status. */ char recbuf[MAXLEN],
+errorstr[SHORTLEN]; int len, ftpcode=0; len = strlen(statusstr); while (1) { if
+(!(fgets(recbuf,MAXLEN,ftp))) { snprintf(errorstr,SHORTLEN,"ERROR: ftp_status
+wants %s but fgets returned 0",statusstr); ffpmsg(errorstr); return 1; /* error
+reading */ } recbuf[len] = '\0'; /* make it short */ if (!strcmp
+(recbuf,statusstr)) { return 0; /* we're ok */ } if (recbuf[0] > '3') { /* oh
+well, some sort of error. */ snprintf(errorstr,SHORTLEN,"ERROR ftp_status wants
+%s but got %s", statusstr, recbuf); ffpmsg(errorstr); /* Return the numerical
+code, if string can be converted to int. But must not return 0 from here. */
+ftpcode = atoi(recbuf); return ftpcode ? ftpcode : 1; } snprintf
+(errorstr,SHORTLEN,"ERROR ftp_status wants %s but got unexpected %s",
+statusstr, recbuf); ffpmsg(errorstr); } } /* *---------------------------------
+------------------------------------- * * CreateSocketAddress -- * * This
+function initializes a sockaddr structure for a host and port. * * Results: * 1
+if the host was valid, 0 if the host could not be converted to * an IP address.
+* * Side effects: * Fills in the *sockaddrPtr structure. * *-------------------
+--------------------------------------------------- */ static int
+CreateSocketAddress( struct sockaddr_in *sockaddrPtr, /* Socket address */ char
+*host, /* Host. NULL implies INADDR_ANY */ int port) /* Port number */ { struct
+hostent *hostent; /* Host database entry */ struct in_addr addr; /* For 64/32
+bit madness */ char localhost[MAXLEN]; strcpy(localhost,host); memset((void *)
+sockaddrPtr, '\0', sizeof(struct sockaddr_in)); sockaddrPtr->sin_family =
+AF_INET; sockaddrPtr->sin_port = htons((unsigned short) (port & 0xFFFF)); if
+(host == NULL) { addr.s_addr = INADDR_ANY; } else { addr.s_addr = inet_addr
+(localhost); if (addr.s_addr == 0xFFFFFFFF) { hostent = gethostbyname
 (localhost); if (hostent != NULL) { memcpy((void *) &addr, (void *) hostent-
 >h_addr_list[0], (size_t) hostent->h_length); } else { #ifdef EHOSTUNREACH
 errno = EHOSTUNREACH; #else #ifdef ENXIO errno = ENXIO; #endif #endif return 0;
 /* error */ } } } /* * NOTE: On 64 bit machines the assignment below is rumored
 to not * do the right thing. Please report errors related to this if you *
 observe incorrect behavior on 64 bit machines such as DEC Alphas. * Should we
 modify this code to do an explicit memcpy? */ sockaddrPtr->sin_addr.s_addr =
```

### Comparing `fitsio-1.1.9/cfitsio3490/drvrsmem.c` & `fitsio-1.2.0/cfitsio-4.2.0/drvrsmem.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/drvrsmem.h` & `fitsio-1.2.0/cfitsio-4.2.0/drvrsmem.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/editcol.c` & `fitsio-1.2.0/cfitsio-4.2.0/editcol.c`

 * *Files 2% similar despite different names*

```diff
@@ -64,19 +64,24 @@
     /* get current image size parameters */
     if (ffghprll(fptr, 99, &simple, &obitpix, &onaxis, onaxes, &pcount,
                &gcount, &extend, status) > 0)
         return(*status);
 
     longbitpix = bitpix;
 
-    /* test for the 2 special cases that represent unsigned integers */
+    /* test for the 4 special cases that represent unsigned integers 
+       or signed bytes */
     if (longbitpix == USHORT_IMG)
         longbitpix = SHORT_IMG;
     else if (longbitpix == ULONG_IMG)
         longbitpix = LONG_IMG;
+    else if (longbitpix == SBYTE_IMG)
+        longbitpix = BYTE_IMG;
+    else if (longbitpix == ULONGLONG_IMG)
+        longbitpix = LONGLONG_IMG;
 
     /* test that the new values are legal */
 
     if (longbitpix != BYTE_IMG && longbitpix != SHORT_IMG && 
         longbitpix != LONG_IMG && longbitpix != LONGLONG_IMG &&
         longbitpix != FLOAT_IMG && longbitpix != DOUBLE_IMG)
     {
@@ -122,15 +127,15 @@
         for (ii = 0; ii < onaxis; ii++)
             oldsize *= onaxes[ii];  
         oldsize = (oldsize + pcount) * gcount * (abs(obitpix) / 8);
     }
 
     oldsize = (oldsize + 2879) / 2880; /* old size, in blocks */
 
-    newsize = (newsize + pcount) * gcount * (abs(longbitpix) / 8);
+    newsize = (newsize + pcount) * gcount * (labs(longbitpix) / 8);
     newsize = (newsize + 2879) / 2880; /* new size, in blocks */
 
     if (newsize > oldsize)   /* have to insert new blocks for image */
     {
         nblocks = (long) (newsize - oldsize);
         if (ffiblk(fptr, nblocks, 1, status) > 0)  
             return(*status);
@@ -179,29 +184,44 @@
         for (ii = naxis; ii < onaxis; ii++)
         {
             ffkeyn("NAXIS", ii+1, keyname, status);
             ffdkey(fptr, keyname, status);
         }
     }
 
-    /* Update the BSCALE and BZERO keywords, if an unsigned integer image */
+    /* Update the BSCALE and BZERO keywords, if an unsigned integer image
+       or a signed byte image.  */
     if (bitpix == USHORT_IMG)
     {
         strcpy(comment, "offset data range to that of unsigned short");
         ffukyg(fptr, "BZERO", 32768., 0, comment, status);
         strcpy(comment, "default scaling factor");
         ffukyg(fptr, "BSCALE", 1.0, 0, comment, status);
     }
     else if (bitpix == ULONG_IMG)
     {
         strcpy(comment, "offset data range to that of unsigned long");
         ffukyg(fptr, "BZERO", 2147483648., 0, comment, status);
         strcpy(comment, "default scaling factor");
         ffukyg(fptr, "BSCALE", 1.0, 0, comment, status);
     }
+    else if (bitpix == ULONGLONG_IMG)
+    {
+        strcpy(comment, "offset data range to that of unsigned long long");
+        ffukyg(fptr, "BZERO", 9223372036854775808., 0, comment, status);
+        strcpy(comment, "default scaling factor");
+        ffukyg(fptr, "BSCALE", 1.0, 0, comment, status);
+    }
+    else if (bitpix == SBYTE_IMG)
+    {
+        strcpy(comment, "offset data range to that of signed byte");
+        ffukyg(fptr, "BZERO", -128., 0, comment, status);
+        strcpy(comment, "default scaling factor");
+        ffukyg(fptr, "BSCALE", 1.0, 0, comment, status);
+    }
 
     /* re-read the header, to make sure structures are updated */
     ffrdef(fptr, status);
     return(*status);
 }
 /*--------------------------------------------------------------------------*/
 int ffirow(fitsfile *fptr,  /* I - FITS file pointer                        */
@@ -1060,14 +1080,15 @@
 */
 {
     int colnum, datacode, decims, tfields, tstatus, ii;
     LONGLONG datasize, firstbyte, nbytes, nadd, naxis1, naxis2, freespace;
     LONGLONG tbcol, firstcol, delbyte;
     long nblock, width, repeat;
     char tfm[FLEN_VALUE], keyname[FLEN_KEYWORD], comm[FLEN_COMMENT], *cptr;
+    char card[FLEN_CARD];
     tcolumn *colptr;
 
     if (*status > 0)
         return(*status);
 
     if (fptr->HDUposition != (fptr->Fptr)->curhdu)
     {
@@ -1271,14 +1292,35 @@
 
            ffpkyg(fptr, keyname, 2147483648., 0, comm, status);
 
            ffkeyn("TSCAL", colnum, keyname, status);
            strcpy(comm, "data are not scaled");
            ffpkyg(fptr, keyname, 1., 0, comm, status);
         }
+        else if (abs(datacode) == TULONGLONG) 
+        {	   
+           /* Replace the 'W' with an 'K' in the TFORMn code */
+           cptr = tfm;
+           while (*cptr != 'W') 
+              cptr++;
+
+           *cptr = 'K';
+           ffpkys(fptr, keyname, tfm, comm, status);
+
+           /* write the TZEROn and TSCALn keywords */
+           ffkeyn("TZERO", colnum, card, status);
+           strcat(card, "     ");  /* make sure name is >= 8 chars long */
+           *(card+8) = '\0';
+	   strcat(card, "=  9223372036854775808 / offset for unsigned integers");
+	   fits_write_record(fptr, card, status);
+
+           ffkeyn("TSCAL", colnum, keyname, status);
+           strcpy(comm, "data are not scaled");
+           ffpkyg(fptr, keyname, 1., 0, comm, status);
+        }
         else
         {
            ffpkys(fptr, keyname, tfm, comm, status);
         }
 
         if ((fptr->Fptr)->hdutype == ASCII_TBL)   /* write the TBCOL keyword */
         {
@@ -2325,14 +2367,254 @@
     free(buffer);
     free(inVarCols);
     free(outVarCols);
     if (varColBuff) free(varColBuff);
     return(*status);
 }
 /*--------------------------------------------------------------------------*/
+int ffcpsr(fitsfile *infptr,    /* I - FITS file pointer to input file  */
+           fitsfile *outfptr,   /* I - FITS file pointer to output file */
+           LONGLONG firstrow,   /* I - number of first row to copy (1 based)  */
+           LONGLONG nrows,      /* I - number of rows to copy  */
+	   char *row_status,    /* I - quality list of rows to keep (1) or not keep (0) */
+           int *status)         /* IO - error status     */
+/*
+  copy consecutive set of rows from infptr and append it in the outfptr table.
+*/
+{
+    LONGLONG innaxis1, innaxis2, outnaxis1, outnaxis2, ii, jj, i0, icol;
+    LONGLONG iVarCol, inPos, outPos, nVarBytes, nVarAllocBytes = 0;
+    unsigned char *buffer, *varColBuff=0;
+    int nInVarCols=0, nOutVarCols=0, varColDiff=0;
+    int *inVarCols=0, *outVarCols=0;
+    long nNewBlocks;
+    LONGLONG hrepeat=0, hoffset=0;
+    tcolumn *colptr=0;
+    LONGLONG n_good_rows = nrows;
+    
+    if (*status > 0)
+        return(*status);
+
+    if (infptr->HDUposition != (infptr->Fptr)->curhdu)
+    {
+        ffmahd(infptr, (infptr->HDUposition) + 1, NULL, status);
+    }
+    else if ((infptr->Fptr)->datastart == DATA_UNDEFINED)
+        ffrdef(infptr, status);                /* rescan header */
+
+    if (outfptr->HDUposition != (outfptr->Fptr)->curhdu)
+    {
+        ffmahd(outfptr, (outfptr->HDUposition) + 1, NULL, status);
+    }
+    else if ((outfptr->Fptr)->datastart == DATA_UNDEFINED)
+        ffrdef(outfptr, status);               /* rescan header */
+
+    if (*status > 0)
+        return(*status);
+
+    if ((infptr->Fptr)->hdutype == IMAGE_HDU || (outfptr->Fptr)->hdutype == IMAGE_HDU)
+    {
+       ffpmsg
+       ("Can not copy rows to or from IMAGE HDUs (ffcprw)");
+       return(*status = NOT_TABLE);
+    }
+
+    if ( ((infptr->Fptr)->hdutype == BINARY_TBL &&  (outfptr->Fptr)->hdutype == ASCII_TBL) ||
+         ((infptr->Fptr)->hdutype == ASCII_TBL &&  (outfptr->Fptr)->hdutype == BINARY_TBL) )
+    {
+       ffpmsg
+       ("Copying rows between Binary and ASCII tables is not supported (ffcprw)");
+       return(*status = NOT_BTABLE);
+    }
+
+    ffgkyjj(infptr,  "NAXIS1", &innaxis1,  0, status);  /* width of input rows */
+    ffgkyjj(infptr,  "NAXIS2", &innaxis2,  0, status);  /* no. of input rows */
+    ffgkyjj(outfptr, "NAXIS1", &outnaxis1, 0, status);  /* width of output rows */
+    ffgkyjj(outfptr, "NAXIS2", &outnaxis2, 0, status);  /* no. of output rows */
+
+    if (*status > 0)
+        return(*status);
+
+    if (outnaxis1 != innaxis1) {
+       ffpmsg
+       ("Input and output tables do not have same width (ffcprw)");
+       return(*status = BAD_ROW_WIDTH);
+    }    
+
+    if (firstrow + nrows - 1 > innaxis2) {
+       ffpmsg
+       ("Not enough rows in input table to copy (ffcprw)");
+       return(*status = BAD_ROW_NUM);
+    }
+    
+    if ((infptr->Fptr)->tfield != (outfptr->Fptr)->tfield)
+    {
+       ffpmsg
+       ("Input and output tables do not have same number of columns (ffcprw)");
+       return(*status = BAD_COL_NUM);
+    }
+    
+    /* allocate buffer to hold 1 row of data */
+    buffer = malloc( (size_t) innaxis1);
+    if (!buffer) {
+       ffpmsg
+       ("Unable to allocate memory (ffcprw)");
+       return(*status = MEMORY_ALLOCATION);
+    }
+ 
+    inVarCols = malloc(infptr->Fptr->tfield*sizeof(int));
+    outVarCols = malloc(outfptr->Fptr->tfield*sizeof(int));
+    fffvcl(infptr, &nInVarCols, inVarCols, status);
+    fffvcl(outfptr, &nOutVarCols, outVarCols, status);
+    if (nInVarCols != nOutVarCols)
+       varColDiff=1;
+    else
+    {
+       for (ii=0; ii<nInVarCols; ++ii)
+       {
+          if (inVarCols[ii] != outVarCols[ii])
+          {
+             varColDiff=1;
+             break;
+          }
+       }
+    }
+    
+    if (varColDiff)
+    {
+       ffpmsg("Input and output tables have different variable columns (ffcprw)");
+       *status = BAD_COL_NUM;
+       goto CLEANUP_RETURN;
+    }
+    
+    jj = outnaxis2 + 1;
+    if (nInVarCols)
+    {
+      if (row_status) {
+	for (n_good_rows = 0, ii = 0; ii < nrows; ii++) {
+	  if (row_status[ii]) n_good_rows++; 
+	}
+      }
+
+       ffirow(outfptr, outnaxis2, n_good_rows, status);
+       for (ii = firstrow, i0 = 0; i0 < nrows; i0++, ii++)
+       {
+	  /* Ignore rows with row_status[] == 0 */
+	  if (row_status && !row_status[i0]) continue;
+
+          fits_read_tblbytes (infptr, ii, 1, innaxis1, buffer, status);
+          fits_write_tblbytes(outfptr, jj, 1, innaxis1, buffer, status);
+          /* Now make corrections for variable length columns */
+          iVarCol=0;
+          colptr = (infptr->Fptr)->tableptr;
+          for (icol=0; icol<(infptr->Fptr)->tfield; ++icol)
+          {
+             if (iVarCol < nInVarCols && inVarCols[iVarCol] == icol+1)
+             {
+                /* Copy from a variable length column */
+                
+                ffgdesll(infptr, icol+1, ii, &hrepeat, &hoffset, status);
+                /* If this is a bit column, hrepeat will be number of
+                   bits, not bytes. If it is a string column, hrepeat
+		   is the number of bytes, twidth is the max col width 
+		   and can be ignored.*/
+                if (colptr->tdatatype == -TBIT)
+		{
+		   nVarBytes = (hrepeat+7)/8;
+		}
+		else if (colptr->tdatatype == -TSTRING)
+		{
+		   nVarBytes = hrepeat;
+		}
+		else
+		{
+		   nVarBytes = hrepeat*colptr->twidth*sizeof(char);
+		}
+                inPos = (infptr->Fptr)->datastart + (infptr->Fptr)->heapstart
+				+ hoffset;
+		outPos = (outfptr->Fptr)->datastart + (outfptr->Fptr)->heapstart
+				+ (outfptr->Fptr)->heapsize;
+                ffmbyt(infptr, inPos, REPORT_EOF, status);
+		/* If this is not the last HDU in the file, then check if */
+		/* extending the heap would overwrite the following header. */
+		/* If so, then have to insert more blocks. */
+                if ( !((outfptr->Fptr)->lasthdu) )
+                {
+		   if (outPos+nVarBytes > 
+		      (outfptr->Fptr)->headstart[(outfptr->Fptr)->curhdu+1])
+		   {
+		      nNewBlocks = (long)(((outPos+nVarBytes - 1 -
+                        (outfptr->Fptr)->headstart[(outfptr->Fptr)->
+                        curhdu+1]) / 2880) + 1);
+                      if (ffiblk(outfptr, nNewBlocks, 1, status) > 0)
+                      {
+                         ffpmsg("Failed to extend the size of the variable length heap (ffcprw)");
+			 goto CLEANUP_RETURN;
+                      }
+
+		   }
+                }
+                if (nVarBytes)
+		{
+		   if (nVarBytes > nVarAllocBytes)
+		   {
+		     /* Grow the copy buffer to accomodate the new maximum size. 
+			Note it is safe to call realloc() with null input pointer, 
+			which is equivalent to malloc(). */
+		     unsigned char *varColBuff1 = (unsigned char *) realloc(varColBuff, nVarBytes);
+		     if (! varColBuff1)
+		     {
+		       *status = MEMORY_ALLOCATION;
+		       ffpmsg("failed to allocate memory for variable column copy (ffcprw)");
+		       goto CLEANUP_RETURN;
+		     }
+		     /* Record the new state */
+		     varColBuff = varColBuff1;
+		     nVarAllocBytes = nVarBytes;
+		   }
+		   /* Copy date from input to output */
+                   ffgbyt(infptr, nVarBytes, varColBuff, status);
+		   ffmbyt(outfptr, outPos, IGNORE_EOF, status);
+                   ffpbyt(outfptr, nVarBytes, varColBuff, status);
+		}
+		ffpdes(outfptr, icol+1, jj, hrepeat, (outfptr->Fptr)->heapsize, status);
+                (outfptr->Fptr)->heapsize += nVarBytes;
+                ++iVarCol;
+             }
+             ++colptr;
+          }
+          ++jj;
+       }
+    }
+    else
+    {    
+       /* copy the rows, 1 at a time */
+       n_good_rows = 0;
+       for (ii = firstrow, i0 = 0; i0 < nrows; i0++, ii++)
+       {
+	  /* Ignore rows with row_status[] == 0 */
+	  if (row_status && !row_status[i0]) continue;
+
+           fits_read_tblbytes (infptr,  ii, 1, innaxis1, buffer, status);
+           fits_write_tblbytes(outfptr, jj, 1, innaxis1, buffer, status);
+	   n_good_rows ++;
+           jj++;
+       }
+    }
+    outnaxis2 += n_good_rows;
+    fits_update_key(outfptr, TLONGLONG, "NAXIS2", &outnaxis2, 0, status);
+
+ CLEANUP_RETURN:
+    free(buffer);
+    free(inVarCols);
+    free(outVarCols);
+    if (varColBuff) free(varColBuff);
+    return(*status);
+}
+/*--------------------------------------------------------------------------*/
 int ffcpky(fitsfile *infptr,    /* I - FITS file pointer to input file  */
            fitsfile *outfptr,   /* I - FITS file pointer to output file */
            int incol,           /* I - input index number   */
            int outcol,          /* I - output index number  */
            char *rootname,      /* I - root name of the keyword to be copied */
            int *status)         /* IO - error status     */
 /*
@@ -2821,15 +3103,16 @@
            int *colnums,     /* O - 1-based variable column positions       */
            int *status)      /* IO - error status                           */
 {
 /*
    Internal function to identify which columns in a binary table are variable length.
    The colnums array will be filled with nvarcols elements - the 1-based numbers
    of all variable length columns in the table.  This ASSUMES calling function
-   has passed in a colnums array large enough to hold these.
+   has passed in a colnums array large enough to hold these (colnums==NULL also 
+   allowed).
 */
    int tfields=0,icol;
    tcolumn *colptr=0;
    
    *nvarcols = 0;
    if (*status > 0)
        return(*status);
@@ -2845,16 +3128,16 @@
       colptr = (fptr->Fptr)->tableptr;
       tfields = (fptr->Fptr)->tfield;
       for (icol=0; icol<tfields; ++icol, ++colptr)
       {
          /* Condition for variable length column: negative tdatatype */
          if (colptr->tdatatype < 0)
          {
-            colnums[*nvarcols] = icol + 1;
-            *nvarcols += 1;            
+	    if (colnums) colnums[*nvarcols] = icol + 1;
+	    *nvarcols += 1;            
          }
       }      
    }   
    return(*status);
 }
 
 /*--------------------------------------------------------------------------*/
```

### Comparing `fitsio-1.1.9/cfitsio3490/edithdu.c` & `fitsio-1.2.0/cfitsio-4.2.0/edithdu.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/eval.l` & `fitsio-1.2.0/cfitsio-4.2.0/eval.l`

 * *Files 10% similar despite different names*

```diff
@@ -1,12 +1,20 @@
-%{
 /************************************************************************/
 /*                                                                      */
 /*                       CFITSIO Lexical Parser                         */
 /*                                                                      */
+
+/* This specifies a thread-safe reentrant version of lex functions */
+%option reentrant
+/* This specifies CFITSIO-unique names for lexer functions */
+%option prefix="fits_parser_yy"
+/* This facilitates calling between the Bison parser and this lexer */
+%option bison-bridge
+
+%{
 /* This file is one of 3 files containing code which parses an          */
 /* arithmetic expression and evaluates it in the context of an input    */
 /* FITS file table extension.  The CFITSIO lexical parser is divided    */
 /* into the following 3 parts/files: the CFITSIO "front-end",           */
 /* eval_f.c, contains the interface between the user/CFITSIO and the    */
 /* real core of the parser; the FLEX interpreter, eval_l.c, takes the   */
 /* input string and parses it into tokens and identifies the FITS       */
@@ -54,23 +62,26 @@
 #include <ctype.h>
 #ifdef sparc
 #include <malloc.h>
 #else
 #include <stdlib.h>
 #endif
 #include "eval_defs.h"
+#include "eval_tab.h"
 
-ParseData gParse;     /* Global structure holding all parser information     */
+/* This is a shorthand accessor to get at the "extra" data inside the
+   lexer, which in our case is the lParse (ParseData) structure */
+#define yylParse (yyextra)
 
 /*****  Internal functions  *****/
 
-       int yyGetVariable( char *varName, YYSTYPE *varVal );
+       int fits_parser_yyGetVariable( ParseData *lParse, char *varName, FITS_PARSER_YYSTYPE *varVal );
 
-static int find_variable( char *varName );
-static int expr_read( char *buf, int nbytes );
+static int find_variable( ParseData *lParse, char *varName );
+static int expr_read( ParseData *lParse, char *buf, int nbytes );
 
 /*****  Definitions  *****/
 
 #define YY_NO_UNPUT   /*  Don't include YYUNPUT function  */
 #define YY_NEVER_INTERACTIVE 1
 
 #define MAXCHR 256
@@ -107,18 +118,19 @@
 /* 
    MJT - 13 June 1996
    read from buffer instead of stdin
    (as per old ftools.skel)
 */
 #undef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-        if ( (result = expr_read( (char *) buf, max_size )) < 0 ) \
+        if ( (result = expr_read( yylParse, (char *) buf, max_size )) < 0 ) \
             YY_FATAL_ERROR( "read() in flex scanner failed" );
 
 %}
+
 bit		([bB][01xX]+)
 oct		([oO][01234567xX]+)
 hex		([hH][0123456789aAbBcCdDeEfFxX]+)
 bitconst        (0b[01]+)
 hexconst        (0x[0123456789aAbBcCdDeEfF]+)
 octconst        (0o]+)
 integer		[0-9]+
@@ -148,26 +160,26 @@
 [ \t]+     ;
 {bit}		{
                   int len;
                   len = strlen(yytext);
 		  while (yytext[len] == ' ')
 			len--;
                   len = len - 1;
-		  strncpy(yylval.str,&yytext[1],len);
-		  yylval.str[len] = '\0';
+		  strncpy(yylval->str,&yytext[1],len);
+		  yylval->str[len] = '\0';
 		  return( BITSTR );
 		}
 {oct}		{
                   int len;
                   char tmpstring[256];
                   char bitstring[256];
                   len = strlen(yytext);
 		  if (len >= 256) {
 		    char errMsg[100];
-		    gParse.status = PARSE_SYNTAX_ERR;
+		    yylParse->status = PARSE_SYNTAX_ERR;
 		    strcpy (errMsg,"Bit string exceeds maximum length: '");
 		    strncat(errMsg, &(yytext[0]), 20);
 		    strcat (errMsg,"...'");
 		    ffpmsg (errMsg);
 		    len = 0;
 		  } else {
 		    while (yytext[len] == ' ')
@@ -209,25 +221,25 @@
 			       case 'x':
 			       case 'X':
 					strcat(bitstring,OCT_X);
 					break;
 			      }
 			len++;
                        }
-                  strcpy( yylval.str, bitstring );
+                  strcpy( yylval->str, bitstring );
 		  return( BITSTR );
 		}
 {hex}		{
                   int len;
                   char tmpstring[256];
                   char bitstring[256];
                   len = strlen(yytext);
 		  if (len >= 256) {
 		    char errMsg[100];
-		    gParse.status = PARSE_SYNTAX_ERR;
+		    yylParse->status = PARSE_SYNTAX_ERR;
 		    strcpy (errMsg,"Hex string exceeds maximum length: '");
 		    strncat(errMsg, &(yytext[0]), 20);
 		    strcat (errMsg,"...'");
 		    ffpmsg (errMsg);
 		    len = 0;
 		  } else {
 		    while (yytext[len] == ' ')
@@ -300,137 +312,145 @@
 			       case 'X':
 					strcat(bitstring,HEX_X);
 					break;
 			      }
 			len++;
                        }
 
-                  strcpy( yylval.str, bitstring );
+                  strcpy( yylval->str, bitstring );
 		  return( BITSTR );
 		}
 {bitconst}      {
 		  long int constval = 0;
 		  char *p;
 		  for (p = &(yytext[2]); *p; p++) {
 		    constval = (constval << 1) | (*p == '1');
 		  }
-		  yylval.lng = constval;
+		  yylval->lng = constval;
 		  return( LONG );
 		}
 {octconst}      {
 		  long int constval = 0;
 		  char *p;
 		  for (p = &(yytext[2]); *p; p++) {
 		    constval = (constval << 3) | (*p - '0');
 		  }
-		  yylval.lng = constval;
+		  yylval->lng = constval;
 		  return( LONG );
 		}
 {hexconst}      {
 		  long int constval = 0;
 		  char *p;
 		  for (p = &(yytext[2]); *p; p++) {
                     int v = (isdigit(*p) ? (*p - '0') : (*p - 'a' + 10));
                     constval = (constval << 4) | v;
 		  }
-		  yylval.lng = constval;
+		  yylval->lng = constval;
 		  return( LONG );
 		}
 
                   
 {integer}	{
-                  yylval.lng = atol(yytext);
+                  yylval->lng = atol(yytext);
 		  return( LONG );
 		}
 {boolean}	{
                   if ((yytext[0] == 't') || (yytext[0] == 'T'))
-		    yylval.log = 1;
+		    yylval->log = 1;
 		  else
-		    yylval.log = 0;
+		    yylval->log = 0;
 		  return( BOOLEAN );
 		}
 {real}		{
-                  yylval.dbl = atof(yytext);
+                  yylval->dbl = atof(yytext);
 		  return( DOUBLE );
 		}
 {constant}	{
                   if(        !fits_strcasecmp(yytext,"#PI") ) {
-		     yylval.dbl = (double)(4) * atan((double)(1));
+		     yylval->dbl = (double)(4) * atan((double)(1));
 		     return( DOUBLE );
 		  } else if( !fits_strcasecmp(yytext,"#E") ) {
-		     yylval.dbl = exp((double)(1));
+		     yylval->dbl = exp((double)(1));
 		     return( DOUBLE );
 		  } else if( !fits_strcasecmp(yytext,"#DEG") ) {
-		     yylval.dbl = ((double)4)*atan((double)1)/((double)180);
+		     yylval->dbl = ((double)4)*atan((double)1)/((double)180);
 		     return( DOUBLE );
 		  } else if( !fits_strcasecmp(yytext,"#ROW") ) {
 		     return( ROWREF );
 		  } else if( !fits_strcasecmp(yytext,"#NULL") ) {
 		     return( NULLREF );
 		  } else if( !fits_strcasecmp(yytext,"#SNULL") ) {
 		     return( SNULLREF );
 		  } else {
                      int len; 
+		     int result;
                      if (yytext[1] == '$') {
                         len = strlen(yytext) - 3;
-                        yylval.str[0]     = '#';
-                        strncpy(yylval.str+1,&yytext[2],len);
-                        yylval.str[len+1] = '\0';
-                        yytext = yylval.str;
+                        yylval->str[0]     = '#';
+                        strncpy(yylval->str+1,&yytext[2],len);
+                        yylval->str[len+1] = '\0';
+                        yytext = yylval->str;
 		     }
-                     return( (*gParse.getData)(yytext, &yylval) );
+                     result = (*yylParse->getData)(yylParse, yytext, (yylval));
+		     return result;
                   }
                 }
 {string}	{
                   int len;
                   len = strlen(yytext) - 2;
 		  if (len >= MAX_STRLEN) {
 		    char errMsg[100];
-		    gParse.status = PARSE_SYNTAX_ERR;
+		    yylParse->status = PARSE_SYNTAX_ERR;
 		    strcpy (errMsg,"String exceeds maximum length: '");
 		    strncat(errMsg, &(yytext[1]), 20);
 		    strcat (errMsg,"...'");
 		    ffpmsg (errMsg);
 		    len = 0;
 		  } else {
-		    strncpy(yylval.str,&yytext[1],len);
+		    strncpy(yylval->str,&yytext[1],len);
 		  }
-		  yylval.str[len] = '\0';
+		  yylval->str[len] = '\0';
 		  return( STRING );
 		}
 {variable}	{
 		 int    len,type;
 
                  if (yytext[0] == '$') {
 		    len = strlen(yytext) - 2;
-		    strncpy(yylval.str,&yytext[1],len);
-		    yylval.str[len] = '\0';
-		    yytext = yylval.str;
+		    strncpy(yylval->str,&yytext[1],len);
+		    yylval->str[len] = '\0';
+		    yytext = yylval->str;
 		 } 
-		 type = yyGetVariable(yytext, &yylval);
+		 type = fits_parser_yyGetVariable(yylParse, yytext, (yylval));
 		 return( type );
 		}
 {function}	{
                   char *fname;
 		  int len=0;
-                  fname = &yylval.str[0];
+                  fname = &(yylval->str[0]);
 		  while( (fname[len]=toupper(yytext[len])) ) len++;
 
                   if(      FSTRCMP(fname,"BOX(")==0 
                         || FSTRCMP(fname,"CIRCLE(")==0 
                         || FSTRCMP(fname,"ELLIPSE(")==0 
                         || FSTRCMP(fname,"NEAR(")==0 
                         || FSTRCMP(fname,"ISNULL(")==0 
                          )
                      /* Return type is always boolean  */
 		     return( BFUNCTION );
 
                   else if( FSTRCMP(fname,"GTIFILTER(")==0 )
                      return( GTIFILTER );
 
+                  else if( FSTRCMP(fname,"GTIOVERLAP(")==0 )
+                     return( GTIOVERLAP );
+
+                  else if( FSTRCMP(fname,"GTIFIND(")==0 )
+                     return( GTIFIND );
+
                   else if( FSTRCMP(fname,"REGFILTER(")==0 )
                      return( REGFILTER );
 
                   else if( FSTRCMP(fname,"STRSTR(")==0 )
                      return( IFUNCTION );  /* Returns integer */
 
                   else 
@@ -449,15 +469,15 @@
 {greater_eq}	{ return( GTE     ); }
 {lesser_eq}	{ return( LTE     ); }
 {xor}           { return( XOR     ); }
 {nl}		{ return( '\n'    ); }
 .		{ return( yytext[0] ); }
 %%
 
-int yywrap()
+int yywrap(yyscan_t scanner)
 {
   /* MJT -- 13 June 1996
      Supplied for compatibility with
      pre-2.5.1 versions of flex which
      do not recognize %option noyywrap 
   */
   return(1);
@@ -469,71 +489,71 @@
    no .skel file necessary! MJT - 13 June 1996
 
    keep a memory of how many bytes have been
    read previously, so that an unlimited-sized
    buffer can be supported. PDW - 28 Feb 1998
 */
 
-static int expr_read(char *buf, int nbytes)
+static int expr_read(ParseData *lParse, char *buf, int nbytes)
 {
  int n;
  
  n = 0;
- if( !gParse.is_eobuf ) {
+ if( !lParse->is_eobuf ) {
      do {
-        buf[n++] = gParse.expr[gParse.index++];
-       } while ((n<nbytes)&&(gParse.expr[gParse.index] != '\0'));
-     if( gParse.expr[gParse.index] == '\0' ) gParse.is_eobuf = 1;
+        buf[n++] = lParse->expr[lParse->index++];
+       } while ((n<nbytes)&&(lParse->expr[lParse->index] != '\0'));
+     if( lParse->expr[lParse->index] == '\0' ) lParse->is_eobuf = 1;
  }
  buf[n] = '\0';
  return(n);
 }
 
-int yyGetVariable( char *varName, YYSTYPE *thelval )
+int fits_parser_yyGetVariable( ParseData *lParse, char *varName, FITS_PARSER_YYSTYPE *thelval )
 {
    int varNum, type;
    char errMsg[MAXVARNAME+25];
 
-   varNum = find_variable( varName );
+   varNum = find_variable( lParse, varName );
    if( varNum<0 ) {
-      if( gParse.getData ) {
-	 type = (*gParse.getData)( varName, thelval );
+      if( lParse->getData ) {
+	 type = (*lParse->getData)( lParse, varName, thelval );
       } else {
 	 type = pERROR;
-	 gParse.status = PARSE_SYNTAX_ERR;
+	 lParse->status = PARSE_SYNTAX_ERR;
 	 strcpy (errMsg,"Unable to find data: ");
 	 strncat(errMsg, varName, MAXVARNAME);
 	 ffpmsg (errMsg);
       }
    } else {
       /*  Convert variable type into expression type  */
-      switch( gParse.varData[ varNum ].type ) {
+      switch( lParse->varData[ varNum ].type ) {
       case LONG:
       case DOUBLE:   type =  COLUMN;  break;
       case BOOLEAN:  type = BCOLUMN;  break;
       case STRING:   type = SCOLUMN;  break;
       case BITSTR:   type =  BITCOL;  break;
       default:
 	 type = pERROR;
-	 gParse.status = PARSE_SYNTAX_ERR;
+	 lParse->status = PARSE_SYNTAX_ERR;
 	 strcpy (errMsg,"Bad datatype for data: ");
 	 strncat(errMsg, varName, MAXVARNAME);
 	 ffpmsg (errMsg);
 	 break;
       }
       thelval->lng = varNum;
    }
    return( type );
 }
 
-static int find_variable(char *varName)
+static int find_variable(ParseData *lParse, char *varName)
 {
    int i;
  
-   if( gParse.nCols )
-      for( i=0; i<gParse.nCols; i++ ) {
-         if( ! fits_strncasecmp(gParse.varData[i].name,varName,MAXVARNAME) ) {
+   if( lParse->nCols )
+      for( i=0; i<lParse->nCols; i++ ) {
+         if( ! fits_strncasecmp(lParse->varData[i].name,varName,MAXVARNAME) ) {
             return( i );
          }
       }
    return( -1 );
 }
```

### Comparing `fitsio-1.1.9/cfitsio3490/eval.y` & `fitsio-1.2.0/cfitsio-4.2.0/eval.y`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,23 @@
-%{
 /************************************************************************/
 /*                                                                      */
 /*                       CFITSIO Lexical Parser                         */
 /*                                                                      */
+
+/* All functions preceeded by fits_parser_yy for uniqueness             */
+%define api.prefix {fits_parser_yy}
+
+/* Pure reentrant parser                                                */
+%define api.pure full
+/* Lexer called with extra state variable                               */
+%param { yyscan_t scanner }
+/* Parser called with extra parse state variable                        */
+%parse-param { ParseData *lParse }
+
+%{
 /* This file is one of 3 files containing code which parses an          */
 /* arithmetic expression and evaluates it in the context of an input    */
 /* FITS file table extension.  The CFITSIO lexical parser is divided    */
 /* into the following 3 parts/files: the CFITSIO "front-end",           */
 /* eval_f.c, contains the interface between the user/CFITSIO and the    */
 /* real core of the parser; the FLEX interpreter, eval_l.c, takes the   */
 /* input string and parses it into tokens and identifies the FITS       */
@@ -61,14 +72,15 @@
 /*  Craig B Markwardt Sum 2006  Add RANDOMN() and RANDOMP() functions   */
 /*  Craig B Markwardt Mar 2007  Allow arguments to RANDOM and RANDOMN to*/
 /*                              determine the output dimensions         */
 /*  Craig B Markwardt Aug 2009  Add substring STRMID() and string search*/
 /*                              STRSTR() functions; more overflow checks*/
 /*  Craig B Markwardt Dec 2019  Add bit/hex/oct literal strings and     */
 /*                              bitwise operatiosn between integers     */
+/*  Craig B Markwardt Mar 2021  Add SETNULL() function                  */
 /*                                                                      */
 /************************************************************************/
 
 #define  APPROX 1.0e-7
 #include "eval_defs.h"
 #include "region.h"
 #include <time.h>
@@ -107,87 +119,93 @@
    while (0)
 
 /***************************************************************/
 /*  Useful macros for accessing/testing Nodes                  */
 /***************************************************************/
 
 #define TEST(a)        if( (a)<0 ) YYERROR
-#define SIZE(a)        gParse.Nodes[ a ].value.nelem
-#define TYPE(a)        gParse.Nodes[ a ].type
-#define OPER(a)        gParse.Nodes[ a ].operation
+#define SIZE(a)        lParse->Nodes[ a ].value.nelem
+#define TYPE(a)        lParse->Nodes[ a ].type
+#define OPER(a)        lParse->Nodes[ a ].operation
 #define PROMOTE(a,b)   if( TYPE(a) > TYPE(b) )                  \
-                          b = New_Unary( TYPE(a), 0, b );       \
+                          b = New_Unary( lParse, TYPE(a), 0, b );       \
                        else if( TYPE(a) < TYPE(b) )             \
-	                  a = New_Unary( TYPE(b), 0, a );
+	                  a = New_Unary( lParse, TYPE(b), 0, a );
 
 /*****  Internal functions  *****/
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-static int  Alloc_Node    ( void );
-static void Free_Last_Node( void );
-static void Evaluate_Node ( int thisNode );
-
-static int  New_Const ( int returnType, void *value, long len );
-static int  New_Column( int ColNum );
-static int  New_Offset( int ColNum, int offset );
-static int  New_Unary ( int returnType, int Op, int Node1 );
-static int  New_BinOp ( int returnType, int Node1, int Op, int Node2 );
-static int  New_Func  ( int returnType, funcOp Op, int nNodes,
+static int  Alloc_Node    ( ParseData * );
+static void Free_Last_Node( ParseData * );
+static void Evaluate_Node ( ParseData *, int thisNode );
+
+static int  New_Const ( ParseData *, int returnType, void *value, long len );
+static int  New_Column( ParseData *, int ColNum );
+static int  New_Offset( ParseData *, int ColNum, int offset );
+static int  New_Unary ( ParseData *, int returnType, int Op, int Node1 );
+static int  New_BinOp ( ParseData *, int returnType, int Node1, int Op, int Node2 );
+static int  New_Func  ( ParseData *, int returnType, funcOp Op, int nNodes,
 			int Node1, int Node2, int Node3, int Node4, 
 			int Node5, int Node6, int Node7 );
-static int  New_FuncSize( int returnType, funcOp Op, int nNodes,
+static int  New_FuncSize( ParseData *, int returnType, funcOp Op, int nNodes,
 			int Node1, int Node2, int Node3, int Node4, 
 			  int Node5, int Node6, int Node7, int Size);
-static int  New_Deref ( int Var,  int nDim,
+static int  New_Deref ( ParseData *, int Var,  int nDim,
 			int Dim1, int Dim2, int Dim3, int Dim4, int Dim5 );
-static int  New_GTI   ( char *fname, int Node1, char *start, char *stop );
-static int  New_REG   ( char *fname, int NodeX, int NodeY, char *colNames );
-static int  New_Vector( int subNode );
-static int  Close_Vec ( int vecNode );
-static int  Locate_Col( Node *this );
-static int  Test_Dims ( int Node1, int Node2 );
-static void Copy_Dims ( int Node1, int Node2 );
-
-static void Allocate_Ptrs( Node *this );
-static void Do_Unary     ( Node *this );
-static void Do_Offset    ( Node *this );
-static void Do_BinOp_bit ( Node *this );
-static void Do_BinOp_str ( Node *this );
-static void Do_BinOp_log ( Node *this );
-static void Do_BinOp_lng ( Node *this );
-static void Do_BinOp_dbl ( Node *this );
-static void Do_Func      ( Node *this );
-static void Do_Deref     ( Node *this );
-static void Do_GTI       ( Node *this );
-static void Do_REG       ( Node *this );
-static void Do_Vector    ( Node *this );
+static int  New_GTI   ( ParseData *, funcOp Op, char *fname, int Node1, int Node2, char *start, char *stop );
+static int  New_REG   ( ParseData *, char *fname, int NodeX, int NodeY, char *colNames );
+static int  New_Vector( ParseData *, int subNode );
+static int  Close_Vec ( ParseData *, int vecNode );
+static int  New_Array(  ParseData *, int valueNode, int dimNode );
+static int  Locate_Col( ParseData *, Node *this );
+static int  Test_Dims ( ParseData *, int Node1, int Node2 );
+static void Copy_Dims ( ParseData *, int Node1, int Node2 );
+
+static void Allocate_Ptrs( ParseData *, Node *this );
+static void Do_Unary     ( ParseData *, Node *this );
+static void Do_Offset    ( ParseData *, Node *this );
+static void Do_BinOp_bit ( ParseData *, Node *this );
+static void Do_BinOp_str ( ParseData *, Node *this );
+static void Do_BinOp_log ( ParseData *, Node *this );
+static void Do_BinOp_lng ( ParseData *, Node *this );
+static void Do_BinOp_dbl ( ParseData *, Node *this );
+static void Do_Func      ( ParseData *, Node *this );
+static void Do_Deref     ( ParseData *, Node *this );
+static void Do_GTI       ( ParseData *, Node *this );
+static void Do_GTI_Over  ( ParseData *, Node *this );
+static void Do_REG       ( ParseData *, Node *this );
+static void Do_Vector    ( ParseData *, Node *this );
+static void Do_Array     ( ParseData *, Node *this );
 
 static long Search_GTI   ( double evtTime, long nGTI, double *start,
-			   double *stop, int ordered );
+			   double *stop, int ordered, long *nextGTI );
+static double GTI_Over(double evtStart, double evtStop,
+		       long nGTI, double *start, double *stop,
+		       long *gtiout);
 
 static char  saobox (double xcen, double ycen, double xwid, double ywid,
 		     double rot,  double xcol, double ycol);
 static char  ellipse(double xcen, double ycen, double xrad, double yrad,
 		     double rot, double xcol, double ycol);
 static char  circle (double xcen, double ycen, double rad,
 		     double xcol, double ycol);
 static char  bnear  (double x, double y, double tolerance);
 static char  bitcmp (char *bitstrm1, char *bitstrm2);
 static char  bitlgte(char *bits1, int oper, char *bits2);
 
 static void  bitand(char *result, char *bitstrm1, char *bitstrm2);
 static void  bitor (char *result, char *bitstrm1, char *bitstrm2);
 static void  bitnot(char *result, char *bits);
-static int cstrmid(char *dest_str, int dest_len,
+static int cstrmid(ParseData *lParse, char *dest_str, int dest_len,
 		   char *src_str,  int src_len, int pos);
 
-static void  yyerror(char *msg);
+static void yyerror(yyscan_t scanner, ParseData *lParse, char *s);
 
 #ifdef __cplusplus
     }
 #endif
 
 %}
 
@@ -204,14 +222,16 @@
 %token <dbl>   DOUBLE
 %token <str>   STRING
 %token <str>   BITSTR
 %token <str>   FUNCTION
 %token <str>   BFUNCTION      /* Bit function */
 %token <str>   IFUNCTION      /* Integer function */
 %token <str>   GTIFILTER
+%token <str>   GTIOVERLAP
+%token <str>   GTIFIND
 %token <str>   REGFILTER
 %token <lng>   COLUMN
 %token <lng>   BCOLUMN
 %token <lng>   SCOLUMN
 %token <lng>   BITCOL
 %token <lng>   ROWREF
 %token <lng>   NULLREF
@@ -246,1105 +266,1239 @@
 lines:   /* nothing ; was | lines line */
        | lines line
        ;
 
 line:           '\n' {}
        | expr   '\n'
                 { if( $1<0 ) {
-		     yyerror("Couldn't build node structure: out of memory?");
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
 		     YYERROR;  }
-                  gParse.resultNode = $1;
+                  lParse->resultNode = $1;
 		}
        | bexpr  '\n'
                 { if( $1<0 ) {
-		     yyerror("Couldn't build node structure: out of memory?");
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
 		     YYERROR;  }
-                  gParse.resultNode = $1;
+                  lParse->resultNode = $1;
 		}
        | sexpr  '\n'
                 { if( $1<0 ) {
-		     yyerror("Couldn't build node structure: out of memory?");
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
 		     YYERROR;  } 
-                  gParse.resultNode = $1;
+                  lParse->resultNode = $1;
 		}
        | bits   '\n'
                 { if( $1<0 ) {
-		     yyerror("Couldn't build node structure: out of memory?");
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
 		     YYERROR;  }
-                  gParse.resultNode = $1;
+                  lParse->resultNode = $1;
 		}
        | error  '\n' {  yyerrok;  }
        ;
 
 bvector: '{' bexpr
-                { $$ = New_Vector( $2 ); TEST($$); }
+                { $$ = New_Vector(lParse,  $2 ); TEST($$); }
        | bvector ',' bexpr
                 {
-                  if( gParse.Nodes[$1].nSubNodes >= MAXSUBS ) {
-		     $1 = Close_Vec( $1 ); TEST($1);
-		     $$ = New_Vector( $1 ); TEST($$);
+                  if( lParse->Nodes[$1].nSubNodes >= MAXSUBS ) {
+		     $1 = Close_Vec(lParse,  $1 ); TEST($1);
+		     $$ = New_Vector(lParse,  $1 ); TEST($$);
                   } else {
                      $$ = $1;
                   }
-		  gParse.Nodes[$$].SubNodes[ gParse.Nodes[$$].nSubNodes++ ]
+		  lParse->Nodes[$$].SubNodes[ lParse->Nodes[$$].nSubNodes++ ]
 		     = $3;
                 }
        ;
 
 vector:  '{' expr
-                { $$ = New_Vector( $2 ); TEST($$); }
+                { $$ = New_Vector(lParse,  $2 ); TEST($$); }
        | vector ',' expr
                 {
                   if( TYPE($1) < TYPE($3) )
                      TYPE($1) = TYPE($3);
-                  if( gParse.Nodes[$1].nSubNodes >= MAXSUBS ) {
-		     $1 = Close_Vec( $1 ); TEST($1);
-		     $$ = New_Vector( $1 ); TEST($$);
+                  if( lParse->Nodes[$1].nSubNodes >= MAXSUBS ) {
+		     $1 = Close_Vec(lParse,  $1 ); TEST($1);
+		     $$ = New_Vector(lParse,  $1 ); TEST($$);
                   } else {
                      $$ = $1;
                   }
-		  gParse.Nodes[$$].SubNodes[ gParse.Nodes[$$].nSubNodes++ ]
+		  lParse->Nodes[$$].SubNodes[ lParse->Nodes[$$].nSubNodes++ ]
 		     = $3;
                 }
        | vector ',' bexpr
                 {
-                  if( gParse.Nodes[$1].nSubNodes >= MAXSUBS ) {
-		     $1 = Close_Vec( $1 ); TEST($1);
-		     $$ = New_Vector( $1 ); TEST($$);
+                  if( lParse->Nodes[$1].nSubNodes >= MAXSUBS ) {
+		     $1 = Close_Vec(lParse,  $1 ); TEST($1);
+		     $$ = New_Vector(lParse,  $1 ); TEST($$);
                   } else {
                      $$ = $1;
                   }
-		  gParse.Nodes[$$].SubNodes[ gParse.Nodes[$$].nSubNodes++ ]
+		  lParse->Nodes[$$].SubNodes[ lParse->Nodes[$$].nSubNodes++ ]
 		     = $3;
                 }
        | bvector ',' expr
                 {
                   TYPE($1) = TYPE($3);
-                  if( gParse.Nodes[$1].nSubNodes >= MAXSUBS ) {
-		     $1 = Close_Vec( $1 ); TEST($1);
-		     $$ = New_Vector( $1 ); TEST($$);
+                  if( lParse->Nodes[$1].nSubNodes >= MAXSUBS ) {
+		     $1 = Close_Vec(lParse,  $1 ); TEST($1);
+		     $$ = New_Vector(lParse,  $1 ); TEST($$);
                   } else {
                      $$ = $1;
                   }
-		  gParse.Nodes[$$].SubNodes[ gParse.Nodes[$$].nSubNodes++ ]
+		  lParse->Nodes[$$].SubNodes[ lParse->Nodes[$$].nSubNodes++ ]
 		     = $3;
                 }
        ;
 
 expr:    vector '}'
-                { $$ = Close_Vec( $1 ); TEST($$); }
+                { $$ = Close_Vec(lParse,  $1 ); TEST($$); }
        ;
 
 bexpr:   bvector '}'
-                { $$ = Close_Vec( $1 ); TEST($$); }
+                { $$ = Close_Vec(lParse,  $1 ); TEST($$); }
        ;
 
 bits:	 BITSTR
                 {
-                  $$ = New_Const( BITSTR, $1, strlen($1)+1 ); TEST($$);
+                  $$ = New_Const(lParse,  BITSTR, $1, strlen($1)+1 ); TEST($$);
 		  SIZE($$) = strlen($1); }
        | BITCOL
-                { $$ = New_Column( $1 ); TEST($$); }
+                { $$ = New_Column(lParse,  $1 ); TEST($$); }
        | BITCOL '{' expr '}'
                 {
                   if( TYPE($3) != LONG
 		      || OPER($3) != CONST_OP ) {
-		     yyerror("Offset argument must be a constant integer");
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
 		     YYERROR;
 		  }
-                  $$ = New_Offset( $1, $3 ); TEST($$);
+                  $$ = New_Offset(lParse,  $1, $3 ); TEST($$);
                 }
        | bits '&' bits
-                { $$ = New_BinOp( BITSTR, $1, '&', $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BITSTR, $1, '&', $3 ); TEST($$);
                   SIZE($$) = ( SIZE($1)>SIZE($3) ? SIZE($1) : SIZE($3) );  }
        | bits '|' bits
-                { $$ = New_BinOp( BITSTR, $1, '|', $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BITSTR, $1, '|', $3 ); TEST($$);
                   SIZE($$) = ( SIZE($1)>SIZE($3) ? SIZE($1) : SIZE($3) );  }
        | bits '+' bits
                 { 
 		  if (SIZE($1)+SIZE($3) >= MAX_STRLEN) {
-		    yyerror("Combined bit string size exceeds " MAX_STRLEN_S " bits");
+		    yyerror(scanner, lParse, "Combined bit string size exceeds " MAX_STRLEN_S " bits");
 		    YYERROR;
 		  }
-		  $$ = New_BinOp( BITSTR, $1, '+', $3 ); TEST($$);
+		  $$ = New_BinOp(lParse,  BITSTR, $1, '+', $3 ); TEST($$);
                   SIZE($$) = SIZE($1) + SIZE($3); 
 		}
        | bits '[' expr ']'
-                { $$ = New_Deref( $1, 1, $3,  0,  0,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 1, $3,  0,  0,  0,   0 ); TEST($$); }
        | bits '[' expr ',' expr ']'
-                { $$ = New_Deref( $1, 2, $3, $5,  0,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 2, $3, $5,  0,  0,   0 ); TEST($$); }
        | bits '[' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 3, $3, $5, $7,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 3, $3, $5, $7,  0,   0 ); TEST($$); }
        | bits '[' expr ',' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 4, $3, $5, $7, $9,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 4, $3, $5, $7, $9,   0 ); TEST($$); }
        | bits '[' expr ',' expr ',' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 5, $3, $5, $7, $9, $11 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 5, $3, $5, $7, $9, $11 ); TEST($$); }
        | NOT bits
-                { $$ = New_Unary( BITSTR, NOT, $2 ); TEST($$);     }
+                { $$ = New_Unary(lParse,  BITSTR, NOT, $2 ); TEST($$);     }
 
        | '(' bits ')'
                 { $$ = $2; }
        ;
 
 expr:    LONG
-                { $$ = New_Const( LONG,   &($1), sizeof(long)   ); TEST($$); }
+                { $$ = New_Const(lParse,  LONG,   &($1), sizeof(long)   ); TEST($$); }
        | DOUBLE
-                { $$ = New_Const( DOUBLE, &($1), sizeof(double) ); TEST($$); }
+                { $$ = New_Const(lParse,  DOUBLE, &($1), sizeof(double) ); TEST($$); }
        | COLUMN
-                { $$ = New_Column( $1 ); TEST($$); }
+                { $$ = New_Column(lParse,  $1 ); TEST($$); }
        | COLUMN '{' expr '}'
                 {
                   if( TYPE($3) != LONG
 		      || OPER($3) != CONST_OP ) {
-		     yyerror("Offset argument must be a constant integer");
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
 		     YYERROR;
 		  }
-                  $$ = New_Offset( $1, $3 ); TEST($$);
+                  $$ = New_Offset(lParse,  $1, $3 ); TEST($$);
                 }
        | ROWREF
-                { $$ = New_Func( LONG, row_fct,  0, 0, 0, 0, 0, 0, 0, 0 ); }
+                { $$ = New_Func(lParse,  LONG, row_fct,  0, 0, 0, 0, 0, 0, 0, 0 ); }
        | NULLREF
-                { $$ = New_Func( LONG, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
+                { $$ = New_Func(lParse,  LONG, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
        | expr '%' expr
-                { PROMOTE($1,$3); $$ = New_BinOp( TYPE($1), $1, '%', $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  TYPE($1), $1, '%', $3 );
 		  TEST($$);                                                }
        | expr '+' expr
-                { PROMOTE($1,$3); $$ = New_BinOp( TYPE($1), $1, '+', $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  TYPE($1), $1, '+', $3 );
 		  TEST($$);                                                }
        | expr '-' expr
-                { PROMOTE($1,$3); $$ = New_BinOp( TYPE($1), $1, '-', $3 ); 
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  TYPE($1), $1, '-', $3 ); 
 		  TEST($$);                                                }
        | expr '*' expr
-                { PROMOTE($1,$3); $$ = New_BinOp( TYPE($1), $1, '*', $3 ); 
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  TYPE($1), $1, '*', $3 ); 
 		  TEST($$);                                                }
        | expr '/' expr
-                { PROMOTE($1,$3); $$ = New_BinOp( TYPE($1), $1, '/', $3 ); 
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  TYPE($1), $1, '/', $3 ); 
 		  TEST($$);                                                }
        | expr '&' expr
                 { 
                    if (TYPE($1) != LONG ||
 		       TYPE($3) != LONG) {
-                     yyerror("Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
+                     yyerror(scanner, lParse, "Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
                       YYERROR;
                    }
-                   $$ = New_BinOp( TYPE($1), $1, '&', $3 );
+                   $$ = New_BinOp(lParse,  TYPE($1), $1, '&', $3 );
                 }
        | expr '|' expr
                 { 
                    if (TYPE($1) != LONG ||
 		       TYPE($3) != LONG) {
-                     yyerror("Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
+                     yyerror(scanner, lParse, "Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
                       YYERROR;
                    }
-                   $$ = New_BinOp( TYPE($1), $1, '|', $3 );
+                   $$ = New_BinOp(lParse,  TYPE($1), $1, '|', $3 );
                 }
        | expr XOR expr
                 { 
                    if (TYPE($1) != LONG ||
 		       TYPE($3) != LONG) {
-                     yyerror("Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
+                     yyerror(scanner, lParse, "Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
                       YYERROR;
                    }
-                   $$ = New_BinOp( TYPE($1), $1, '^', $3 );
+                   $$ = New_BinOp(lParse,  TYPE($1), $1, '^', $3 );
                 }
        | expr POWER expr
-                { PROMOTE($1,$3); $$ = New_BinOp( TYPE($1), $1, POWER, $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  TYPE($1), $1, POWER, $3 );
 		  TEST($$);                                                }
        | '+' expr %prec UMINUS
                 { $$ = $2; }
        | '-' expr %prec UMINUS
-                { $$ = New_Unary( TYPE($2), UMINUS, $2 ); TEST($$); }
+                { $$ = New_Unary(lParse,  TYPE($2), UMINUS, $2 ); TEST($$); }
        |  '(' expr ')'
                 { $$ = $2; }
        | expr '*' bexpr
-                { $3 = New_Unary( TYPE($1), 0, $3 );
-                  $$ = New_BinOp( TYPE($1), $1, '*', $3 ); 
+                { $3 = New_Unary(lParse,  TYPE($1), 0, $3 );
+                  $$ = New_BinOp(lParse,  TYPE($1), $1, '*', $3 ); 
 		  TEST($$);                                }
        | bexpr '*' expr
-                { $1 = New_Unary( TYPE($3), 0, $1 );
-                  $$ = New_BinOp( TYPE($3), $1, '*', $3 );
+                { $1 = New_Unary(lParse,  TYPE($3), 0, $1 );
+                  $$ = New_BinOp(lParse,  TYPE($3), $1, '*', $3 );
                   TEST($$);                                }
        | bexpr '?' expr ':' expr
                 {
                   PROMOTE($3,$5);
-                  if( ! Test_Dims($3,$5) ) {
-                     yyerror("Incompatible dimensions in '?:' arguments");
+                  if( ! Test_Dims( lParse, $3,$5) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
 		     YYERROR;
                   }
-                  $$ = New_Func( 0, ifthenelse_fct, 3, $3, $5, $1,
+                  $$ = New_Func(lParse,  0, ifthenelse_fct, 3, $3, $5, $1,
                                  0, 0, 0, 0 );
                   TEST($$);
-                  if( SIZE($3)<SIZE($5) )  Copy_Dims($$, $5);
+                  if( SIZE($3)<SIZE($5) )  Copy_Dims( lParse,$$, $5);
                   TYPE($1) = TYPE($3);
-                  if( ! Test_Dims($1,$$) ) {
-                     yyerror("Incompatible dimensions in '?:' condition");
+                  if( ! Test_Dims( lParse, $1,$$) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
 		     YYERROR;
                   }
                   TYPE($1) = BOOLEAN;
-                  if( SIZE($$)<SIZE($1) )  Copy_Dims($$, $1);
+                  if( SIZE($$)<SIZE($1) )  Copy_Dims( lParse,$$, $1);
                 }
        | bexpr '?' bexpr ':' expr
                 {
                   PROMOTE($3,$5);
-                  if( ! Test_Dims($3,$5) ) {
-                     yyerror("Incompatible dimensions in '?:' arguments");
+                  if( ! Test_Dims( lParse, $3,$5) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
 		     YYERROR;
                   }
-                  $$ = New_Func( 0, ifthenelse_fct, 3, $3, $5, $1,
+                  $$ = New_Func(lParse,  0, ifthenelse_fct, 3, $3, $5, $1,
                                  0, 0, 0, 0 );
                   TEST($$);
-                  if( SIZE($3)<SIZE($5) )  Copy_Dims($$, $5);
+                  if( SIZE($3)<SIZE($5) )  Copy_Dims( lParse,$$, $5);
                   TYPE($1) = TYPE($3);
-                  if( ! Test_Dims($1,$$) ) {
-                     yyerror("Incompatible dimensions in '?:' condition");
+                  if( ! Test_Dims( lParse, $1,$$) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
 		     YYERROR;
                   }
                   TYPE($1) = BOOLEAN;
-                  if( SIZE($$)<SIZE($1) )  Copy_Dims($$, $1);
+                  if( SIZE($$)<SIZE($1) )  Copy_Dims( lParse,$$, $1);
                 }
        | bexpr '?' expr ':' bexpr
                 {
                   PROMOTE($3,$5);
-                  if( ! Test_Dims($3,$5) ) {
-                     yyerror("Incompatible dimensions in '?:' arguments");
+                  if( ! Test_Dims( lParse, $3,$5) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
 		     YYERROR;
                   }
-                  $$ = New_Func( 0, ifthenelse_fct, 3, $3, $5, $1,
+                  $$ = New_Func(lParse,  0, ifthenelse_fct, 3, $3, $5, $1,
                                  0, 0, 0, 0 );
                   TEST($$);
-                  if( SIZE($3)<SIZE($5) )  Copy_Dims($$, $5);
+                  if( SIZE($3)<SIZE($5) )  Copy_Dims( lParse,$$, $5);
                   TYPE($1) = TYPE($3);
-                  if( ! Test_Dims($1,$$) ) {
-                     yyerror("Incompatible dimensions in '?:' condition");
+                  if( ! Test_Dims( lParse, $1,$$) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
 		     YYERROR;
                   }
                   TYPE($1) = BOOLEAN;
-                  if( SIZE($$)<SIZE($1) )  Copy_Dims($$, $1);
+                  if( SIZE($$)<SIZE($1) )  Copy_Dims( lParse,$$, $1);
                 }
        | FUNCTION ')'
                 { if (FSTRCMP($1,"RANDOM(") == 0) {  /* Scalar RANDOM() */
-                     $$ = New_Func( DOUBLE, rnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
+                     $$ = New_Func(lParse,  DOUBLE, rnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
 		  } else if (FSTRCMP($1,"RANDOMN(") == 0) {/*Scalar RANDOMN()*/
-		     $$ = New_Func( DOUBLE, gasrnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
+		     $$ = New_Func(lParse,  DOUBLE, gasrnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
                   } else {
-                     yyerror("Function() not supported");
+                     yyerror(scanner, lParse, "Function() not supported");
 		     YYERROR;
 		  }
                   TEST($$); 
                 }
        | FUNCTION bexpr ')'
                 { if (FSTRCMP($1,"SUM(") == 0) {
-		     $$ = New_Func( LONG, sum_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+		     $$ = New_Func(lParse,  LONG, sum_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
                   } else if (FSTRCMP($1,"NELEM(") == 0) {
-                     $$ = New_Const( LONG, &( SIZE($2) ), sizeof(long) );
+                     $$ = New_Const(lParse,  LONG, &( SIZE($2) ), sizeof(long) );
                   } else if (FSTRCMP($1,"ACCUM(") == 0) {
 		    long zero = 0;
-		    $$ = New_BinOp( LONG , $2, ACCUM, New_Const( LONG, &zero, sizeof(zero) ));
+		    $$ = New_BinOp(lParse,  LONG , $2, ACCUM, New_Const(lParse,  LONG, &zero, sizeof(zero) ));
 		  } else {
-                     yyerror("Function(bool) not supported");
+                     yyerror(scanner, lParse, "Function(bool) not supported");
+		     YYERROR;
+		  }
+                  TEST($$); 
+		}
+       | FUNCTION bexpr ',' expr ')'
+                { if (FSTRCMP($1,"AXISELEM(") == 0) {  /* AXISELEM(V,n) */
+		     if (OPER($4) != CONST_OP
+			 || SIZE($4) != 1) {
+		       yyerror(scanner, lParse, "AXISELEM second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER($2) == CONST_OP) {
+		       long one = 1;
+		       $$ = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {
+		       if ( TYPE($4) != LONG ) $4 = New_Unary(lParse, LONG, 0, $4);
+		       $$ = New_Func(lParse, 0, axiselem_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
+		       TEST($$);
+		       TYPE($$) = LONG;
+		     }
+		   } else if (FSTRCMP($1,"NAXES(") == 0) {  /* NAXES(V,n) */
+		     if (OPER($4) != CONST_OP
+			 || SIZE($4) != 1) {
+		       yyerror(scanner, lParse, "NAXES second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER($2) == CONST_OP) { /* if V is constant, return 1 in every case */
+		       long one = 1;
+		       $$ = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {                    /* determine now the dimension of the expression */
+		       long iaxis;
+		       int naxis;
+		       if ( TYPE($4) != LONG ) $4 = New_Unary(lParse, LONG, 0, $4);
+		       /* Since it is already constant, we can extract long value directly */
+		       iaxis = (lParse->Nodes[$4].value.data.lng);
+		       naxis = lParse->Nodes[$2].value.naxis;
+
+		       if (iaxis == 0)          iaxis = naxis;   /* NAXIS(V,0) = NAXIS */
+		       else if (iaxis <= naxis) iaxis = lParse->Nodes[$2].value.naxes[iaxis-1]; /* NAXIS(V,n) = NAXISn */
+		       else                     iaxis = 1;       /* Out of bounds use 1 */
+
+		       $$ = New_Const(lParse,  LONG, &iaxis, sizeof(iaxis) );
+		       TEST($$);
+		     }
+		   } else if (FSTRCMP($1,"ARRAY(") == 0) {  /* NAXES(bexpr,n) */
+		     $$ = New_Array(lParse, $2, $4);
+		     TEST($$);
+		  } else {
+                     yyerror(scanner, lParse, "Function(bool,expr) not supported");
 		     YYERROR;
 		  }
                   TEST($$); 
 		}
        | FUNCTION sexpr ')'
                 { if (FSTRCMP($1,"NELEM(") == 0) {
-                     $$ = New_Const( LONG, &( SIZE($2) ), sizeof(long) );
+                     $$ = New_Const(lParse,  LONG, &( SIZE($2) ), sizeof(long) );
 		  } else if (FSTRCMP($1,"NVALID(") == 0) {
-		     $$ = New_Func( LONG, nonnull_fct, 1, $2,
+		     $$ = New_Func(lParse,  LONG, nonnull_fct, 1, $2,
 				    0, 0, 0, 0, 0, 0 );
 		  } else {
-                     yyerror("Function(str) not supported");
+                     yyerror(scanner, lParse, "Function(str) not supported");
 		     YYERROR;
 		  }
                   TEST($$); 
 		}
        | FUNCTION bits ')'
                 { if (FSTRCMP($1,"NELEM(") == 0) {
-                     $$ = New_Const( LONG, &( SIZE($2) ), sizeof(long) );
+                     $$ = New_Const(lParse,  LONG, &( SIZE($2) ), sizeof(long) );
 		} else if (FSTRCMP($1,"NVALID(") == 0) { /* Bit arrays do not have NULL */
-                     $$ = New_Const( LONG, &( SIZE($2) ), sizeof(long) );
+                     $$ = New_Const(lParse,  LONG, &( SIZE($2) ), sizeof(long) );
 		} else if (FSTRCMP($1,"SUM(") == 0) {
-		     $$ = New_Func( LONG, sum_fct, 1, $2,
+		     $$ = New_Func(lParse,  LONG, sum_fct, 1, $2,
 				    0, 0, 0, 0, 0, 0 );
 		} else if (FSTRCMP($1,"MIN(") == 0) {
-		     $$ = New_Func( TYPE($2),  /* Force 1D result */
+		     $$ = New_Func(lParse,  TYPE($2),  /* Force 1D result */
 				    min1_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     /* Note: $2 is a vector so the result can never
 		        be a constant.  Therefore it will never be set
 		        inside New_Func(), and it is safe to set SIZE() */
 		     SIZE($$) = 1;
 		} else if (FSTRCMP($1,"ACCUM(") == 0) {
 		    long zero = 0;
-		    $$ = New_BinOp( LONG , $2, ACCUM, New_Const( LONG, &zero, sizeof(zero) ));
+		    $$ = New_BinOp(lParse,  LONG , $2, ACCUM, New_Const(lParse,  LONG, &zero, sizeof(zero) ));
 		} else if (FSTRCMP($1,"MAX(") == 0) {
-		     $$ = New_Func( TYPE($2),  /* Force 1D result */
+		     $$ = New_Func(lParse,  TYPE($2),  /* Force 1D result */
 				    max1_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     /* Note: $2 is a vector so the result can never
 		        be a constant.  Therefore it will never be set
 		        inside New_Func(), and it is safe to set SIZE() */
 		     SIZE($$) = 1;
 		} else {
-                     yyerror("Function(bits) not supported");
+                     yyerror(scanner, lParse, "Function(bits) not supported");
 		     YYERROR;
 		  }
                   TEST($$); 
 		}
        | FUNCTION expr ')'
                 { if (FSTRCMP($1,"SUM(") == 0)
-		     $$ = New_Func( TYPE($2), sum_fct, 1, $2,
+		     $$ = New_Func(lParse,  TYPE($2), sum_fct, 1, $2,
 				    0, 0, 0, 0, 0, 0 );
 		  else if (FSTRCMP($1,"AVERAGE(") == 0)
-		     $$ = New_Func( DOUBLE, average_fct, 1, $2,
+		     $$ = New_Func(lParse,  DOUBLE, average_fct, 1, $2,
 				    0, 0, 0, 0, 0, 0 );
 		  else if (FSTRCMP($1,"STDDEV(") == 0)
-		     $$ = New_Func( DOUBLE, stddev_fct, 1, $2,
+		     $$ = New_Func(lParse,  DOUBLE, stddev_fct, 1, $2,
 				    0, 0, 0, 0, 0, 0 );
 		  else if (FSTRCMP($1,"MEDIAN(") == 0)
-		     $$ = New_Func( TYPE($2), median_fct, 1, $2,
+		     $$ = New_Func(lParse,  TYPE($2), median_fct, 1, $2,
 				    0, 0, 0, 0, 0, 0 );
 		  else if (FSTRCMP($1,"NELEM(") == 0)
-                     $$ = New_Const( LONG, &( SIZE($2) ), sizeof(long) );
+                     $$ = New_Const(lParse,  LONG, &( SIZE($2) ), sizeof(long) );
 		  else if (FSTRCMP($1,"NVALID(") == 0)
-		     $$ = New_Func( LONG, nonnull_fct, 1, $2,
+		     $$ = New_Func(lParse,  LONG, nonnull_fct, 1, $2,
 				    0, 0, 0, 0, 0, 0 );
 		  else if   ((FSTRCMP($1,"ACCUM(") == 0) && (TYPE($2) == LONG)) {
 		    long zero = 0;
-		    $$ = New_BinOp( LONG ,   $2, ACCUM, New_Const( LONG,   &zero, sizeof(zero) ));
+		    $$ = New_BinOp(lParse,  LONG ,   $2, ACCUM, New_Const(lParse,  LONG,   &zero, sizeof(zero) ));
 		  } else if ((FSTRCMP($1,"ACCUM(") == 0) && (TYPE($2) == DOUBLE)) {
 		    double zero = 0;
-		    $$ = New_BinOp( DOUBLE , $2, ACCUM, New_Const( DOUBLE, &zero, sizeof(zero) ));
+		    $$ = New_BinOp(lParse,  DOUBLE , $2, ACCUM, New_Const(lParse,  DOUBLE, &zero, sizeof(zero) ));
 		  } else if ((FSTRCMP($1,"SEQDIFF(") == 0) && (TYPE($2) == LONG)) {
 		    long zero = 0;
-		    $$ = New_BinOp( LONG ,   $2, DIFF, New_Const( LONG,   &zero, sizeof(zero) ));
+		    $$ = New_BinOp(lParse,  LONG ,   $2, DIFF, New_Const(lParse,  LONG,   &zero, sizeof(zero) ));
 		  } else if ((FSTRCMP($1,"SEQDIFF(") == 0) && (TYPE($2) == DOUBLE)) {
 		    double zero = 0;
-		    $$ = New_BinOp( DOUBLE , $2, DIFF, New_Const( DOUBLE, &zero, sizeof(zero) ));
+		    $$ = New_BinOp(lParse,  DOUBLE , $2, DIFF, New_Const(lParse,  DOUBLE, &zero, sizeof(zero) ));
 		  } else if (FSTRCMP($1,"ABS(") == 0)
-		     $$ = New_Func( 0, abs_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+		     $$ = New_Func(lParse,  0, abs_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
  		  else if (FSTRCMP($1,"MIN(") == 0)
-		     $$ = New_Func( TYPE($2),  /* Force 1D result */
+		     $$ = New_Func(lParse,  TYPE($2),  /* Force 1D result */
 				    min1_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		  else if (FSTRCMP($1,"MAX(") == 0)
-		     $$ = New_Func( TYPE($2),  /* Force 1D result */
+		     $$ = New_Func(lParse,  TYPE($2),  /* Force 1D result */
 				    max1_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		  else if (FSTRCMP($1,"RANDOM(") == 0) { /* Vector RANDOM() */
-                     $$ = New_Func( 0, rnd_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+                     $$ = New_Func(lParse,  0, rnd_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     TEST($$);
 		     TYPE($$) = DOUBLE;
 		  } else if (FSTRCMP($1,"RANDOMN(") == 0) {
-		     $$ = New_Func( 0, gasrnd_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+		     $$ = New_Func(lParse,  0, gasrnd_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     TEST($$);
 		     TYPE($$) = DOUBLE;
+		  } else if (FSTRCMP($1,"ELEMENTNUM(") == 0) {
+		     if (OPER($2) == CONST_OP) {
+		       long one = 1;
+		       $$ = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {
+		       $$ = New_Func(lParse,  0, elemnum_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+		       TEST($$);
+		       TYPE($$) = LONG;
+		     }
+		  } else if (FSTRCMP($1,"NAXIS(") == 0) {  /* NAXIS(V) */
+		     if (OPER($2) == CONST_OP) { /* if V is constant, return 1 in every case */
+		       long one = 1;
+		       $$ = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {                    /* determine now the dimension of the expression */
+		       long naxis = lParse->Nodes[$2].value.naxis;
+
+		       $$ = New_Const(lParse,  LONG, &naxis, sizeof(naxis) );
+		       TEST($$);
+		     }
                   } 
   		  else {  /*  These all take DOUBLE arguments  */
-		     if( TYPE($2) != DOUBLE ) $2 = New_Unary( DOUBLE, 0, $2 );
+		     if( TYPE($2) != DOUBLE ) $2 = New_Unary(lParse,  DOUBLE, 0, $2 );
                      if (FSTRCMP($1,"SIN(") == 0)
-			$$ = New_Func( 0, sin_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, sin_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"COS(") == 0)
-			$$ = New_Func( 0, cos_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, cos_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"TAN(") == 0)
-			$$ = New_Func( 0, tan_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, tan_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"ARCSIN(") == 0
 			      || FSTRCMP($1,"ASIN(") == 0)
-			$$ = New_Func( 0, asin_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, asin_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"ARCCOS(") == 0
 			      || FSTRCMP($1,"ACOS(") == 0)
-			$$ = New_Func( 0, acos_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, acos_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"ARCTAN(") == 0
 			      || FSTRCMP($1,"ATAN(") == 0)
-			$$ = New_Func( 0, atan_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, atan_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"SINH(") == 0)
-			$$ = New_Func( 0, sinh_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, sinh_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"COSH(") == 0)
-			$$ = New_Func( 0, cosh_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, cosh_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"TANH(") == 0)
-			$$ = New_Func( 0, tanh_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, tanh_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"EXP(") == 0)
-			$$ = New_Func( 0, exp_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, exp_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"LOG(") == 0)
-			$$ = New_Func( 0, log_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, log_fct,  1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"LOG10(") == 0)
-			$$ = New_Func( 0, log10_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, log10_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"SQRT(") == 0)
-			$$ = New_Func( 0, sqrt_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, sqrt_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"ROUND(") == 0)
-			$$ = New_Func( 0, round_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, round_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"FLOOR(") == 0)
-			$$ = New_Func( 0, floor_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, floor_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"CEIL(") == 0)
-			$$ = New_Func( 0, ceil_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
+			$$ = New_Func(lParse,  0, ceil_fct, 1, $2, 0, 0, 0, 0, 0, 0 );
 		     else if (FSTRCMP($1,"RANDOMP(") == 0) {
-		       $$ = New_Func( 0, poirnd_fct, 1, $2, 
+		       $$ = New_Func(lParse,  0, poirnd_fct, 1, $2, 
 				      0, 0, 0, 0, 0, 0 );
 		       TYPE($$) = LONG;
 		     } else {
-			yyerror("Function(expr) not supported");
+			yyerror(scanner, lParse, "Function(expr) not supported");
 			YYERROR;
 		     }
 		  }
                   TEST($$); 
                 }
        | IFUNCTION sexpr ',' sexpr ')'
                 { 
 		  if (FSTRCMP($1,"STRSTR(") == 0) {
-		    $$ = New_Func( LONG, strpos_fct, 2, $2, $4, 0, 
+		    $$ = New_Func(lParse,  LONG, strpos_fct, 2, $2, $4, 0, 
 				   0, 0, 0, 0 );
 		    TEST($$);
 		  }
                 }
        | FUNCTION expr ',' expr ')'
                 { 
 		   if (FSTRCMP($1,"DEFNULL(") == 0) {
-		      if( SIZE($2)>=SIZE($4) && Test_Dims( $2, $4 ) ) {
+		      if( SIZE($2)>=SIZE($4) && Test_Dims( lParse,  $2, $4 ) ) {
 			 PROMOTE($2,$4);
-			 $$ = New_Func( 0, defnull_fct, 2, $2, $4, 0,
+			 $$ = New_Func(lParse,  0, defnull_fct, 2, $2, $4, 0,
 					0, 0, 0, 0 );
 			 TEST($$); 
 		      } else {
-			 yyerror("Dimensions of DEFNULL arguments "
+			 yyerror(scanner, lParse, "Dimensions of DEFNULL arguments "
 				 "are not compatible");
 			 YYERROR;
 		      }
 		   } else if (FSTRCMP($1,"ARCTAN2(") == 0) {
-		     if( TYPE($2) != DOUBLE ) $2 = New_Unary( DOUBLE, 0, $2 );
-		     if( TYPE($4) != DOUBLE ) $4 = New_Unary( DOUBLE, 0, $4 );
-		     if( Test_Dims( $2, $4 ) ) {
-			$$ = New_Func( 0, atan2_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
+		     if( TYPE($2) != DOUBLE ) $2 = New_Unary(lParse,  DOUBLE, 0, $2 );
+		     if( TYPE($4) != DOUBLE ) $4 = New_Unary(lParse,  DOUBLE, 0, $4 );
+		     if( Test_Dims( lParse,  $2, $4 ) ) {
+			$$ = New_Func(lParse,  0, atan2_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
 			TEST($$); 
-			if( SIZE($2)<SIZE($4) ) Copy_Dims($$, $4);
+			if( SIZE($2)<SIZE($4) ) Copy_Dims( lParse,$$, $4);
 		     } else {
-			yyerror("Dimensions of arctan2 arguments "
+			yyerror(scanner, lParse, "Dimensions of arctan2 arguments "
 				"are not compatible");
 			YYERROR;
 		     }
 		   } else if (FSTRCMP($1,"MIN(") == 0) {
 		      PROMOTE( $2, $4 );
-		      if( Test_Dims( $2, $4 ) ) {
-			$$ = New_Func( 0, min2_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
+		      if( Test_Dims( lParse,  $2, $4 ) ) {
+			$$ = New_Func(lParse,  0, min2_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
 			TEST($$);
-			if( SIZE($2)<SIZE($4) ) Copy_Dims($$, $4);
+			if( SIZE($2)<SIZE($4) ) Copy_Dims( lParse,$$, $4);
 		      } else {
-			yyerror("Dimensions of min(a,b) arguments "
+			yyerror(scanner, lParse, "Dimensions of min(a,b) arguments "
 				"are not compatible");
 			YYERROR;
 		      }
 		   } else if (FSTRCMP($1,"MAX(") == 0) {
 		      PROMOTE( $2, $4 );
-		      if( Test_Dims( $2, $4 ) ) {
-			$$ = New_Func( 0, max2_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
+		      if( Test_Dims( lParse,  $2, $4 ) ) {
+			$$ = New_Func(lParse,  0, max2_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
 			TEST($$);
-			if( SIZE($2)<SIZE($4) ) Copy_Dims($$, $4);
+			if( SIZE($2)<SIZE($4) ) Copy_Dims( lParse,$$, $4);
 		      } else {
-			yyerror("Dimensions of max(a,b) arguments "
+			yyerror(scanner, lParse, "Dimensions of max(a,b) arguments "
 				"are not compatible");
 			YYERROR;
 		      }
-#if 0
-		   } else if (FSTRCMP($1,"STRSTR(") == 0) {
-		     if( TYPE($2) != STRING || TYPE($4) != STRING) {
-		       yyerror("Arguments to strstr(s,r) must be strings");
+		   } else if (FSTRCMP($1,"SETNULL(") == 0) {
+		     if (OPER($2) != CONST_OP
+			 || SIZE($2) != 1) {
+		       yyerror(scanner, lParse, "SETNULL first argument must be a scalar constant");
 		       YYERROR;
 		     }
-		     $$ = New_Func( LONG, strpos_fct, 2, $2, $4, 0, 
-				    0, 0, 0, 0 );
+		     /* Make sure first arg is same type as second arg */
+		     if ( TYPE($2) != TYPE($4) ) $2 = New_Unary(lParse,  TYPE($4), 0, $2 );
+		     $$ = New_Func(lParse,  0, setnull_fct, 2, $4, $2, 0, 0, 0, 0, 0 );
+		   } else if (FSTRCMP($1,"AXISELEM(") == 0) {  /* AXISELEM(V,n) */
+		     if (OPER($4) != CONST_OP
+			 || SIZE($4) != 1) {
+		       yyerror(scanner, lParse, "AXISELEM second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER($2) == CONST_OP) {
+		       long one = 1;
+		       $$ = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {
+		       if ( TYPE($4) != LONG ) $4 = New_Unary(lParse, LONG, 0, $4);
+		       $$ = New_Func(lParse, 0, axiselem_fct, 2, $2, $4, 0, 0, 0, 0, 0 );
+		       TEST($$);
+		       TYPE($$) = LONG;
+		     }
+		   } else if (FSTRCMP($1,"NAXES(") == 0) {  /* NAXES(V,n) */
+		     if (OPER($4) != CONST_OP
+			 || SIZE($4) != 1) {
+		       yyerror(scanner, lParse, "NAXES second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER($2) == CONST_OP) { /* if V is constant, return 1 in every case */
+		       long one = 1;
+		       $$ = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {                    /* determine now the dimension of the expression */
+		       long iaxis;
+		       int naxis;
+		       if ( TYPE($4) != LONG ) $4 = New_Unary(lParse, LONG, 0, $4);
+		       /* Since it is already constant, we can extract long value directly */
+		       iaxis = (lParse->Nodes[$4].value.data.lng);
+		       naxis = lParse->Nodes[$2].value.naxis;
+
+		       if (iaxis == 0)          iaxis = naxis;   /* NAXIS(V,0) = NAXIS */
+		       else if (iaxis <= naxis) iaxis = lParse->Nodes[$2].value.naxes[iaxis-1]; /* NAXIS(V,n) = NAXISn */
+		       else                     iaxis = 1;       /* Out of bounds use 1 */
+
+		       $$ = New_Const(lParse,  LONG, &iaxis, sizeof(iaxis) );
+		       TEST($$);
+		     }
+		   } else if (FSTRCMP($1,"ARRAY(") == 0) {  /* NAXES(expr,n) */
+		     $$ = New_Array(lParse, $2, $4);
 		     TEST($$);
-#endif
 		   } else {
-		      yyerror("Function(expr,expr) not supported");
+		      yyerror(scanner, lParse, "Function(expr,expr) not supported");
 		      YYERROR;
 		   }
                 }
        | FUNCTION expr ',' expr ',' expr ',' expr ')'
                 { 
 		  if (FSTRCMP($1,"ANGSEP(") == 0) {
-		    if( TYPE($2) != DOUBLE ) $2 = New_Unary( DOUBLE, 0, $2 );
-		    if( TYPE($4) != DOUBLE ) $4 = New_Unary( DOUBLE, 0, $4 );
-		    if( TYPE($6) != DOUBLE ) $6 = New_Unary( DOUBLE, 0, $6 );
-		    if( TYPE($8) != DOUBLE ) $8 = New_Unary( DOUBLE, 0, $8 );
-		    if( Test_Dims( $2, $4 ) && Test_Dims( $4, $6 ) && 
-			Test_Dims( $6, $8 ) ) {
-		      $$ = New_Func( 0, angsep_fct, 4, $2, $4, $6, $8,0,0,0 );
+		    if( TYPE($2) != DOUBLE ) $2 = New_Unary(lParse,  DOUBLE, 0, $2 );
+		    if( TYPE($4) != DOUBLE ) $4 = New_Unary(lParse,  DOUBLE, 0, $4 );
+		    if( TYPE($6) != DOUBLE ) $6 = New_Unary(lParse,  DOUBLE, 0, $6 );
+		    if( TYPE($8) != DOUBLE ) $8 = New_Unary(lParse,  DOUBLE, 0, $8 );
+		    if( Test_Dims( lParse,  $2, $4 ) && Test_Dims( lParse,  $4, $6 ) && 
+			Test_Dims( lParse,  $6, $8 ) ) {
+		      $$ = New_Func(lParse,  0, angsep_fct, 4, $2, $4, $6, $8,0,0,0 );
 		      TEST($$); 
-		      if( SIZE($2)<SIZE($4) ) Copy_Dims($$, $4);
-		      if( SIZE($4)<SIZE($6) ) Copy_Dims($$, $6);
-		      if( SIZE($6)<SIZE($8) ) Copy_Dims($$, $8);
+		      if( SIZE($2)<SIZE($4) ) Copy_Dims( lParse,$$, $4);
+		      if( SIZE($4)<SIZE($6) ) Copy_Dims( lParse,$$, $6);
+		      if( SIZE($6)<SIZE($8) ) Copy_Dims( lParse,$$, $8);
 		    } else {
-		      yyerror("Dimensions of ANGSEP arguments "
+		      yyerror(scanner, lParse, "Dimensions of ANGSEP arguments "
 			      "are not compatible");
 		      YYERROR;
 		    }
 		   } else {
-		      yyerror("Function(expr,expr,expr,expr) not supported");
+		      yyerror(scanner, lParse, "Function(expr,expr,expr,expr) not supported");
 		      YYERROR;
 		   }
                 }
        | expr '[' expr ']'
-                { $$ = New_Deref( $1, 1, $3,  0,  0,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 1, $3,  0,  0,  0,   0 ); TEST($$); }
        | expr '[' expr ',' expr ']'
-                { $$ = New_Deref( $1, 2, $3, $5,  0,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 2, $3, $5,  0,  0,   0 ); TEST($$); }
        | expr '[' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 3, $3, $5, $7,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 3, $3, $5, $7,  0,   0 ); TEST($$); }
        | expr '[' expr ',' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 4, $3, $5, $7, $9,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 4, $3, $5, $7, $9,   0 ); TEST($$); }
        | expr '[' expr ',' expr ',' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 5, $3, $5, $7, $9, $11 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 5, $3, $5, $7, $9, $11 ); TEST($$); }
        | INTCAST expr
-		{ $$ = New_Unary( LONG,   INTCAST, $2 );  TEST($$);  }
+		{ $$ = New_Unary(lParse,  LONG,   INTCAST, $2 );  TEST($$);  }
        | INTCAST bexpr
-                { $$ = New_Unary( LONG,   INTCAST, $2 );  TEST($$);  }
+                { $$ = New_Unary(lParse,  LONG,   INTCAST, $2 );  TEST($$);  }
        | FLTCAST expr
-		{ $$ = New_Unary( DOUBLE, FLTCAST, $2 );  TEST($$);  }
+		{ $$ = New_Unary(lParse,  DOUBLE, FLTCAST, $2 );  TEST($$);  }
        | FLTCAST bexpr
-                { $$ = New_Unary( DOUBLE, FLTCAST, $2 );  TEST($$);  }
+                { $$ = New_Unary(lParse,  DOUBLE, FLTCAST, $2 );  TEST($$);  }
        ;
 
 bexpr:   BOOLEAN
-                { $$ = New_Const( BOOLEAN, &($1), sizeof(char) ); TEST($$); }
+                { $$ = New_Const(lParse,  BOOLEAN, &($1), sizeof(char) ); TEST($$); }
        | BCOLUMN
-                { $$ = New_Column( $1 ); TEST($$); }
+                { $$ = New_Column(lParse,  $1 ); TEST($$); }
        | BCOLUMN '{' expr '}'
                 {
                   if( TYPE($3) != LONG
 		      || OPER($3) != CONST_OP ) {
-		     yyerror("Offset argument must be a constant integer");
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
 		     YYERROR;
 		  }
-                  $$ = New_Offset( $1, $3 ); TEST($$);
+                  $$ = New_Offset(lParse,  $1, $3 ); TEST($$);
                 }
        | bits EQ bits
-                { $$ = New_BinOp( BOOLEAN, $1, EQ,  $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, EQ,  $3 ); TEST($$);
 		  SIZE($$) = 1;                                     }
        | bits NE bits
-                { $$ = New_BinOp( BOOLEAN, $1, NE,  $3 ); TEST($$); 
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, NE,  $3 ); TEST($$); 
 		  SIZE($$) = 1;                                     }
        | bits LT bits
-                { $$ = New_BinOp( BOOLEAN, $1, LT,  $3 ); TEST($$); 
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, LT,  $3 ); TEST($$); 
 		  SIZE($$) = 1;                                     }
        | bits LTE bits
-                { $$ = New_BinOp( BOOLEAN, $1, LTE, $3 ); TEST($$); 
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, LTE, $3 ); TEST($$); 
 		  SIZE($$) = 1;                                     }
        | bits GT bits
-                { $$ = New_BinOp( BOOLEAN, $1, GT,  $3 ); TEST($$); 
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, GT,  $3 ); TEST($$); 
 		  SIZE($$) = 1;                                     }
        | bits GTE bits
-                { $$ = New_BinOp( BOOLEAN, $1, GTE, $3 ); TEST($$); 
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, GTE, $3 ); TEST($$); 
 		  SIZE($$) = 1;                                     }
        | expr GT expr
-                { PROMOTE($1,$3); $$ = New_BinOp( BOOLEAN, $1, GT,  $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  BOOLEAN, $1, GT,  $3 );
                   TEST($$);                                               }
        | expr LT expr
-                { PROMOTE($1,$3); $$ = New_BinOp( BOOLEAN, $1, LT,  $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  BOOLEAN, $1, LT,  $3 );
                   TEST($$);                                               }
        | expr GTE expr
-                { PROMOTE($1,$3); $$ = New_BinOp( BOOLEAN, $1, GTE, $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  BOOLEAN, $1, GTE, $3 );
                   TEST($$);                                               }
        | expr LTE expr
-                { PROMOTE($1,$3); $$ = New_BinOp( BOOLEAN, $1, LTE, $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  BOOLEAN, $1, LTE, $3 );
                   TEST($$);                                               }
        | expr '~' expr
-                { PROMOTE($1,$3); $$ = New_BinOp( BOOLEAN, $1, '~', $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  BOOLEAN, $1, '~', $3 );
                   TEST($$);                                               }
        | expr EQ expr
-                { PROMOTE($1,$3); $$ = New_BinOp( BOOLEAN, $1, EQ,  $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  BOOLEAN, $1, EQ,  $3 );
                   TEST($$);                                               }
        | expr NE expr
-                { PROMOTE($1,$3); $$ = New_BinOp( BOOLEAN, $1, NE,  $3 );
+                { PROMOTE($1,$3); $$ = New_BinOp(lParse,  BOOLEAN, $1, NE,  $3 );
                   TEST($$);                                               }
        | sexpr EQ sexpr
-                { $$ = New_BinOp( BOOLEAN, $1, EQ,  $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, EQ,  $3 ); TEST($$);
                   SIZE($$) = 1; }
        | sexpr NE sexpr
-                { $$ = New_BinOp( BOOLEAN, $1, NE,  $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, NE,  $3 ); TEST($$);
                   SIZE($$) = 1; }
        | sexpr GT sexpr
-                { $$ = New_BinOp( BOOLEAN, $1, GT,  $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, GT,  $3 ); TEST($$);
                   SIZE($$) = 1; }
        | sexpr GTE sexpr
-                { $$ = New_BinOp( BOOLEAN, $1, GTE, $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, GTE, $3 ); TEST($$);
                   SIZE($$) = 1; }
        | sexpr LT sexpr
-                { $$ = New_BinOp( BOOLEAN, $1, LT,  $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, LT,  $3 ); TEST($$);
                   SIZE($$) = 1; }
        | sexpr LTE sexpr
-                { $$ = New_BinOp( BOOLEAN, $1, LTE, $3 ); TEST($$);
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, LTE, $3 ); TEST($$);
                   SIZE($$) = 1; }
        | bexpr AND bexpr
-                { $$ = New_BinOp( BOOLEAN, $1, AND, $3 ); TEST($$); }
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, AND, $3 ); TEST($$); }
        | bexpr OR bexpr
-                { $$ = New_BinOp( BOOLEAN, $1, OR,  $3 ); TEST($$); }
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, OR,  $3 ); TEST($$); }
        | bexpr EQ bexpr
-                { $$ = New_BinOp( BOOLEAN, $1, EQ,  $3 ); TEST($$); }
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, EQ,  $3 ); TEST($$); }
        | bexpr NE bexpr
-                { $$ = New_BinOp( BOOLEAN, $1, NE,  $3 ); TEST($$); }
+                { $$ = New_BinOp(lParse,  BOOLEAN, $1, NE,  $3 ); TEST($$); }
 
        | expr '=' expr ':' expr
                 { PROMOTE($1,$3); PROMOTE($1,$5); PROMOTE($3,$5);
-		  $3 = New_BinOp( BOOLEAN, $3, LTE, $1 );
-                  $5 = New_BinOp( BOOLEAN, $1, LTE, $5 );
-                  $$ = New_BinOp( BOOLEAN, $3, AND, $5 );
+		  $3 = New_BinOp(lParse,  BOOLEAN, $3, LTE, $1 );
+                  $5 = New_BinOp(lParse,  BOOLEAN, $1, LTE, $5 );
+                  $$ = New_BinOp(lParse,  BOOLEAN, $3, AND, $5 );
                   TEST($$);                                         }
 
        | bexpr '?' bexpr ':' bexpr
                 {
-                  if( ! Test_Dims($3,$5) ) {
-                     yyerror("Incompatible dimensions in '?:' arguments");
+                  if( ! Test_Dims( lParse, $3,$5) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
 		     YYERROR;
                   }
-                  $$ = New_Func( 0, ifthenelse_fct, 3, $3, $5, $1,
+                  $$ = New_Func(lParse,  0, ifthenelse_fct, 3, $3, $5, $1,
                                  0, 0, 0, 0 );
                   TEST($$);
-                  if( SIZE($3)<SIZE($5) )  Copy_Dims($$, $5);
-                  if( ! Test_Dims($1,$$) ) {
-                     yyerror("Incompatible dimensions in '?:' condition");
+                  if( SIZE($3)<SIZE($5) )  Copy_Dims( lParse,$$, $5);
+                  if( ! Test_Dims( lParse, $1,$$) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
 		     YYERROR;
                   }
-                  if( SIZE($$)<SIZE($1) )  Copy_Dims($$, $1);
+                  if( SIZE($$)<SIZE($1) )  Copy_Dims( lParse,$$, $1);
                 }
 
        | BFUNCTION expr ')'
                 {
 		   if (FSTRCMP($1,"ISNULL(") == 0) {
-		      $$ = New_Func( 0, isnull_fct, 1, $2, 0, 0,
+		      $$ = New_Func(lParse,  0, isnull_fct, 1, $2, 0, 0,
 				     0, 0, 0, 0 );
 		      TEST($$); 
                       /* Use expression's size, but return BOOLEAN */
 		      TYPE($$) = BOOLEAN;
 		   } else {
-		      yyerror("Boolean Function(expr) not supported");
+		      yyerror(scanner, lParse, "Boolean Function(expr) not supported");
 		      YYERROR;
 		   }
 		}
        | BFUNCTION bexpr ')'
                 {
 		   if (FSTRCMP($1,"ISNULL(") == 0) {
-		      $$ = New_Func( 0, isnull_fct, 1, $2, 0, 0,
+		      $$ = New_Func(lParse,  0, isnull_fct, 1, $2, 0, 0,
 				     0, 0, 0, 0 );
 		      TEST($$); 
                       /* Use expression's size, but return BOOLEAN */
 		      TYPE($$) = BOOLEAN;
 		   } else {
-		      yyerror("Boolean Function(expr) not supported");
+		      yyerror(scanner, lParse, "Boolean Function(expr) not supported");
 		      YYERROR;
 		   }
 		}
        | BFUNCTION sexpr ')'
                 {
 		   if (FSTRCMP($1,"ISNULL(") == 0) {
-		      $$ = New_Func( BOOLEAN, isnull_fct, 1, $2, 0, 0,
+		      $$ = New_Func(lParse,  BOOLEAN, isnull_fct, 1, $2, 0, 0,
 				     0, 0, 0, 0 );
 		      TEST($$); 
 		   } else {
-		      yyerror("Boolean Function(expr) not supported");
+		      yyerror(scanner, lParse, "Boolean Function(expr) not supported");
 		      YYERROR;
 		   }
 		}
        | FUNCTION bexpr ',' bexpr ')'
                 {
 		   if (FSTRCMP($1,"DEFNULL(") == 0) {
-		      if( SIZE($2)>=SIZE($4) && Test_Dims( $2, $4 ) ) {
-			 $$ = New_Func( 0, defnull_fct, 2, $2, $4, 0,
+		      if( SIZE($2)>=SIZE($4) && Test_Dims( lParse,  $2, $4 ) ) {
+			 $$ = New_Func(lParse,  0, defnull_fct, 2, $2, $4, 0,
 					0, 0, 0, 0 );
 			 TEST($$); 
 		      } else {
-			 yyerror("Dimensions of DEFNULL arguments are not compatible");
+			 yyerror(scanner, lParse, "Dimensions of DEFNULL arguments are not compatible");
 			 YYERROR;
 		      }
 		   } else {
-		      yyerror("Boolean Function(expr,expr) not supported");
+		      yyerror(scanner, lParse, "Boolean Function(expr,expr) not supported");
 		      YYERROR;
 		   }
 		}
        | BFUNCTION expr ',' expr ',' expr ')'
 		{
-		   if( TYPE($2) != DOUBLE ) $2 = New_Unary( DOUBLE, 0, $2 );
-		   if( TYPE($4) != DOUBLE ) $4 = New_Unary( DOUBLE, 0, $4 );
-		   if( TYPE($6) != DOUBLE ) $6 = New_Unary( DOUBLE, 0, $6 );
-		   if( ! (Test_Dims( $2, $4 ) && Test_Dims( $4, $6 ) ) ) {
-		       yyerror("Dimensions of NEAR arguments "
+		   if( TYPE($2) != DOUBLE ) $2 = New_Unary(lParse,  DOUBLE, 0, $2 );
+		   if( TYPE($4) != DOUBLE ) $4 = New_Unary(lParse,  DOUBLE, 0, $4 );
+		   if( TYPE($6) != DOUBLE ) $6 = New_Unary(lParse,  DOUBLE, 0, $6 );
+		   if( ! (Test_Dims( lParse,  $2, $4 ) && Test_Dims( lParse,  $4, $6 ) ) ) {
+		       yyerror(scanner, lParse, "Dimensions of NEAR arguments "
 			       "are not compatible");
 		       YYERROR;
 		   } else {
 		     if (FSTRCMP($1,"NEAR(") == 0) {
-		       $$ = New_Func( BOOLEAN, near_fct, 3, $2, $4, $6,
+		       $$ = New_Func(lParse,  BOOLEAN, near_fct, 3, $2, $4, $6,
 				      0, 0, 0, 0 );
 		     } else {
-		       yyerror("Boolean Function not supported");
+		       yyerror(scanner, lParse, "Boolean Function not supported");
 		       YYERROR;
 		     }
 		     TEST($$); 
 
-		     if( SIZE($$)<SIZE($2) )  Copy_Dims($$, $2);
-		     if( SIZE($2)<SIZE($4) )  Copy_Dims($$, $4);
-		     if( SIZE($4)<SIZE($6) )  Copy_Dims($$, $6);
+		     if( SIZE($$)<SIZE($2) )  Copy_Dims( lParse,$$, $2);
+		     if( SIZE($2)<SIZE($4) )  Copy_Dims( lParse,$$, $4);
+		     if( SIZE($4)<SIZE($6) )  Copy_Dims( lParse,$$, $6);
 		   }
 		}
        | BFUNCTION expr ',' expr ',' expr ',' expr ',' expr ')'
 	        {
-		   if( TYPE($2) != DOUBLE ) $2 = New_Unary( DOUBLE, 0, $2 );
-		   if( TYPE($4) != DOUBLE ) $4 = New_Unary( DOUBLE, 0, $4 );
-		   if( TYPE($6) != DOUBLE ) $6 = New_Unary( DOUBLE, 0, $6 );
-		   if( TYPE($8) != DOUBLE ) $8 = New_Unary( DOUBLE, 0, $8 );
-		   if( TYPE($10)!= DOUBLE ) $10= New_Unary( DOUBLE, 0, $10);
-		   if( ! (Test_Dims( $2, $4 ) && Test_Dims( $4, $6 ) && 
-			  Test_Dims( $6, $8 ) && Test_Dims( $8, $10 )) ) {
-		     yyerror("Dimensions of CIRCLE arguments "
+		   if( TYPE($2) != DOUBLE ) $2 = New_Unary(lParse,  DOUBLE, 0, $2 );
+		   if( TYPE($4) != DOUBLE ) $4 = New_Unary(lParse,  DOUBLE, 0, $4 );
+		   if( TYPE($6) != DOUBLE ) $6 = New_Unary(lParse,  DOUBLE, 0, $6 );
+		   if( TYPE($8) != DOUBLE ) $8 = New_Unary(lParse,  DOUBLE, 0, $8 );
+		   if( TYPE($10)!= DOUBLE ) $10= New_Unary(lParse,  DOUBLE, 0, $10);
+		   if( ! (Test_Dims( lParse,  $2, $4 ) && Test_Dims( lParse,  $4, $6 ) && 
+			  Test_Dims( lParse,  $6, $8 ) && Test_Dims( lParse,  $8, $10 )) ) {
+		     yyerror(scanner, lParse, "Dimensions of CIRCLE arguments "
 			     "are not compatible");
 		     YYERROR;
 		   } else {
 		     if (FSTRCMP($1,"CIRCLE(") == 0) {
-		       $$ = New_Func( BOOLEAN, circle_fct, 5, $2, $4, $6, $8,
+		       $$ = New_Func(lParse,  BOOLEAN, circle_fct, 5, $2, $4, $6, $8,
 				      $10, 0, 0 );
 		     } else {
-		       yyerror("Boolean Function not supported");
+		       yyerror(scanner, lParse, "Boolean Function not supported");
 		       YYERROR;
 		     }
 		     TEST($$); 
-		     if( SIZE($$)<SIZE($2) )  Copy_Dims($$, $2);
-		     if( SIZE($2)<SIZE($4) )  Copy_Dims($$, $4);
-		     if( SIZE($4)<SIZE($6) )  Copy_Dims($$, $6);
-		     if( SIZE($6)<SIZE($8) )  Copy_Dims($$, $8);
-		     if( SIZE($8)<SIZE($10) ) Copy_Dims($$, $10);
+		     if( SIZE($$)<SIZE($2) )  Copy_Dims( lParse,$$, $2);
+		     if( SIZE($2)<SIZE($4) )  Copy_Dims( lParse,$$, $4);
+		     if( SIZE($4)<SIZE($6) )  Copy_Dims( lParse,$$, $6);
+		     if( SIZE($6)<SIZE($8) )  Copy_Dims( lParse,$$, $8);
+		     if( SIZE($8)<SIZE($10) ) Copy_Dims( lParse,$$, $10);
 		   }
 		}
        | BFUNCTION expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'
                 {
-		   if( TYPE($2) != DOUBLE ) $2 = New_Unary( DOUBLE, 0, $2 );
-		   if( TYPE($4) != DOUBLE ) $4 = New_Unary( DOUBLE, 0, $4 );
-		   if( TYPE($6) != DOUBLE ) $6 = New_Unary( DOUBLE, 0, $6 );
-		   if( TYPE($8) != DOUBLE ) $8 = New_Unary( DOUBLE, 0, $8 );
-		   if( TYPE($10)!= DOUBLE ) $10= New_Unary( DOUBLE, 0, $10);
-		   if( TYPE($12)!= DOUBLE ) $12= New_Unary( DOUBLE, 0, $12);
-		   if( TYPE($14)!= DOUBLE ) $14= New_Unary( DOUBLE, 0, $14);
-		   if( ! (Test_Dims( $2, $4 ) && Test_Dims( $4, $6 ) && 
-			  Test_Dims( $6, $8 ) && Test_Dims( $8, $10 ) &&
-			  Test_Dims($10,$12 ) && Test_Dims($12, $14 ) ) ) {
-		     yyerror("Dimensions of BOX or ELLIPSE arguments "
+		   if( TYPE($2) != DOUBLE ) $2 = New_Unary(lParse,  DOUBLE, 0, $2 );
+		   if( TYPE($4) != DOUBLE ) $4 = New_Unary(lParse,  DOUBLE, 0, $4 );
+		   if( TYPE($6) != DOUBLE ) $6 = New_Unary(lParse,  DOUBLE, 0, $6 );
+		   if( TYPE($8) != DOUBLE ) $8 = New_Unary(lParse,  DOUBLE, 0, $8 );
+		   if( TYPE($10)!= DOUBLE ) $10= New_Unary(lParse,  DOUBLE, 0, $10);
+		   if( TYPE($12)!= DOUBLE ) $12= New_Unary(lParse,  DOUBLE, 0, $12);
+		   if( TYPE($14)!= DOUBLE ) $14= New_Unary(lParse,  DOUBLE, 0, $14);
+		   if( ! (Test_Dims( lParse,  $2, $4 ) && Test_Dims( lParse,  $4, $6 ) && 
+			  Test_Dims( lParse,  $6, $8 ) && Test_Dims( lParse,  $8, $10 ) &&
+			  Test_Dims( lParse, $10,$12 ) && Test_Dims( lParse, $12, $14 ) ) ) {
+		     yyerror(scanner, lParse, "Dimensions of BOX or ELLIPSE arguments "
 			     "are not compatible");
 		     YYERROR;
 		   } else {
 		     if (FSTRCMP($1,"BOX(") == 0) {
-		       $$ = New_Func( BOOLEAN, box_fct, 7, $2, $4, $6, $8,
+		       $$ = New_Func(lParse,  BOOLEAN, box_fct, 7, $2, $4, $6, $8,
 				      $10, $12, $14 );
 		     } else if (FSTRCMP($1,"ELLIPSE(") == 0) {
-		       $$ = New_Func( BOOLEAN, elps_fct, 7, $2, $4, $6, $8,
+		       $$ = New_Func(lParse,  BOOLEAN, elps_fct, 7, $2, $4, $6, $8,
 				      $10, $12, $14 );
 		     } else {
-		       yyerror("SAO Image Function not supported");
+		       yyerror(scanner, lParse, "SAO Image Function not supported");
 		       YYERROR;
 		     }
 		     TEST($$); 
-		     if( SIZE($$)<SIZE($2) )  Copy_Dims($$, $2);
-		     if( SIZE($2)<SIZE($4) )  Copy_Dims($$, $4);
-		     if( SIZE($4)<SIZE($6) )  Copy_Dims($$, $6);
-		     if( SIZE($6)<SIZE($8) )  Copy_Dims($$, $8);
-		     if( SIZE($8)<SIZE($10) ) Copy_Dims($$, $10);
-		     if( SIZE($10)<SIZE($12) ) Copy_Dims($$, $12);
-		     if( SIZE($12)<SIZE($14) ) Copy_Dims($$, $14);
+		     if( SIZE($$)<SIZE($2) )  Copy_Dims( lParse,$$, $2);
+		     if( SIZE($2)<SIZE($4) )  Copy_Dims( lParse,$$, $4);
+		     if( SIZE($4)<SIZE($6) )  Copy_Dims( lParse,$$, $6);
+		     if( SIZE($6)<SIZE($8) )  Copy_Dims( lParse,$$, $8);
+		     if( SIZE($8)<SIZE($10) ) Copy_Dims( lParse,$$, $10);
+		     if( SIZE($10)<SIZE($12) ) Copy_Dims( lParse,$$, $12);
+		     if( SIZE($12)<SIZE($14) ) Copy_Dims( lParse,$$, $14);
 		   }
 		}
 
        | GTIFILTER ')'
                 { /* Use defaults for all elements */
-                   $$ = New_GTI( "", -99, "*START*", "*STOP*" );
+		   $$ = New_GTI(lParse, gtifilt_fct,  "", -99, -99, "*START*", "*STOP*" );
                    TEST($$);                                        }
        | GTIFILTER STRING ')'
                 { /* Use defaults for all except filename */
-                   $$ = New_GTI( $2, -99, "*START*", "*STOP*" );
+		  $$ = New_GTI(lParse, gtifilt_fct,  $2, -99, -99, "*START*", "*STOP*" );
                    TEST($$);                                        }
        | GTIFILTER STRING ',' expr ')'
-                {  $$ = New_GTI( $2, $4, "*START*", "*STOP*" );
+                {  $$ = New_GTI(lParse, gtifilt_fct,  $2, $4, -99, "*START*", "*STOP*" );
                    TEST($$);                                        }
        | GTIFILTER STRING ',' expr ',' STRING ',' STRING ')'
-                {  $$ = New_GTI( $2, $4, $6, $8 );
+                {  $$ = New_GTI(lParse, gtifilt_fct,  $2, $4, -99, $6, $8 );
                    TEST($$);                                        }
 
+
+       | GTIOVERLAP STRING ',' expr ',' expr ')'
+                {  $$ = New_GTI(lParse, gtiover_fct,  $2, $4, $6, "*START*", "*STOP*");
+                   TEST($$);                                        }
+       | GTIOVERLAP STRING ',' expr ',' expr ',' STRING ',' STRING ')'
+                {  $$ = New_GTI(lParse, gtiover_fct,  $2, $4, $6, $8, $10 );
+                   TEST($$);                                        }
+
+       /* GTIFIND('myfile.gti', TIME_EXPR, 'START', 'STOP') */
+       | GTIFIND ')'
+                { /* Use defaults for all elements */
+		   $$ = New_GTI(lParse, gtifind_fct,  "", -99, -99, "*START*", "*STOP*" );
+                   TEST($$);                                        }
+       | GTIFIND STRING ')'
+                { /* Use defaults for all except filename */
+		  $$ = New_GTI(lParse, gtifind_fct,  $2, -99, -99, "*START*", "*STOP*" );
+                   TEST($$);                                        }
+       | GTIFIND STRING ',' expr ')'
+                {  $$ = New_GTI(lParse, gtifind_fct,  $2, $4, -99, "*START*", "*STOP*" );
+                   TEST($$);                                        }
+       | GTIFIND STRING ',' expr ',' STRING ',' STRING ')'
+                {  $$ = New_GTI(lParse, gtifind_fct,  $2, $4, -99, $6, $8 );
+                   TEST($$);                                        }
+
+
        | REGFILTER STRING ')'
                 { /* Use defaults for all except filename */
-                   $$ = New_REG( $2, -99, -99, "" );
+                   $$ = New_REG(lParse,  $2, -99, -99, "" );
                    TEST($$);                                        }
        | REGFILTER STRING ',' expr ',' expr ')'
-                {  $$ = New_REG( $2, $4, $6, "" );
+                {  $$ = New_REG(lParse,  $2, $4, $6, "" );
                    TEST($$);                                        }
        | REGFILTER STRING ',' expr ',' expr ',' STRING ')'
-                {  $$ = New_REG( $2, $4, $6, $8 );
+                {  $$ = New_REG(lParse,  $2, $4, $6, $8 );
                    TEST($$);                                        }
 
        | bexpr '[' expr ']'
-                { $$ = New_Deref( $1, 1, $3,  0,  0,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 1, $3,  0,  0,  0,   0 ); TEST($$); }
        | bexpr '[' expr ',' expr ']'
-                { $$ = New_Deref( $1, 2, $3, $5,  0,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 2, $3, $5,  0,  0,   0 ); TEST($$); }
        | bexpr '[' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 3, $3, $5, $7,  0,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 3, $3, $5, $7,  0,   0 ); TEST($$); }
        | bexpr '[' expr ',' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 4, $3, $5, $7, $9,   0 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 4, $3, $5, $7, $9,   0 ); TEST($$); }
        | bexpr '[' expr ',' expr ',' expr ',' expr ',' expr ']'
-                { $$ = New_Deref( $1, 5, $3, $5, $7, $9, $11 ); TEST($$); }
+                { $$ = New_Deref(lParse,  $1, 5, $3, $5, $7, $9, $11 ); TEST($$); }
        | NOT bexpr
-                { $$ = New_Unary( BOOLEAN, NOT, $2 ); TEST($$); }
+                { $$ = New_Unary(lParse,  BOOLEAN, NOT, $2 ); TEST($$); }
        | '(' bexpr ')'
                 { $$ = $2; }
        ;
 
 sexpr:   STRING
-                { $$ = New_Const( STRING, $1, strlen($1)+1 ); TEST($$);
+                { $$ = New_Const(lParse,  STRING, $1, strlen($1)+1 ); TEST($$);
                   SIZE($$) = strlen($1); }
        | SCOLUMN
-                { $$ = New_Column( $1 ); TEST($$); }
+                { $$ = New_Column(lParse,  $1 ); TEST($$); }
        | SCOLUMN '{' expr '}'
                 {
                   if( TYPE($3) != LONG
 		      || OPER($3) != CONST_OP ) {
-		     yyerror("Offset argument must be a constant integer");
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
 		     YYERROR;
 		  }
-                  $$ = New_Offset( $1, $3 ); TEST($$);
+                  $$ = New_Offset(lParse,  $1, $3 ); TEST($$);
                 }
        | SNULLREF
-                { $$ = New_Func( STRING, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
+                { $$ = New_Func(lParse,  STRING, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
        | '(' sexpr ')'
                 { $$ = $2; }
        | sexpr '+' sexpr
                 { 
 		  if (SIZE($1)+SIZE($3) >= MAX_STRLEN) {
-		    yyerror("Combined string size exceeds " MAX_STRLEN_S " characters");
+		    yyerror(scanner, lParse, "Combined string size exceeds " MAX_STRLEN_S " characters");
 		    YYERROR;
 		  }
-		  $$ = New_BinOp( STRING, $1, '+', $3 );  TEST($$);
+		  $$ = New_BinOp(lParse,  STRING, $1, '+', $3 );  TEST($$);
 		  SIZE($$) = SIZE($1) + SIZE($3);
 		}
        | bexpr '?' sexpr ':' sexpr
                 {
 		  int outSize;
                   if( SIZE($1)!=1 ) {
-                     yyerror("Cannot have a vector string column");
+                     yyerror(scanner, lParse, "Cannot have a vector string column");
 		     YYERROR;
                   }
 		  /* Since the output can be calculated now, as a constant
 		     scalar, we must precalculate the output size, in
 		     order to avoid an overflow. */
 		  outSize = SIZE($3);
 		  if (SIZE($5) > outSize) outSize = SIZE($5);
-                  $$ = New_FuncSize( 0, ifthenelse_fct, 3, $3, $5, $1,
+                  $$ = New_FuncSize(lParse,  0, ifthenelse_fct, 3, $3, $5, $1,
 				     0, 0, 0, 0, outSize);
 		  
                   TEST($$);
-                  if( SIZE($3)<SIZE($5) )  Copy_Dims($$, $5);
+                  if( SIZE($3)<SIZE($5) )  Copy_Dims( lParse,$$, $5);
                 }
 
        | FUNCTION sexpr ',' sexpr ')'
                 { 
 		  if (FSTRCMP($1,"DEFNULL(") == 0) {
 		     int outSize;
 		     /* Since the output can be calculated now, as a constant
 			scalar, we must precalculate the output size, in
 			order to avoid an overflow. */
 		     outSize = SIZE($2);
 		     if (SIZE($4) > outSize) outSize = SIZE($4);
 		     
-		     $$ = New_FuncSize( 0, defnull_fct, 2, $2, $4, 0,
+		     $$ = New_FuncSize(lParse,  0, defnull_fct, 2, $2, $4, 0,
 					0, 0, 0, 0, outSize );
 		     TEST($$); 
 		     if( SIZE($4)>SIZE($2) ) SIZE($$) = SIZE($4);
 		  } else {
-		     yyerror("Function(string,string) not supported");
+		     yyerror(scanner, lParse, "Function(string,string) not supported");
 		     YYERROR;
 		  }
 		}
        | FUNCTION sexpr ',' expr ',' expr ')'
                 { 
 		  if (FSTRCMP($1,"STRMID(") == 0) {
 		    int len;
 		    if( TYPE($4) != LONG || SIZE($4) != 1 ||
 			TYPE($6) != LONG || SIZE($6) != 1) {
-		      yyerror("When using STRMID(S,P,N), P and N must be integers (and not vector columns)");
+		      yyerror(scanner, lParse, "When using STRMID(S,P,N), P and N must be integers (and not vector columns)");
 		      YYERROR;
 		    }
 		    if (OPER($6) == CONST_OP) {
 		      /* Constant value: use that directly */
-		      len = (gParse.Nodes[$6].value.data.lng);
+		      len = (lParse->Nodes[$6].value.data.lng);
 		    } else {
 		      /* Variable value: use the maximum possible (from $2) */
 		      len = SIZE($2);
 		    }
 		    if (len <= 0 || len >= MAX_STRLEN) {
-		      yyerror("STRMID(S,P,N), N must be 1-" MAX_STRLEN_S);
+		      yyerror(scanner, lParse, "STRMID(S,P,N), N must be 1-" MAX_STRLEN_S);
 		      YYERROR;
 		    }
-		    $$ = New_FuncSize( 0, strmid_fct, 3, $2, $4,$6,0,0,0,0,len);
+		    $$ = New_FuncSize(lParse,  0, strmid_fct, 3, $2, $4,$6,0,0,0,0,len);
 		    TEST($$);
 		  } else {
-		     yyerror("Function(string,expr,expr) not supported");
+		     yyerror(scanner, lParse, "Function(string,expr,expr) not supported");
 		     YYERROR;
 		  }
 		}
 
 	;
 
 %%
 
 /*************************************************************************/
 /*  Start of "New" routines which build the expression Nodal structure   */
 /*************************************************************************/
 
-static int Alloc_Node( void )
+static int Alloc_Node( ParseData *lParse )
 {
                       /* Use this for allocation to guarantee *Nodes */
    Node *newNodePtr;  /* survives on failure, making it still valid  */
                       /* while working our way out of this error     */
 
-   if( gParse.nNodes == gParse.nNodesAlloc ) {
-      if( gParse.Nodes ) {
-	 gParse.nNodesAlloc += gParse.nNodesAlloc;
-	 newNodePtr = (Node *)realloc( gParse.Nodes,
-				       sizeof(Node)*gParse.nNodesAlloc );
+   if( lParse->nNodes == lParse->nNodesAlloc ) {
+      if( lParse->Nodes ) {
+	 lParse->nNodesAlloc += lParse->nNodesAlloc;
+	 newNodePtr = (Node *)realloc( lParse->Nodes,
+				       sizeof(Node)*lParse->nNodesAlloc );
       } else {
-	 gParse.nNodesAlloc = 100;
-	 newNodePtr = (Node *)malloc ( sizeof(Node)*gParse.nNodesAlloc );
+	 lParse->nNodesAlloc = 100;
+	 newNodePtr = (Node *)malloc ( sizeof(Node)*lParse->nNodesAlloc );
       }	 
 
       if( newNodePtr ) {
-	 gParse.Nodes = newNodePtr;
+	 lParse->Nodes = newNodePtr;
       } else {
-	 gParse.status = MEMORY_ALLOCATION;
+	 lParse->status = MEMORY_ALLOCATION;
 	 return( -1 );
       }
    }
 
-   return ( gParse.nNodes++ );
+   return ( lParse->nNodes++ );
 }
 
-static void Free_Last_Node( void )
+static void Free_Last_Node( ParseData *lParse )
 {
-   if( gParse.nNodes ) gParse.nNodes--;
+   if( lParse->nNodes ) lParse->nNodes--;
 }
 
-static int New_Const( int returnType, void *value, long len )
+static int New_Const( ParseData *lParse, int returnType, void *value, long len )
 {
    Node *this;
    int n;
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this             = gParse.Nodes + n;
+      this             = lParse->Nodes + n;
       this->operation  = CONST_OP;             /* Flag a constant */
       this->DoOp       = NULL;
       this->nSubNodes  = 0;
       this->type       = returnType;
       memcpy( &(this->value.data), value, len );
       this->value.undef = NULL;
       this->value.nelem = 1;
       this->value.naxis = 1;
       this->value.naxes[0] = 1;
    }
    return(n);
 }
 
-static int New_Column( int ColNum )
+static int New_Column( ParseData *lParse, int ColNum )
 {
    Node *this;
    int  n, i;
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = -ColNum;
       this->DoOp        = NULL;
       this->nSubNodes   = 0;
-      this->type        = gParse.varData[ColNum].type;
-      this->value.nelem = gParse.varData[ColNum].nelem;
-      this->value.naxis = gParse.varData[ColNum].naxis;
-      for( i=0; i<gParse.varData[ColNum].naxis; i++ )
-	 this->value.naxes[i] = gParse.varData[ColNum].naxes[i];
+      this->type        = lParse->varData[ColNum].type;
+      this->value.nelem = lParse->varData[ColNum].nelem;
+      this->value.naxis = lParse->varData[ColNum].naxis;
+      for( i=0; i<lParse->varData[ColNum].naxis; i++ )
+	 this->value.naxes[i] = lParse->varData[ColNum].naxes[i];
    }
    return(n);
 }
 
-static int New_Offset( int ColNum, int offsetNode )
+static int New_Offset( ParseData *lParse, int ColNum, int offsetNode )
 {
    Node *this;
    int  n, i, colNode;
 
-   colNode = New_Column( ColNum );
+   colNode = New_Column( lParse, ColNum );
    if( colNode<0 ) return(-1);
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = '{';
       this->DoOp        = Do_Offset;
       this->nSubNodes   = 2;
       this->SubNodes[0] = colNode;
       this->SubNodes[1] = offsetNode;
-      this->type        = gParse.varData[ColNum].type;
-      this->value.nelem = gParse.varData[ColNum].nelem;
-      this->value.naxis = gParse.varData[ColNum].naxis;
-      for( i=0; i<gParse.varData[ColNum].naxis; i++ )
-	 this->value.naxes[i] = gParse.varData[ColNum].naxes[i];
+      this->type        = lParse->varData[ColNum].type;
+      this->value.nelem = lParse->varData[ColNum].nelem;
+      this->value.naxis = lParse->varData[ColNum].naxis;
+      for( i=0; i<lParse->varData[ColNum].naxis; i++ )
+	 this->value.naxes[i] = lParse->varData[ColNum].naxes[i];
    }
    return(n);
 }
 
-static int New_Unary( int returnType, int Op, int Node1 )
+static int New_Unary( ParseData *lParse, int returnType, int Op, int Node1 )
 {
    Node *this, *that;
    int  i,n;
 
    if( Node1<0 ) return(-1);
-   that = gParse.Nodes + Node1;
+   that = lParse->Nodes + Node1;
 
    if( !Op ) Op = returnType;
 
    if( (Op==DOUBLE || Op==FLTCAST) && that->type==DOUBLE  ) return( Node1 );
    if( (Op==LONG   || Op==INTCAST) && that->type==LONG    ) return( Node1 );
    if( (Op==BOOLEAN              ) && that->type==BOOLEAN ) return( Node1 );
    
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = Op;
       this->DoOp        = Do_Unary;
       this->nSubNodes   = 1;
       this->SubNodes[0] = Node1;
       this->type        = returnType;
 
-      that              = gParse.Nodes + Node1; /* Reset in case .Nodes mv'd */
+      that              = lParse->Nodes + Node1; /* Reset in case .Nodes mv'd */
       this->value.nelem = that->value.nelem;
       this->value.naxis = that->value.naxis;
       for( i=0; i<that->value.naxis; i++ )
 	 this->value.naxes[i] = that->value.naxes[i];
 
-      if( that->operation==CONST_OP ) this->DoOp( this );
+      if( that->operation==CONST_OP ) this->DoOp( lParse, this );
    }
    return( n );
 }
 
-static int New_BinOp( int returnType, int Node1, int Op, int Node2 )
+static int New_BinOp( ParseData *lParse, int returnType, int Node1, int Op, int Node2 )
 {
    Node *this,*that1,*that2;
    int  n,i,constant;
 
    if( Node1<0 || Node2<0 ) return(-1);
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this             = gParse.Nodes + n;
+      this             = lParse->Nodes + n;
       this->operation  = Op;
       this->nSubNodes  = 2;
       this->SubNodes[0]= Node1;
       this->SubNodes[1]= Node2;
       this->type       = returnType;
 
-      that1            = gParse.Nodes + Node1;
-      that2            = gParse.Nodes + Node2;
+      that1            = lParse->Nodes + Node1;
+      that2            = lParse->Nodes + Node2;
       constant         = (that1->operation==CONST_OP
                           && that2->operation==CONST_OP);
       if( that1->type!=STRING && that1->type!=BITSTR )
-	 if( !Test_Dims( Node1, Node2 ) ) {
-	    Free_Last_Node();
-	    yyerror("Array sizes/dims do not match for binary operator");
+	if( !Test_Dims( lParse, Node1, Node2 ) ) {
+	    Free_Last_Node(lParse);
+	    yyerror(0, lParse, "Array sizes/dims do not match for binary operator");
 	    return(-1);
 	 }
       if( that1->value.nelem == 1 ) that1 = that2;
 
       this->value.nelem = that1->value.nelem;
       this->value.naxis = that1->value.naxis;
       for( i=0; i<that1->value.naxis; i++ )
@@ -1361,43 +1515,46 @@
       switch( that1->type ) {
       case BITSTR:  this->DoOp = Do_BinOp_bit;  break;
       case STRING:  this->DoOp = Do_BinOp_str;  break;
       case BOOLEAN: this->DoOp = Do_BinOp_log;  break;
       case LONG:    this->DoOp = Do_BinOp_lng;  break;
       case DOUBLE:  this->DoOp = Do_BinOp_dbl;  break;
       }
-      if( constant ) this->DoOp( this );
+      if( constant ) this->DoOp( lParse, this );
    }
    return( n );
 }
 
-static int New_Func( int returnType, funcOp Op, int nNodes,
+static int New_Func( ParseData *lParse,
+		     int returnType, funcOp Op, int nNodes,
 		     int Node1, int Node2, int Node3, int Node4, 
 		     int Node5, int Node6, int Node7 )
 {
-  return New_FuncSize(returnType, Op, nNodes,
+  return New_FuncSize(lParse,
+		      returnType, Op, nNodes,
 		      Node1, Node2, Node3, Node4, 
 		      Node5, Node6, Node7, 0);
 }
 
-static int New_FuncSize( int returnType, funcOp Op, int nNodes,
-		     int Node1, int Node2, int Node3, int Node4, 
+static int New_FuncSize( ParseData *lParse,
+			 int returnType, funcOp Op, int nNodes,
+			 int Node1, int Node2, int Node3, int Node4, 
 			 int Node5, int Node6, int Node7, int Size )
 /* If returnType==0 , use Node1's type and vector sizes as returnType, */
 /* else return a single value of type returnType                       */
 {
    Node *this, *that;
    int  i,n,constant;
 
    if( Node1<0 || Node2<0 || Node3<0 || Node4<0 || 
        Node5<0 || Node6<0 || Node7<0 ) return(-1);
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = (int)Op;
       this->DoOp        = Do_Func;
       this->nSubNodes   = nNodes;
       this->SubNodes[0] = Node1;
       this->SubNodes[1] = Node2;
       this->SubNodes[2] = Node3;
       this->SubNodes[3] = Node4;
@@ -1412,66 +1569,66 @@
       
       if( returnType ) {
 	 this->type           = returnType;
 	 this->value.nelem    = 1;
 	 this->value.naxis    = 1;
 	 this->value.naxes[0] = 1;
       } else {
-	 that              = gParse.Nodes + Node1;
+	 that              = lParse->Nodes + Node1;
 	 this->type        = that->type;
 	 this->value.nelem = that->value.nelem;
 	 this->value.naxis = that->value.naxis;
 	 for( i=0; i<that->value.naxis; i++ )
 	    this->value.naxes[i] = that->value.naxes[i];
       }
       /* Force explicit size before evaluating */
       if (Size > 0) this->value.nelem = Size;
 
-      if( constant ) this->DoOp( this );
+      if( constant ) this->DoOp( lParse, this );
    }
    return( n );
 }
 
-static int New_Deref( int Var,  int nDim,
+static int New_Deref( ParseData *lParse, int Var,  int nDim,
 		      int Dim1, int Dim2, int Dim3, int Dim4, int Dim5 )
 {
    int n, idx, constant;
    long elem=0;
    Node *this, *theVar, *theDim[MAXDIMS];
 
    if( Var<0 || Dim1<0 || Dim2<0 || Dim3<0 || Dim4<0 || Dim5<0 ) return(-1);
 
-   theVar = gParse.Nodes + Var;
+   theVar = lParse->Nodes + Var;
    if( theVar->operation==CONST_OP || theVar->value.nelem==1 ) {
-      yyerror("Cannot index a scalar value");
+      yyerror(0, lParse, "Cannot index a scalar value");
       return(-1);
    }
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->nSubNodes   = nDim+1;
-      theVar            = gParse.Nodes + (this->SubNodes[0]=Var);
-      theDim[0]         = gParse.Nodes + (this->SubNodes[1]=Dim1);
-      theDim[1]         = gParse.Nodes + (this->SubNodes[2]=Dim2);
-      theDim[2]         = gParse.Nodes + (this->SubNodes[3]=Dim3);
-      theDim[3]         = gParse.Nodes + (this->SubNodes[4]=Dim4);
-      theDim[4]         = gParse.Nodes + (this->SubNodes[5]=Dim5);
+      theVar            = lParse->Nodes + (this->SubNodes[0]=Var);
+      theDim[0]         = lParse->Nodes + (this->SubNodes[1]=Dim1);
+      theDim[1]         = lParse->Nodes + (this->SubNodes[2]=Dim2);
+      theDim[2]         = lParse->Nodes + (this->SubNodes[3]=Dim3);
+      theDim[3]         = lParse->Nodes + (this->SubNodes[4]=Dim4);
+      theDim[4]         = lParse->Nodes + (this->SubNodes[5]=Dim5);
       constant          = theVar->operation==CONST_OP;
       for( idx=0; idx<nDim; idx++ )
 	 constant = (constant && theDim[idx]->operation==CONST_OP);
 
       for( idx=0; idx<nDim; idx++ )
 	 if( theDim[idx]->value.nelem>1 ) {
-	    Free_Last_Node();
-	    yyerror("Cannot use an array as an index value");
+	    Free_Last_Node(lParse);
+	    yyerror(0, lParse, "Cannot use an array as an index value");
 	    return(-1);
 	 } else if( theDim[idx]->type!=LONG ) {
-	    Free_Last_Node();
-	    yyerror("Index value must be an integer type");
+	    Free_Last_Node(lParse);
+	    yyerror(0, lParse, "Index value must be an integer type");
 	    return(-1);
 	 }
 
       this->operation   = '[';
       this->DoOp        = Do_Deref;
       this->type        = theVar->type;
 
@@ -1483,53 +1640,66 @@
 	 elem=1;
 	 this->value.naxis = theVar->value.naxis-1;
 	 for( idx=0; idx<this->value.naxis; idx++ ) {
 	    elem *= ( this->value.naxes[idx] = theVar->value.naxes[idx] );
 	 }
 	 this->value.nelem = elem;
       } else {
-	 Free_Last_Node();
-	 yyerror("Must specify just one or all indices for vector");
+	 Free_Last_Node(lParse);
+	 yyerror(0, lParse, "Must specify just one or all indices for vector");
 	 return(-1);
       }
-      if( constant ) this->DoOp( this );
+      if( constant ) this->DoOp( lParse, this );
    }
    return(n);
 }
 
-extern int yyGetVariable( char *varName, YYSTYPE *varVal );
+extern int fits_parser_yyGetVariable( ParseData *lParse, char *varName, YYSTYPE *varVal );
 
-static int New_GTI( char *fname, int Node1, char *start, char *stop )
+static int New_GTI( ParseData *lParse, funcOp Op, char *fname, int Node1, int Node2, char *start, char *stop )
 {
    fitsfile *fptr;
-   Node *this, *that0, *that1;
+   Node *this, *that0, *that1, *that2;
    int  type,i,n, startCol, stopCol, Node0;
    int  hdutype, hdunum, evthdu, samefile, extvers, movetotype, tstat;
    char extname[100];
    long nrows;
    double timeZeroI[2], timeZeroF[2], dt, timeSpan;
    char xcol[20], xexpr[20];
    YYSTYPE colVal;
 
-   if( Node1==-99 ) {
-      type = yyGetVariable( "TIME", &colVal );
+   if( (Op == gtifilt_fct || Op == gtifind_fct) && Node1==-99 ) {
+      type = fits_parser_yyGetVariable( lParse,  "TIME", &colVal );
       if( type==COLUMN ) {
-	 Node1 = New_Column( (int)colVal.lng );
+	 Node1 = New_Column( lParse, (int)colVal.lng );
       } else {
-	 yyerror("Could not build TIME column for GTIFILTER");
+	 yyerror(0, lParse, "Could not build TIME column for GTIFILTER/GTIFIND");
 	 return(-1);
       }
    }
-   Node1 = New_Unary( DOUBLE, 0, Node1 );
-   Node0 = Alloc_Node(); /* This will hold the START/STOP times */
+
+   if (Op == gtiover_fct) {
+     if (Node1 == -99 || Node2 == -99) {
+       yyerror(0, lParse, "startExpr and stopExpr values must be defined for GTIOVERLAP");
+       return(-1);
+     }
+     /* Also case TIME_STOP to double precision */
+     Node2 = New_Unary( lParse, DOUBLE, 0, Node2 );
+     if (Node2 < 0) return(-1);
+
+   }
+
+   /* Type cast TIME to double precision */
+   Node1 = New_Unary( lParse, DOUBLE, 0, Node1 );
+   Node0 = Alloc_Node(lParse); /* This will hold the START/STOP times */
    if( Node1<0 || Node0<0 ) return(-1);
 
    /*  Record current HDU number in case we need to move within this file  */
 
-   fptr = gParse.def_fptr;
+   fptr = lParse->def_fptr;
    ffghdn( fptr, &evthdu );
 
    /*  Look for TIMEZERO keywords in current extension  */
 
    tstat = 0;
    if( ffgkyd( fptr, "TIMEZERO", timeZeroI, NULL, &tstat ) ) {
       tstat = 0;
@@ -1553,71 +1723,71 @@
       samefile = 1;
       i = 1;
       while( fname[i] != '\0' && fname[i] != ']' ) i++;
       if( fname[i] ) {
 	 fname[i] = '\0';
 	 fname++;
 	 ffexts( fname, &hdunum, extname, &extvers, &movetotype,
-		 xcol, xexpr, &gParse.status );
+		 xcol, xexpr, &lParse->status );
          if( *extname ) {
-	    ffmnhd( fptr, movetotype, extname, extvers, &gParse.status );
+	    ffmnhd( fptr, movetotype, extname, extvers, &lParse->status );
 	    ffghdn( fptr, &hdunum );
 	 } else if( hdunum ) {
-	    ffmahd( fptr, ++hdunum, &hdutype, &gParse.status );
-	 } else if( !gParse.status ) {
-	    yyerror("Cannot use primary array for GTI filter");
+	    ffmahd( fptr, ++hdunum, &hdutype, &lParse->status );
+	 } else if( !lParse->status ) {
+	    yyerror(0, lParse, "Cannot use primary array for GTI filter");
 	    return( -1 );
 	 }
       } else {
-	 yyerror("File extension specifier lacks closing ']'");
+	 yyerror(0, lParse, "File extension specifier lacks closing ']'");
 	 return( -1 );
       }
       break;
    case '+':
       samefile = 1;
       hdunum = atoi( fname ) + 1;
       if( hdunum>1 )
-	 ffmahd( fptr, hdunum, &hdutype, &gParse.status );
+	 ffmahd( fptr, hdunum, &hdutype, &lParse->status );
       else {
-	 yyerror("Cannot use primary array for GTI filter");
+	 yyerror(0, lParse, "Cannot use primary array for GTI filter / GTIFIND");
 	 return( -1 );
       }
       break;
    default:
       samefile = 0;
-      if( ! ffopen( &fptr, fname, READONLY, &gParse.status ) )
+      if( ! ffopen( &fptr, fname, READONLY, &lParse->status ) )
 	 ffghdn( fptr, &hdunum );
       break;
    }
-   if( gParse.status ) return(-1);
+   if( lParse->status ) return(-1);
 
    /*  If at primary, search for GTI extension  */
 
    if( hdunum==1 ) {
       while( 1 ) {
 	 hdunum++;
-	 if( ffmahd( fptr, hdunum, &hdutype, &gParse.status ) ) break;
+	 if( ffmahd( fptr, hdunum, &hdutype, &lParse->status ) ) break;
 	 if( hdutype==IMAGE_HDU ) continue;
 	 tstat = 0;
 	 if( ffgkys( fptr, "EXTNAME", extname, NULL, &tstat ) ) continue;
 	 ffupch( extname );
 	 if( strstr( extname, "GTI" ) ) break;
       }
-      if( gParse.status ) {
-	 if( gParse.status==END_OF_FILE )
-	    yyerror("GTI extension not found in this file");
+      if( lParse->status ) {
+	 if( lParse->status==END_OF_FILE )
+	    yyerror(0, lParse, "GTI extension not found in this file");
 	 return(-1);
       }
    }
 
    /*  Locate START/STOP Columns  */
 
-   ffgcno( fptr, CASEINSEN, start, &startCol, &gParse.status );
-   ffgcno( fptr, CASEINSEN, stop,  &stopCol,  &gParse.status );
-   if( gParse.status ) return(-1);
+   ffgcno( fptr, CASEINSEN, start, &startCol, &lParse->status );
+   ffgcno( fptr, CASEINSEN, stop,  &stopCol,  &lParse->status );
+   if( lParse->status ) return(-1);
 
    /*  Look for TIMEZERO keywords in GTI extension  */
 
    tstat = 0;
    if( ffgkyd( fptr, "TIMEZERO", timeZeroI+1, NULL, &tstat ) ) {
       tstat = 0;
       if( ffgkyd( fptr, "TIMEZERI", timeZeroI+1, NULL, &tstat ) ) {
@@ -1625,54 +1795,72 @@
       } else if( ffgkyd( fptr, "TIMEZERF", timeZeroF+1, NULL, &tstat ) ) {
 	 timeZeroF[1] = 0.0;
       }
    } else {
       timeZeroF[1] = 0.0;
    }
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n >= 0 ) {
-      this                 = gParse.Nodes + n;
-      this->nSubNodes      = 2;
+      this                 = lParse->Nodes + n;
       this->SubNodes[1]    = Node1;
-      this->operation      = (int)gtifilt_fct;
-      this->DoOp           = Do_GTI;
-      this->type           = BOOLEAN;
-      that1                = gParse.Nodes + Node1;
+      this->operation      = (int) Op;
+      if (Op == gtifilt_fct) {
+	this->nSubNodes      = 2;
+	this->DoOp           = Do_GTI;
+	this->type           = BOOLEAN;
+      } else if (Op == gtifind_fct) {
+	this->nSubNodes      = 2;
+	this->DoOp           = Do_GTI;
+	this->type           = LONG;
+      } else {
+	this->nSubNodes      = 3;
+	this->DoOp           = Do_GTI_Over;
+	this->type           = DOUBLE;
+      }
+      that1                = lParse->Nodes + Node1;
       this->value.nelem    = that1->value.nelem;
       this->value.naxis    = that1->value.naxis;
       for( i=0; i < that1->value.naxis; i++ )
 	 this->value.naxes[i] = that1->value.naxes[i];
+      if (Op == gtiover_fct) {
+	this->SubNodes[2]  = Node2;
+	that2 = lParse->Nodes + Node2;
+	if (that1->value.nelem != that2->value.nelem) {
+	  yyerror(0, lParse, "Dimensions of TIME and TIME_STOP must match for GTIOVERLAP");
+	  return(-1);
+	}
+      }
 
       /* Init START/STOP node to be treated as a "constant" */
 
       this->SubNodes[0]    = Node0;
-      that0                = gParse.Nodes + Node0;
+      that0                = lParse->Nodes + Node0;
       that0->operation     = CONST_OP;
       that0->DoOp          = NULL;
       that0->value.data.ptr= NULL;
 
       /*  Read in START/STOP times  */
 
-      if( ffgkyj( fptr, "NAXIS2", &nrows, NULL, &gParse.status ) )
+      if( ffgkyj( fptr, "NAXIS2", &nrows, NULL, &lParse->status ) )
 	 return(-1);
       that0->value.nelem = nrows;
       if( nrows ) {
 
 	 that0->value.data.dblptr = (double*)malloc( 2*nrows*sizeof(double) );
 	 if( !that0->value.data.dblptr ) {
-	    gParse.status = MEMORY_ALLOCATION;
+	    lParse->status = MEMORY_ALLOCATION;
 	    return(-1);
 	 }
 	 
 	 ffgcvd( fptr, startCol, 1L, 1L, nrows, 0.0,
-		 that0->value.data.dblptr, &i, &gParse.status );
+		 that0->value.data.dblptr, &i, &lParse->status );
 	 ffgcvd( fptr, stopCol, 1L, 1L, nrows, 0.0,
-		 that0->value.data.dblptr+nrows, &i, &gParse.status );
-	 if( gParse.status ) {
+		 that0->value.data.dblptr+nrows, &i, &lParse->status );
+	 if( lParse->status ) {
 	    free( that0->value.data.dblptr );
 	    return(-1);
 	 }
 
 	 /*  Test for fully time-ordered GTI... both START && STOP  */
 
 	 that0->type = 1; /*  Assume yes  */
@@ -1681,96 +1869,106 @@
 	    if(    that0->value.data.dblptr[i-1]
                    >= that0->value.data.dblptr[i]
 		|| that0->value.data.dblptr[i-1+nrows]
 		   >= that0->value.data.dblptr[i+nrows] ) {
 	       that0->type = 0;
 	       break;
 	    }
+
+	 /* GTIOVERLAP() requires ordered GTI */
+	 if (that0->type != 1 && Op == gtiover_fct) {
+	   yyerror(0, lParse, "Input GTI must be time-ordered for GTIOVERLAP");
+	   return(-1);
+	 }
 	 
 	 /*  Handle TIMEZERO offset, if any  */
 	 
 	 dt = (timeZeroI[1] - timeZeroI[0]) + (timeZeroF[1] - timeZeroF[0]);
 	 timeSpan = that0->value.data.dblptr[nrows+nrows-1]
 	    - that0->value.data.dblptr[0];
+	 if (timeSpan == 0) timeSpan = 1.0;
 	 
 	 if( fabs( dt / timeSpan ) > 1e-12 ) {
 	    for( i=0; i<(nrows+nrows); i++ )
 	       that0->value.data.dblptr[i] += dt;
 	 }
       }
-      if( OPER(Node1)==CONST_OP )
-	 this->DoOp( this );
+      /* If Node1 is constant (gtifilt_fct) or
+	 Node1 and Node2 are constant (gtiover_fct), then evaluate now */
+      if( OPER(Node1)==CONST_OP && (Op == gtifilt_fct || OPER(Node2)==CONST_OP)) {
+	this->DoOp( lParse, this );
+      }
    }
 
    if( samefile )
-      ffmahd( fptr, evthdu, &hdutype, &gParse.status );
+      ffmahd( fptr, evthdu, &hdutype, &lParse->status );
    else
-      ffclos( fptr, &gParse.status );
+      ffclos( fptr, &lParse->status );
 
    return( n );
 }
 
-static int New_REG( char *fname, int NodeX, int NodeY, char *colNames )
+static int New_REG( ParseData *lParse, char *fname, int NodeX, int NodeY, char *colNames )
 {
    Node *this, *that0;
    int  type, n, Node0;
    int  Xcol, Ycol, tstat;
    WCSdata wcs;
    SAORegion *Rgn;
    char *cX, *cY;
    YYSTYPE colVal;
 
    if( NodeX==-99 ) {
-      type = yyGetVariable( "X", &colVal );
+      type = fits_parser_yyGetVariable( lParse,  "X", &colVal );
       if( type==COLUMN ) {
-	 NodeX = New_Column( (int)colVal.lng );
+	 NodeX = New_Column( lParse, (int)colVal.lng );
       } else {
-	 yyerror("Could not build X column for REGFILTER");
+	 yyerror(0, lParse, "Could not build X column for REGFILTER");
 	 return(-1);
       }
    }
    if( NodeY==-99 ) {
-      type = yyGetVariable( "Y", &colVal );
+      type = fits_parser_yyGetVariable( lParse, "Y", &colVal );
       if( type==COLUMN ) {
-	 NodeY = New_Column( (int)colVal.lng );
+ 	 NodeY = New_Column( lParse, (int)colVal.lng );
       } else {
-	 yyerror("Could not build Y column for REGFILTER");
+	 yyerror(0, lParse, "Could not build Y column for REGFILTER");
 	 return(-1);
       }
    }
-   NodeX = New_Unary( DOUBLE, 0, NodeX );
-   NodeY = New_Unary( DOUBLE, 0, NodeY );
-   Node0 = Alloc_Node(); /* This will hold the Region Data */
+   NodeX = New_Unary( lParse, DOUBLE, 0, NodeX );
+   NodeY = New_Unary( lParse, DOUBLE, 0, NodeY );
+   Node0 = Alloc_Node(lParse); /* This will hold the Region Data */
    if( NodeX<0 || NodeY<0 || Node0<0 ) return(-1);
 
-   if( ! (Test_Dims( NodeX, NodeY ) ) ) {
-     yyerror("Dimensions of REGFILTER arguments are not compatible");
+   if( ! (Test_Dims( lParse, NodeX, NodeY ) ) ) {
+     yyerror(0, lParse, "Dimensions of REGFILTER arguments are not compatible");
      return (-1);
    }
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n >= 0 ) {
-      this                 = gParse.Nodes + n;
+      this                 = lParse->Nodes + n;
       this->nSubNodes      = 3;
       this->SubNodes[0]    = Node0;
       this->SubNodes[1]    = NodeX;
       this->SubNodes[2]    = NodeY;
       this->operation      = (int)regfilt_fct;
       this->DoOp           = Do_REG;
       this->type           = BOOLEAN;
       this->value.nelem    = 1;
       this->value.naxis    = 1;
       this->value.naxes[0] = 1;
       
-      Copy_Dims(n, NodeX);
-      if( SIZE(NodeX)<SIZE(NodeY) )  Copy_Dims(n, NodeY);
+      Copy_Dims(lParse, n, NodeX);
+      if( SIZE(NodeX)<SIZE(NodeY) )  Copy_Dims(lParse, n, NodeY);
 
       /* Init Region node to be treated as a "constant" */
 
-      that0                = gParse.Nodes + Node0;
+      that0                = lParse->Nodes + Node0;
       that0->operation     = CONST_OP;
       that0->DoOp          = NULL;
 
       /*  Identify what columns to use for WCS information  */
 
       Xcol = Ycol = 0;
       if( *colNames ) {
@@ -1778,167 +1976,242 @@
 	 while( *colNames==' ' ) colNames++;
 	 cX = cY = colNames;
 	 while( *cY && *cY!=' ' && *cY!=',' ) cY++;
 	 if( *cY )
 	    *(cY++) = '\0';
 	 while( *cY==' ' ) cY++;
 	 if( !*cY ) {
-	    yyerror("Could not extract valid pair of column names from REGFILTER");
-	    Free_Last_Node();
+	    yyerror(0, lParse, "Could not extract valid pair of column names from REGFILTER");
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 }
-	 fits_get_colnum( gParse.def_fptr, CASEINSEN, cX, &Xcol,
-			  &gParse.status );
-	 fits_get_colnum( gParse.def_fptr, CASEINSEN, cY, &Ycol,
-			  &gParse.status );
-	 if( gParse.status ) {
-	    yyerror("Could not locate columns indicated for WCS info");
-	    Free_Last_Node();
+	 fits_get_colnum( lParse->def_fptr, CASEINSEN, cX, &Xcol,
+			  &lParse->status );
+	 fits_get_colnum( lParse->def_fptr, CASEINSEN, cY, &Ycol,
+			  &lParse->status );
+	 if( lParse->status ) {
+	    yyerror(0, lParse, "Could not locate columns indicated for WCS info");
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 }
 
       } else {
 	 /*  Try to find columns used in X/Y expressions  */
-	 Xcol = Locate_Col( gParse.Nodes + NodeX );
-	 Ycol = Locate_Col( gParse.Nodes + NodeY );
+	 Xcol = Locate_Col( lParse, lParse->Nodes + NodeX );
+	 Ycol = Locate_Col( lParse, lParse->Nodes + NodeY );
 	 if( Xcol<0 || Ycol<0 ) {
-	    yyerror("Found multiple X/Y column references in REGFILTER");
-	    Free_Last_Node();
+	    yyerror(0, lParse, "Found multiple X/Y column references in REGFILTER");
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 }
       }
 
       /*  Now, get the WCS info, if it exists, from the indicated columns  */
       wcs.exists = 0;
       if( Xcol>0 && Ycol>0 ) {
 	 tstat = 0;
-	 ffgtcs( gParse.def_fptr, Xcol, Ycol,
+	 ffgtcs( lParse->def_fptr, Xcol, Ycol,
 		 &wcs.xrefval, &wcs.yrefval,
 		 &wcs.xrefpix, &wcs.yrefpix,
 		 &wcs.xinc,    &wcs.yinc,
 		 &wcs.rot,      wcs.type,
 		 &tstat );
 	 if( tstat==NO_WCS_KEY ) {
 	    wcs.exists = 0;
 	 } else if( tstat ) {
-	    gParse.status = tstat;
-	    Free_Last_Node();
+	    lParse->status = tstat;
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 } else {
 	    wcs.exists = 1;
 	 }
       }
 
       /*  Read in Region file  */
 
-      fits_read_rgnfile( fname, &wcs, &Rgn, &gParse.status );
-      if( gParse.status ) {
-	 Free_Last_Node();
+      fits_read_rgnfile( fname, &wcs, &Rgn, &lParse->status );
+      if( lParse->status ) {
+	 Free_Last_Node(lParse);
 	 return( -1 );
       }
 
       that0->value.data.ptr = Rgn;
 
       if( OPER(NodeX)==CONST_OP && OPER(NodeY)==CONST_OP )
-	 this->DoOp( this );
+	 this->DoOp( lParse, this );
    }
 
    return( n );
 }
 
-static int New_Vector( int subNode )
+static int New_Vector( ParseData *lParse, int subNode )
 {
    Node *this, *that;
    int n;
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n >= 0 ) {
-      this              = gParse.Nodes + n;
-      that              = gParse.Nodes + subNode;
+      this              = lParse->Nodes + n;
+      that              = lParse->Nodes + subNode;
       this->type        = that->type;
       this->nSubNodes   = 1;
       this->SubNodes[0] = subNode;
       this->operation   = '{';
       this->DoOp        = Do_Vector;
    }
 
    return( n );
 }
 
-static int Close_Vec( int vecNode )
+static int Close_Vec( ParseData *lParse, int vecNode )
 {
    Node *this;
    int n, nelem=0;
 
-   this = gParse.Nodes + vecNode;
+   this = lParse->Nodes + vecNode;
    for( n=0; n < this->nSubNodes; n++ ) {
       if( TYPE( this->SubNodes[n] ) != this->type ) {
-	 this->SubNodes[n] = New_Unary( this->type, 0, this->SubNodes[n] );
+	 this->SubNodes[n] = New_Unary( lParse, this->type, 0, this->SubNodes[n] );
 	 if( this->SubNodes[n]<0 ) return(-1);
       }
       nelem += SIZE(this->SubNodes[n]);
    }
    this->value.naxis    = 1;
    this->value.nelem    = nelem;
    this->value.naxes[0] = nelem;
 
    return( vecNode );
 }
 
-static int Locate_Col( Node *this )
+static int New_Array( ParseData *lParse, int valueNode, int dimNode )
+{
+  Node *dims;
+  long naxis, nelem;
+  long naxes[MAXDIMS];
+  Node *this;
+  int  n,i;
+
+   if( valueNode<0 || dimNode<0 ) return(-1);
+
+   /* Check that dimensions are {a,b,c,d}
+        - vector
+	- every element is constant integer
+	- 5 or fewer dimensions 
+   */
+
+   if (SIZE(valueNode) > 1) {
+     yyerror(0, lParse, "ARRAY(V,n) value V must have vector dimension of 1");
+     return (-1);
+   }
+
+   dims = &(lParse->Nodes[dimNode]);
+   for (i=0; i<MAXDIMS; i++) naxes[i] = 1;
+
+   if (OPER(dimNode) == CONST_OP) { /* ARRAY(V,n) is a constant integer */
+     if ( TYPE(dimNode) != LONG ) dimNode = New_Unary(lParse, LONG, 0, dimNode);
+     if (dimNode < 0) return (-1);
+     naxis = 1;
+     naxes[0] = lParse->Nodes[dimNode].value.data.lng;
+
+   } else if (OPER(dimNode) == '{') { /* ARRAY(V,{a,b,c,d,e}) up to 5 dimensions */
+     if (dims->nSubNodes > MAXDIMS) {
+       yyerror(0, lParse, "ARRAY(V,{...}) number of dimensions must not exceed 5");
+       return (-1);
+     }
+     naxis = dims->nSubNodes;
+     for (i=0; i<dims->nSubNodes; i++) {
+       if ( TYPE(dims->SubNodes[i]) != LONG ) {
+	 dims->SubNodes[i] = New_Unary(lParse, LONG, 0, dims->SubNodes[i]);
+	 if (dims->SubNodes[i] < 0) return (-1);
+       }
+       naxes[i] = lParse->Nodes[ dims->SubNodes[i] ].value.data.lng;
+     }
+   } else {
+     yyerror(0, lParse, "ARRAY(V,dims) dims must be either integer or const vector");
+     return (-1);
+   }
+
+   nelem = 1;
+   for (i=0; i<naxis; i++) {
+     if (naxes[i] <= 0) {
+       yyerror(0, lParse, "ARRAY(V,dims) must have positive dimensions");
+       return (-1);
+     }
+     nelem *= naxes[i];
+   }
+
+   n = Alloc_Node(lParse);
+   if( n>=0 ) {
+      this             = lParse->Nodes + n;
+      this->operation  = array_fct;
+      this->nSubNodes  = 1;
+      this->SubNodes[0]= valueNode;
+      this->type       = TYPE(valueNode);
+
+      this->value.nelem = nelem;
+      this->value.naxis = naxis;
+      for( i=0; i<naxis; i++ )
+	this->value.naxes[i] = naxes[i];
+
+      this->DoOp = Do_Array;
+   }
+   return( n );
+}
+
+static int Locate_Col( ParseData *lParse, Node *this )
 /*  Locate the TABLE column number of any columns in "this" calculation.  */
 /*  Return ZERO if none found, or negative if more than 1 found.          */
 {
    Node *that;
    int  i, col=0, newCol, nfound=0;
    
    if( this->nSubNodes==0
        && this->operation<=0 && this->operation!=CONST_OP )
-      return gParse.colData[ - this->operation].colnum;
+      return lParse->colData[ - this->operation].colnum;
 
    for( i=0; i<this->nSubNodes; i++ ) {
-      that = gParse.Nodes + this->SubNodes[i];
+      that = lParse->Nodes + this->SubNodes[i];
       if( that->operation>0 ) {
-	 newCol = Locate_Col( that );
+	 newCol = Locate_Col( lParse, that );
 	 if( newCol<=0 ) {
 	    nfound += -newCol;
 	 } else {
 	    if( !nfound ) {
 	       col = newCol;
 	       nfound++;
 	    } else if( col != newCol ) {
 	       nfound++;
 	    }
 	 }
       } else if( that->operation!=CONST_OP ) {
 	 /*  Found a Column  */
-	 newCol = gParse.colData[- that->operation].colnum;
+	 newCol = lParse->colData[- that->operation].colnum;
 	 if( !nfound ) {
 	    col = newCol;
 	    nfound++;
 	 } else if( col != newCol ) {
 	    nfound++;
 	 }
       }
    }
    if( nfound!=1 )
       return( - nfound );
    else
       return( col );
 }
 
-static int Test_Dims( int Node1, int Node2 )
+static int Test_Dims( ParseData *lParse, int Node1, int Node2 )
 {
    Node *that1, *that2;
    int valid, i;
 
    if( Node1<0 || Node2<0 ) return(0);
 
-   that1 = gParse.Nodes + Node1;
-   that2 = gParse.Nodes + Node2;
+   that1 = lParse->Nodes + Node1;
+   that2 = lParse->Nodes + Node2;
 
    if( that1->value.nelem==1 || that2->value.nelem==1 )
       valid = 1;
    else if( that1->type==that2->type
 	    && that1->value.nelem==that2->value.nelem
 	    && that1->value.naxis==that2->value.naxis ) {
       valid = 1;
@@ -1947,35 +2220,35 @@
 	    valid = 0;
       }
    } else
       valid = 0;
    return( valid );
 }   
 
-static void Copy_Dims( int Node1, int Node2 )
+static void Copy_Dims( ParseData *lParse, int Node1, int Node2 )
 {
    Node *that1, *that2;
    int i;
 
    if( Node1<0 || Node2<0 ) return;
 
-   that1 = gParse.Nodes + Node1;
-   that2 = gParse.Nodes + Node2;
+   that1 = lParse->Nodes + Node1;
+   that2 = lParse->Nodes + Node2;
 
    that1->value.nelem = that2->value.nelem;
    that1->value.naxis = that2->value.naxis;
    for( i=0; i<that2->value.naxis; i++ )
       that1->value.naxes[i] = that2->value.naxes[i];
 }
 
 /********************************************************************/
 /*    Routines for actually evaluating the expression start here    */
 /********************************************************************/
 
-void Evaluate_Parser( long firstRow, long nRows )
+void Evaluate_Parser( ParseData *lParse, long firstRow, long nRows )
     /***********************************************************************/
     /*  Reset the parser for processing another batch of data...           */
     /*    firstRow:  Row number of the first element to evaluate           */
     /*    nRows:     Number of rows to be processed                        */
     /*  Initialize each COLUMN node so that its UNDEF and DATA pointers    */
     /*  point to the appropriate column arrays.                            */
     /*  Finally, call Evaluate_Node for final node.                        */
@@ -1987,137 +2260,137 @@
 
    /* Initialize the random number generator once and only once */
    if (rand_initialized == 0) {
      simplerng_srand( (unsigned int) time(NULL) );
      rand_initialized = 1;
    }
 
-   gParse.firstRow = firstRow;
-   gParse.nRows    = nRows;
+   lParse->firstRow = firstRow;
+   lParse->nRows    = nRows;
 
    /*  Reset Column Nodes' pointers to point to right data and UNDEF arrays  */
 
-   rowOffset = firstRow - gParse.firstDataRow;
-   for( i=0; i<gParse.nNodes; i++ ) {
+   rowOffset = firstRow - lParse->firstDataRow;
+   for( i=0; i<lParse->nNodes; i++ ) {
      if(    OPER(i) >  0 || OPER(i) == CONST_OP ) continue;
 
       column = -OPER(i);
-      offset = gParse.varData[column].nelem * rowOffset;
+      offset = lParse->varData[column].nelem * rowOffset;
 
-      gParse.Nodes[i].value.undef = gParse.varData[column].undef + offset;
+      lParse->Nodes[i].value.undef = lParse->varData[column].undef + offset;
 
-      switch( gParse.Nodes[i].type ) {
+      switch( lParse->Nodes[i].type ) {
       case BITSTR:
-	 gParse.Nodes[i].value.data.strptr =
-	    (char**)gParse.varData[column].data + rowOffset;
-	 gParse.Nodes[i].value.undef       = NULL;
+	 lParse->Nodes[i].value.data.strptr =
+	    (char**)lParse->varData[column].data + rowOffset;
+	 lParse->Nodes[i].value.undef       = NULL;
 	 break;
       case STRING:
-	 gParse.Nodes[i].value.data.strptr = 
-	    (char**)gParse.varData[column].data + rowOffset;
-	 gParse.Nodes[i].value.undef = gParse.varData[column].undef + rowOffset;
+	 lParse->Nodes[i].value.data.strptr = 
+	    (char**)lParse->varData[column].data + rowOffset;
+	 lParse->Nodes[i].value.undef = lParse->varData[column].undef + rowOffset;
 	 break;
       case BOOLEAN:
-	 gParse.Nodes[i].value.data.logptr = 
-	    (char*)gParse.varData[column].data + offset;
+	 lParse->Nodes[i].value.data.logptr = 
+	    (char*)lParse->varData[column].data + offset;
 	 break;
       case LONG:
-	 gParse.Nodes[i].value.data.lngptr = 
-	    (long*)gParse.varData[column].data + offset;
+	 lParse->Nodes[i].value.data.lngptr = 
+	    (long*)lParse->varData[column].data + offset;
 	 break;
       case DOUBLE:
-	 gParse.Nodes[i].value.data.dblptr = 
-	    (double*)gParse.varData[column].data + offset;
+	 lParse->Nodes[i].value.data.dblptr = 
+	    (double*)lParse->varData[column].data + offset;
 	 break;
       }
    }
 
-   Evaluate_Node( gParse.resultNode );
+   Evaluate_Node( lParse, lParse->resultNode );
 }
 
-static void Evaluate_Node( int thisNode )
+static void Evaluate_Node( ParseData *lParse, int thisNode )
     /**********************************************************************/
     /*  Recursively evaluate thisNode's subNodes, then call one of the    */
     /*  Do_<Action> functions pointed to by thisNode's DoOp element.      */
     /**********************************************************************/
 {
    Node *this;
    int i;
    
-   if( gParse.status ) return;
+   if( lParse->status ) return;
 
-   this = gParse.Nodes + thisNode;
+   this = lParse->Nodes + thisNode;
    if( this->operation>0 ) {  /* <=0 indicate constants and columns */
       i = this->nSubNodes;
       while( i-- ) {
-	 Evaluate_Node( this->SubNodes[i] );
-	 if( gParse.status ) return;
+	 Evaluate_Node( lParse, this->SubNodes[i] );
+	 if( lParse->status ) return;
       }
-      this->DoOp( this );
+      this->DoOp( lParse, this );
    }
 }
 
-static void Allocate_Ptrs( Node *this )
+static void Allocate_Ptrs( ParseData *lParse, Node *this )
 {
    long elem, row, size;
 
    if( this->type==BITSTR || this->type==STRING ) {
 
-      this->value.data.strptr = (char**)malloc( gParse.nRows
+      this->value.data.strptr = (char**)malloc( lParse->nRows
 						* sizeof(char*) );
       if( this->value.data.strptr ) {
-	 this->value.data.strptr[0] = (char*)malloc( gParse.nRows
+	 this->value.data.strptr[0] = (char*)malloc( lParse->nRows
 						     * (this->value.nelem+2)
 						     * sizeof(char) );
 	 if( this->value.data.strptr[0] ) {
 	    row = 0;
-	    while( (++row)<gParse.nRows ) {
+	    while( (++row)<lParse->nRows ) {
 	       this->value.data.strptr[row] =
 		  this->value.data.strptr[row-1] + this->value.nelem+1;
 	    }
 	    if( this->type==STRING ) {
 	       this->value.undef = this->value.data.strptr[row-1]
                                    + this->value.nelem+1;
 	    } else {
 	       this->value.undef = NULL;  /* BITSTRs don't use undef array */
 	    }
 	 } else {
-	    gParse.status = MEMORY_ALLOCATION;
+	    lParse->status = MEMORY_ALLOCATION;
 	    free( this->value.data.strptr );
 	 }
       } else {
-	 gParse.status = MEMORY_ALLOCATION;
+	 lParse->status = MEMORY_ALLOCATION;
       }
 
    } else {
 
-      elem = this->value.nelem * gParse.nRows;
+      elem = this->value.nelem * lParse->nRows;
       switch( this->type ) {
       case DOUBLE:  size = sizeof( double ); break;
       case LONG:    size = sizeof( long   ); break;
       case BOOLEAN: size = sizeof( char   ); break;
       default:      size = 1;                break;
       }
 
       this->value.data.ptr = calloc(size+1, elem);
 
       if( this->value.data.ptr==NULL ) {
-	 gParse.status = MEMORY_ALLOCATION;
+	 lParse->status = MEMORY_ALLOCATION;
       } else {
 	 this->value.undef = (char *)this->value.data.ptr + elem*size;
       }
    }
 }
 
-static void Do_Unary( Node *this )
+static void Do_Unary( ParseData *lParse, Node *this )
 {
    Node *that;
    long elem;
 
-   that = gParse.Nodes + this->SubNodes[0];
+   that = lParse->Nodes + this->SubNodes[0];
 
    if( that->operation==CONST_OP ) {  /* Operating on a constant! */
       switch( this->operation ) {
       case DOUBLE:
       case FLTCAST:
 	 if( that->type==LONG )
 	    this->value.data.dbl = (double)that->value.data.lng;
@@ -2150,27 +2423,27 @@
 	    bitnot( this->value.data.str, that->value.data.str );
 	 break;
       }
       this->operation = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
 	 if( this->type!=BITSTR ) {
-	    elem = gParse.nRows;
+	    elem = lParse->nRows;
 	    if( this->type!=STRING )
 	       elem *= this->value.nelem;
 	    while( elem-- )
 	       this->value.undef[elem] = that->value.undef[elem];
 	 }
 
-	 elem = gParse.nRows * this->value.nelem;
+	 elem = lParse->nRows * this->value.nelem;
 
 	 switch( this->operation ) {
 
 	 case BOOLEAN:
 	    if( that->type==DOUBLE )
 	       while( elem-- )
 		  this->value.data.logptr[elem] =
@@ -2219,56 +2492,56 @@
 
 	 case NOT:
 	    if( that->type==BOOLEAN ) {
 	       while( elem-- )
 		  this->value.data.logptr[elem] =
 		     ( ! that->value.data.logptr[elem] );
 	    } else if( that->type==BITSTR ) {
-	       elem = gParse.nRows;
+	       elem = lParse->nRows;
 	       while( elem-- )
 		  bitnot( this->value.data.strptr[elem],
 			  that->value.data.strptr[elem] );
 	    }
 	    break;
 	 }
       }
    }
 
    if( that->operation>0 ) {
       free( that->value.data.ptr );
    }
 }
 
-static void Do_Offset( Node *this )
+static void Do_Offset( ParseData *lParse, Node *this )
 {
    Node *col;
    long fRow, nRowOverlap, nRowReload, rowOffset;
    long nelem, elem, offset, nRealElem;
    int status;
 
-   col       = gParse.Nodes + this->SubNodes[0];
-   rowOffset = gParse.Nodes[  this->SubNodes[1] ].value.data.lng;
+   col       = lParse->Nodes + this->SubNodes[0];
+   rowOffset = lParse->Nodes[  this->SubNodes[1] ].value.data.lng;
 
-   Allocate_Ptrs( this );
+   Allocate_Ptrs( lParse, this );
 
-   fRow   = gParse.firstRow + rowOffset;
+   fRow   = lParse->firstRow + rowOffset;
    if( this->type==STRING || this->type==BITSTR )
       nRealElem = 1;
    else
       nRealElem = this->value.nelem;
 
    nelem = nRealElem;
 
-   if( fRow < gParse.firstDataRow ) {
+   if( fRow < lParse->firstDataRow ) {
 
       /* Must fill in data at start of array */
 
-      nRowReload = gParse.firstDataRow - fRow;
-      if( nRowReload > gParse.nRows ) nRowReload = gParse.nRows;
-      nRowOverlap = gParse.nRows - nRowReload;
+      nRowReload = lParse->firstDataRow - fRow;
+      if( nRowReload > lParse->nRows ) nRowReload = lParse->nRows;
+      nRowOverlap = lParse->nRows - nRowReload;
 
       offset = 0;
 
       /*  NULLify any values falling out of bounds  */
 
       while( fRow<1 && nRowReload>0 ) {
 	 if( this->type == BITSTR ) {
@@ -2281,32 +2554,32 @@
 	       this->value.undef[offset++] = 1;
 	 }
 	 nelem = nRealElem;
 	 fRow++;
 	 nRowReload--;
       }
 
-   } else if( fRow + gParse.nRows > gParse.firstDataRow + gParse.nDataRows ) {
+   } else if( fRow + lParse->nRows > lParse->firstDataRow + lParse->nDataRows ) {
 
       /* Must fill in data at end of array */
 
-      nRowReload = (fRow+gParse.nRows) - (gParse.firstDataRow+gParse.nDataRows);
-      if( nRowReload>gParse.nRows ) {
-	 nRowReload = gParse.nRows;
+      nRowReload = (fRow+lParse->nRows) - (lParse->firstDataRow+lParse->nDataRows);
+      if( nRowReload>lParse->nRows ) {
+	 nRowReload = lParse->nRows;
       } else {
-	 fRow = gParse.firstDataRow + gParse.nDataRows;
+	 fRow = lParse->firstDataRow + lParse->nDataRows;
       }
-      nRowOverlap = gParse.nRows - nRowReload;
+      nRowOverlap = lParse->nRows - nRowReload;
 
       offset = nRowOverlap * nelem;
 
       /*  NULLify any values falling out of bounds  */
 
-      elem = gParse.nRows * nelem;
-      while( fRow+nRowReload>gParse.totalRows && nRowReload>0 ) {
+      elem = lParse->nRows * nelem;
+      while( fRow+nRowReload>lParse->totalRows && nRowReload>0 ) {
 	 if( this->type == BITSTR ) {
 	    nelem = this->value.nelem;
 	    elem--;
 	    this->value.data.strptr[elem][ nelem ] = '\0';
 	    while( nelem-- ) this->value.data.strptr[elem][nelem] = '0';
 	 } else {
 	    while( nelem-- )
@@ -2315,57 +2588,57 @@
 	 nelem = nRealElem;
 	 nRowReload--;
       }
 
    } else {
 
       nRowReload  = 0;
-      nRowOverlap = gParse.nRows;
+      nRowOverlap = lParse->nRows;
       offset      = 0;
 
    }
 
    if( nRowReload>0 ) {
       switch( this->type ) {
       case BITSTR:
       case STRING:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.strptr+offset,
 				      this->value.undef+offset );
 	 break;
       case BOOLEAN:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.logptr+offset,
 				      this->value.undef+offset );
 	 break;
       case LONG:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.lngptr+offset,
 				      this->value.undef+offset );
 	 break;
       case DOUBLE:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.dblptr+offset,
 				      this->value.undef+offset );
 	 break;
       }
    }
 
    /*  Now copy over the overlapping region, if any  */
 
    if( nRowOverlap <= 0 ) return;
 
    if( rowOffset>0 )
       elem = nRowOverlap * nelem;
    else
-      elem = gParse.nRows * nelem;
+      elem = lParse->nRows * nelem;
 
    offset = nelem * rowOffset;
-   while( nRowOverlap-- && !gParse.status ) {
-      while( nelem-- && !gParse.status ) {
+   while( nRowOverlap-- && !lParse->status ) {
+      while( nelem-- && !lParse->status ) {
 	 elem--;
 	 if( this->type != BITSTR )
 	    this->value.undef[elem] = col->value.undef[elem+offset];
 	 switch( this->type ) {
 	 case BITSTR:
 	    strcpy( this->value.data.strptr[elem       ],
                      col->value.data.strptr[elem+offset] );
@@ -2385,23 +2658,23 @@
 	    break;
 	 }
       }
       nelem = nRealElem;
    }
 }
 
-static void Do_BinOp_bit( Node *this )
+static void Do_BinOp_bit( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    char *sptr1=NULL, *sptr2=NULL;
    int  const1, const2;
    long rows;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    const1 = ( that1->operation==CONST_OP );
    const2 = ( that2->operation==CONST_OP );
    sptr1  = ( const1 ? that1->value.data.str : NULL );
    sptr2  = ( const2 ? that2->value.data.str : NULL );
 
    if( const1 && const2 ) {
@@ -2437,18 +2710,18 @@
 	break;
 	
       }
       this->operation = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
-
-      if( !gParse.status ) {
-	 rows  = gParse.nRows;
+      Allocate_Ptrs( lParse, this );
+     
+      if( !lParse->status ) {
+	 rows  = lParse->nRows;
 	 switch( this->operation ) {
 
 	    /*  BITSTR comparisons  */
 
 	 case NE:
 	 case EQ:
 	 case GT:
@@ -2530,23 +2803,23 @@
    }
    if( that2->operation>0 ) {
       free( that2->value.data.strptr[0] );
       free( that2->value.data.strptr    );
    }
 }
 
-static void Do_BinOp_str( Node *this )
+static void Do_BinOp_str( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    char *sptr1, *sptr2, null1=0, null2=0;
    int const1, const2, val;
    long rows;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    const1 = ( that1->operation==CONST_OP );
    const2 = ( that2->operation==CONST_OP );
    sptr1  = ( const1 ? that1->value.data.str : NULL );
    sptr2  = ( const2 ? that2->value.data.str : NULL );
 
    if( const1 && const2 ) {  /*  Result is a constant  */
@@ -2579,19 +2852,19 @@
 	 strcat( this->value.data.str, sptr2 );
 	 break;
       }
       this->operation = CONST_OP;
 
    } else {  /*  Not a constant  */
 
-      Allocate_Ptrs( this );
+     Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
-	 rows = gParse.nRows;
+	 rows = lParse->nRows;
 	 switch( this->operation ) {
 
 	    /*  Compare Strings  */
 
 	 case NE:
 	 case EQ:
 	    while( rows-- ) {
@@ -2665,23 +2938,23 @@
    }
    if( that2->operation>0 ) {
       free( that2->value.data.strptr[0] );
       free( that2->value.data.strptr );
    }
 }
 
-static void Do_BinOp_log( Node *this )
+static void Do_BinOp_log( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    int vector1, vector2;
    char val1=0, val2=0, null1=0, null2=0;
    long rows, nelem, elem;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    vector1 = ( that1->operation!=CONST_OP );
    if( vector1 )
       vector1 = that1->value.nelem;
    else {
       val1  = that1->value.data.log;
    }
@@ -2710,21 +2983,21 @@
       case ACCUM:
 	 this->value.data.lng = val1;
 	 break;
       }
       this->operation=CONST_OP;
    } else if (this->operation == ACCUM) {
       long i, previous, curr;
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
       
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
       
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	previous = that2->value.data.lng;
 	
 	/* Cumulative sum of this chunk */
 	for (i=0; i<elem; i++) {
 	  if (!that1->value.undef[i]) {
 	    curr = that1->value.data.logptr[i];
 	    previous += curr;
@@ -2734,21 +3007,21 @@
 	}
 	
 	/* Store final cumulant for next pass */
 	that2->value.data.lng = previous;
       }
       
    } else {
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	
 	 if (this->operation == ACCUM) {
 	   long i, previous, curr;
 	   
 	   previous = that2->value.data.lng;
 	   
 	   /* Cumulative sum of this chunk */
@@ -2834,24 +3107,24 @@
       free( that1->value.data.ptr );
    }
    if( that2->operation>0 ) {
       free( that2->value.data.ptr );
    }
 }
 
-static void Do_BinOp_lng( Node *this )
+static void Do_BinOp_lng( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    int  vector1, vector2;
    long val1=0, val2=0;
    char null1=0, null2=0;
    long rows, nelem, elem;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    vector1 = ( that1->operation!=CONST_OP );
    if( vector1 )
       vector1 = that1->value.nelem;
    else {
       val1  = that1->value.data.lng;
    }
@@ -2880,19 +3153,19 @@
 
       case '&':   this->value.data.lng = (val1  & val2);   break;
       case '|':   this->value.data.lng = (val1  | val2);   break;
       case '^':   this->value.data.lng = (val1  ^ val2);   break;
 
       case '%':
 	 if( val2 ) this->value.data.lng = (val1 % val2);
-	 else       yyerror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case '/': 
 	 if( val2 ) this->value.data.lng = (val1 / val2); 
-	 else       yyerror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case POWER:
 	 this->value.data.lng = (long)pow((double)val1,(double)val2);
 	 break;
       case ACCUM:
 	 this->value.data.lng = val1;
 	 break;
@@ -2901,21 +3174,21 @@
 	 break;
       }
       this->operation=CONST_OP;
 
    } else if ((this->operation == ACCUM) || (this->operation == DIFF)) {
       long i, previous, curr;
       long undef;
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
       
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
       
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	previous = that2->value.data.lng;
 	undef    = (long) that2->value.undef;
 	
 	if (this->operation == ACCUM) {
 	  /* Cumulative sum of this chunk */
 	  for (i=0; i<elem; i++) {
 	    if (!that1->value.undef[i]) {
@@ -2947,22 +3220,22 @@
 	/* Store final cumulant for next pass */
 	that2->value.data.lng = previous;
 	that2->value.undef    = (char *) undef; /* XXX evil, but no harm here */
       }
       
    } else {
 
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      while( rows-- && !gParse.status ) {
-	 while( nelem-- && !gParse.status ) {
+      while( rows-- && !lParse->status ) {
+	 while( nelem-- && !lParse->status ) {
 	    elem--;
 
 	    if( vector1>1 ) {
 	       val1  = that1->value.data.lngptr[elem];
 	       null1 = that1->value.undef[elem];
 	    } else if( vector1 ) {
 	       val1  = that1->value.data.lngptr[rows];
@@ -3022,24 +3295,24 @@
       free( that1->value.data.ptr );
    }
    if( that2->operation>0 ) {
       free( that2->value.data.ptr );
    }
 }
 
-static void Do_BinOp_dbl( Node *this )
+static void Do_BinOp_dbl( ParseData *lParse, Node *this )
 {
    Node   *that1, *that2;
    int    vector1, vector2;
    double val1=0.0, val2=0.0;
    char   null1=0, null2=0;
    long   rows, nelem, elem;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    vector1 = ( that1->operation!=CONST_OP );
    if( vector1 )
       vector1 = that1->value.nelem;
    else {
       val1  = that1->value.data.dbl;
    }
@@ -3064,19 +3337,19 @@
 
       case '+':   this->value.data.dbl = (val1  + val2);   break;
       case '-':   this->value.data.dbl = (val1  - val2);   break;
       case '*':   this->value.data.dbl = (val1  * val2);   break;
 
       case '%':
 	 if( val2 ) this->value.data.dbl = val1 - val2*((int)(val1/val2));
-	 else       yyerror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case '/': 
 	 if( val2 ) this->value.data.dbl = (val1 / val2); 
-	 else       yyerror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case POWER:
 	 this->value.data.dbl = (double)pow(val1,val2);
 	 break;
       case ACCUM:
 	 this->value.data.dbl = val1;
 	 break;
@@ -3086,21 +3359,21 @@
       }
       this->operation=CONST_OP;
 
    } else if ((this->operation == ACCUM) || (this->operation == DIFF)) {
       long i;
       long undef;
       double previous, curr;
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
       
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
       
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	previous = that2->value.data.dbl;
 	undef    = (long) that2->value.undef;
 	
 	if (this->operation == ACCUM) {
 	  /* Cumulative sum of this chunk */
 	  for (i=0; i<elem; i++) {
 	    if (!that1->value.undef[i]) {
@@ -3132,22 +3405,22 @@
 	/* Store final cumulant for next pass */
 	that2->value.data.dbl = previous;
 	that2->value.undef    = (char *) undef; /* XXX evil, but no harm here */
       }
       
    } else {
 
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      while( rows-- && !gParse.status ) {
-	 while( nelem-- && !gParse.status ) {
+      while( rows-- && !lParse->status ) {
+	 while( nelem-- && !lParse->status ) {
 	    elem--;
 
 	    if( vector1>1 ) {
 	       val1  = that1->value.data.dblptr[elem];
 	       null1 = that1->value.undef[elem];
 	    } else if( vector1 ) {
 	       val1  = that1->value.data.dblptr[rows];
@@ -3393,29 +3666,29 @@
   /* Sanity checking to avoid a range error in the sqrt()'s below */
   if (a < 0) { a = 0; }
   if (a > 1) { a = 1; }
 
   return 2.0*atan2(sqrt(a), sqrt(1.0 - a)) / deg;
 }
 
-static void Do_Func( Node *this )
+static void Do_Func( ParseData *lParse, Node *this )
 {
    Node *theParams[MAXSUBS];
    int  vector[MAXSUBS], allConst;
    lval pVals[MAXSUBS];
    char pNull[MAXSUBS];
    long   ival;
    double dval;
    int  i, valInit;
    long row, elem, nelem;
 
    i = this->nSubNodes;
    allConst = 1;
    while( i-- ) {
-      theParams[i] = gParse.Nodes + this->SubNodes[i];
+      theParams[i] = lParse->Nodes + this->SubNodes[i];
       vector[i]   = ( theParams[i]->operation!=CONST_OP );
       if( vector[i] ) {
 	 allConst = 0;
 	 vector[i] = theParams[i]->value.nelem;
       } else {
 	 if( theParams[i]->type==DOUBLE ) {
 	    pVals[i].data.dbl = theParams[i]->value.data.dbl;
@@ -3500,14 +3773,20 @@
             else if( this->type==LONG )
 	       this->value.data.lng = pVals[0].data.lng;
             else if( this->type==DOUBLE )
 	       this->value.data.dbl = pVals[0].data.dbl;
             else if( this->type==STRING )
 	       strcpy(this->value.data.str,pVals[0].data.str);
 	    break;
+        case setnull_fct: /* Only defined for numeric expressions */
+            if( this->type==LONG )
+ 	      this->value.data.lng = pVals[0].data.lng;
+            else if( this->type==DOUBLE )
+	       this->value.data.dbl = pVals[0].data.dbl;
+	    break;
 
 	    /* Math functions with 1 double argument */
 
 	 case sin_fct:
 	    this->value.data.dbl = sin( pVals[0].data.dbl );
 	    break;
 	 case cos_fct:
@@ -3515,22 +3794,22 @@
 	    break;
 	 case tan_fct:
 	    this->value.data.dbl = tan( pVals[0].data.dbl );
 	    break;
 	 case asin_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<-1.0 || dval>1.0 )
-	       yyerror("Out of range argument to arcsin");
+	       yyerror(0, lParse, "Out of range argument to arcsin");
 	    else
 	       this->value.data.dbl = asin( dval );
 	    break;
 	 case acos_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<-1.0 || dval>1.0 )
-	       yyerror("Out of range argument to arccos");
+	       yyerror(0, lParse, "Out of range argument to arccos");
 	    else
 	       this->value.data.dbl = acos( dval );
 	    break;
 	 case atan_fct:
 	    this->value.data.dbl = atan( pVals[0].data.dbl );
 	    break;
 	 case sinh_fct:
@@ -3544,29 +3823,29 @@
 	    break;
 	 case exp_fct:
 	    this->value.data.dbl = exp( pVals[0].data.dbl );
 	    break;
 	 case log_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<=0.0 )
-	       yyerror("Out of range argument to log");
+	       yyerror(0, lParse, "Out of range argument to log");
 	    else
 	       this->value.data.dbl = log( dval );
 	    break;
 	 case log10_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<=0.0 )
-	       yyerror("Out of range argument to log10");
+	       yyerror(0, lParse, "Out of range argument to log10");
 	    else
 	       this->value.data.dbl = log10( dval );
 	    break;
 	 case sqrt_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<0.0 )
-	       yyerror("Out of range argument to sqrt");
+	       yyerror(0, lParse, "Out of range argument to sqrt");
 	    else
 	       this->value.data.dbl = sqrt( dval );
 	    break;
 	 case ceil_fct:
 	    this->value.data.dbl = ceil( pVals[0].data.dbl );
 	    break;
 	 case floor_fct:
@@ -3673,15 +3952,16 @@
                                               pVals[1].data.str ) );
                break;
             }
             break;
 
 	    /* String functions */
          case strmid_fct:
-	   cstrmid(this->value.data.str, this->value.nelem, 
+	   cstrmid(lParse, 
+		   this->value.data.str, this->value.nelem, 
 		   pVals[0].data.str,    pVals[0].nelem,
 		   pVals[1].data.lng);
 	   break;
          case strpos_fct:
 	   {
 	     char *res = strstr(pVals[0].data.str, pVals[1].data.str);
 	     if (res == NULL) {
@@ -3693,27 +3973,27 @@
 	   }
 
       }
       this->operation = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+     Allocate_Ptrs( lParse, this );
 
-      row  = gParse.nRows;
+      row  = lParse->nRows;
       elem = row * this->value.nelem;
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	 switch( this->operation ) {
 
 	    /* Special functions with no arguments */
 
 	 case row_fct:
 	    while( row-- ) {
-	       this->value.data.lngptr[row] = gParse.firstRow + row;
+	       this->value.data.lngptr[row] = lParse->firstRow + row;
 	       this->value.undef[row] = 0;
 	    }
 	    break;
 	 case null_fct:
             if( this->type==LONG ) {
                while( row-- ) {
                   this->value.data.lngptr[row] = 0;
@@ -3722,14 +4002,57 @@
             } else if( this->type==STRING ) {
                while( row-- ) {
                   this->value.data.strptr[row][0] = '\0';
                   this->value.undef[row] = 1;
                }
             }
 	    break;
+	 case axiselem_fct:
+	   {
+	     long ielem;
+	     long iaxis[MAXDIMS] = {1, 1, 1, 1, 1};
+	     long ipos = pVals[1].data.lng - 1; /* This should be a constant long value */
+	     int naxis = this->value.naxis;
+	     int j;
+	     if (ipos < 0 || ipos >= MAXDIMS) {
+	         yyerror(0, lParse, "AXISELEM(V,n) n value exceeded maximum dimension");
+		 free( this->value.data.ptr );
+		 break;
+	     }
+
+	     for (ielem = 0; ielem<elem; ielem++) {
+	       this->value.data.lngptr[ielem] = iaxis[ipos];
+	       this->value.undef[ielem] = 0;
+	       iaxis[0]++;
+	       for (j = 0; j < naxis; j++) {
+		 if (iaxis[j] > this->value.naxes[j]) { 
+		   iaxis[j] = 1; 
+		   if (j < (naxis-1)) iaxis[j+1]++;
+		 } else {
+		   break;
+		 }
+	       }
+
+	     }
+	   }
+	   break;
+	 case elemnum_fct:
+	   {
+	     long ielem;
+	     long elemnum = 1;
+	     int j;
+
+	     for (ielem = 0; ielem<elem; ielem++) {
+	       this->value.data.lngptr[ielem] = elemnum;
+	       this->value.undef[ielem] = 0;
+	       elemnum ++;
+	       if (elemnum > this->value.nelem) elemnum = 1;
+	     }
+	   }
+	   break;
 	 case rnd_fct:
 	   while( elem-- ) {
 	     this->value.data.dblptr[elem] = simplerng_getuniform();
 	     this->value.undef[elem] = 0;
 	    }
 	    break;
 
@@ -3980,15 +4303,15 @@
 	       char *uptr = theParams[0]->value.undef;
 	       long *mptr = (long *) malloc(sizeof(long)*nelem);
 	       int irow;
 
 	       /* Allocate temporary storage for this row, since the
                   quickselect function will scramble the contents */
 	       if (mptr == 0) {
-		 yyerror("Could not allocate temporary memory in median function");
+		 yyerror(0, lParse, "Could not allocate temporary memory in median function");
 		 free( this->value.data.ptr );
 		 break;
 	       }
 
 	       for (irow=0; irow<row; irow++) {
 		  long *p = mptr;
 		  int nelem1 = nelem;
@@ -4019,15 +4342,15 @@
 	       char   *uptr = theParams[0]->value.undef;
 	       double *mptr = (double *) malloc(sizeof(double)*nelem);
 	       int irow;
 
 	       /* Allocate temporary storage for this row, since the
                   quickselect function will scramble the contents */
 	       if (mptr == 0) {
-		 yyerror("Could not allocate temporary memory in median function");
+		 yyerror(0, lParse, "Could not allocate temporary memory in median function");
 		 free( this->value.data.ptr );
 		 break;
 	       }
 
 	       for (irow=0; irow<row; irow++) {
 		  double *p = mptr;
 		  int nelem1 = nelem;
@@ -4183,14 +4506,42 @@
 		  } else {
 		     this->value.undef[elem] = 0;
 		     strcpy(this->value.data.strptr[row],pVals[0].data.str);
 		  }
 	       }
 	    }
 	    break;
+         case setnull_fct:
+	    switch( this->type ) {
+	    case LONG:
+	      while( elem-- ) {
+		if ( theParams[1]->value.data.lng == 
+		     theParams[0]->value.data.lngptr[elem] ) {
+		  this->value.data.lngptr[elem] = 0;
+		  this->value.undef[elem] = 1;
+		} else {
+		  this->value.data.lngptr[elem] = theParams[0]->value.data.lngptr[elem];
+		  this->value.undef[elem] = theParams[0]->value.undef[elem];
+		}
+	      }
+	      break;
+	    case DOUBLE:
+	      while( elem-- ) {
+		if ( theParams[1]->value.data.dbl == 
+		     theParams[0]->value.data.dblptr[elem] ) {
+		  this->value.data.dblptr[elem] = 0;
+		  this->value.undef[elem] = 1;
+		} else {
+		  this->value.data.dblptr[elem] = theParams[0]->value.data.dblptr[elem];
+		  this->value.undef[elem] = theParams[0]->value.undef[elem];
+		}
+	      }
+	      break;
+	    }
+	    break;
 
 	    /* Math functions with 1 double argument */
 
 	 case sin_fct:
 	    while( elem-- )
 	       if( !(this->value.undef[elem] = theParams[0]->value.undef[elem]) ) {
 		  this->value.data.dblptr[elem] = 
@@ -4909,15 +5260,16 @@
 		  } else {
 		    len = theParams[2]->value.data.lngptr[row];
 		    if (theParams[2]->value.undef[row]) undef = 1;
 		  }
 		  this->value.data.strptr[row][0] = '\0';
 		  if (pos == 0) undef = 1;
 		  if (! undef ) {
-		    if (cstrmid(this->value.data.strptr[row], len,
+		    if (cstrmid(lParse,
+				this->value.data.strptr[row], len,
 				str, src_len, pos) < 0) break;
 		  }
 		  this->value.undef[row] = undef;
 		}
 	      }		      
 	      break;
 
@@ -4956,40 +5308,40 @@
 		  this->value.undef[row] = undef;
 		}
 	      }
 	      break;
 
 		    
 	 } /* End switch(this->operation) */
-      } /* End if (!gParse.status) */
+      } /* End if (!lParse->status) */
    } /* End non-constant operations */
 
    i = this->nSubNodes;
    while( i-- ) {
       if( theParams[i]->operation>0 ) {
 	 /*  Currently only numeric params allowed  */
 	 free( theParams[i]->value.data.ptr );
       }
    }
 }
 
-static void Do_Deref( Node *this )
+static void Do_Deref( ParseData *lParse, Node *this )
 {
    Node *theVar, *theDims[MAXDIMS];
    int  isConst[MAXDIMS], allConst;
    long dimVals[MAXDIMS];
    int  i, nDims;
    long row, elem, dsize;
 
-   theVar = gParse.Nodes + this->SubNodes[0];
+   theVar = lParse->Nodes + this->SubNodes[0];
 
    i = nDims = this->nSubNodes-1;
    allConst = 1;
    while( i-- ) {
-      theDims[i] = gParse.Nodes + this->SubNodes[i+1];
+      theDims[i] = lParse->Nodes + this->SubNodes[i+1];
       isConst[i] = ( theDims[i]->operation==CONST_OP );
       if( isConst[i] )
 	 dimVals[i] = theDims[i]->value.data.lng;
       else
 	 allConst = 0;
    }
 
@@ -4998,30 +5350,30 @@
    } else if( this->type==LONG ) {
       dsize = sizeof( long );
    } else if( this->type==BOOLEAN ) {
       dsize = sizeof( char );
    } else
       dsize = 0;
 
-   Allocate_Ptrs( this );
+   Allocate_Ptrs( lParse, this );
 
-   if( !gParse.status ) {
+   if( !lParse->status ) {
 
       if( allConst && theVar->value.naxis==nDims ) {
 
 	 /* Dereference completely using constant indices */
 
 	 elem = 0;
 	 i    = nDims;
 	 while( i-- ) {
 	    if( dimVals[i]<1 || dimVals[i]>theVar->value.naxes[i] ) break;
 	    elem = theVar->value.naxes[i]*elem + dimVals[i]-1;
 	 }
 	 if( i<0 ) {
-	    for( row=0; row<gParse.nRows; row++ ) {
+	    for( row=0; row<lParse->nRows; row++ ) {
 	       if( this->type==STRING )
 		 this->value.undef[row] = theVar->value.undef[row];
 	       else if( this->type==BITSTR ) 
 		 this->value.undef;  /* Dummy - BITSTRs do not have undefs */
 	       else 
 		 this->value.undef[row] = theVar->value.undef[elem];
 
@@ -5042,42 +5394,42 @@
 		  this->value.data.strptr[row][0] = 
 		     theVar->value.data.strptr[0][elem+row];
 		  this->value.data.strptr[row][1] = 0;  /* Null terminate */
 	       }
 	       elem += theVar->value.nelem;
 	    }
 	 } else {
-	    yyerror("Index out of range");
+	    yyerror(0, lParse, "Index out of range");
 	    free( this->value.data.ptr );
 	 }
 	 
       } else if( allConst && nDims==1 ) {
 	 
 	 /* Reduce dimensions by 1, using a constant index */
 	 
 	 if( dimVals[0] < 1 ||
 	     dimVals[0] > theVar->value.naxes[ theVar->value.naxis-1 ] ) {
-	    yyerror("Index out of range");
+	    yyerror(0, lParse, "Index out of range");
 	    free( this->value.data.ptr );
 	 } else if ( this->type == BITSTR || this->type == STRING ) {
 	    elem = this->value.nelem * (dimVals[0]-1);
-	    for( row=0; row<gParse.nRows; row++ ) {
+	    for( row=0; row<lParse->nRows; row++ ) {
 	      if (this->value.undef) 
 		this->value.undef[row] = theVar->value.undef[row];
 	      memcpy( (char*)this->value.data.strptr[0]
 		      + row*sizeof(char)*(this->value.nelem+1),
 		      (char*)theVar->value.data.strptr[0] + elem*sizeof(char),
 		      this->value.nelem * sizeof(char) );
 	      /* Null terminate */
 	      this->value.data.strptr[row][this->value.nelem] = 0;
 	      elem += theVar->value.nelem+1;
 	    }	       
 	 } else {
 	    elem = this->value.nelem * (dimVals[0]-1);
-	    for( row=0; row<gParse.nRows; row++ ) {
+	    for( row=0; row<lParse->nRows; row++ ) {
 	       memcpy( this->value.undef + row*this->value.nelem,
 		       theVar->value.undef + elem,
 		       this->value.nelem * sizeof(char) );
 	       memcpy( (char*)this->value.data.ptr
 		       + row*dsize*this->value.nelem,
 		       (char*)theVar->value.data.ptr + elem*dsize,
 		       this->value.nelem * dsize );
@@ -5085,27 +5437,27 @@
 	    }	       
 	 }
       
       } else if( theVar->value.naxis==nDims ) {
 
 	 /* Dereference completely using an expression for the indices */
 
-	 for( row=0; row<gParse.nRows; row++ ) {
+	 for( row=0; row<lParse->nRows; row++ ) {
 
 	    for( i=0; i<nDims; i++ ) {
 	       if( !isConst[i] ) {
 		  if( theDims[i]->value.undef[row] ) {
-		     yyerror("Null encountered as vector index");
+		     yyerror(0, lParse, "Null encountered as vector index");
 		     free( this->value.data.ptr );
 		     break;
 		  } else
 		     dimVals[i] = theDims[i]->value.data.lngptr[row];
 	       }
 	    }
-	    if( gParse.status ) break;
+	    if( lParse->status ) break;
 
 	    elem = 0;
 	    i    = nDims;
 	    while( i-- ) {
 	       if( dimVals[i]<1 || dimVals[i]>theVar->value.naxes[i] ) break;
 	       elem = theVar->value.naxes[i]*elem + dimVals[i]-1;
 	    }
@@ -5134,37 +5486,37 @@
                     characters per string, followed by (nelem+1)
                     "undef" values. */
 		  this->value.data.strptr[row][0] = 
 		     theVar->value.data.strptr[0][elem+row];
 		  this->value.data.strptr[row][1] = 0;  /* Null terminate */
 	       }
 	    } else {
-	       yyerror("Index out of range");
+	       yyerror(0, lParse, "Index out of range");
 	       free( this->value.data.ptr );
 	    }
 	 }
 
       } else {
 
 	 /* Reduce dimensions by 1, using a nonconstant expression */
 
-	 for( row=0; row<gParse.nRows; row++ ) {
+	 for( row=0; row<lParse->nRows; row++ ) {
 
 	    /* Index cannot be a constant */
 
 	    if( theDims[0]->value.undef[row] ) {
-	       yyerror("Null encountered as vector index");
+	       yyerror(0, lParse, "Null encountered as vector index");
 	       free( this->value.data.ptr );
 	       break;
 	    } else
 	       dimVals[0] = theDims[0]->value.data.lngptr[row];
 
 	    if( dimVals[0] < 1 ||
 		dimVals[0] > theVar->value.naxes[ theVar->value.naxis-1 ] ) {
-	       yyerror("Index out of range");
+	       yyerror(0, lParse, "Index out of range");
 	       free( this->value.data.ptr );
 	    } else if ( this->type == BITSTR || this->type == STRING ) {
 	      elem = this->value.nelem * (dimVals[0]-1);
 	      elem += row*(theVar->value.nelem+1);
 	      if (this->value.undef) 
 		this->value.undef[row] = theVar->value.undef[row];
 	      memcpy( (char*)this->value.data.strptr[0]
@@ -5196,120 +5548,300 @@
    }
    for( i=0; i<nDims; i++ )
       if( theDims[i]->operation>0 ) {
 	 free( theDims[i]->value.data.ptr );
       }
 }
 
-static void Do_GTI( Node *this )
+static void Do_GTI( ParseData *lParse, Node *this )
 {
    Node *theExpr, *theTimes;
    double *start, *stop, *times;
    long elem, nGTI, gti;
    int ordered;
+   int dorow = (this->operation == gtifind_fct);
 
-   theTimes = gParse.Nodes + this->SubNodes[0];
-   theExpr  = gParse.Nodes + this->SubNodes[1];
+   theTimes = lParse->Nodes + this->SubNodes[0];
+   theExpr  = lParse->Nodes + this->SubNodes[1];
 
    nGTI    = theTimes->value.nelem;
    start   = theTimes->value.data.dblptr;
    stop    = theTimes->value.data.dblptr + nGTI;
    ordered = theTimes->type;
 
    if( theExpr->operation==CONST_OP ) {
-
-      this->value.data.log = 
-	 (Search_GTI( theExpr->value.data.dbl, nGTI, start, stop, ordered )>=0);
+      gti = Search_GTI( theExpr->value.data.dbl, nGTI, start, stop, ordered, 0 );
+      if (dorow) {
+	this->value.data.lng = (gti >= 0) ? (gti+1) : -1;
+      } else {
+	this->value.data.log = (gti>=0);
+      }
       this->operation      = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
       times = theExpr->value.data.dblptr;
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
-	 elem = gParse.nRows * this->value.nelem;
+	 elem = lParse->nRows * this->value.nelem;
 	 if( nGTI ) {
 	    gti = -1;
 	    while( elem-- ) {
 	       if( (this->value.undef[elem] = theExpr->value.undef[elem]) )
 		  continue;
 
             /*  Before searching entire GTI, check the GTI found last time  */
 	       if( gti<0 || times[elem]<start[gti] || times[elem]>stop[gti] ) {
-		  gti = Search_GTI( times[elem], nGTI, start, stop, ordered );
+		 gti = Search_GTI( times[elem], nGTI, start, stop, ordered, 0 );
+	       }
+	       if (dorow) {
+		 this->value.data.lngptr[elem] = ( gti >= 0 ) ? (gti + 1) : (-1);
+		 this->value.undef[elem]  = ( gti >= 0 ) ? 0 : 1;
+	       } else {
+		 this->value.data.logptr[elem] = ( gti>=0 );
 	       }
-	       this->value.data.logptr[elem] = ( gti>=0 );
 	    }
-	 } else
-	    while( elem-- ) {
+	 } else { /* nGTI == 0 */
+
+	   if (dorow) { /* no good times so all values are undef */
+	     while( elem-- ) {
+	       this->value.undef[elem]       = 1;
+	     }
+	   } else {    /* no good times so all logicals are 0 */
+	     while( elem-- ) {
 	       this->value.data.logptr[elem] = 0;
 	       this->value.undef[elem]       = 0;
-	    }
+	     }
+	   }
+	   
+	 }
       }
    }
 
    if( theExpr->operation>0 )
       free( theExpr->value.data.ptr );
 }
 
+static void Do_GTI_Over( ParseData *lParse, Node *this )
+{
+   Node *theTimes, *theStart, *theStop;
+   double *gtiStart, *gtiStop;
+   double *evtStart, *evtStop;
+   long elem, nGTI, gti, nextGTI;
+   int ordered;
+
+   theTimes = lParse->Nodes + this->SubNodes[0]; /* GTI times */
+   theStop  = lParse->Nodes + this->SubNodes[2]; /* User start time */
+   theStart = lParse->Nodes + this->SubNodes[1]; /* User stop time */
+
+   nGTI     = theTimes->value.nelem;
+   gtiStart = theTimes->value.data.dblptr;        /* GTI start */
+   gtiStop  = theTimes->value.data.dblptr + nGTI; /* GTI stop */
+
+   if( theStart->operation==CONST_OP && theStop->operation==CONST_OP) {
+
+      this->value.data.dbl = 
+	(GTI_Over( theStart->value.data.dbl, theStop->value.data.dbl,
+		   nGTI, gtiStart, gtiStop, &gti));
+      this->operation      = CONST_OP;
+
+   } else {
+      char undefStart = 0, undefStop = 0; /* Input values are undef? */
+      double uStart, uStop;       /* User start/stop values */
+      if (theStart->operation==CONST_OP) uStart = theStart->value.data.dbl;
+      if (theStop ->operation==CONST_OP) uStop  = theStop ->value.data.dbl;
+
+      Allocate_Ptrs( lParse, this );
+
+      evtStart = theStart->value.data.dblptr;
+      evtStop  = theStop ->value.data.dblptr;
+      if( !lParse->status ) {
+
+	 elem = lParse->nRows * this->value.nelem;
+	 if( nGTI ) {
+	    double toverlap = 0.0;
+	    gti = -1;
+	    while( elem-- ) {
+	      if (theStart->operation!=CONST_OP) {
+		undefStart = theStart->value.undef[elem];
+		uStart     = evtStart[elem];
+	      }
+	      if (theStop->operation!=CONST_OP) {
+		undefStop  = theStop ->value.undef[elem];
+		uStop      = evtStop[elem];
+	      }
+	      /* This works because at least one of the values is not const */
+	      if( (this->value.undef[elem] = (undefStart||undefStop)) )
+		  continue;
+
+            /*  Before searching entire GTI, check the GTI found last time  */
+	       if( gti<0 || 
+		   uStart<gtiStart[gti] || uStart>gtiStop[gti] ||
+		   uStop <gtiStart[gti] || uStop >gtiStop[gti]) {
+		 /* Nope, need to recalculate */
+		 toverlap = GTI_Over(uStart, uStop, 
+				     nGTI, gtiStart, gtiStop, 
+				     &gti);
+	       } else {
+		 /* We are in same GTI, the overlap is just stop-start of user range */
+		 toverlap = (uStop-uStart);
+	       }
+
+	       /* This works because at least one of the values is not const */
+	       this->value.data.dblptr[elem] = toverlap;
+	    }
+	 } else
+	    /* nGTI == 0; there is no overlap so set all values to 0.0 */
+	    while( elem-- ) {
+	       this->value.data.dblptr[elem] = 0.0;
+	       this->value.undef[elem]       = 0;
+	    }
+      }
+   }
+
+   if( theStart->operation>0 ) {
+     free( theStart->value.data.ptr );
+   }
+   if( theStop->operation>0 ) {
+     free( theStop->value.data.ptr );
+   }
+}
+
+static double GTI_Over(double evtStart, double evtStop,
+		       long nGTI, double *start, double *stop,
+		       long *gtiout)
+{
+  long gti1, gti2, nextGTI1, nextGTI2;
+  long gti, nMax;
+  double overlap = 0.0;
+
+  *gtiout = -1L;
+  /* Zero or negative bin size */
+  if (evtStop <= evtStart) return 0.0;
+
+  /* Locate adjacent GTIs for evtStart and evtStop */
+  gti1 = Search_GTI(evtStart, nGTI, start, stop, 1, &nextGTI1);
+  gti2 = Search_GTI(evtStop,  nGTI, start, stop, 1, &nextGTI2);
+
+  /* evtStart is in gti1, we return that for future processing */
+  if (gti1 >= 0) *gtiout = gti1;
+
+  /* Both evtStart/evtStop are beyond the last GTI */
+  if (nextGTI1 < 0 && nextGTI2 < 0) return 0.0;
+
+  /* Both evtStart/evtStop are in the same gap between GTIs */
+  if (gti1 < 0 && gti2 < 0 && nextGTI1 == nextGTI2) return 0.0;
+
+  /* Both evtStart/evtStop are in the same GTI */
+  if (gti1 >= 0 && gti1 == gti2) return (evtStop-evtStart);
+
+  /* Count through the remaining GTIs; there will be at least one */
+  /* The largest GTI to consider is either nextGTI2-1, if it exists,
+     or nGTI-1 */
+  if (nextGTI2 < 0) nMax = nGTI-1;
+  else if (gti2 >= 0) nMax = nextGTI2;
+  else nMax = nextGTI2-1;
+  for (gti = nextGTI1; gti <= nMax; gti++) {
+    double starti = start[gti], stopi = stop[gti];
+    /* Trim the GTI by actual evtStart/Stop times */
+    if (evtStart > starti) starti = evtStart;
+    if (evtStop  < stopi ) stopi  = evtStop;
+    overlap += (stopi - starti);
+  }
+    
+  return overlap;
+}
+
+/*
+ * Search_GTI - search GTI for requested evtTime
+ * 
+ * double evtTime - requested event time
+ * long nGTI - number of entries in start[] and stop[]
+ * double start[], stop[] - start and stop of each GTI
+ * int ordered - set to 1 if time-ordered
+ * long *nextGTI0 - upon return, *nextGTI0 is either
+ *                   the GTI evtTime is inside
+ *                   the next GTI if evtTime is not inside
+ *                   -1L if there is no next GTI
+ *                   not set if nextGTI0 is a null pointer
+ *
+ * NOTE: for *nextGTI to be well-defined, the GTI must
+ *   be ordered.  This is true when called by Do_GTI.
+ *
+ * RETURNS: gti index that evtTime is located inside, or -1L
+ */
 static long Search_GTI( double evtTime, long nGTI, double *start,
-			double *stop, int ordered )
+			double *stop, int ordered, long *nextGTI0 )
 {
-   long gti, step;
+   long gti, nextGTI = -1L, step;
                              
    if( ordered && nGTI>15 ) { /*  If time-ordered and lots of GTIs,   */
                               /*  use "FAST" Binary search algorithm  */
       if( evtTime>=start[0] && evtTime<=stop[nGTI-1] ) {
 	 gti = step = (nGTI >> 1);
 	 while(1) {
 	    if( step>1L ) step >>= 1;
 	    
 	    if( evtTime>stop[gti] ) {
 	       if( evtTime>=start[gti+1] )
 		  gti += step;
 	       else {
+		  nextGTI = gti+1;
 		  gti = -1L;
 		  break;
 	       }
 	    } else if( evtTime<start[gti] ) {
 	       if( evtTime<=stop[gti-1] )
 		  gti -= step;
 	       else {
+		  nextGTI = gti;
 		  gti = -1L;
 		  break;
 	       }
 	    } else {
+	       nextGTI = gti;
 	       break;
 	    }
 	 }
-      } else
+      } else {
+	 if (start[0] > evtTime) nextGTI = 0;
 	 gti = -1L;
+      }
       
-   } else { /*  Use "SLOW" linear search  */
+   } else { /*  Use "SLOW" linear search.  Not required to be 
+	        ordered, so we have to search the whole table
+		no matter what.
+	    */
       gti = nGTI;
-      while( gti-- )
-	 if( evtTime>=start[gti] && evtTime<=stop[gti] )
+      while( gti-- ) {
+	if( stop[gti] >= evtTime ) nextGTI = gti;
+	if( evtTime>=start[gti] && evtTime<=stop[gti] )
 	    break;
+      }
    }
+
+   if (nextGTI >= nGTI) nextGTI = -1;
+   if (nextGTI0) *nextGTI0 = nextGTI;
+
    return( gti );
 }
 
-static void Do_REG( Node *this )
+static void Do_REG( ParseData *lParse, Node *this )
 {
    Node *theRegion, *theX, *theY;
    double Xval=0.0, Yval=0.0;
    char   Xnull=0, Ynull=0;
    int    Xvector, Yvector;
    long   nelem, elem, rows;
 
-   theRegion = gParse.Nodes + this->SubNodes[0];
-   theX      = gParse.Nodes + this->SubNodes[1];
-   theY      = gParse.Nodes + this->SubNodes[2];
+   theRegion = lParse->Nodes + this->SubNodes[0];
+   theX      = lParse->Nodes + this->SubNodes[1];
+   theY      = lParse->Nodes + this->SubNodes[2];
 
    Xvector = ( theX->operation!=CONST_OP );
    if( Xvector )
       Xvector = theX->value.nelem;
    else {
       Xval  = theX->value.data.dbl;
    }
@@ -5326,19 +5858,19 @@
       this->value.data.log =
 	 ( fits_in_region( Xval, Yval, (SAORegion *)theRegion->value.data.ptr )
 	   != 0 );
       this->operation      = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
-	 rows  = gParse.nRows;
+	 rows  = lParse->nRows;
 	 nelem = this->value.nelem;
 	 elem  = rows*nelem;
 
 	 while( rows-- ) {
 	    while( nelem-- ) {
 	       elem--;
 
@@ -5374,31 +5906,31 @@
 
    if( theX->operation>0 )
       free( theX->value.data.ptr );
    if( theY->operation>0 )
       free( theY->value.data.ptr );
 }
 
-static void Do_Vector( Node *this )
+static void Do_Vector( ParseData *lParse, Node *this )
 {
    Node *that;
    long row, elem, idx, jdx, offset=0;
    int node;
 
-   Allocate_Ptrs( this );
+   Allocate_Ptrs( lParse, this );
 
-   if( !gParse.status ) {
+   if( !lParse->status ) {
 
       for( node=0; node<this->nSubNodes; node++ ) {
 
-	 that = gParse.Nodes + this->SubNodes[node];
+	 that = lParse->Nodes + this->SubNodes[node];
 
 	 if( that->operation == CONST_OP ) {
 
-	    idx = gParse.nRows*this->value.nelem + offset;
+	    idx = lParse->nRows*this->value.nelem + offset;
 	    while( (idx-=this->value.nelem)>=0 ) {
 	       
 	       this->value.undef[idx] = 0;
 
 	       switch( this->type ) {
 	       case BOOLEAN:
 		  this->value.data.logptr[idx] = that->value.data.log;
@@ -5410,15 +5942,15 @@
 		  this->value.data.dblptr[idx] = that->value.data.dbl;
 		  break;
 	       }
 	    }
 	    
 	 } else {
 	       
-	    row  = gParse.nRows;
+	    row  = lParse->nRows;
 	    idx  = row * that->value.nelem;
 	    while( row-- ) {
 	       elem = that->value.nelem;
 	       jdx = row*this->value.nelem + offset;
 	       while( elem-- ) {
 		  this->value.undef[jdx+elem] =
 		     that->value.undef[--idx];
@@ -5443,15 +5975,81 @@
 	 offset += that->value.nelem;
       }
 
    }
 
    for( node=0; node < this->nSubNodes; node++ )
      if( OPER(this->SubNodes[node])>0 )
-       free( gParse.Nodes[this->SubNodes[node]].value.data.ptr );
+       free( lParse->Nodes[this->SubNodes[node]].value.data.ptr );
+}
+
+static void Do_Array( ParseData *lParse, Node *this )
+{
+   Node *that;
+   long row, elem, idx, jdx, offset=0;
+   int node;
+
+   Allocate_Ptrs( lParse, this );
+
+   if( !lParse->status ) {
+
+     /* This is the item to be replicated */
+     that = lParse->Nodes + this->SubNodes[0];
+
+     if( that->operation == CONST_OP ) {
+
+       idx = lParse->nRows*this->value.nelem + offset;
+       while( (idx--)>=0 ) {
+	       
+	 this->value.undef[idx] = 0;
+
+	 switch( this->type ) {
+	 case BOOLEAN:
+	   this->value.data.logptr[idx] = that->value.data.log;
+	   break;
+	 case LONG:
+	   this->value.data.lngptr[idx] = that->value.data.lng;
+	   break;
+	 case DOUBLE:
+	   this->value.data.dblptr[idx] = that->value.data.dbl;
+	   break;
+	 }
+       }
+       
+     } else {
+       
+       row  = lParse->nRows;
+       idx  = row * this->value.nelem - 1;
+       while( row-- ) {
+	 elem = this->value.nelem;
+	 while( elem-- ) {
+	   this->value.undef[idx] = that->value.undef[row];
+
+	   switch( this->type ) {
+	   case BOOLEAN:
+	     this->value.data.logptr[idx] = that->value.data.logptr[row];
+	     break;
+	   case LONG:
+	     this->value.data.lngptr[idx] = that->value.data.lngptr[row];
+	     break;
+	   case DOUBLE:
+	     this->value.data.dblptr[idx] = that->value.data.dblptr[row];
+	     break;
+	   }
+	   idx--;
+	 }
+       }
+
+     } /* not constant */
+
+     if( OPER(this->SubNodes[0])>0 )
+       free( lParse->Nodes[this->SubNodes[0]].value.data.ptr );
+
+   }
+
 }
 
 /*****************************************************************************/
 /*  Utility routines which perform the calculations on bits and SAO regions  */
 /*****************************************************************************/
 
 static char bitlgte(char *bits1, int oper, char *bits2)
@@ -5720,25 +6318,25 @@
  else
    return ( 0 );
 }
 
 /*
  * Extract substring
  */
-int cstrmid(char *dest_str, int dest_len,
+ int cstrmid(ParseData *lParse, char *dest_str, int dest_len,
 	    char *src_str,  int src_len,
 	    int pos)
 {
   /* char fill_char = ' '; */
   char fill_char = '\0';
   if (src_len == 0) { src_len = strlen(src_str); } /* .. if constant */
 
   /* Fill destination with blanks */
   if (pos < 0) { 
-    yyerror("STRMID(S,P,N) P must be 0 or greater");
+    yyerror(0, lParse, "STRMID(S,P,N) P must be 0 or greater");
     return -1;
   }
   if (pos > src_len || pos == 0) {
     /* pos==0: blank string requested */
     memset(dest_str, fill_char, dest_len);
   } else if (pos+dest_len > src_len) {
     /* Copy a subset */
@@ -5753,17 +6351,17 @@
   }
   dest_str[dest_len] = '\0'; /* Null-terminate */
 
   return 0;
 }
 
 
-static void yyerror(char *s)
+static void yyerror(yyscan_t scanner, ParseData *lParse, char *s)
 {
     char msg[80];
 
-    if( !gParse.status ) gParse.status = PARSE_SYNTAX_ERR;
+    if( !lParse->status ) lParse->status = PARSE_SYNTAX_ERR;
 
     strncpy(msg, s, 80);
     msg[79] = '\0';
     ffpmsg(msg);
 }
```

### Comparing `fitsio-1.1.9/cfitsio3490/eval_f.c` & `fitsio-1.2.0/cfitsio-4.2.0/eval_f.c`

 * *Files 11% similar despite different names*

```diff
@@ -51,30 +51,22 @@
 /************************************************************************/
 
 #include <limits.h>
 #include <ctype.h>
 #include "eval_defs.h"
 #include "region.h"
 
-typedef struct {
-     int  datatype;   /* Data type to cast parse results into for user       */
-     void *dataPtr;   /* Pointer to array of results, NULL if to use iterCol */
-     void *nullPtr;   /* Pointer to nulval, use zero if NULL                 */
-     long maxRows;    /* Max No. of rows to process, -1=all, 0=1 iteration   */
-     int  anyNull;    /* Flag indicating at least 1 undef value encountered  */
-} parseInfo;
 
 /*  Internal routines needed to allow the evaluator to operate on FITS data  */
 
-static void Setup_DataArrays( int nCols, iteratorCol *cols,
+static void Setup_DataArrays( ParseData *lParse, int nCols, iteratorCol *cols,
                               long fRow, long nRows );
-static int  find_column( char *colName, void *itslval );
-static int  find_keywd ( char *key,     void *itslval );
-static int  allocateCol( int nCol, int *status );
-static int  load_column( int varNum, long fRow, long nRows,
+static int  find_column( ParseData *lParse, char *colName, void *itslval );
+static int  find_keywd ( ParseData *lParse, char *key,     void *itslval );
+static int  load_column( ParseData *lParse, int varNum, long fRow, long nRows,
                          void *data, char *undef );
 
 static int DEBUG_PIXFILTER;
 
 #define FREE(x) { if (x) free(x); else printf("invalid free(" #x ") at %s:%d\n", __FILE__, __LINE__); }
 
 /*---------------------------------------------------------------------------*/
@@ -90,50 +82,50 @@
 /* array of flags indicating which rows evaluated to TRUE/FALSE              */
 /*---------------------------------------------------------------------------*/
 {
    parseInfo Info;
    int naxis, constant;
    long nelem, naxes[MAXDIMS], elem;
    char result;
+   ParseData lParse;
 
    if( *status ) return( *status );
+   memset(&Info, 0, sizeof(Info));   
 
-   FFLOCK;
    if( ffiprs( fptr, 0, expr, MAXDIMS, &Info.datatype, &nelem, &naxis,
-               naxes, status ) ) {
-      ffcprs();
-      FFUNLOCK;
+               naxes, &lParse, status ) ) {
+      ffcprs(&lParse);
       return( *status );
    }
    if( nelem<0 ) {
       constant = 1;
       nelem = -nelem;
    } else
       constant = 0;
 
    if( Info.datatype!=TLOGICAL || nelem!=1 ) {
-      ffcprs();
+      ffcprs(&lParse);
       ffpmsg("Expression does not evaluate to a logical scalar.");
-      FFUNLOCK;
       return( *status = PARSE_BAD_TYPE );
    }
 
    if( constant ) { /* No need to call parser... have result from ffiprs */
-      result = gParse.Nodes[gParse.resultNode].value.data.log;
+      result = lParse.Nodes[lParse.resultNode].value.data.log;
       *n_good_rows = nrows;
       for( elem=0; elem<nrows; elem++ )
          row_status[elem] = result;
    } else {
       firstrow     = (firstrow>1 ? firstrow : 1);
       Info.dataPtr = row_status;
       Info.nullPtr = NULL;
       Info.maxRows = nrows;
+      Info.parseData = &lParse;
 
-      if( ffiter( gParse.nCols, gParse.colData, firstrow-1, 0,
-                  parse_data, (void*)&Info, status ) == -1 )
+      if( ffiter( lParse.nCols, lParse.colData, firstrow-1, 0,
+                  fits_parser_workfn, (void*)&Info, status ) == -1 )
          *status = 0;  /* -1 indicates exitted without error before end... OK */
 
       if( *status ) {
 
          /***********************/
          /* Error... Do nothing */
          /***********************/
@@ -147,16 +139,15 @@
          *n_good_rows = 0L;
          for( elem=0; elem<Info.maxRows; elem++ ) {
             if( row_status[elem]==1 ) ++*n_good_rows;
          }
       }
    }
 
-   ffcprs();
-   FFUNLOCK;
+   ffcprs(&lParse);
    return(*status);
 }
 
 /*--------------------------------------------------------------------------*/
 int ffsrow( fitsfile *infptr,   /* I - Input FITS file                      */
             fitsfile *outfptr,  /* I - Output FITS file                     */
             char     *expr,     /* I - Boolean expression                   */
@@ -176,126 +167,123 @@
    LONGLONG ntodo, inbyteloc, outbyteloc, hsize;
    long freespace;
    unsigned char *buffer, result;
    struct {
       LONGLONG rowLength, numRows, heapSize;
       LONGLONG dataStart, heapStart;
    } inExt, outExt;
+   ParseData lParse;
 
    if( *status ) return( *status );
 
-   FFLOCK;
+   memset(&Info, 0, sizeof(Info));   
+   memset(&inExt, 0, sizeof(inExt));
+   memset(&outExt, 0, sizeof(outExt));
+
    if( ffiprs( infptr, 0, expr, MAXDIMS, &Info.datatype, &nelem, &naxis,
-               naxes, status ) ) {
-      ffcprs();
-      FFUNLOCK;
+               naxes, &lParse, status ) ) {
+      ffcprs(&lParse);
       return( *status );
    }
 
    if( nelem<0 ) {
       constant = 1;
       nelem = -nelem;
    } else
       constant = 0;
 
    /**********************************************************************/
    /* Make sure expression evaluates to the right type... logical scalar */
    /**********************************************************************/
 
    if( Info.datatype!=TLOGICAL || nelem!=1 ) {
-      ffcprs();
+      ffcprs(&lParse);
       ffpmsg("Expression does not evaluate to a logical scalar.");
-      FFUNLOCK;
       return( *status = PARSE_BAD_TYPE );
    }
 
    /***********************************************************/
    /*  Extract various table information from each extension  */
    /***********************************************************/
 
    if( infptr->HDUposition != (infptr->Fptr)->curhdu )
       ffmahd( infptr, (infptr->HDUposition) + 1, NULL, status );
    if( *status ) {
-      ffcprs();
-      FFUNLOCK;
+      ffcprs(&lParse);
       return( *status );
    }
    inExt.rowLength = (long) (infptr->Fptr)->rowlength;
    inExt.numRows   = (infptr->Fptr)->numrows;
    inExt.heapSize  = (infptr->Fptr)->heapsize;
    if( inExt.numRows == 0 ) { /* Nothing to copy */
-      ffcprs();
-      FFUNLOCK;
+      ffcprs(&lParse);
       return( *status );
    }
 
    if( outfptr->HDUposition != (outfptr->Fptr)->curhdu )
       ffmahd( outfptr, (outfptr->HDUposition) + 1, NULL, status );
    if( (outfptr->Fptr)->datastart < 0 )
       ffrdef( outfptr, status );
    if( *status ) {
-      ffcprs();
-      FFUNLOCK;
+      ffcprs(&lParse);
       return( *status );
    }
    outExt.rowLength = (long) (outfptr->Fptr)->rowlength;
    outExt.numRows   = (outfptr->Fptr)->numrows;
    if( !outExt.numRows )
       (outfptr->Fptr)->heapsize = 0L;
    outExt.heapSize  = (outfptr->Fptr)->heapsize;
 
    if( inExt.rowLength != outExt.rowLength ) {
       ffpmsg("Output table has different row length from input");
-      ffcprs();
-      FFUNLOCK;
+      ffcprs(&lParse);
       return( *status = PARSE_BAD_OUTPUT );
    }
 
    /***********************************/
    /*  Fill out Info data for parser  */
    /***********************************/
 
    Info.dataPtr = (char *)malloc( (size_t) ((inExt.numRows + 1) * sizeof(char)) );
    Info.nullPtr = NULL;
    Info.maxRows = (long) inExt.numRows;
+   Info.parseData = &lParse;
    if( !Info.dataPtr ) {
       ffpmsg("Unable to allocate memory for row selection");
-      ffcprs();
-      FFUNLOCK;
+      ffcprs(&lParse);
       return( *status = MEMORY_ALLOCATION );
    }
    
    /* make sure array is zero terminated */
    ((char*)Info.dataPtr)[inExt.numRows] = 0;
 
    if( constant ) { /*  Set all rows to the same value from constant result  */
 
-      result = gParse.Nodes[gParse.resultNode].value.data.log;
+      result = lParse.Nodes[lParse.resultNode].value.data.log;
       for( ntodo = 0; ntodo<inExt.numRows; ntodo++ )
          ((char*)Info.dataPtr)[ntodo] = result;
       nGood = (long) (result ? inExt.numRows : 0);
 
    } else {
 
-      ffiter( gParse.nCols, gParse.colData, 0L, 0L,
-              parse_data, (void*)&Info, status );
+      ffiter( lParse.nCols, lParse.colData, 0L, 0L,
+              fits_parser_workfn, (void*)&Info, status );
 
       nGood = 0;
       for( ntodo = 0; ntodo<inExt.numRows; ntodo++ )
          if( ((char*)Info.dataPtr)[ntodo] ) nGood++;
    }
 
    if( *status ) {
       /* Error... Do nothing */
    } else {
       rdlen  = (long) inExt.rowLength;
       buffer = (unsigned char *)malloc(maxvalue(500000,rdlen) * sizeof(char) );
       if( buffer==NULL ) {
-         ffcprs();
-         FFUNLOCK;
+         ffcprs(&lParse);
          return( *status=MEMORY_ALLOCATION );
       }
       maxrows = maxvalue( (500000L/rdlen), 1);
       nbuff = 0;
       inloc = 1;
       if( infptr==outfptr ) { /* Skip initial good rows if input==output file */
          while( ((char*)Info.dataPtr)[inloc-1] ) inloc++;
@@ -406,18 +394,17 @@
 
       } /*  End of HEAP copy  */
 
       FREE(buffer);
    }
 
    FREE(Info.dataPtr);
-   ffcprs();
+   ffcprs(&lParse);
 
    ffcmph(outfptr, status);  /* compress heap, deleting any orphaned data */
-   FFUNLOCK;
    return(*status);
 }
 
 /*---------------------------------------------------------------------------*/
 int ffcrow( fitsfile *fptr,      /* I - Input FITS file                      */
             int      datatype,   /* I - Datatype to return results as        */
             char     *expr,      /* I - Arithmetic expression                */
@@ -435,48 +422,48 @@
 /* even multiple of the result dimension.  Call fftexp to obtain the         */
 /* dimensions of the results.                                                */
 /*---------------------------------------------------------------------------*/
 {
    parseInfo Info;
    int naxis;
    long nelem1, naxes[MAXDIMS];
+   ParseData lParse;
 
    if( *status ) return( *status );
 
-   FFLOCK;
+   memset(&Info, 0, sizeof(Info));   
+
    if( ffiprs( fptr, 0, expr, MAXDIMS, &Info.datatype, &nelem1, &naxis,
-               naxes, status ) ) {
-      ffcprs();
-      FFUNLOCK;
+               naxes, &lParse, status ) ) {
+      ffcprs(&lParse);
       return( *status );
    }
    if( nelem1<0 ) nelem1 = - nelem1;
 
    if( nelements<nelem1 ) {
-      ffcprs();
+      ffcprs(&lParse);
       ffpmsg("Array not large enough to hold at least one row of data.");
-      FFUNLOCK;
       return( *status = PARSE_LRG_VECTOR );
    }
 
    firstrow = (firstrow>1 ? firstrow : 1);
 
    if( datatype ) Info.datatype = datatype;
 
    Info.dataPtr = array;
    Info.nullPtr = nulval;
    Info.maxRows = nelements / nelem1;
+   Info.parseData = &lParse;
    
-   if( ffiter( gParse.nCols, gParse.colData, firstrow-1, 0,
-               parse_data, (void*)&Info, status ) == -1 )
+   if( ffiter( lParse.nCols, lParse.colData, firstrow-1, 0,
+               fits_parser_workfn, (void*)&Info, status ) == -1 )
       *status=0;  /* -1 indicates exitted without error before end... OK */
 
    *anynul = Info.anyNull;
-   ffcprs();
-   FFUNLOCK;
+   ffcprs(&lParse);
    return( *status );
 }
 
 /*--------------------------------------------------------------------------*/
 int ffcalc( fitsfile *infptr,   /* I - Input FITS file                      */
             char     *expr,     /* I - Arithmetic expression                */
             fitsfile *outfptr,  /* I - Output fits file                     */
@@ -521,66 +508,65 @@
 {
    parseInfo Info;
    int naxis, constant, typecode, newNullKwd=0;
    long nelem, naxes[MAXDIMS], repeat, width;
    int col_cnt, colNo;
    Node *result;
    char card[81], tform[16], nullKwd[9], tdimKwd[9];
+   ParseData lParse;
 
    if( *status ) return( *status );
 
-   FFLOCK;
+   memset(&Info, 0, sizeof(Info));   
+
    if( ffiprs( infptr, 0, expr, MAXDIMS, &Info.datatype, &nelem, &naxis,
-               naxes, status ) ) {
+               naxes, &lParse, status ) ) {
 
-      ffcprs();
-      FFUNLOCK;
+      ffcprs(&lParse);
       return( *status );
    }
    if( nelem<0 ) {
       constant = 1;
       nelem = -nelem;
    } else
       constant = 0;
 
+   Info.parseData = &lParse;
    /*  Case (1): If column exists put it there  */
 
    colNo = 0;
    if( ffgcno( outfptr, CASEINSEN, parName, &colNo, status )==COL_NOT_FOUND ) {
 
       /*  Output column doesn't exist.  Test for keyword. */
 
       /* Case (2): Does parName indicate result should be put into keyword */
 
       *status = 0;
       if( parName[0]=='#' ) {
          if( ! constant ) {
-            ffcprs();
+            ffcprs(&lParse);
             ffpmsg( "Cannot put tabular result into keyword (ffcalc)" );
-            FFUNLOCK;
             return( *status = PARSE_BAD_TYPE );
          }
          parName++;  /* Advance past '#' */
 	 if ( (fits_strcasecmp(parName,"HISTORY") == 0 || fits_strcasecmp(parName,"COMMENT") == 0) &&
 	      Info.datatype != TSTRING ) {
-            ffcprs();
+            ffcprs(&lParse);
             ffpmsg( "HISTORY and COMMENT values must be strings (ffcalc)" );
-	    FFUNLOCK;
 	    return( *status = PARSE_BAD_TYPE );
 	 }
 
       } else if( constant ) {
 
          /* Case (3): Does a keyword named parName already exist */
 
          if( ffgcrd( outfptr, parName, card, status )==KEY_NO_EXIST ) {
             colNo = -1;
          } else if( *status ) {
-            ffcprs();
-            FFUNLOCK;
+            ffcprs(&lParse);
             return( *status );
          }
 
       } else
          colNo = -1;
 
       if( colNo<0 ) {
@@ -588,84 +574,86 @@
          /* Case (4): Create new column */
 
          *status = 0;
          ffgncl( outfptr, &colNo, status );
          colNo++;
          if( parInfo==NULL || *parInfo=='\0' ) {
             /*  Figure out best default column type  */
-            if( gParse.hdutype==BINARY_TBL ) {
+            if( lParse.hdutype==BINARY_TBL ) {
                snprintf(tform,15,"%ld",nelem);
                switch( Info.datatype ) {
                case TLOGICAL:  strcat(tform,"L");  break;
                case TLONG:     strcat(tform,"J");  break;
                case TDOUBLE:   strcat(tform,"D");  break;
                case TSTRING:   strcat(tform,"A");  break;
                case TBIT:      strcat(tform,"X");  break;
                case TLONGLONG: strcat(tform,"K");  break;
                }
             } else {
                switch( Info.datatype ) {
                case TLOGICAL:
-                  ffcprs();
+                  ffcprs(&lParse);
                   ffpmsg("Cannot create LOGICAL column in ASCII table");
-                  FFUNLOCK;
                   return( *status = NOT_BTABLE );
                case TLONG:     strcpy(tform,"I11");     break;
                case TDOUBLE:   strcpy(tform,"D23.15");  break;
                case TSTRING:   
                case TBIT:      snprintf(tform,16,"A%ld",nelem);  break;
                }
             }
             parInfo = tform;
-         } else if( !(isdigit((int) *parInfo)) && gParse.hdutype==BINARY_TBL ) {
+         } else if( !(isdigit((int) *parInfo)) && lParse.hdutype==BINARY_TBL ) {
             if( Info.datatype==TBIT && *parInfo=='B' )
                nelem = (nelem+7)/8;
             snprintf(tform,16,"%ld%s",nelem,parInfo);
             parInfo = tform;
          }
          fficol( outfptr, colNo, parName, parInfo, status );
          if( naxis>1 )
             ffptdm( outfptr, colNo, naxis, naxes, status );
 
          /*  Setup TNULLn keyword in case NULLs are encountered  */
 
          ffkeyn("TNULL", colNo, nullKwd, status);
          if( ffgcrd( outfptr, nullKwd, card, status )==KEY_NO_EXIST ) {
             *status = 0;
-            if( gParse.hdutype==BINARY_TBL ) {
+            if( lParse.hdutype==BINARY_TBL ) {
 	       LONGLONG nullVal=0;
                fits_binary_tform( parInfo, &typecode, &repeat, &width, status );
                if( typecode==TBYTE )
                   nullVal = UCHAR_MAX;
                else if( typecode==TSHORT )
                   nullVal = SHRT_MIN;
                else if( typecode==TINT )
                   nullVal = INT_MIN;
-               else if( typecode==TLONG )
-                  nullVal = LONG_MIN;
+               else if( typecode==TLONG ) {
+                  if (sizeof(long) == 8 && sizeof(int) == 4)
+                     nullVal = INT_MIN;
+                  else
+                     nullVal = LONG_MIN;
+               }
                else if( typecode==TLONGLONG )
                   nullVal = LONGLONG_MIN;
 		  
                if( nullVal ) {
                   ffpkyj( outfptr, nullKwd, nullVal, "Null value", status );
                   fits_set_btblnull( outfptr, colNo, nullVal, status );
                   newNullKwd = 1;
                }
-            } else if( gParse.hdutype==ASCII_TBL ) {
+            } else if( lParse.hdutype==ASCII_TBL ) {
                ffpkys( outfptr, nullKwd, "NULL", "Null value string", status );
                fits_set_atblnull( outfptr, colNo, "NULL", status );
                newNullKwd = 1;
             }
          }
 
       }
 
    } else if( *status ) {
-      ffcprs();
-      FFUNLOCK;
+      ffcprs(&lParse);
       return( *status );
    } else {
 
       /********************************************************/
       /*  Check if a TDIM keyword should be written/updated.  */
       /********************************************************/
 
@@ -681,16 +669,15 @@
          ffcmsg();
          if( naxis>1 )
             ffptdm( outfptr, colNo, naxis, naxes, status );
       }
       if( *status ) {
          /*  Either some other error happened in ffgcrd   */
          /*  or one happened in ffptdm                    */
-         ffcprs();
-         FFUNLOCK;
+         ffcprs(&lParse);
          return( *status );
       }
 
    }
 
    if( colNo>0 ) {
 
@@ -702,24 +689,23 @@
 
       ffgkyj(infptr, "NAXIS2", &totaln, 0, status);
 
       /*************************************/
       /* Create new iterator Output Column */
       /*************************************/
 
-      col_cnt = gParse.nCols;
-      if( allocateCol( col_cnt, status ) ) {
-         ffcprs();
-         FFUNLOCK;
+      col_cnt = lParse.nCols;
+      if( fits_parser_allocateCol( &lParse, col_cnt, status ) ) {
+         ffcprs(&lParse);
          return( *status );
       }
 
-      fits_iter_set_by_num( gParse.colData+col_cnt, outfptr,
+      fits_iter_set_by_num( lParse.colData+col_cnt, outfptr,
                             colNo, 0, OutputCol );
-      gParse.nCols++;
+      lParse.nCols++;
 
       for( i=0; i<nRngs; i++ ) {
          Info.dataPtr = NULL;
          Info.maxRows = end[i]-start[i]+1;
 
           /*
             If there is only 1 range, and it includes all the rows,
@@ -731,34 +717,33 @@
 
          if( (Info.maxRows >= 10) && (nRngs == 1) &&
              (start[0] == 1) && (end[0] == totaln))
               nPerLp = 0;
          else
               nPerLp = Info.maxRows;
 
-         if( ffiter( gParse.nCols, gParse.colData, start[i]-1,
-                     nPerLp, parse_data, (void*)&Info, status ) == -1 )
+         if( ffiter( lParse.nCols, lParse.colData, start[i]-1,
+                     nPerLp, fits_parser_workfn, (void*)&Info, status ) == -1 )
             *status = 0;
          else if( *status ) {
-            ffcprs();
-            FFUNLOCK;
+            ffcprs(&lParse);
             return( *status );
          }
          if( Info.anyNull ) anyNull = 1;
       }
 
       if( newNullKwd && !anyNull ) {
          ffdkey( outfptr, nullKwd, status );
       }
 
    } else {
 
       /* Put constant result into keyword */
 
-      result  = gParse.Nodes + gParse.resultNode;
+      result  = lParse.Nodes + lParse.resultNode;
       switch( Info.datatype ) {
       case TDOUBLE:
          ffukyd( outfptr, parName, result->value.data.dbl, 15,
                  parInfo, status );
          break;
       case TLONG:
          ffukyj( outfptr, parName, result->value.data.lng, parInfo, status );
@@ -775,16 +760,15 @@
 	 } else {
 	   ffukys( outfptr, parName, result->value.data.str, parInfo, status );
 	 }
          break;
       }
    }
 
-   ffcprs();
-   FFUNLOCK;
+   ffcprs(&lParse);
    return( *status );
 }
 
 /*--------------------------------------------------------------------------*/
 int fftexp( fitsfile *fptr,      /* I - Input FITS file                     */
             char     *expr,      /* I - Arithmetic expression               */
             int      maxdim,     /* I - Max Dimension of naxes              */
@@ -793,126 +777,144 @@
             int      *naxis,     /* O - # of dimensions of result           */
             long     *naxes,     /* O - Size of each dimension              */
             int      *status )   /* O - Error status                        */
 /*                                                                          */
 /* Evaluate the given expression and return information on the result.      */
 /*--------------------------------------------------------------------------*/
 {
-   FFLOCK;
-   ffiprs( fptr, 0, expr, maxdim, datatype, nelem, naxis, naxes, status );
-   ffcprs();
-   FFUNLOCK;
+   ParseData lParse;
+
+   ffiprs( fptr, 0, expr, maxdim, datatype, nelem, naxis, naxes, &lParse, status );
+   ffcprs(&lParse);
    return( *status );
 }
 
+
 /*--------------------------------------------------------------------------*/
 int ffiprs( fitsfile *fptr,      /* I - Input FITS file                     */
             int      compressed, /* I - Is FITS file hkunexpanded?          */
             char     *expr,      /* I - Arithmetic expression               */
             int      maxdim,     /* I - Max Dimension of naxes              */
             int      *datatype,  /* O - Data type of result                 */
             long     *nelem,     /* O - Vector length of result             */
             int      *naxis,     /* O - # of dimensions of result           */
             long     *naxes,     /* O - Size of each dimension              */
+	    ParseData *lParse,   /* O - parser status                       */
             int      *status )   /* O - Error status                        */
 /*                                                                          */
 /* Initialize the parser and determine what type of result the expression   */
 /* produces.                                                                */
 /*--------------------------------------------------------------------------*/
 {
    Node *result;
    int  i,lexpr, tstatus = 0;
    int xaxis, bitpix;
    long xaxes[9];
-   static iteratorCol dmyCol;
+   yyscan_t yylex_scanner; /* Used internally by FLEX lexer */
+   PixelFilter *pixFilter = 0;
 
    if( *status ) return( *status );
 
    /* make sure all internal structures for this HDU are current */
    if ( ffrdef(fptr, status) ) return(*status);
 
    /*  Initialize the Parser structure  */
 
-   gParse.def_fptr   = fptr;
-   gParse.compressed = compressed;
-   gParse.nCols      = 0;
-   gParse.colData    = NULL;
-   gParse.varData    = NULL;
-   gParse.getData    = find_column;
-   gParse.loadData   = load_column;
-   gParse.Nodes      = NULL;
-   gParse.nNodesAlloc= 0;
-   gParse.nNodes     = 0;
-   gParse.hdutype    = 0;
-   gParse.status     = 0;
+   /* Unfortunately we need to preserve the pixFilter value since it
+      is pre-set when ffiprs() is called */
+   pixFilter = lParse->pixFilter;
+   memset(lParse, 0, sizeof(*lParse));
+   lParse->pixFilter = pixFilter;
+
+   lParse->def_fptr   = fptr;
+   lParse->compressed = compressed;
+   lParse->nCols      = 0;
+   lParse->colData    = NULL;
+   lParse->varData    = NULL;
+   lParse->getData    = find_column;
+   lParse->loadData   = load_column;
+   lParse->Nodes      = NULL;
+   lParse->nNodesAlloc= 0;
+   lParse->nNodes     = 0;
+   lParse->hdutype    = 0;
+   lParse->status     = 0;
 
-   fits_get_hdu_type(fptr, &gParse.hdutype, status );
+   fits_get_hdu_type(fptr, &(lParse->hdutype), status );
 
-   if (gParse.hdutype == IMAGE_HDU) {
+   if (lParse->hdutype == IMAGE_HDU) {
 
       fits_get_img_param(fptr, 9, &bitpix, &xaxis, xaxes, status);
       if (*status) {
          ffpmsg("ffiprs: unable to get image dimensions");
          return( *status );
       }
-      gParse.totalRows = xaxis > 0 ? 1 : 0;
+      lParse->totalRows = xaxis > 0 ? 1 : 0;
       for (i = 0; i < xaxis; ++i)
-         gParse.totalRows *= xaxes[i];
+         lParse->totalRows *= xaxes[i];
       if (DEBUG_PIXFILTER)
-         printf("naxis=%d, gParse.totalRows=%ld\n", xaxis, gParse.totalRows);
+         printf("naxis=%d, lParse->totalRows=%ld\n", xaxis, lParse->totalRows);
    }
-   else if( ffgkyj(fptr, "NAXIS2", &gParse.totalRows, 0, &tstatus) )
+   else if( ffgkyj(fptr, "NAXIS2", &lParse->totalRows, 0, &tstatus) )
    {
       /* this might be a 1D or null image with no NAXIS2 keyword */
-      gParse.totalRows = 0;
+      lParse->totalRows = 0;
    } 
    
 
    /*  Copy expression into parser... read from file if necessary  */
 
 
    if( expr[0]=='@' ) {
-      if( ffimport_file( expr+1, &gParse.expr, status ) ) return( *status );
-      lexpr = strlen(gParse.expr);
+      if( ffimport_file( expr+1, &lParse->expr, status ) ) return( *status );
+      lexpr = strlen(lParse->expr);
    } else {
       lexpr = strlen(expr);
-      gParse.expr = (char*)malloc( (2+lexpr)*sizeof(char));
-      strcpy(gParse.expr,expr);
+      lParse->expr = (char*)malloc( (2+lexpr)*sizeof(char));
+      strcpy(lParse->expr,expr);
    }
-   strcat(gParse.expr + lexpr,"\n");
-   gParse.index    = 0;
-   gParse.is_eobuf = 0;
+   strcat(lParse->expr + lexpr,"\n");
+   lParse->index    = 0;
+   lParse->is_eobuf = 0;
 
    /*  Parse the expression, building the Nodes and determing  */
    /*  which columns are needed and what data type is returned  */
+   
+   fits_parser_yylex_init_extra(lParse, &yylex_scanner);
+   fits_parser_yyrestart(NULL, yylex_scanner);
+   *status = fits_parser_yyparse(yylex_scanner, lParse);
+   fits_parser_yylex_destroy(yylex_scanner);
 
-   ffrestart(NULL);
-   if( ffparse() ) {
-      return( *status = PARSE_SYNTAX_ERR );
-   }
-   /*  Check results  */
+   if( *status  ) return( *status = PARSE_SYNTAX_ERR );
 
-   *status = gParse.status;
+   /*  Check results  */
+   *status = lParse->status;
    if( *status ) return(*status);
 
-   if( !gParse.nNodes ) {
+   if( !lParse->nNodes ) {
       ffpmsg("Blank expression");
       return( *status = PARSE_SYNTAX_ERR );
    }
-   if( !gParse.nCols ) {
-      dmyCol.fptr = fptr;         /* This allows iterator to know value of */
-      gParse.colData = &dmyCol;   /* fptr when no columns are referenced   */
+   if( !lParse->nCols ) {
+     lParse->colData = (iteratorCol *) malloc(sizeof(iteratorCol));
+     if (lParse->colData == 0) {
+       ffpmsg("memory allocation failed (ffiprs)");
+       return( *status = MEMORY_ALLOCATION );
+     }
+     /* This allows iterator to know value of */ 
+     /* fptr when no columns are referenced   */
+     memset(lParse->colData, 0, sizeof(iteratorCol));
+     lParse->colData[0].fptr = fptr;
    }
 
-   result = gParse.Nodes + gParse.resultNode;
+   result = lParse->Nodes + lParse->resultNode;
 
-   *naxis = result->value.naxis;
-   *nelem = result->value.nelem;
+   *naxis = lParse->nAxis     = result->value.naxis;
+   *nelem = lParse->nElements = result->value.nelem;
    for( i=0; i<*naxis && i<maxdim; i++ )
-      naxes[i] = result->value.naxes[i];
+      naxes[i] = lParse->nAxes[i] = result->value.naxes[i];
 
    switch( result->type ) {
    case BOOLEAN:
       *datatype = TLOGICAL;
       break;
    case LONG:
       *datatype = TLONG;
@@ -925,68 +927,72 @@
       break;
    case STRING:
       *datatype = TSTRING;
       break;
    default:
       *datatype = 0;
       ffpmsg("Bad return data type");
-      *status = gParse.status = PARSE_BAD_TYPE;
+      *status = lParse->status = PARSE_BAD_TYPE;
       break;
    }
-   gParse.datatype = *datatype;
-   FREE(gParse.expr);
+   lParse->datatype = *datatype;
+   FREE(lParse->expr);
 
    if( result->operation==CONST_OP ) *nelem = - *nelem;
    return(*status);
 }
 
 /*--------------------------------------------------------------------------*/
-void ffcprs( void )  /*  No parameters                                      */
+void ffcprs( ParseData *lParse )
 /*                                                                          */
 /* Clear the parser, making it ready to accept a new expression.            */
 /*--------------------------------------------------------------------------*/
 {
    int col, node, i;
 
-   if( gParse.nCols > 0 ) {
-      FREE( gParse.colData  );
-      for( col=0; col<gParse.nCols; col++ ) {
-         if( gParse.varData[col].undef == NULL ) continue;
-         if( gParse.varData[col].type  == BITSTR )
-           FREE( ((char**)gParse.varData[col].data)[0] );
-         free( gParse.varData[col].undef );
-      }
-      FREE( gParse.varData );
-      gParse.nCols = 0;
+   if( lParse->nCols > 0 ) {
+      FREE( lParse->colData  );
+      for( col=0; col<lParse->nCols; col++ ) {
+         if( lParse->varData[col].undef == NULL ) continue;
+         if( lParse->varData[col].type  == BITSTR )
+           FREE( ((char**)lParse->varData[col].data)[0] );
+         free( lParse->varData[col].undef );
+      }
+      FREE( lParse->varData );
+      lParse->nCols = 0;
+   } else if ( lParse->colData ) {
+     /* Special case if colData needed to be created with no columns */
+     FREE( lParse->colData );
    }
 
-   if( gParse.nNodes > 0 ) {
-      node = gParse.nNodes;
+   if( lParse->nNodes > 0 ) {
+      node = lParse->nNodes;
       while( node-- ) {
-         if( gParse.Nodes[node].operation==gtifilt_fct ) {
-            i = gParse.Nodes[node].SubNodes[0];
-            if (gParse.Nodes[ i ].value.data.ptr)
-	        FREE( gParse.Nodes[ i ].value.data.ptr );
+         if( lParse->Nodes[node].operation==gtifilt_fct ) {
+            i = lParse->Nodes[node].SubNodes[0];
+            if (lParse->Nodes[ i ].value.data.ptr)
+	        FREE( lParse->Nodes[ i ].value.data.ptr );
          }
-         else if( gParse.Nodes[node].operation==regfilt_fct ) {
-            i = gParse.Nodes[node].SubNodes[0];
-            fits_free_region( (SAORegion *)gParse.Nodes[ i ].value.data.ptr );
+         else if( lParse->Nodes[node].operation==regfilt_fct ) {
+            i = lParse->Nodes[node].SubNodes[0];
+            fits_free_region( (SAORegion *)lParse->Nodes[ i ].value.data.ptr );
          }
       }
-      gParse.nNodes = 0;
+      lParse->nNodes = 0;
    }
-   if( gParse.Nodes ) free( gParse.Nodes );
-   gParse.Nodes = NULL;
+   if( lParse->Nodes ) free( lParse->Nodes );
+   lParse->Nodes = NULL;
 
-   gParse.hdutype = ANY_HDU;
-   gParse.pixFilter = 0;
+   lParse->hdutype = ANY_HDU;
+   lParse->pixFilter = 0;
+   lParse->nDataRows = lParse->nPrevDataRows = 0;
 }
 
 /*---------------------------------------------------------------------------*/
-int parse_data( long    totalrows,     /* I - Total rows to be processed     */
+int fits_parser_workfn( long    totalrows,     /* I - Total rows to be processed     */
                 long    offset,        /* I - Number of rows skipped at start*/
                 long    firstrow,      /* I - First row of this iteration    */
                 long    nrows,         /* I - Number of rows in this iter    */
                 int      nCols,        /* I - Number of columns in use       */
                 iteratorCol *colData,  /* IO- Column information/data        */
                 void    *userPtr )     /* I - Data handling instructions     */
 /*                                                                           */
@@ -995,357 +1001,395 @@
 /* structure.                                                                */
 /*---------------------------------------------------------------------------*/
 {
     int status, constant=0, anyNullThisTime=0;
     long jj, kk, idx, remain, ntodo;
     Node *result;
     iteratorCol * outcol;
+    ParseData *lParse = ((parseInfo*)userPtr)->parseData;
+    struct ParseStatusVariables *pv = &( ((parseInfo*)userPtr)->parseVariables );
+    void *Data0 = 0;
 
     /* declare variables static to preserve their values between calls */
-    static void *Data, *Null;
-    static int  datasize;
-    static long lastRow, repeat, resDataSize;
-    static LONGLONG jnull;
-    static parseInfo *userInfo;
-    static long zeros[4] = {0,0,0,0};
+    long zeros[4] = {0,0,0,0};
 
     if (DEBUG_PIXFILTER)
-       printf("parse_data(total=%ld, offset=%ld, first=%ld, rows=%ld, cols=%d)\n",
+       printf("fits_parser_workfn(total=%ld, offset=%ld, first=%ld, rows=%ld, cols=%d)\n",
                 totalrows, offset, firstrow, nrows, nCols);
     /*--------------------------------------------------------*/
     /*  Initialization procedures: execute on the first call  */
     /*--------------------------------------------------------*/
     outcol = colData + (nCols - 1);
     if (firstrow == offset+1)
     {
-       userInfo = (parseInfo*)userPtr;
-       userInfo->anyNull = 0;
+       (pv->userInfo) = (parseInfo*)userPtr;
+       (pv->userInfo)->anyNull = 0;
+
+       /* Unfortunately there are two copies of the iterator columns,
+	  one inside the parser and one outside maintained by the
+	  higher level.  (This could happen if the histogramming
+	  routines are binning multiple columns, and so there are
+	  multiple parsers being managed at one time.) Upon the first
+	  call we make sure they match */
+       for (jj = 0; jj<nCols; jj++) {
+	 lParse->colData[jj].repeat = colData[jj].repeat;
+       }
 
-       if( userInfo->maxRows>0 )
-          userInfo->maxRows = minvalue(totalrows,userInfo->maxRows);
-       else if( userInfo->maxRows<0 )
-          userInfo->maxRows = totalrows;
+       if( (pv->userInfo)->maxRows>0 )
+          (pv->userInfo)->maxRows = minvalue(totalrows,(pv->userInfo)->maxRows);
+       else if( (pv->userInfo)->maxRows<0 )
+          (pv->userInfo)->maxRows = totalrows;
        else
-          userInfo->maxRows = nrows;
+          (pv->userInfo)->maxRows = nrows;
 
-       lastRow = firstrow + userInfo->maxRows - 1;
+       (pv->lastRow) = firstrow + (pv->userInfo)->maxRows - 1;
 
-       if( userInfo->dataPtr==NULL ) {
+       /* dataPtr == NULL indicates an iterator-derived column, which
+	  means that the first value will be a null value and the remaining
+	  values will be the where the outputs are placed */
+       if( (pv->userInfo)->dataPtr==NULL ) {
 
           if( outcol->iotype == InputCol ) {
              ffpmsg("Output column for parser results not found!");
              return( PARSE_NO_OUTPUT );
           }
           /* Data gets set later */
-          Null = outcol->array;
-          userInfo->datatype = outcol->datatype;
+          (pv->Null) = outcol->array;
+          (pv->userInfo)->datatype = outcol->datatype;
 
           /* Check for a TNULL/BLANK keyword for output column/image */
 
           status = 0;
-          jnull = 0;
-          if (gParse.hdutype == IMAGE_HDU) {
-             if (gParse.pixFilter->blank)
-                jnull = (LONGLONG) gParse.pixFilter->blank;
+          (pv->jnull) = 0;
+          if (lParse->hdutype == IMAGE_HDU) {
+             if (lParse->pixFilter->blank)
+                (pv->jnull) = (LONGLONG) lParse->pixFilter->blank;
           }
           else {
-             ffgknjj( outcol->fptr, "TNULL", outcol->colnum,
-                        1, &jnull, (int*)&jj, &status );
+	    if (outcol->iotype != TemporaryCol) {
+	      ffgknjj( outcol->fptr, "TNULL", outcol->colnum,
+		       1, &(pv->jnull), (int*)&jj, &status );
+	    }
 
-             if( status==BAD_INTKEY ) {
+             if( status==BAD_INTKEY || outcol->iotype == TemporaryCol) {
                 /*  Probably ASCII table with text TNULL keyword  */
-                switch( userInfo->datatype ) {
-                   case TSHORT:  jnull = (LONGLONG) SHRT_MIN;      break;
-                   case TINT:    jnull = (LONGLONG) INT_MIN;       break;
-                   case TLONG:   jnull = (LONGLONG) LONG_MIN;      break;
+                switch( (pv->userInfo)->datatype ) {
+                   case TSHORT:  (pv->jnull) = (LONGLONG) SHRT_MIN;      break;
+                   case TINT:    (pv->jnull) = (LONGLONG) INT_MIN;       break;
+                   case TLONG:   (pv->jnull) = (LONGLONG) LONG_MIN;      break;
                 }
              }
           }
-          repeat = outcol->repeat;
+          (pv->repeat) = outcol->repeat;
 /*
           if (DEBUG_PIXFILTER)
-            printf("parse_data: using null value %ld\n", jnull);
+            printf("fits_parser_workfn: using null value %ld\n", (pv->jnull));
 */
        } else {
 
-          Data = userInfo->dataPtr;
-          Null = (userInfo->nullPtr ? userInfo->nullPtr : zeros);
-          repeat = gParse.Nodes[gParse.resultNode].value.nelem;
+	  /* This clause applies if the user is passing user-allocated 
+	     data arrays, which is where the data will be placed.  This 
+	     means they should also be passing null values */
+          (pv->Data) = (pv->userInfo)->dataPtr;
+          (pv->Null) = ((pv->userInfo)->nullPtr ? (pv->userInfo)->nullPtr : zeros);
+          (pv->repeat) = lParse->Nodes[lParse->resultNode].value.nelem;
 
        }
 
        /* Determine the size of each element of the returned result */
 
-       switch( userInfo->datatype ) {
+       switch( (pv->userInfo)->datatype ) {
        case TBIT:       /*  Fall through to TBYTE  */
        case TLOGICAL:   /*  Fall through to TBYTE  */
-       case TBYTE:     datasize = sizeof(char);     break;
-       case TSHORT:    datasize = sizeof(short);    break;
-       case TINT:      datasize = sizeof(int);      break;
-       case TLONG:     datasize = sizeof(long);     break;
-       case TLONGLONG: datasize = sizeof(LONGLONG); break;
-       case TFLOAT:    datasize = sizeof(float);    break;
-       case TDOUBLE:   datasize = sizeof(double);   break;
-       case TSTRING:   datasize = sizeof(char*);    break;
+       case TBYTE:     (pv->datasize) = sizeof(char);     break;
+       case TSHORT:    (pv->datasize) = sizeof(short);    break;
+       case TINT:      (pv->datasize) = sizeof(int);      break;
+       case TLONG:     (pv->datasize) = sizeof(long);     break;
+       case TLONGLONG: (pv->datasize) = sizeof(LONGLONG); break;
+       case TFLOAT:    (pv->datasize) = sizeof(float);    break;
+       case TDOUBLE:   (pv->datasize) = sizeof(double);   break;
+       case TSTRING:   (pv->datasize) = sizeof(char*);    break;
        }
 
        /* Determine the size of each element of the calculated result */
        /*   (only matters for numeric/logical data)                   */
 
-       switch( gParse.Nodes[gParse.resultNode].type ) {
-       case BOOLEAN:   resDataSize = sizeof(char);    break;
-       case LONG:      resDataSize = sizeof(long);    break;
-       case DOUBLE:    resDataSize = sizeof(double);  break;
+       switch( lParse->Nodes[lParse->resultNode].type ) {
+       case BOOLEAN:   (pv->resDataSize) = sizeof(char);    break;
+       case LONG:      (pv->resDataSize) = sizeof(long);    break;
+       case DOUBLE:    (pv->resDataSize) = sizeof(double);  break;
        }
     }
 
     /*-------------------------------------------*/
     /*  Main loop: process all the rows of data  */
     /*-------------------------------------------*/
 
     /*  If writing to output column, set first element to appropriate  */
     /*  null value.  If no NULLs encounter, zero out before returning. */
 /*
           if (DEBUG_PIXFILTER)
-            printf("parse_data: using null value %ld\n", jnull);
+            printf("fits_parser_workfn: using null value %ld\n", (pv->jnull));
 */
 
-    if( userInfo->dataPtr == NULL ) {
-       /* First, reset Data pointer to start of output array */
-       Data = (char*) outcol->array + datasize;
-
-       switch( userInfo->datatype ) {
-       case TLOGICAL: *(char  *)Null = 'U';             break;
-       case TBYTE:    *(char  *)Null = (char )jnull;    break;
-       case TSHORT:   *(short *)Null = (short)jnull;    break;
-       case TINT:     *(int   *)Null = (int  )jnull;    break;
-       case TLONG:    *(long  *)Null = (long )jnull;    break;
-       case TLONGLONG: *(LONGLONG  *)Null = (LONGLONG )jnull;    break;
-       case TFLOAT:   *(float *)Null = FLOATNULLVALUE;  break;
-       case TDOUBLE:  *(double*)Null = DOUBLENULLVALUE; break;
-       case TSTRING: (*(char **)Null)[0] = '\1';
-                     (*(char **)Null)[1] = '\0';        break;
+    if( (pv->userInfo)->dataPtr == NULL ) {
+       /* First, reset Data pointer to start of output array, plus 1
+	  because the 0th element is the null value (cute undocumented
+	  feature of the iterator!) */
+       (pv->Data) = (char*) outcol->array + (pv->datasize);
+
+       /* A TemporaryCol with null value specified explicitly */
+       if (outcol->iotype == TemporaryCol && (pv->userInfo)->nullPtr) {
+
+	 pv->Null = (pv->userInfo)->nullPtr;
+
+       } else {
+
+	 /* ... or an OutputCol or TemporaryCol with no explicit null */
+	 switch( (pv->userInfo)->datatype ) {
+	 case TLOGICAL: *(char  *)(pv->Null) = 'U';             break;
+	 case TBYTE:    *(char  *)(pv->Null) = (char )(pv->jnull);    break;
+	 case TSHORT:   *(short *)(pv->Null) = (short)(pv->jnull);    break;
+	 case TINT:     *(int   *)(pv->Null) = (int  )(pv->jnull);    break;
+	 case TLONG:    *(long  *)(pv->Null) = (long )(pv->jnull);    break;
+	 case TLONGLONG: *(LONGLONG  *)(pv->Null) = (LONGLONG )(pv->jnull);    break;
+	 case TFLOAT:   *(float *)(pv->Null) = FLOATNULLVALUE;  break;
+	 case TDOUBLE:  *(double*)(pv->Null) = DOUBLENULLVALUE; break;
+	 case TSTRING: (*(char **)(pv->Null))[0] = '\1';
+	               (*(char **)(pv->Null))[1] = '\0';        break;
+	 }
        }
     }
 
     /* Alter nrows in case calling routine didn't want to do all rows */
 
-    nrows = minvalue(nrows,lastRow-firstrow+1);
+    Data0 = pv->Data; /* Record starting point */
+    nrows = minvalue(nrows,(pv->lastRow)-firstrow+1);
 
-    Setup_DataArrays( nCols, colData, firstrow, nrows );
+    Setup_DataArrays( lParse, nCols, colData, firstrow, nrows );
 
     /* Parser allocates arrays for each column and calculation it performs. */
     /* Limit number of rows processed during each pass to reduce memory     */
     /* requirements... In most cases, iterator will limit rows to less      */
-    /* than 2500 rows per iteration, so this is really only relevant for    */
+    /* than 10000 rows per iteration, so this is really only relevant for    */
     /* hk-compressed files which must be decompressed in memory and sent    */
-    /* whole to parse_data in a single iteration.                           */
+    /* whole to fits_parser_workfn in a single iteration.                           */
 
     remain = nrows;
     while( remain ) {
-       ntodo = minvalue(remain,2500);
-       Evaluate_Parser ( firstrow, ntodo );
-       if( gParse.status ) break;
+       ntodo = minvalue(remain,10000);
+       Evaluate_Parser ( lParse, firstrow, ntodo );
+       if( lParse->status ) break;
 
        firstrow += ntodo;
        remain   -= ntodo;
 
        /*  Copy results into data array  */
 
-       result = gParse.Nodes + gParse.resultNode;
+       result = lParse->Nodes + lParse->resultNode;
        if( result->operation==CONST_OP ) constant = 1;
 
        switch( result->type ) {
 
        case BOOLEAN:
        case LONG:
        case DOUBLE:
           if( constant ) {
              char undef=0;
              for( kk=0; kk<ntodo; kk++ )
-                for( jj=0; jj<repeat; jj++ )
-                   ffcvtn( gParse.datatype,
+                for( jj=0; jj<(pv->repeat); jj++ )
+                   ffcvtn( lParse->datatype,
                            &(result->value.data),
                            &undef, result->value.nelem /* 1 */,
-                           userInfo->datatype, Null,
-                           (char*)Data + (kk*repeat+jj)*datasize,
-                           &anyNullThisTime, &gParse.status );
+                           (pv->userInfo)->datatype, (pv->Null),
+                           (char*)(pv->Data) + (kk*(pv->repeat)+jj)*(pv->datasize),
+                           &anyNullThisTime, &lParse->status );
           } else {
-             if ( repeat == result->value.nelem ) {
-                ffcvtn( gParse.datatype,
+             if ( (pv->repeat) == result->value.nelem ) {
+                ffcvtn( lParse->datatype,
                         result->value.data.ptr,
                         result->value.undef,
                         result->value.nelem*ntodo,
-                        userInfo->datatype, Null, Data,
-                        &anyNullThisTime, &gParse.status );
+                        (pv->userInfo)->datatype, (pv->Null), (pv->Data),
+                        &anyNullThisTime, &lParse->status );
              } else if( result->value.nelem == 1 ) {
                 for( kk=0; kk<ntodo; kk++ )
-                   for( jj=0; jj<repeat; jj++ ) {
-                      ffcvtn( gParse.datatype,
-                              (char*)result->value.data.ptr + kk*resDataSize,
+                   for( jj=0; jj<(pv->repeat); jj++ ) {
+                      ffcvtn( lParse->datatype,
+                              (char*)result->value.data.ptr + kk*(pv->resDataSize),
                               (char*)result->value.undef + kk,
-                              1, userInfo->datatype, Null,
-                              (char*)Data + (kk*repeat+jj)*datasize,
-                              &anyNullThisTime, &gParse.status );
+                              1, (pv->userInfo)->datatype, (pv->Null),
+                              (char*)(pv->Data) + (kk*(pv->repeat)+jj)*(pv->datasize),
+                              &anyNullThisTime, &lParse->status );
                    }
              } else {
                 int nCopy;
-                nCopy = minvalue( repeat, result->value.nelem );
+                nCopy = minvalue( (pv->repeat), result->value.nelem );
                 for( kk=0; kk<ntodo; kk++ ) {
-                   ffcvtn( gParse.datatype,
+                   ffcvtn( lParse->datatype,
                            (char*)result->value.data.ptr
-                                  + kk*result->value.nelem*resDataSize,
+                                  + kk*result->value.nelem*(pv->resDataSize),
                            (char*)result->value.undef
                                   + kk*result->value.nelem,
-                           nCopy, userInfo->datatype, Null,
-                           (char*)Data + (kk*repeat)*datasize,
-                           &anyNullThisTime, &gParse.status );
-                   if( nCopy < repeat ) {
-                      memset( (char*)Data + (kk*repeat+nCopy)*datasize,
-                              0, (repeat-nCopy)*datasize);
+                           nCopy, (pv->userInfo)->datatype, (pv->Null),
+                           (char*)(pv->Data) + (kk*(pv->repeat))*(pv->datasize),
+                           &anyNullThisTime, &lParse->status );
+                   if( nCopy < (pv->repeat) ) {
+                      memset( (char*)(pv->Data) + (kk*(pv->repeat)+nCopy)*(pv->datasize),
+                              0, ((pv->repeat)-nCopy)*(pv->datasize));
                    }
                 }
 
              }
              if( result->operation>0 ) {
                 FREE( result->value.data.ptr );
              }
           }
-          if( gParse.status==OVERFLOW_ERR ) {
-             gParse.status = NUM_OVERFLOW;
+          if( lParse->status==OVERFLOW_ERR ) {
+             lParse->status = NUM_OVERFLOW;
              ffpmsg("Numerical overflow while converting expression to necessary datatype");
           }
           break;
 
        case BITSTR:
-          switch( userInfo->datatype ) {
+          switch( (pv->userInfo)->datatype ) {
           case TBYTE:
              idx = -1;
              for( kk=0; kk<ntodo; kk++ ) {
                 for( jj=0; jj<result->value.nelem; jj++ ) {
                    if( jj%8 == 0 )
-                      ((char*)Data)[++idx] = 0;
+                      ((char*)(pv->Data))[++idx] = 0;
                    if( constant ) {
                       if( result->value.data.str[jj]=='1' )
-                         ((char*)Data)[idx] |= 128>>(jj%8);
+                         ((char*)(pv->Data))[idx] |= 128>>(jj%8);
                    } else {
                       if( result->value.data.strptr[kk][jj]=='1' )
-                         ((char*)Data)[idx] |= 128>>(jj%8);
+                         ((char*)(pv->Data))[idx] |= 128>>(jj%8);
                    }
                 }
              }
              break;
           case TBIT:
           case TLOGICAL:
              if( constant ) {
                 for( kk=0; kk<ntodo; kk++ )
                    for( jj=0; jj<result->value.nelem; jj++ ) {
-                      ((char*)Data)[ jj+kk*result->value.nelem ] =
+                      ((char*)(pv->Data))[ jj+kk*result->value.nelem ] =
                          ( result->value.data.str[jj]=='1' );
                    }
              } else {
                 for( kk=0; kk<ntodo; kk++ )
                    for( jj=0; jj<result->value.nelem; jj++ ) {
-                      ((char*)Data)[ jj+kk*result->value.nelem ] =
+                      ((char*)(pv->Data))[ jj+kk*result->value.nelem ] =
                          ( result->value.data.strptr[kk][jj]=='1' );
                    }
              }
              break; 
           case TSTRING:
              if( constant ) {
                 for( jj=0; jj<ntodo; jj++ ) {
-                   strcpy( ((char**)Data)[jj], result->value.data.str );
+                   strcpy( ((char**)(pv->Data))[jj], result->value.data.str );
                 }
              } else {
                 for( jj=0; jj<ntodo; jj++ ) {
-                   strcpy( ((char**)Data)[jj], result->value.data.strptr[jj] );
+                   strcpy( ((char**)(pv->Data))[jj], result->value.data.strptr[jj] );
                 }
              }
              break;
           default:
              ffpmsg("Cannot convert bit expression to desired type.");
-             gParse.status = PARSE_BAD_TYPE;
+             lParse->status = PARSE_BAD_TYPE;
              break;
           }
           if( result->operation>0 ) {
              FREE( result->value.data.strptr[0] );
              FREE( result->value.data.strptr );
           }
           break;
 
        case STRING:
-          if( userInfo->datatype==TSTRING ) {
+          if( (pv->userInfo)->datatype==TSTRING ) {
              if( constant ) {
                 for( jj=0; jj<ntodo; jj++ )
-                   strcpy( ((char**)Data)[jj], result->value.data.str );
+                   strcpy( ((char**)(pv->Data))[jj], result->value.data.str );
              } else {
                 for( jj=0; jj<ntodo; jj++ )
                    if( result->value.undef[jj] ) {
                       anyNullThisTime = 1;
-                      strcpy( ((char**)Data)[jj],
-                              *(char **)Null );
+                      strcpy( ((char**)(pv->Data))[jj],
+                              *(char **)(pv->Null) );
                    } else {
-                      strcpy( ((char**)Data)[jj],
+                      strcpy( ((char**)(pv->Data))[jj],
                               result->value.data.strptr[jj] );
                    }
              }
           } else {
              ffpmsg("Cannot convert string expression to desired type.");
-             gParse.status = PARSE_BAD_TYPE;
+             lParse->status = PARSE_BAD_TYPE;
           }
           if( result->operation>0 ) {
              FREE( result->value.data.strptr[0] );
              FREE( result->value.data.strptr );
           }
           break;
        }
 
-       if( gParse.status ) break;
+       if( lParse->status ) break;
 
        /*  Increment Data to point to where the next block should go  */
 
-       if( result->type==BITSTR && userInfo->datatype==TBYTE )
-          Data = (char*)Data
-                    + datasize * ( (result->value.nelem+7)/8 ) * ntodo;
+       if( result->type==BITSTR && (pv->userInfo)->datatype==TBYTE )
+          (pv->Data) = (char*)(pv->Data)
+                    + (pv->datasize) * ( (result->value.nelem+7)/8 ) * ntodo;
        else if( result->type==STRING )
-          Data = (char*)Data + datasize * ntodo;
+          (pv->Data) = (char*)(pv->Data) + (pv->datasize) * ntodo;
        else
-          Data = (char*)Data + datasize * ntodo * repeat;
+          (pv->Data) = (char*)(pv->Data) + (pv->datasize) * ntodo * (pv->repeat);
+    }
+
+    /* If a TemporaryCol output is used, we want to inform the caller
+       what the null value is expected to be */
+    if (pv->Null != outcol->array && 
+	(Data0) == (char*) outcol->array + (pv->datasize)) {
+      if( (pv->userInfo)->datatype == TSTRING )
+	memcpy( outcol->array, *(char **)(pv->Null), 2 );
+      else 
+	memcpy( outcol->array, (pv->Null), (pv->datasize) );
     }
 
     /* If no NULLs encountered during this pass, set Null value to */
     /* zero to make the writing of the output column data faster   */
 
     if( anyNullThisTime )
-       userInfo->anyNull = 1;
-    else if( userInfo->dataPtr == NULL ) {
-       if( userInfo->datatype == TSTRING )
-          memcpy( *(char **)Null, zeros, 2 );
+       (pv->userInfo)->anyNull = 1;
+    else if( pv->Null == outcol->array ) {
+       if( (pv->userInfo)->datatype == TSTRING )
+          memcpy( *(char **)(pv->Null), zeros, 2 );
        else 
-          memcpy( Null, zeros, datasize );
+          memcpy( (pv->Null), zeros, (pv->datasize) );
     }
 
     /*-------------------------------------------------------*/
     /*  Clean up procedures:  after processing all the rows  */
     /*-------------------------------------------------------*/
 
     /*  if the calling routine specified that only a limited number    */
     /*  of rows in the table should be processed, return a value of -1 */
     /*  once all the rows have been done, if no other error occurred.  */
 
-    if (gParse.hdutype != IMAGE_HDU && firstrow - 1 == lastRow) {
-           if (!gParse.status && userInfo->maxRows<totalrows) {
+    if (lParse->hdutype != IMAGE_HDU && firstrow - 1 == (pv->lastRow)) {
+           if (!lParse->status && (pv->userInfo)->maxRows<totalrows) {
                   return (-1);
            }
     }
 
-    return(gParse.status);  /* return successful status */
+    return(lParse->status);  /* return successful status */
 }
 
-static void Setup_DataArrays( int nCols, iteratorCol *cols,
+static void Setup_DataArrays( ParseData *lParse, int nCols, iteratorCol *cols,
                               long fRow, long nRows )
     /***********************************************************************/
     /*  Setup the varData array in gParse to contain the fits column data. */
     /*  Then, allocate and initialize the necessary UNDEF arrays for each  */
     /*  column used by the parser.                                         */
     /***********************************************************************/
 {
@@ -1353,51 +1397,56 @@
    long    nelem, len, row, idx;
    char  **bitStrs;
    char  **sptr;
    char   *barray;
    long   *iarray;
    double *rarray;
    char msg[80];
+   int do_realloc = 0;
 
-   gParse.firstDataRow = fRow;
-   gParse.nDataRows    = nRows;
+   lParse->firstDataRow = fRow;
+   lParse->nDataRows    = nRows;
+   /* Only perform reallocations if the number of rows changed */
+   if (lParse->nPrevDataRows != nRows) do_realloc = 1;
 
    /*  Resize and fill in UNDEF arrays for each column  */
 
    for( i=0; i<nCols; i++ ) {
 
       iteratorCol *icol = cols + i;
-      DataInfo *varData = gParse.varData + i;
+      DataInfo *varData = lParse->varData + i;
 
-      if( icol->iotype == OutputCol ) continue;
+      if( icol->iotype == OutputCol || icol->iotype == TemporaryCol ) continue;
 
       nelem  = varData->nelem;
       len    = nelem * nRows;
 
       switch ( varData->type ) {
 
       case BITSTR:
       /* No need for UNDEF array, but must make string DATA array */
          len = (nelem+1)*nRows;   /* Count '\0' */
          bitStrs = (char**)varData->data;
-         if( bitStrs ) FREE( bitStrs[0] );
-         free( bitStrs );
-         bitStrs = (char**)malloc( nRows*sizeof(char*) );
-         if( bitStrs==NULL ) {
-            varData->data = varData->undef = NULL;
-            gParse.status = MEMORY_ALLOCATION;
-            break;
-         }
-         bitStrs[0] = (char*)malloc( len*sizeof(char) );
-         if( bitStrs[0]==NULL ) {
-            free( bitStrs );
-            varData->data = varData->undef = NULL;
-            gParse.status = MEMORY_ALLOCATION;
-            break;
-         }
+	 if (do_realloc) {
+	   if( bitStrs ) FREE( bitStrs[0] );
+	   free( bitStrs );
+	   bitStrs = (char**)malloc( nRows*sizeof(char*) );
+	   if( bitStrs==NULL ) {
+	     varData->data = varData->undef = NULL;
+	     lParse->status = MEMORY_ALLOCATION;
+	     break;
+	   }
+	   bitStrs[0] = (char*)malloc( len*sizeof(char) );
+	   if( bitStrs[0]==NULL ) {
+	     free( bitStrs );
+	     varData->data = varData->undef = NULL;
+	     lParse->status = MEMORY_ALLOCATION;
+	     break;
+	   }
+	 }
 
          for( row=0; row<nRows; row++ ) {
             bitStrs[row] = bitStrs[0] + row*(nelem+1);
             idx = (row)*( (nelem+7)/8 ) + 1;
             for(len=0; len<nelem; len++) {
                if( ((char*)icol->array)[idx] & (1<<(7-len%8)) )
                   bitStrs[row][len] = '1';
@@ -1409,93 +1458,104 @@
          }
          varData->undef = (char*)bitStrs;
          varData->data  = (char*)bitStrs;
          break;
 
       case STRING:
          sptr = (char**)icol->array;
-         if (varData->undef)
-            free( varData->undef );
-         varData->undef = (char*)malloc( nRows*sizeof(char) );
-         if( varData->undef==NULL ) {
-            gParse.status = MEMORY_ALLOCATION;
-            break;
-         }
+	 if (do_realloc) {
+	   if (varData->undef)
+	     free( varData->undef );
+	   varData->undef = (char*)malloc( nRows*sizeof(char) );
+	   if( varData->undef==NULL ) {
+	     lParse->status = MEMORY_ALLOCATION;
+	     break;
+	   }
+	 }
          row = nRows;
          while( row-- )
             varData->undef[row] =
                ( **sptr != '\0' && FSTRCMP( sptr[0], sptr[row+1] )==0 );
          varData->data  = sptr + 1;
          break;
 
       case BOOLEAN:
          barray = (char*)icol->array;
-         if (varData->undef)
-            free( varData->undef );
-         varData->undef = (char*)malloc( len*sizeof(char) );
-         if( varData->undef==NULL ) {
-            gParse.status = MEMORY_ALLOCATION;
-            break;
-         }
+	 if (do_realloc) {
+	   if (varData->undef)
+	     free( varData->undef );
+	   varData->undef = (char*)malloc( len*sizeof(char) );
+	   if( varData->undef==NULL ) {
+	     lParse->status = MEMORY_ALLOCATION;
+	     break;
+	   }
+	 }
          while( len-- ) {
             varData->undef[len] = 
                ( barray[0]!=0 && barray[0]==barray[len+1] );
          }
          varData->data  = barray + 1;
          break;
 
       case LONG:
          iarray = (long*)icol->array;
-         if (varData->undef)
-            free( varData->undef );
-         varData->undef = (char*)malloc( len*sizeof(char) );
-         if( varData->undef==NULL ) {
-            gParse.status = MEMORY_ALLOCATION;
-            break;
-         }
+	 if (do_realloc) {
+	   if (varData->undef)
+	     free( varData->undef );
+	   varData->undef = (char*)malloc( len*sizeof(char) );
+	   if( varData->undef==NULL ) {
+	     lParse->status = MEMORY_ALLOCATION;
+	     break;
+	   }
+	 }
          while( len-- ) {
             varData->undef[len] = 
                ( iarray[0]!=0L && iarray[0]==iarray[len+1] );
          }
          varData->data  = iarray + 1;
          break;
 
       case DOUBLE:
          rarray = (double*)icol->array;
-         if (varData->undef)
-            free( varData->undef );
-         varData->undef = (char*)malloc( len*sizeof(char) );
-         if( varData->undef==NULL ) {
-            gParse.status = MEMORY_ALLOCATION;
-            break;
-         }
+	 if (do_realloc) {
+	   if (varData->undef)
+	     free( varData->undef );
+	   varData->undef = (char*)malloc( len*sizeof(char) );
+	   if( varData->undef==NULL ) {
+	     lParse->status = MEMORY_ALLOCATION;
+	     break;
+	   }
+	 }
          while( len-- ) {
             varData->undef[len] = 
                ( rarray[0]!=0.0 && rarray[0]==rarray[len+1]);
          }
          varData->data  = rarray + 1;
          break;
 
       default:
          snprintf(msg, 80, "SetupDataArrays, unhandled type %d\n",
                 varData->type);
          ffpmsg(msg);
       }
 
-      if( gParse.status ) {  /*  Deallocate NULL arrays of previous columns */
+      if( lParse->status ) {  /*  Deallocate NULL arrays of previous columns */
          while( i-- ) {
-            varData = gParse.varData + i;
+            varData = lParse->varData + i;
             if( varData->type==BITSTR )
                FREE( ((char**)varData->data)[0] );
             FREE( varData->undef );
             varData->undef = NULL;
          }
+	 lParse->nPrevDataRows = 0;
          return;
       }
    }
+
+   lParse->nPrevDataRows = nRows;
 }
 
 /*--------------------------------------------------------------------------*/
 int ffcvtn( int   inputType,  /* I - Data type of input array               */
             void  *input,     /* I - Input array of type inputType          */
             char  *undef,     /* I - Array of flags indicating UNDEF elems  */
             long  ntodo,      /* I - Number of elements to process          */
@@ -1860,131 +1920,165 @@
 {
    parseInfo Info;
    long alen, width;
    int parNo, typecode;
    int naxis, constant, nCol=0;
    long nelem, naxes[MAXDIMS], elem;
    char result;
+   ParseData lParse;
 
    if( *status ) return( *status );
 
-   fits_get_colnum( fptr, CASEINSEN, timeCol, &gParse.timeCol, status );
-   fits_get_colnum( fptr, CASEINSEN, parCol,  &gParse.parCol , status );
-   fits_get_colnum( fptr, CASEINSEN, valCol,  &gParse.valCol, status );
-   if( *status ) return( *status );
-   
+   memset(&Info, 0, sizeof(Info));   
+
    if( ffiprs( fptr, 1, expr, MAXDIMS, &Info.datatype, &nelem,
-               &naxis, naxes, status ) ) {
-      ffcprs();
+               &naxis, naxes, &lParse, status ) ) {
+      ffcprs(&lParse);
       return( *status );
    }
+
+   fits_get_colnum( fptr, CASEINSEN, timeCol, &lParse.timeCol, status );
+   fits_get_colnum( fptr, CASEINSEN, parCol,  &lParse.parCol , status );
+   fits_get_colnum( fptr, CASEINSEN, valCol,  &lParse.valCol, status );
+   if( *status ) return( *status );
+   
    if( nelem<0 ) {
       constant = 1;
       nelem = -nelem;
-      nCol = gParse.nCols;
-      gParse.nCols = 0;    /*  Ignore all column references  */
+      nCol = lParse.nCols;
+      lParse.nCols = 0;    /*  Ignore all column references  */
    } else
       constant = 0;
 
    if( Info.datatype!=TLOGICAL || nelem!=1 ) {
-      ffcprs();
+      ffcprs(&lParse);
       ffpmsg("Expression does not evaluate to a logical scalar.");
       return( *status = PARSE_BAD_TYPE );
    }
 
    /*******************************************/
    /* Allocate data arrays for each parameter */
    /*******************************************/
    
-   parNo = gParse.nCols;
+   parNo = lParse.nCols;
    while( parNo-- ) {
-      switch( gParse.colData[parNo].datatype ) {
+      switch( lParse.colData[parNo].datatype ) {
       case TLONG:
-         if( (gParse.colData[parNo].array =
+         if( (lParse.colData[parNo].array =
               (long *)malloc( (ntimes+1)*sizeof(long) )) )
-            ((long*)gParse.colData[parNo].array)[0] = 1234554321;
+            ((long*)lParse.colData[parNo].array)[0] = 1234554321;
          else
             *status = MEMORY_ALLOCATION;
          break;
       case TDOUBLE:
-         if( (gParse.colData[parNo].array =
+         if( (lParse.colData[parNo].array =
               (double *)malloc( (ntimes+1)*sizeof(double) )) )
-            ((double*)gParse.colData[parNo].array)[0] = DOUBLENULLVALUE;
+            ((double*)lParse.colData[parNo].array)[0] = DOUBLENULLVALUE;
          else
             *status = MEMORY_ALLOCATION;
          break;
       case TSTRING:
-         if( !fits_get_coltype( fptr, gParse.valCol, &typecode,
+         if( !fits_get_coltype( fptr, lParse.valCol, &typecode,
                                 &alen, &width, status ) ) {
             alen++;
-            if( (gParse.colData[parNo].array =
+            if( (lParse.colData[parNo].array =
                  (char **)malloc( (ntimes+1)*sizeof(char*) )) ) {
-               if( (((char **)gParse.colData[parNo].array)[0] =
+               if( (((char **)lParse.colData[parNo].array)[0] =
                     (char *)malloc( (ntimes+1)*sizeof(char)*alen )) ) {
                   for( elem=1; elem<=ntimes; elem++ )
-                     ((char **)gParse.colData[parNo].array)[elem] =
-                        ((char **)gParse.colData[parNo].array)[elem-1]+alen;
-                  ((char **)gParse.colData[parNo].array)[0][0] = '\0';
+                     ((char **)lParse.colData[parNo].array)[elem] =
+                        ((char **)lParse.colData[parNo].array)[elem-1]+alen;
+                  ((char **)lParse.colData[parNo].array)[0][0] = '\0';
                } else {
-                  free( gParse.colData[parNo].array );
+                  free( lParse.colData[parNo].array );
                   *status = MEMORY_ALLOCATION;
                }
             } else {
                *status = MEMORY_ALLOCATION;
             }
          }
          break;
       }
       if( *status ) {
          while( parNo-- ) {
-            if( gParse.colData[parNo].datatype==TSTRING )
-               FREE( ((char **)gParse.colData[parNo].array)[0] );
-            FREE( gParse.colData[parNo].array );
+            if( lParse.colData[parNo].datatype==TSTRING )
+               FREE( ((char **)lParse.colData[parNo].array)[0] );
+            FREE( lParse.colData[parNo].array );
          }
          return( *status );
       }
    }
    
    /**********************************************************************/
    /* Read data from columns needed for the expression and then parse it */
    /**********************************************************************/
    
-   if( !uncompress_hkdata( fptr, ntimes, times, status ) ) {
+   if( !fits_uncompress_hkdata( &lParse, fptr, ntimes, times, status ) ) {
       if( constant ) {
-         result = gParse.Nodes[gParse.resultNode].value.data.log;
+         result = lParse.Nodes[lParse.resultNode].value.data.log;
          elem = ntimes;
          while( elem-- ) time_status[elem] = result;
       } else {
          Info.dataPtr  = time_status;
          Info.nullPtr  = NULL;
          Info.maxRows  = ntimes;
-         *status       = parse_data( ntimes, 0, 1, ntimes, gParse.nCols,
-                                     gParse.colData, (void*)&Info );
+         *status       = fits_parser_workfn( ntimes, 0, 1, ntimes, lParse.nCols,
+                                     lParse.colData, (void*)&Info );
       }
    }
    
    /************/
    /* Clean up */
    /************/
    
-   parNo = gParse.nCols;
+   parNo = lParse.nCols;
    while ( parNo-- ) {
-      if( gParse.colData[parNo].datatype==TSTRING )
-         FREE( ((char **)gParse.colData[parNo].array)[0] );
-      FREE( gParse.colData[parNo].array );
+      if( lParse.colData[parNo].datatype==TSTRING )
+         FREE( ((char **)lParse.colData[parNo].array)[0] );
+      FREE( lParse.colData[parNo].array );
    }
    
-   if( constant ) gParse.nCols = nCol;
+   if( constant ) lParse.nCols = nCol;
 
-   ffcprs();
+   ffcprs(&lParse);
    return(*status);
 }
 
 /*---------------------------------------------------------------------------*/
-int uncompress_hkdata( fitsfile *fptr,
+int fits_parser_set_temporary_col(ParseData *lParse,
+				  parseInfo *Info,
+				  long int nrows,
+				  void *nulval,
+				  int *status)
+{
+  int col_cnt;
+  /* Setup iterator column and parser information to be ready to compute 
+     temporary calculator expression */
+
+  if (*status) return *status;
+
+  col_cnt = lParse->nCols;
+
+  if( fits_parser_allocateCol( lParse, col_cnt, status ) ) return *status;
+	
+  /* Set important variables for TemporaryCol where calculated results end up */
+  fits_iter_set_by_num( &(lParse->colData[col_cnt]), 0, 0, TDOUBLE, TemporaryCol);
+  lParse->colData[col_cnt].repeat = lParse->nElements;
+  Info->dataPtr = NULL;
+  Info->nullPtr = nulval;
+  Info->maxRows = nrows;
+  Info->parseData = lParse;
+  lParse->nCols ++;
+
+  return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+int fits_uncompress_hkdata( ParseData *lParse,
+		       fitsfile *fptr,
                        long     ntimes,
                        double   *times,
                        int      *status )
 /*                                                                           */
 /* description                                                               */
 /*---------------------------------------------------------------------------*/
 {
@@ -1993,150 +2087,155 @@
    long naxis2, row, currelem;
    double currtime, newtime;
 
    sPtr[0] = parName;
    currelem = 0;
    currtime = -1e38;
 
-   parNo=gParse.nCols;
+   parNo=lParse->nCols;
    while( parNo-- ) found[parNo] = 0;
 
    if( ffgkyj( fptr, "NAXIS2", &naxis2, NULL, status ) ) return( *status );
 
    for( row=1; row<=naxis2; row++ ) {
-      if( ffgcvd( fptr, gParse.timeCol, row, 1L, 1L, 0.0,
+      if( ffgcvd( fptr, lParse->timeCol, row, 1L, 1L, 0.0,
                   &newtime, &anynul, status ) ) return( *status );
       if( newtime != currtime ) {
          /*  New time encountered... propogate parameters to next row  */
          if( currelem==ntimes ) {
             ffpmsg("Found more unique time stamps than caller indicated");
             return( *status = PARSE_BAD_COL );
          }
          times[currelem++] = currtime = newtime;
-         parNo = gParse.nCols;
+         parNo = lParse->nCols;
          while( parNo-- ) {
-            switch( gParse.colData[parNo].datatype ) {
+            switch( lParse->colData[parNo].datatype ) {
             case TLONG:
-               ((long*)gParse.colData[parNo].array)[currelem] =
-                  ((long*)gParse.colData[parNo].array)[currelem-1];
+               ((long*)lParse->colData[parNo].array)[currelem] =
+                  ((long*)lParse->colData[parNo].array)[currelem-1];
                break;
             case TDOUBLE:
-               ((double*)gParse.colData[parNo].array)[currelem] =
-                  ((double*)gParse.colData[parNo].array)[currelem-1];
+               ((double*)lParse->colData[parNo].array)[currelem] =
+                  ((double*)lParse->colData[parNo].array)[currelem-1];
                break;
             case TSTRING:
-               strcpy( ((char **)gParse.colData[parNo].array)[currelem],
-                       ((char **)gParse.colData[parNo].array)[currelem-1] );
+               strcpy( ((char **)lParse->colData[parNo].array)[currelem],
+                       ((char **)lParse->colData[parNo].array)[currelem-1] );
                break;
             }
          }
       }
 
-      if( ffgcvs( fptr, gParse.parCol, row, 1L, 1L, "",
+      if( ffgcvs( fptr, lParse->parCol, row, 1L, 1L, "",
                   sPtr, &anynul, status ) ) return( *status );
-      parNo = gParse.nCols;
+      parNo = lParse->nCols;
       while( parNo-- )
-         if( !fits_strcasecmp( parName, gParse.varData[parNo].name ) ) break;
+         if( !fits_strcasecmp( parName, lParse->varData[parNo].name ) ) break;
 
       if( parNo>=0 ) {
          found[parNo] = 1; /* Flag this parameter as found */
-         switch( gParse.colData[parNo].datatype ) {
+         switch( lParse->colData[parNo].datatype ) {
          case TLONG:
-            ffgcvj( fptr, gParse.valCol, row, 1L, 1L,
-                    ((long*)gParse.colData[parNo].array)[0],
-                    ((long*)gParse.colData[parNo].array)+currelem,
+            ffgcvj( fptr, lParse->valCol, row, 1L, 1L,
+                    ((long*)lParse->colData[parNo].array)[0],
+                    ((long*)lParse->colData[parNo].array)+currelem,
                     &anynul, status );
             break;
          case TDOUBLE:
-            ffgcvd( fptr, gParse.valCol, row, 1L, 1L,
-                    ((double*)gParse.colData[parNo].array)[0],
-                    ((double*)gParse.colData[parNo].array)+currelem,
+            ffgcvd( fptr, lParse->valCol, row, 1L, 1L,
+                    ((double*)lParse->colData[parNo].array)[0],
+                    ((double*)lParse->colData[parNo].array)+currelem,
                     &anynul, status );
             break;
          case TSTRING:
-            ffgcvs( fptr, gParse.valCol, row, 1L, 1L,
-                    ((char**)gParse.colData[parNo].array)[0],
-                    ((char**)gParse.colData[parNo].array)+currelem,
+            ffgcvs( fptr, lParse->valCol, row, 1L, 1L,
+                    ((char**)lParse->colData[parNo].array)[0],
+                    ((char**)lParse->colData[parNo].array)+currelem,
                     &anynul, status );
             break;
          }
          if( *status ) return( *status );
       }
    }
 
    if( currelem<ntimes ) {
       ffpmsg("Found fewer unique time stamps than caller indicated");
       return( *status = PARSE_BAD_COL );
    }
 
    /*  Check for any parameters which were not located in the table  */
-   parNo = gParse.nCols;
+   parNo = lParse->nCols;
    while( parNo-- )
       if( !found[parNo] ) {
          snprintf( parName, 256, "Parameter not found: %-30s", 
-                  gParse.varData[parNo].name );
+                  lParse->varData[parNo].name );
          ffpmsg( parName );
          *status = PARSE_SYNTAX_ERR;
       }
    return( *status );
 }
 
+typedef struct {
+  long *prownum;
+  ParseData *lParse;
+} ffffrw_workdata;
+
 /*---------------------------------------------------------------------------*/
 int ffffrw( fitsfile *fptr,         /* I - Input FITS file                   */
             char     *expr,         /* I - Boolean expression                */
             long     *rownum,       /* O - First row of table to eval to T   */
             int      *status )      /* O - Error status                      */
 /*                                                                           */
 /* Evaluate a boolean expression, returning the row number of the first      */
 /* row which evaluates to TRUE                                               */
 /*---------------------------------------------------------------------------*/
 {
    int naxis, constant, dtype;
    long nelem, naxes[MAXDIMS];
    char result;
+   ParseData lParse;
 
    if( *status ) return( *status );
 
-   FFLOCK;
    if( ffiprs( fptr, 0, expr, MAXDIMS, &dtype, &nelem, &naxis,
-               naxes, status ) ) {
-      ffcprs();
-      FFUNLOCK;
+               naxes, &lParse, status ) ) {
+      ffcprs(&lParse);
       return( *status );
    }
    if( nelem<0 ) {
       constant = 1;
       nelem = -nelem;
    } else
       constant = 0;
 
    if( dtype!=TLOGICAL || nelem!=1 ) {
-      ffcprs();
+      ffcprs(&lParse);
       ffpmsg("Expression does not evaluate to a logical scalar.");
-      FFUNLOCK;
       return( *status = PARSE_BAD_TYPE );
    }
 
    *rownum = 0;
    if( constant ) { /* No need to call parser... have result from ffiprs */
-      result = gParse.Nodes[gParse.resultNode].value.data.log;
+      result = lParse.Nodes[lParse.resultNode].value.data.log;
       if( result ) {
          /*  Make sure there is at least 1 row in table  */
          ffgnrw( fptr, &nelem, status );
          if( nelem )
             *rownum = 1;
       }
    } else {
-      if( ffiter( gParse.nCols, gParse.colData, 0, 0,
-                  ffffrw_work, (void*)rownum, status ) == -1 )
+      ffffrw_workdata workData;
+      workData.prownum = rownum;
+      workData.lParse = &lParse;
+      if( ffiter( lParse.nCols, lParse.colData, 0, 0,
+                  ffffrw_work, (void*)&workData, status ) == -1 )
          *status = 0;  /* -1 indicates exitted without error before end... OK */
    }
 
-   ffcprs();
-   FFUNLOCK;
+   ffcprs(&lParse);
    return(*status);
 }
 
 /*---------------------------------------------------------------------------*/
 int ffffrw_work(long        totalrows, /* I - Total rows to be processed     */
                 long        offset,    /* I - Number of rows skipped at start*/
                 long        firstrow,  /* I - First row of this iteration    */
@@ -2147,43 +2246,46 @@
 /*                                                                           */
 /* Iterator work function which calls the parser and searches for the        */
 /* first row which evaluates to TRUE.                                        */
 /*---------------------------------------------------------------------------*/
 {
     long idx;
     Node *result;
+    ffffrw_workdata *workData = userPtr;
+    ParseData *lParse = workData->lParse;
 
-    Evaluate_Parser( firstrow, nrows );
+    Evaluate_Parser( lParse, firstrow, nrows );
 
-    if( !gParse.status ) {
+    if( !lParse->status ) {
 
-       result = gParse.Nodes + gParse.resultNode;
+       result = lParse->Nodes + lParse->resultNode;
        if( result->operation==CONST_OP ) {
 
           if( result->value.data.log ) {
-             *(long*)userPtr = firstrow;
+	     *(workData->prownum) = firstrow;
              return( -1 );
           }
 
        } else {
 
           for( idx=0; idx<nrows; idx++ )
              if( result->value.data.logptr[idx] && !result->value.undef[idx] ) {
-                *(long*)userPtr = firstrow + idx;
+	        *(workData->prownum) = firstrow + idx;;
                 return( -1 );
              }
        }
     }
 
-    return( gParse.status );
+    return( lParse->status );
 }
 
 
-static int set_image_col_types (fitsfile * fptr, const char * name, int bitpix,
-                DataInfo * varInfo, iteratorCol *colIter) {
+static int set_image_col_types (ParseData *lParse,
+				fitsfile * fptr, const char * name, int bitpix,
+				DataInfo * varInfo, iteratorCol *colIter) {
 
    int istatus;
    double tscale, tzero;
    char temp[80];
 
    switch (bitpix) {
       case BYTE_IMG:
@@ -2216,123 +2318,123 @@
          varInfo->type     = DOUBLE;
          colIter->datatype = TDOUBLE;
          break;
       default:
          snprintf(temp, 80,"set_image_col_types: unrecognized image bitpix [%d]\n",
                 bitpix);
          ffpmsg(temp);
-         return gParse.status = PARSE_BAD_TYPE;
+         return lParse->status = PARSE_BAD_TYPE;
    }
    return 0;
 }
 
 
 /*************************************************************************
 
         Functions used by the evaluator to access FITS data
-            (find_column, find_keywd, allocateCol, load_column)
+            (find_column, find_keywd, fits_parser_allocateCol, load_column)
 
  *************************************************************************/
 
-static int find_column( char *colName, void *itslval )
+static int find_column( ParseData *lParse, char *colName, void *itslval )
 {
-   FFSTYPE *thelval = (FFSTYPE*)itslval;
+   FITS_PARSER_YYSTYPE *thelval = (FITS_PARSER_YYSTYPE*)itslval;
    int col_cnt, status;
    int colnum, typecode, type;
    long repeat, width;
    fitsfile *fptr;
    char temp[80];
    double tzero,tscale;
    int istatus;
    DataInfo *varInfo;
    iteratorCol *colIter;
 
 if (DEBUG_PIXFILTER)
    printf("find_column(%s)\n", colName);
 
    if( *colName == '#' )
-      return( find_keywd( colName + 1, itslval ) );
+     return( find_keywd( lParse, colName + 1, itslval ) );
 
-   fptr = gParse.def_fptr;
+   fptr = lParse->def_fptr;
 
    status = 0;
-   col_cnt = gParse.nCols;
+   col_cnt = lParse->nCols;
 
-if (gParse.hdutype == IMAGE_HDU) {
+if (lParse->hdutype == IMAGE_HDU) {
    int i;
-   if (!gParse.pixFilter) {
-      gParse.status = COL_NOT_FOUND;
+   if (!lParse->pixFilter) {
+      lParse->status = COL_NOT_FOUND;
       ffpmsg("find_column: IMAGE_HDU but no PixelFilter");
       return pERROR;
    }
 
    colnum = -1;
-   for (i = 0; i < gParse.pixFilter->count; ++i) {
-      if (!fits_strcasecmp(colName, gParse.pixFilter->tag[i]))
+   for (i = 0; i < lParse->pixFilter->count; ++i) {
+      if (!fits_strcasecmp(colName, lParse->pixFilter->tag[i]))
          colnum = i;
    }
    if (colnum < 0) {
       snprintf(temp, 80, "find_column: PixelFilter tag %s not found", colName);
       ffpmsg(temp);
-      gParse.status = COL_NOT_FOUND;
+      lParse->status = COL_NOT_FOUND;
       return pERROR;
    }
 
-   if( allocateCol( col_cnt, &gParse.status ) ) return pERROR;
+   if( fits_parser_allocateCol( lParse, col_cnt, &lParse->status ) ) return pERROR;
 
-   varInfo = gParse.varData + col_cnt;
-   colIter = gParse.colData + col_cnt;
+   varInfo = lParse->varData + col_cnt;
+   colIter = lParse->colData + col_cnt;
 
-   fptr = gParse.pixFilter->ifptr[colnum];
+   fptr = lParse->pixFilter->ifptr[colnum];
    fits_get_img_param(fptr,
                 MAXDIMS,
                 &typecode, /* actually bitpix */
                 &varInfo->naxis,
                 &varInfo->naxes[0],
                 &status);
    varInfo->nelem = 1;
    type = COLUMN;
-   if (set_image_col_types(fptr, colName, typecode, varInfo, colIter))
+   if (set_image_col_types(lParse, fptr, colName, typecode, varInfo, colIter))
       return pERROR;
    colIter->fptr = fptr;
    colIter->iotype = InputCol;
 }
 else { /* HDU holds a table */
-   if( gParse.compressed )
-      colnum = gParse.valCol;
+   if( lParse->compressed )
+      colnum = lParse->valCol;
    else
       if( fits_get_colnum( fptr, CASEINSEN, colName, &colnum, &status ) ) {
          if( status == COL_NOT_FOUND ) {
-            type = find_keywd( colName, itslval );
+	   type = find_keywd( lParse, colName, itslval );
             if( type != pERROR ) ffcmsg();
             return( type );
          }
-         gParse.status = status;
+         lParse->status = status;
          return pERROR;
       }
    
    if( fits_get_coltype( fptr, colnum, &typecode,
                          &repeat, &width, &status ) ) {
-      gParse.status = status;
+      lParse->status = status;
       return pERROR;
    }
 
-   if( allocateCol( col_cnt, &gParse.status ) ) return pERROR;
+   if( fits_parser_allocateCol( lParse, col_cnt, &lParse->status ) ) return pERROR;
 
-   varInfo = gParse.varData + col_cnt;
-   colIter = gParse.colData + col_cnt;
+   varInfo = lParse->varData + col_cnt;
+   colIter = lParse->colData + col_cnt;
 
    fits_iter_set_by_num( colIter, fptr, colnum, 0, InputCol );
 }
 
    /*  Make sure we don't overflow variable name array  */
    strncpy(varInfo->name,colName,MAXVARNAME);
    varInfo->name[MAXVARNAME] = '\0';
 
-if (gParse.hdutype != IMAGE_HDU) {
+if (lParse->hdutype != IMAGE_HDU) {
    switch( typecode ) {
    case TBIT:
       varInfo->type     = BITSTR;
       colIter->datatype = TBYTE;
       type = BITCOL;
       break;
    case TBYTE:
@@ -2389,74 +2491,76 @@
       varInfo->type     = STRING;
       colIter->datatype = TSTRING;
       type = SCOLUMN;
       if ( width >= MAX_STRLEN ) {
 	snprintf(temp, 80, "column %d is wider than maximum %d characters",
 		colnum, MAX_STRLEN-1);
         ffpmsg(temp);
-	gParse.status = PARSE_LRG_VECTOR;
+	lParse->status = PARSE_LRG_VECTOR;
 	return pERROR;
       }
-      if( gParse.hdutype == ASCII_TBL ) repeat = width;
+      if( lParse->hdutype == ASCII_TBL ) repeat = width;
       break;
    default:
       if (typecode < 0) {
         snprintf(temp, 80,"variable-length array columns are not supported. typecode = %d", typecode);
         ffpmsg(temp);
       }
-      gParse.status = PARSE_BAD_TYPE;
+      lParse->status = PARSE_BAD_TYPE;
       return pERROR;
    }
    varInfo->nelem = repeat;
+   colIter->repeat = 0; /* ffiter() will fill in this value */
    if( repeat>1 && typecode!=TSTRING ) {
       if( fits_read_tdim( fptr, colnum, MAXDIMS,
                           &varInfo->naxis,
                           &varInfo->naxes[0], &status )
           ) {
-         gParse.status = status;
+         lParse->status = status;
          return pERROR;
       }
    } else {
       varInfo->naxis = 1;
       varInfo->naxes[0] = 1;
    }
 }
-   gParse.nCols++;
+   lParse->nCols++;
    thelval->lng = col_cnt;
 
    return( type );
 }
 
-static int find_keywd(char *keyname, void *itslval )
+static int find_keywd(ParseData *lParse, char *keyname, void *itslval )
 {
-   FFSTYPE *thelval = (FFSTYPE*)itslval;
+   FITS_PARSER_YYSTYPE *thelval = (FITS_PARSER_YYSTYPE*)itslval;
    int status, type;
    char keyvalue[FLEN_VALUE], dtype;
    fitsfile *fptr;
    double rval;
    int bval;
    long ival;
 
    status = 0;
-   fptr = gParse.def_fptr;
+   fptr = lParse->def_fptr;
    if( fits_read_keyword( fptr, keyname, keyvalue, NULL, &status ) ) {
       if( status == KEY_NO_EXIST ) {
          /*  Do this since ffgkey doesn't put an error message on stack  */
          snprintf(keyvalue,FLEN_VALUE, "ffgkey could not find keyword: %s",keyname);
          ffpmsg(keyvalue);
       }
-      gParse.status = status;
+      lParse->status = status;
       return( pERROR );
    }
       
    if( fits_get_keytype( keyvalue, &dtype, &status ) ) {
-      gParse.status = status;
+      lParse->status = status;
       return( pERROR );
    }
-      
+
+   /* Read appropriate value type and set to CONST_OP */
    switch( dtype ) {
    case 'C':
       fits_read_key_str( fptr, keyname, keyvalue, NULL, &status );
       type = STRING;
       strcpy( thelval->str , keyvalue );
       break;
    case 'L':
@@ -2476,57 +2580,61 @@
       break;
    default:
       type = pERROR;
       break;
    }
 
    if( status ) {
-      gParse.status=status;
+      lParse->status=status;
       return pERROR;
    }
 
    return( type );
 }
 
-static int allocateCol( int nCol, int *status )
+/* Allocates parser iterator column storage for 25 columns *more* than
+   nCols */
+int fits_parser_allocateCol( ParseData *lParse, int nCol, int *status )
 {
    if( (nCol%25)==0 ) {
-      if( nCol ) {
-         gParse.colData  = (iteratorCol*) realloc( gParse.colData,
-                                              (nCol+25)*sizeof(iteratorCol) );
-         gParse.varData  = (DataInfo   *) realloc( gParse.varData,
-                                              (nCol+25)*sizeof(DataInfo)    );
-      } else {
-         gParse.colData  = (iteratorCol*) malloc( 25*sizeof(iteratorCol) );
-         gParse.varData  = (DataInfo   *) malloc( 25*sizeof(DataInfo)    );
-      }
-      if(    gParse.colData  == NULL
-          || gParse.varData  == NULL    ) {
-         if( gParse.colData  ) free(gParse.colData);
-         if( gParse.varData  ) free(gParse.varData);
-         gParse.colData = NULL;
-         gParse.varData = NULL;
+     lParse->colData = (iteratorCol*) fits_recalloc( lParse->colData,
+						     nCol, nCol+25,
+						     sizeof(iteratorCol) );
+     lParse->varData = (DataInfo   *) fits_recalloc( lParse->varData,
+						     nCol, nCol+25,
+						     sizeof(DataInfo) );
+
+     memset( (lParse->colData + nCol), 0x00, sizeof(iteratorCol)*25 );
+     memset( (lParse->varData + nCol), 0x00, sizeof(DataInfo)*25    );
+
+     if(    lParse->colData  == NULL
+	    || lParse->varData  == NULL    ) {
+         if( lParse->colData  ) free(lParse->colData);
+         if( lParse->varData  ) free(lParse->varData);
+         lParse->colData = NULL;
+         lParse->varData = NULL;
          return( *status = MEMORY_ALLOCATION );
-      }
+     }
    }
-   gParse.varData[nCol].data  = NULL;
-   gParse.varData[nCol].undef = NULL;
+   lParse->varData[nCol].data  = NULL;
+   lParse->varData[nCol].undef = NULL;
    return 0;
 }
 
-static int load_column( int varNum, long fRow, long nRows,
+static int load_column( ParseData *lParse, int varNum, long fRow, long nRows,
                         void *data, char *undef )
 {
-   iteratorCol *var = gParse.colData+varNum;
+   iteratorCol *var;
    long nelem,nbytes,row,len,idx;
    char **bitStrs, msg[80];
    unsigned char *bytes;
    int status = 0, anynul;
 
-  if (gParse.hdutype == IMAGE_HDU) {
+   var = lParse->colData+varNum;
+   if (lParse->hdutype == IMAGE_HDU) {
     /* This test would need to be on a per varNum basis to support
      * cross HDU operations */
     fits_read_imgnull(var->fptr, var->datatype, fRow, nRows,
                 data, undef, &anynul, &status);
     if (DEBUG_PIXFILTER)
         printf("load_column: IMAGE_HDU fRow=%ld, nRows=%ld => %d\n",
                         fRow, nRows, status);
@@ -2576,15 +2684,15 @@
       break;
    default:
       snprintf(msg,80,"load_column: unexpected datatype %d", var->datatype);
       ffpmsg(msg);
    }
   }
    if( status ) {
-      gParse.status = status;
+      lParse->status = status;
       return pERROR;
    }
 
    return 0;
 }
 
 
@@ -2600,36 +2708,39 @@
    Node *result;
    int datatype;
    fitsfile * infptr;
    fitsfile * outfptr;
    char * DEFAULT_TAGS[] = { "X" };
    char msg[256];
    int writeBlankKwd = 0;   /* write BLANK if any output nulls? */
+   ParseData lParse;
 
    DEBUG_PIXFILTER = getenv("DEBUG_PIXFILTER") ? 1 : 0;
 
+   memset(&Info, 0, sizeof(Info));   
+
    if (*status)
       return (*status);
 
-   FFLOCK;
    if (!filter->tag || !filter->tag[0] || !filter->tag[0][0]) {
       filter->tag = DEFAULT_TAGS;
       if (DEBUG_PIXFILTER)
          printf("using default tag '%s'\n", filter->tag[0]);
    }
 
    infptr = filter->ifptr[0];
    outfptr = filter->ofptr;
-   gParse.pixFilter = filter;
+   lParse.pixFilter = filter;
 
    if (ffiprs(infptr, 0, filter->expression, MAXDIMS,
-            &Info.datatype, &nelem, &naxis, naxes, status)) {
+	      &Info.datatype, &nelem, &naxis, naxes, &lParse, status)) {
       goto CLEANUP;
    }
 
+
    if (nelem < 0) {
       nelem = -nelem;
    }
 
    {
       /* validate result type */
       const char * type = 0;
@@ -2744,16 +2855,20 @@
 
             writeBlankKwd = 1;
 
             if (bitpix == BYTE_IMG)
                 nullVal = UCHAR_MAX;
             else if (bitpix == SHORT_IMG)
                 nullVal = SHRT_MIN;
-            else if (bitpix == LONG_IMG)
-                nullVal = LONG_MIN;
+            else if (bitpix == LONG_IMG) {
+               if (sizeof(long) == 8 && sizeof(int) == 4)
+                  nullVal = INT_MIN;
+               else
+                  nullVal = LONG_MIN;
+            }
             else
                 printf("unhandled positive output BITPIX %d\n", bitpix);
          }
 
          filter->blank = nullVal;
       }
 
@@ -2766,29 +2881,30 @@
    if (!filter->keyword[0]) {
       iteratorCol * colIter;
       DataInfo * varInfo;
 
       /*************************************/
       /* Create new iterator Output Column */
       /*************************************/
-      col_cnt = gParse.nCols;
-      if (allocateCol(col_cnt, status))
+      col_cnt = lParse.nCols;
+      if (fits_parser_allocateCol(&lParse, col_cnt, status))
          goto CLEANUP;
-      gParse.nCols++;
+      lParse.nCols++;
 
-      colIter = &gParse.colData[col_cnt];
+      colIter = &lParse.colData[col_cnt];
       colIter->fptr = filter->ofptr;
       colIter->iotype = OutputCol;
-      varInfo = &gParse.varData[col_cnt];
-      set_image_col_types(colIter->fptr, "CREATED", bitpix, varInfo, colIter);
+      varInfo = &lParse.varData[col_cnt];
+      set_image_col_types(&lParse, colIter->fptr, "CREATED", bitpix, varInfo, colIter);
 
       Info.maxRows = -1;
+      Info.parseData = &lParse;
 
-      if (ffiter(gParse.nCols, gParse.colData, 0,
-                     0, parse_data, &Info, status) == -1)
+      if (ffiter(lParse.nCols, lParse.colData, 0,
+                     0, fits_parser_workfn, &Info, status) == -1)
             *status = 0;
       else if (*status)
          goto CLEANUP;
 
       if (Info.anyNull) {
          if (writeBlankKwd) {
             fits_update_key_lng(outfptr, "BLANK", filter->blank, "NULL pixel value", status);
@@ -2806,15 +2922,15 @@
    }
    else {
 
       /* Put constant result into keyword */
       char * parName = filter->keyword;
       char * parInfo = filter->comment;
 
-      result  = gParse.Nodes + gParse.resultNode;
+      result  = lParse.Nodes + lParse.resultNode;
       switch (Info.datatype) {
       case TDOUBLE:
          ffukyd(outfptr, parName, result->value.data.dbl, 15, parInfo, status);
          break;
       case TLONG:
          ffukyj(outfptr, parName, result->value.data.lng, parInfo, status);
          break;
@@ -2829,11 +2945,10 @@
          snprintf(msg, 256,"pixel_filter: unexpected constant result type [%d]\n",
                 Info.datatype);
          ffpmsg(msg);
       }
    }
 
 CLEANUP:
-   ffcprs();
-   FFUNLOCK;
+   ffcprs(&lParse);
    return (*status);
 }
```

### Comparing `fitsio-1.1.9/cfitsio3490/eval_y.c` & `fitsio-1.2.0/cfitsio-4.2.0/eval_y.c`

 * *Files 9% similar despite different names*

```diff
@@ -1,25 +1,26 @@
-/* A Bison parser, made by GNU Bison 3.0.5.  */
+/* A Bison parser, made by GNU Bison 3.8.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
-   Copyright (C) 1984, 1989-1990, 2000-2015, 2018 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
 
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
 
    You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
 
 /* As a special exception, you may create a larger work that contains
    part or all of the Bison parser skeleton and distribute that work
    under terms of your choice, so long as that work isn't itself a
    parser generator using the skeleton or a modified version thereof
    as a parser skeleton.  Alternatively, if you modify or redistribute
    the parser skeleton itself, you may (at your option) remove this
@@ -29,49 +30,55 @@
 
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
 /* C LALR(1) parser skeleton written by Richard Stallman, by
    simplifying the original so-called "semantic" parser.  */
 
-/* All symbols defined below should begin with ff or FF, to avoid
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
    variables, as they might otherwise be expanded by user macros.
    There are some unavoidable exceptions within include files to
    define necessary library symbols; they are noted "INFRINGES ON
    USER NAME SPACE" below.  */
 
-/* Identify Bison output.  */
-#define FFBISON 1
+/* Identify Bison output, and Bison version.  */
+#define YYBISON 30800
 
-/* Bison version.  */
-#define FFBISON_VERSION "3.0.5"
+/* Bison version string.  */
+#define YYBISON_VERSION "3.8"
 
 /* Skeleton name.  */
-#define FFSKELETON_NAME "yacc.c"
+#define YYSKELETON_NAME "yacc.c"
 
 /* Pure parsers.  */
-#define FFPURE 0
+#define YYPURE 2
 
 /* Push parsers.  */
-#define FFPUSH 0
+#define YYPUSH 0
 
 /* Pull parsers.  */
-#define FFPULL 1
-
+#define YYPULL 1
 
+/* Substitute the type names.  */
+#define YYSTYPE         FITS_PARSER_YYSTYPE
+/* Substitute the variable and function names.  */
+#define yyparse         fits_parser_yyparse
+#define yylex           fits_parser_yylex
+#define yyerror         fits_parser_yyerror
+#define yydebug         fits_parser_yydebug
+#define yynerrs         fits_parser_yynerrs
 
+/* First part of user prologue.  */
+#line 16 "eval.y"
 
-/* Copy the first part of user declarations.  */
-#line 1 "eval.y" /* yacc.c:339  */
-
-/************************************************************************/
-/*                                                                      */
-/*                       CFITSIO Lexical Parser                         */
-/*                                                                      */
 /* This file is one of 3 files containing code which parses an          */
 /* arithmetic expression and evaluates it in the context of an input    */
 /* FITS file table extension.  The CFITSIO lexical parser is divided    */
 /* into the following 3 parts/files: the CFITSIO "front-end",           */
 /* eval_f.c, contains the interface between the user/CFITSIO and the    */
 /* real core of the parser; the FLEX interpreter, eval_l.c, takes the   */
 /* input string and parses it into tokens and identifies the FITS       */
@@ -124,14 +131,17 @@
 /*  Craig B Markwardt Aug 2005  CIRCLE, BOX, ELLIPSE, NEAR and REGFILTER*/
 /*                              functions now accept vector arguments   */
 /*  Craig B Markwardt Sum 2006  Add RANDOMN() and RANDOMP() functions   */
 /*  Craig B Markwardt Mar 2007  Allow arguments to RANDOM and RANDOMN to*/
 /*                              determine the output dimensions         */
 /*  Craig B Markwardt Aug 2009  Add substring STRMID() and string search*/
 /*                              STRSTR() functions; more overflow checks*/
+/*  Craig B Markwardt Dec 2019  Add bit/hex/oct literal strings and     */
+/*                              bitwise operatiosn between integers     */
+/*  Craig B Markwardt Mar 2021  Add SETNULL() function                  */
 /*                                                                      */
 /************************************************************************/
 
 #define  APPROX 1.0e-7
 #include "eval_defs.h"
 #include "region.h"
 #include <time.h>
@@ -143,3581 +153,3592 @@
 #endif
 
 /* Random number generators for various distributions */
 #include "simplerng.h"
 
    /*  Shrink the initial stack depth to keep local data <32K (mac limit)  */
    /*  yacc will allocate more space if needed, though.                    */
-#define  FFINITDEPTH   100
+#define  YYINITDEPTH   100
 
 /***************************************************************/
 /*  Replace Bison's BACKUP macro with one that fixes a bug --  */
 /*  must update state after popping the stack -- and allows    */
 /*  popping multiple terms at one time.                        */
 /***************************************************************/
 
-#define FFNEWBACKUP(token, value)                               \
+#define YYNEWBACKUP(token, value)                               \
    do								\
-     if (ffchar == FFEMPTY )   					\
-       { ffchar = (token);                                      \
-         memcpy( &fflval, &(value), sizeof(value) );            \
-         ffchar1 = FFTRANSLATE (ffchar);			\
-         while (fflen--) FFPOPSTACK;				\
-         ffstate = *ffssp;					\
-         goto ffbackup;						\
+     if (yychar == YYEMPTY )   					\
+       { yychar = (token);                                      \
+         memcpy( &yylval, &(value), sizeof(value) );            \
+         yychar1 = YYTRANSLATE (yychar);			\
+         while (yylen--) YYPOPSTACK;				\
+         yystate = *yyssp;					\
+         goto yybackup;						\
        }							\
      else							\
-       { fferror ("syntax error: cannot back up"); FFERROR; }	\
+       { yyerror ("syntax error: cannot back up"); YYERROR; }	\
    while (0)
 
 /***************************************************************/
 /*  Useful macros for accessing/testing Nodes                  */
 /***************************************************************/
 
-#define TEST(a)        if( (a)<0 ) FFERROR
-#define SIZE(a)        gParse.Nodes[ a ].value.nelem
-#define TYPE(a)        gParse.Nodes[ a ].type
-#define OPER(a)        gParse.Nodes[ a ].operation
+#define TEST(a)        if( (a)<0 ) YYERROR
+#define SIZE(a)        lParse->Nodes[ a ].value.nelem
+#define TYPE(a)        lParse->Nodes[ a ].type
+#define OPER(a)        lParse->Nodes[ a ].operation
 #define PROMOTE(a,b)   if( TYPE(a) > TYPE(b) )                  \
-                          b = New_Unary( TYPE(a), 0, b );       \
+                          b = New_Unary( lParse, TYPE(a), 0, b );       \
                        else if( TYPE(a) < TYPE(b) )             \
-	                  a = New_Unary( TYPE(b), 0, a );
+	                  a = New_Unary( lParse, TYPE(b), 0, a );
 
 /*****  Internal functions  *****/
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-static int  Alloc_Node    ( void );
-static void Free_Last_Node( void );
-static void Evaluate_Node ( int thisNode );
-
-static int  New_Const ( int returnType, void *value, long len );
-static int  New_Column( int ColNum );
-static int  New_Offset( int ColNum, int offset );
-static int  New_Unary ( int returnType, int Op, int Node1 );
-static int  New_BinOp ( int returnType, int Node1, int Op, int Node2 );
-static int  New_Func  ( int returnType, funcOp Op, int nNodes,
+static int  Alloc_Node    ( ParseData * );
+static void Free_Last_Node( ParseData * );
+static void Evaluate_Node ( ParseData *, int thisNode );
+
+static int  New_Const ( ParseData *, int returnType, void *value, long len );
+static int  New_Column( ParseData *, int ColNum );
+static int  New_Offset( ParseData *, int ColNum, int offset );
+static int  New_Unary ( ParseData *, int returnType, int Op, int Node1 );
+static int  New_BinOp ( ParseData *, int returnType, int Node1, int Op, int Node2 );
+static int  New_Func  ( ParseData *, int returnType, funcOp Op, int nNodes,
 			int Node1, int Node2, int Node3, int Node4, 
 			int Node5, int Node6, int Node7 );
-static int  New_FuncSize( int returnType, funcOp Op, int nNodes,
+static int  New_FuncSize( ParseData *, int returnType, funcOp Op, int nNodes,
 			int Node1, int Node2, int Node3, int Node4, 
 			  int Node5, int Node6, int Node7, int Size);
-static int  New_Deref ( int Var,  int nDim,
+static int  New_Deref ( ParseData *, int Var,  int nDim,
 			int Dim1, int Dim2, int Dim3, int Dim4, int Dim5 );
-static int  New_GTI   ( char *fname, int Node1, char *start, char *stop );
-static int  New_REG   ( char *fname, int NodeX, int NodeY, char *colNames );
-static int  New_Vector( int subNode );
-static int  Close_Vec ( int vecNode );
-static int  Locate_Col( Node *this );
-static int  Test_Dims ( int Node1, int Node2 );
-static void Copy_Dims ( int Node1, int Node2 );
-
-static void Allocate_Ptrs( Node *this );
-static void Do_Unary     ( Node *this );
-static void Do_Offset    ( Node *this );
-static void Do_BinOp_bit ( Node *this );
-static void Do_BinOp_str ( Node *this );
-static void Do_BinOp_log ( Node *this );
-static void Do_BinOp_lng ( Node *this );
-static void Do_BinOp_dbl ( Node *this );
-static void Do_Func      ( Node *this );
-static void Do_Deref     ( Node *this );
-static void Do_GTI       ( Node *this );
-static void Do_REG       ( Node *this );
-static void Do_Vector    ( Node *this );
+static int  New_GTI   ( ParseData *, funcOp Op, char *fname, int Node1, int Node2, char *start, char *stop );
+static int  New_REG   ( ParseData *, char *fname, int NodeX, int NodeY, char *colNames );
+static int  New_Vector( ParseData *, int subNode );
+static int  Close_Vec ( ParseData *, int vecNode );
+static int  New_Array(  ParseData *, int valueNode, int dimNode );
+static int  Locate_Col( ParseData *, Node *this );
+static int  Test_Dims ( ParseData *, int Node1, int Node2 );
+static void Copy_Dims ( ParseData *, int Node1, int Node2 );
+
+static void Allocate_Ptrs( ParseData *, Node *this );
+static void Do_Unary     ( ParseData *, Node *this );
+static void Do_Offset    ( ParseData *, Node *this );
+static void Do_BinOp_bit ( ParseData *, Node *this );
+static void Do_BinOp_str ( ParseData *, Node *this );
+static void Do_BinOp_log ( ParseData *, Node *this );
+static void Do_BinOp_lng ( ParseData *, Node *this );
+static void Do_BinOp_dbl ( ParseData *, Node *this );
+static void Do_Func      ( ParseData *, Node *this );
+static void Do_Deref     ( ParseData *, Node *this );
+static void Do_GTI       ( ParseData *, Node *this );
+static void Do_GTI_Over  ( ParseData *, Node *this );
+static void Do_REG       ( ParseData *, Node *this );
+static void Do_Vector    ( ParseData *, Node *this );
+static void Do_Array     ( ParseData *, Node *this );
 
 static long Search_GTI   ( double evtTime, long nGTI, double *start,
-			   double *stop, int ordered );
+			   double *stop, int ordered, long *nextGTI );
+static double GTI_Over(double evtStart, double evtStop,
+		       long nGTI, double *start, double *stop,
+		       long *gtiout);
 
 static char  saobox (double xcen, double ycen, double xwid, double ywid,
 		     double rot,  double xcol, double ycol);
 static char  ellipse(double xcen, double ycen, double xrad, double yrad,
 		     double rot, double xcol, double ycol);
 static char  circle (double xcen, double ycen, double rad,
 		     double xcol, double ycol);
 static char  bnear  (double x, double y, double tolerance);
 static char  bitcmp (char *bitstrm1, char *bitstrm2);
 static char  bitlgte(char *bits1, int oper, char *bits2);
 
 static void  bitand(char *result, char *bitstrm1, char *bitstrm2);
 static void  bitor (char *result, char *bitstrm1, char *bitstrm2);
 static void  bitnot(char *result, char *bits);
-static int cstrmid(char *dest_str, int dest_len,
+static int cstrmid(ParseData *lParse, char *dest_str, int dest_len,
 		   char *src_str,  int src_len, int pos);
 
-static void  fferror(char *msg);
+static void yyerror(yyscan_t scanner, ParseData *lParse, char *s);
 
 #ifdef __cplusplus
     }
 #endif
 
 
-#line 257 "y.tab.c" /* yacc.c:339  */
+#line 273 "eval_y.c"
 
-# ifndef FF_NULLPTR
-#  if defined __cplusplus && 201103L <= __cplusplus
-#   define FF_NULLPTR nullptr
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
 #  else
-#   define FF_NULLPTR 0
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
+# ifndef YY_NULLPTR
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
+#  else
+#   define YY_NULLPTR ((void*)0)
 #  endif
 # endif
 
-/* Enabling verbose error messages.  */
-#ifdef FFERROR_VERBOSE
-# undef FFERROR_VERBOSE
-# define FFERROR_VERBOSE 1
-#else
-# define FFERROR_VERBOSE 0
-#endif
-
-/* In a future release of Bison, this section will be replaced
-   by #include "y.tab.h".  */
-#ifndef FF_FF_Y_TAB_H_INCLUDED
-# define FF_FF_Y_TAB_H_INCLUDED
-/* Debug traces.  */
-#ifndef FFDEBUG
-# define FFDEBUG 0
-#endif
-#if FFDEBUG
-extern int ffdebug;
-#endif
-
-/* Token type.  */
-#ifndef FFTOKENTYPE
-# define FFTOKENTYPE
-  enum fftokentype
-  {
-    BOOLEAN = 258,
-    LONG = 259,
-    DOUBLE = 260,
-    STRING = 261,
-    BITSTR = 262,
-    FUNCTION = 263,
-    BFUNCTION = 264,
-    IFUNCTION = 265,
-    GTIFILTER = 266,
-    REGFILTER = 267,
-    COLUMN = 268,
-    BCOLUMN = 269,
-    SCOLUMN = 270,
-    BITCOL = 271,
-    ROWREF = 272,
-    NULLREF = 273,
-    SNULLREF = 274,
-    OR = 275,
-    AND = 276,
-    EQ = 277,
-    NE = 278,
-    GT = 279,
-    LT = 280,
-    LTE = 281,
-    GTE = 282,
-    XOR = 283,
-    POWER = 284,
-    NOT = 285,
-    INTCAST = 286,
-    FLTCAST = 287,
-    UMINUS = 288,
-    ACCUM = 289,
-    DIFF = 290
-  };
-#endif
-/* Tokens.  */
-#define BOOLEAN 258
-#define LONG 259
-#define DOUBLE 260
-#define STRING 261
-#define BITSTR 262
-#define FUNCTION 263
-#define BFUNCTION 264
-#define IFUNCTION 265
-#define GTIFILTER 266
-#define REGFILTER 267
-#define COLUMN 268
-#define BCOLUMN 269
-#define SCOLUMN 270
-#define BITCOL 271
-#define ROWREF 272
-#define NULLREF 273
-#define SNULLREF 274
-#define OR 275
-#define AND 276
-#define EQ 277
-#define NE 278
-#define GT 279
-#define LT 280
-#define LTE 281
-#define GTE 282
-#define XOR 283
-#define POWER 284
-#define NOT 285
-#define INTCAST 286
-#define FLTCAST 287
-#define UMINUS 288
-#define ACCUM 289
-#define DIFF 290
-
-/* Value type.  */
-#if ! defined FFSTYPE && ! defined FFSTYPE_IS_DECLARED
-
-union FFSTYPE
-{
-#line 192 "eval.y" /* yacc.c:355  */
-
-    int    Node;        /* Index of Node */
-    double dbl;         /* real value    */
-    long   lng;         /* integer value */
-    char   log;         /* logical value */
-    char   str[MAX_STRLEN];    /* string value  */
-
-#line 375 "y.tab.c" /* yacc.c:355  */
+#include "eval_tab.h"
+/* Symbol kind.  */
+enum yysymbol_kind_t
+{
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_BOOLEAN = 3,                    /* BOOLEAN  */
+  YYSYMBOL_LONG = 4,                       /* LONG  */
+  YYSYMBOL_DOUBLE = 5,                     /* DOUBLE  */
+  YYSYMBOL_STRING = 6,                     /* STRING  */
+  YYSYMBOL_BITSTR = 7,                     /* BITSTR  */
+  YYSYMBOL_FUNCTION = 8,                   /* FUNCTION  */
+  YYSYMBOL_BFUNCTION = 9,                  /* BFUNCTION  */
+  YYSYMBOL_IFUNCTION = 10,                 /* IFUNCTION  */
+  YYSYMBOL_GTIFILTER = 11,                 /* GTIFILTER  */
+  YYSYMBOL_GTIOVERLAP = 12,                /* GTIOVERLAP  */
+  YYSYMBOL_GTIFIND = 13,                   /* GTIFIND  */
+  YYSYMBOL_REGFILTER = 14,                 /* REGFILTER  */
+  YYSYMBOL_COLUMN = 15,                    /* COLUMN  */
+  YYSYMBOL_BCOLUMN = 16,                   /* BCOLUMN  */
+  YYSYMBOL_SCOLUMN = 17,                   /* SCOLUMN  */
+  YYSYMBOL_BITCOL = 18,                    /* BITCOL  */
+  YYSYMBOL_ROWREF = 19,                    /* ROWREF  */
+  YYSYMBOL_NULLREF = 20,                   /* NULLREF  */
+  YYSYMBOL_SNULLREF = 21,                  /* SNULLREF  */
+  YYSYMBOL_22_ = 22,                       /* ','  */
+  YYSYMBOL_23_ = 23,                       /* '='  */
+  YYSYMBOL_24_ = 24,                       /* ':'  */
+  YYSYMBOL_25_ = 25,                       /* '{'  */
+  YYSYMBOL_26_ = 26,                       /* '}'  */
+  YYSYMBOL_27_ = 27,                       /* '?'  */
+  YYSYMBOL_OR = 28,                        /* OR  */
+  YYSYMBOL_AND = 29,                       /* AND  */
+  YYSYMBOL_EQ = 30,                        /* EQ  */
+  YYSYMBOL_NE = 31,                        /* NE  */
+  YYSYMBOL_32_ = 32,                       /* '~'  */
+  YYSYMBOL_GT = 33,                        /* GT  */
+  YYSYMBOL_LT = 34,                        /* LT  */
+  YYSYMBOL_LTE = 35,                       /* LTE  */
+  YYSYMBOL_GTE = 36,                       /* GTE  */
+  YYSYMBOL_37_ = 37,                       /* '+'  */
+  YYSYMBOL_38_ = 38,                       /* '-'  */
+  YYSYMBOL_39_ = 39,                       /* '%'  */
+  YYSYMBOL_40_ = 40,                       /* '*'  */
+  YYSYMBOL_41_ = 41,                       /* '/'  */
+  YYSYMBOL_42_ = 42,                       /* '|'  */
+  YYSYMBOL_43_ = 43,                       /* '&'  */
+  YYSYMBOL_XOR = 44,                       /* XOR  */
+  YYSYMBOL_POWER = 45,                     /* POWER  */
+  YYSYMBOL_NOT = 46,                       /* NOT  */
+  YYSYMBOL_INTCAST = 47,                   /* INTCAST  */
+  YYSYMBOL_FLTCAST = 48,                   /* FLTCAST  */
+  YYSYMBOL_UMINUS = 49,                    /* UMINUS  */
+  YYSYMBOL_50_ = 50,                       /* '['  */
+  YYSYMBOL_ACCUM = 51,                     /* ACCUM  */
+  YYSYMBOL_DIFF = 52,                      /* DIFF  */
+  YYSYMBOL_53_n_ = 53,                     /* '\n'  */
+  YYSYMBOL_54_ = 54,                       /* ']'  */
+  YYSYMBOL_55_ = 55,                       /* '('  */
+  YYSYMBOL_56_ = 56,                       /* ')'  */
+  YYSYMBOL_YYACCEPT = 57,                  /* $accept  */
+  YYSYMBOL_lines = 58,                     /* lines  */
+  YYSYMBOL_line = 59,                      /* line  */
+  YYSYMBOL_bvector = 60,                   /* bvector  */
+  YYSYMBOL_vector = 61,                    /* vector  */
+  YYSYMBOL_expr = 62,                      /* expr  */
+  YYSYMBOL_bexpr = 63,                     /* bexpr  */
+  YYSYMBOL_bits = 64,                      /* bits  */
+  YYSYMBOL_sexpr = 65                      /* sexpr  */
 };
+typedef enum yysymbol_kind_t yysymbol_kind_t;
 
-typedef union FFSTYPE FFSTYPE;
-# define FFSTYPE_IS_TRIVIAL 1
-# define FFSTYPE_IS_DECLARED 1
-#endif
 
 
-extern FFSTYPE fflval;
-
-int ffparse (void);
-
-#endif /* !FF_FF_Y_TAB_H_INCLUDED  */
-
-/* Copy the second part of user declarations.  */
-
-#line 392 "y.tab.c" /* yacc.c:358  */
 
 #ifdef short
 # undef short
 #endif
 
-#ifdef FFTYPE_UINT8
-typedef FFTYPE_UINT8 fftype_uint8;
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
+
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
+#endif
+
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
 #else
-typedef unsigned char fftype_uint8;
+typedef signed char yytype_int8;
 #endif
 
-#ifdef FFTYPE_INT8
-typedef FFTYPE_INT8 fftype_int8;
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
 #else
-typedef signed char fftype_int8;
+typedef short yytype_int16;
+#endif
+
+/* Work around bug in HP-UX 11.23, which defines these macros
+   incorrectly for preprocessor constants.  This workaround can likely
+   be removed in 2023, as HPE has promised support for HP-UX 11.23
+   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
+   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
+#ifdef __hpux
+# undef UINT_LEAST8_MAX
+# undef UINT_LEAST16_MAX
+# define UINT_LEAST8_MAX 255
+# define UINT_LEAST16_MAX 65535
 #endif
 
-#ifdef FFTYPE_UINT16
-typedef FFTYPE_UINT16 fftype_uint16;
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
 #else
-typedef unsigned short int fftype_uint16;
+typedef short yytype_uint8;
 #endif
 
-#ifdef FFTYPE_INT16
-typedef FFTYPE_INT16 fftype_int16;
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
 #else
-typedef short int fftype_int16;
+typedef int yytype_uint16;
 #endif
 
-#ifndef FFSIZE_T
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
+#endif
+
+#ifndef YYSIZE_T
 # ifdef __SIZE_TYPE__
-#  define FFSIZE_T __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
 # elif defined size_t
-#  define FFSIZE_T size_t
-# elif ! defined FFSIZE_T
+#  define YYSIZE_T size_t
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
 #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define FFSIZE_T size_t
+#  define YYSIZE_T size_t
 # else
-#  define FFSIZE_T unsigned int
+#  define YYSIZE_T unsigned
 # endif
 #endif
 
-#define FFSIZE_MAXIMUM ((FFSIZE_T) -1)
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
 
-#ifndef FF_
-# if defined FFENABLE_NLS && FFENABLE_NLS
+/* Stored state numbers (used for stacks). */
+typedef yytype_int16 yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
 #  if ENABLE_NLS
 #   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define FF_(Msgid) dgettext ("bison-runtime", Msgid)
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
 #  endif
 # endif
-# ifndef FF_
-#  define FF_(Msgid) Msgid
+# ifndef YY_
+#  define YY_(Msgid) Msgid
 # endif
 #endif
 
-#ifndef FF_ATTRIBUTE
-# if (defined __GNUC__                                               \
-      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
-     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
-#  define FF_ATTRIBUTE(Spec) __attribute__(Spec)
+
+#ifndef YY_ATTRIBUTE_PURE
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
 # else
-#  define FF_ATTRIBUTE(Spec) /* empty */
+#  define YY_ATTRIBUTE_PURE
 # endif
 #endif
 
-#ifndef FF_ATTRIBUTE_PURE
-# define FF_ATTRIBUTE_PURE   FF_ATTRIBUTE ((__pure__))
-#endif
-
-#ifndef FF_ATTRIBUTE_UNUSED
-# define FF_ATTRIBUTE_UNUSED FF_ATTRIBUTE ((__unused__))
-#endif
-
-#if !defined _Noreturn \
-     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
-# if defined _MSC_VER && 1200 <= _MSC_VER
-#  define _Noreturn __declspec (noreturn)
+#ifndef YY_ATTRIBUTE_UNUSED
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
 # else
-#  define _Noreturn FF_ATTRIBUTE ((__noreturn__))
+#  define YY_ATTRIBUTE_UNUSED
 # endif
 #endif
 
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
-# define FFUSE(E) ((void) (E))
+# define YY_USE(E) ((void) (E))
 #else
-# define FFUSE(E) /* empty */
+# define YY_USE(E) /* empty */
 #endif
 
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
-/* Suppress an incorrect diagnostic about fflval being uninitialized.  */
-# define FF_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
+# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
+# else
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
     _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define FF_IGNORE_MAYBE_UNINITIALIZED_END \
+# endif
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
     _Pragma ("GCC diagnostic pop")
 #else
-# define FF_INITIAL_VALUE(Value) Value
+# define YY_INITIAL_VALUE(Value) Value
 #endif
-#ifndef FF_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define FF_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define FF_IGNORE_MAYBE_UNINITIALIZED_END
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
 #endif
-#ifndef FF_INITIAL_VALUE
-# define FF_INITIAL_VALUE(Value) /* Nothing. */
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
 #endif
 
 
-#if ! defined ffoverflow || FFERROR_VERBOSE
+#define YY_ASSERT(E) ((void) (0 && (E)))
+
+#if !defined yyoverflow
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
-# ifdef FFSTACK_USE_ALLOCA
-#  if FFSTACK_USE_ALLOCA
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
 #   ifdef __GNUC__
-#    define FFSTACK_ALLOC __builtin_alloca
+#    define YYSTACK_ALLOC __builtin_alloca
 #   elif defined __BUILTIN_VA_ARG_INCR
 #    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
 #   elif defined _AIX
-#    define FFSTACK_ALLOC __alloca
+#    define YYSTACK_ALLOC __alloca
 #   elif defined _MSC_VER
 #    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
 #    define alloca _alloca
 #   else
-#    define FFSTACK_ALLOC alloca
+#    define YYSTACK_ALLOC alloca
 #    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
       /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
 #     ifndef EXIT_SUCCESS
 #      define EXIT_SUCCESS 0
 #     endif
 #    endif
 #   endif
 #  endif
 # endif
 
-# ifdef FFSTACK_ALLOC
+# ifdef YYSTACK_ALLOC
    /* Pacify GCC's 'empty if-body' warning.  */
-#  define FFSTACK_FREE(Ptr) do { /* empty */; } while (0)
-#  ifndef FFSTACK_ALLOC_MAXIMUM
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
     /* The OS might guarantee only one guard page at the bottom of the stack,
        and a page size can be as small as 4096 bytes.  So we cannot safely
        invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        to allow for a few compiler-allocated temporary stack slots.  */
-#   define FFSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
 # else
-#  define FFSTACK_ALLOC FFMALLOC
-#  define FFSTACK_FREE FFFREE
-#  ifndef FFSTACK_ALLOC_MAXIMUM
-#   define FFSTACK_ALLOC_MAXIMUM FFSIZE_MAXIMUM
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
 #  if (defined __cplusplus && ! defined EXIT_SUCCESS \
-       && ! ((defined FFMALLOC || defined malloc) \
-             && (defined FFFREE || defined free)))
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
 #   ifndef EXIT_SUCCESS
 #    define EXIT_SUCCESS 0
 #   endif
 #  endif
-#  ifndef FFMALLOC
-#   define FFMALLOC malloc
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
 #   if ! defined malloc && ! defined EXIT_SUCCESS
-void *malloc (FFSIZE_T); /* INFRINGES ON USER NAME SPACE */
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
-#  ifndef FFFREE
-#   define FFFREE free
+#  ifndef YYFREE
+#   define YYFREE free
 #   if ! defined free && ! defined EXIT_SUCCESS
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 # endif
-#endif /* ! defined ffoverflow || FFERROR_VERBOSE */
-
+#endif /* !defined yyoverflow */
 
-#if (! defined ffoverflow \
+#if (! defined yyoverflow \
      && (! defined __cplusplus \
-         || (defined FFSTYPE_IS_TRIVIAL && FFSTYPE_IS_TRIVIAL)))
+         || (defined FITS_PARSER_YYSTYPE_IS_TRIVIAL && FITS_PARSER_YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
-union ffalloc
+union yyalloc
 {
-  fftype_int16 ffss_alloc;
-  FFSTYPE ffvs_alloc;
+  yy_state_t yyss_alloc;
+  YYSTYPE yyvs_alloc;
 };
 
 /* The size of the maximum gap between one aligned stack and the next.  */
-# define FFSTACK_GAP_MAXIMUM (sizeof (union ffalloc) - 1)
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
 
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
-# define FFSTACK_BYTES(N) \
-     ((N) * (sizeof (fftype_int16) + sizeof (FFSTYPE)) \
-      + FFSTACK_GAP_MAXIMUM)
+# define YYSTACK_BYTES(N) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
 
-# define FFCOPY_NEEDED 1
+# define YYCOPY_NEEDED 1
 
 /* Relocate STACK from its old location to the new one.  The
-   local variables FFSIZE and FFSTACKSIZE give the old and new number of
-   elements in the stack, and FFPTR gives the new location of the
-   stack.  Advance FFPTR to a properly aligned location for the next
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
    stack.  */
-# define FFSTACK_RELOCATE(Stack_alloc, Stack)                           \
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
     do                                                                  \
       {                                                                 \
-        FFSIZE_T ffnewbytes;                                            \
-        FFCOPY (&ffptr->Stack_alloc, Stack, ffsize);                    \
-        Stack = &ffptr->Stack_alloc;                                    \
-        ffnewbytes = ffstacksize * sizeof (*Stack) + FFSTACK_GAP_MAXIMUM; \
-        ffptr += ffnewbytes / sizeof (*ffptr);                          \
+        YYPTRDIFF_T yynewbytes;                                         \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
       }                                                                 \
     while (0)
 
 #endif
 
-#if defined FFCOPY_NEEDED && FFCOPY_NEEDED
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
 /* Copy COUNT objects from SRC to DST.  The source and destination do
    not overlap.  */
-# ifndef FFCOPY
+# ifndef YYCOPY
 #  if defined __GNUC__ && 1 < __GNUC__
-#   define FFCOPY(Dst, Src, Count) \
-      __builtin_memcpy (Dst, Src, (Count) * sizeof (*(Src)))
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
 #  else
-#   define FFCOPY(Dst, Src, Count)              \
+#   define YYCOPY(Dst, Src, Count)              \
       do                                        \
         {                                       \
-          FFSIZE_T ffi;                         \
-          for (ffi = 0; ffi < (Count); ffi++)   \
-            (Dst)[ffi] = (Src)[ffi];            \
+          YYPTRDIFF_T yyi;                      \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
         }                                       \
       while (0)
 #  endif
 # endif
-#endif /* !FFCOPY_NEEDED */
+#endif /* !YYCOPY_NEEDED */
 
-/* FFFINAL -- State number of the termination state.  */
-#define FFFINAL  2
-/* FFLAST -- Last index in FFTABLE.  */
-#define FFLAST   1630
-
-/* FFNTOKENS -- Number of terminals.  */
-#define FFNTOKENS  55
-/* FFNNTS -- Number of nonterminals.  */
-#define FFNNTS  9
-/* FFNRULES -- Number of rules.  */
-#define FFNRULES  128
-/* FFNSTATES -- Number of states.  */
-#define FFNSTATES  296
-
-/* FFTRANSLATE[FFX] -- Symbol number corresponding to FFX as returned
-   by fflex, with out-of-bounds checking.  */
-#define FFUNDEFTOK  2
-#define FFMAXUTOK   290
-
-#define FFTRANSLATE(FFX)                                                \
-  ((unsigned int) (FFX) <= FFMAXUTOK ? fftranslate[FFX] : FFUNDEFTOK)
-
-/* FFTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
-   as returned by fflex, without out-of-bounds checking.  */
-static const fftype_uint8 fftranslate[] =
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  2
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   1776
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  57
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  9
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  135
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  322
+
+/* YYMAXUTOK -- Last valid token kind.  */
+#define YYMAXUTOK   292
+
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex.  */
+static const yytype_int8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-      51,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      53,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,    37,    41,     2,
-      53,    54,    38,    35,    20,    36,     2,    39,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,    22,     2,
-       2,    21,     2,    25,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,    39,    43,     2,
+      55,    56,    40,    37,    22,    38,     2,    41,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    24,     2,
+       2,    23,     2,    27,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,    48,     2,    52,     2,     2,     2,     2,     2,     2,
+       2,    50,     2,    54,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,    23,    40,    24,    30,     2,     2,     2,
+       2,     2,     2,    25,    42,    26,    32,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    26,    27,    28,    29,    31,
-      32,    33,    34,    42,    43,    44,    45,    46,    47,    49,
-      50
+      15,    16,    17,    18,    19,    20,    21,    28,    29,    30,
+      31,    33,    34,    35,    36,    44,    45,    46,    47,    48,
+      49,    51,    52
 };
 
-#if FFDEBUG
-  /* FFRLINE[FFN] -- Source line where rule number FFN was defined.  */
-static const fftype_uint16 ffrline[] =
-{
-       0,   244,   244,   245,   248,   249,   255,   261,   267,   273,
-     276,   278,   291,   293,   306,   317,   331,   335,   339,   343,
-     345,   354,   357,   360,   369,   371,   373,   375,   377,   379,
-     382,   386,   388,   390,   392,   401,   403,   405,   408,   411,
-     414,   417,   420,   429,   438,   447,   450,   452,   454,   456,
-     460,   464,   483,   502,   521,   532,   546,   558,   589,   684,
-     692,   754,   778,   780,   782,   784,   786,   788,   790,   792,
-     794,   798,   800,   802,   811,   814,   817,   820,   823,   826,
-     829,   832,   835,   838,   841,   844,   847,   850,   853,   856,
-     859,   862,   865,   868,   870,   872,   874,   877,   884,   901,
-     914,   927,   938,   954,   978,  1006,  1043,  1047,  1051,  1054,
-    1058,  1062,  1065,  1069,  1071,  1073,  1075,  1077,  1079,  1081,
-    1085,  1088,  1090,  1099,  1101,  1103,  1112,  1131,  1150
+#if FITS_PARSER_YYDEBUG
+/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_int16 yyrline[] =
+{
+       0,   266,   266,   267,   270,   271,   277,   283,   289,   295,
+     298,   300,   313,   315,   328,   339,   353,   357,   361,   365,
+     367,   376,   379,   382,   391,   393,   395,   397,   399,   401,
+     404,   408,   410,   412,   414,   423,   425,   427,   430,   433,
+     436,   439,   442,   451,   460,   469,   472,   474,   476,   478,
+     482,   486,   505,   524,   543,   554,   568,   617,   629,   660,
+     774,   782,   885,   909,   911,   913,   915,   917,   919,   921,
+     923,   925,   929,   931,   933,   942,   945,   948,   951,   954,
+     957,   960,   963,   966,   969,   972,   975,   978,   981,   984,
+     987,   990,   993,   996,   999,  1001,  1003,  1005,  1008,  1015,
+    1032,  1045,  1058,  1069,  1085,  1109,  1137,  1174,  1178,  1182,
+    1185,  1190,  1193,  1198,  1202,  1206,  1209,  1214,  1218,  1221,
+    1225,  1227,  1229,  1231,  1233,  1235,  1237,  1241,  1244,  1246,
+    1255,  1257,  1259,  1268,  1287,  1306
 };
 #endif
 
-#if FFDEBUG || FFERROR_VERBOSE || 0
-/* FFTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at FFNTOKENS, nonterminals.  */
-static const char *const fftname[] =
-{
-  "$end", "error", "$undefined", "BOOLEAN", "LONG", "DOUBLE", "STRING",
-  "BITSTR", "FUNCTION", "BFUNCTION", "IFUNCTION", "GTIFILTER", "REGFILTER",
-  "COLUMN", "BCOLUMN", "SCOLUMN", "BITCOL", "ROWREF", "NULLREF",
-  "SNULLREF", "','", "'='", "':'", "'{'", "'}'", "'?'", "OR", "AND", "EQ",
-  "NE", "'~'", "GT", "LT", "LTE", "GTE", "'+'", "'-'", "'%'", "'*'", "'/'",
-  "'|'", "'&'", "XOR", "POWER", "NOT", "INTCAST", "FLTCAST", "UMINUS",
-  "'['", "ACCUM", "DIFF", "'\\n'", "']'", "'('", "')'", "$accept", "lines",
-  "line", "bvector", "vector", "expr", "bexpr", "bits", "sexpr", FF_NULLPTR
-};
-#endif
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
 
-# ifdef FFPRINT
-/* FFTOKNUM[NUM] -- (External) token number corresponding to the
-   (internal) symbol number NUM (which must be that of a token).  */
-static const fftype_uint16 fftoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-      44,    61,    58,   123,   125,    63,   275,   276,   277,   278,
-     126,   279,   280,   281,   282,    43,    45,    37,    42,    47,
-     124,    38,   283,   284,   285,   286,   287,   288,    91,   289,
-     290,    10,    93,    40,    41
+#if FITS_PARSER_YYDEBUG || 0
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
+
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "\"end of file\"", "error", "\"invalid token\"", "BOOLEAN", "LONG",
+  "DOUBLE", "STRING", "BITSTR", "FUNCTION", "BFUNCTION", "IFUNCTION",
+  "GTIFILTER", "GTIOVERLAP", "GTIFIND", "REGFILTER", "COLUMN", "BCOLUMN",
+  "SCOLUMN", "BITCOL", "ROWREF", "NULLREF", "SNULLREF", "','", "'='",
+  "':'", "'{'", "'}'", "'?'", "OR", "AND", "EQ", "NE", "'~'", "GT", "LT",
+  "LTE", "GTE", "'+'", "'-'", "'%'", "'*'", "'/'", "'|'", "'&'", "XOR",
+  "POWER", "NOT", "INTCAST", "FLTCAST", "UMINUS", "'['", "ACCUM", "DIFF",
+  "'\\n'", "']'", "'('", "')'", "$accept", "lines", "line", "bvector",
+  "vector", "expr", "bexpr", "bits", "sexpr", YY_NULLPTR
 };
-# endif
 
-#define FFPACT_NINF -50
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
+{
+  return yytname[yysymbol];
+}
+#endif
+
+#define YYPACT_NINF (-41)
 
-#define ffpact_value_is_default(Yystate) \
-  (!!((Yystate) == (-50)))
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
 
-#define FFTABLE_NINF -1
+#define YYTABLE_NINF (-1)
 
-#define fftable_value_is_error(Yytable_value) \
+#define yytable_value_is_error(Yyn) \
   0
 
-  /* FFPACT[STATE-NUM] -- Index in FFTABLE of the portion describing
-     STATE-NUM.  */
-static const fftype_int16 ffpact[] =
-{
-     -50,   306,   -50,   -49,   -50,   -50,   -50,   -50,   -50,   357,
-     409,   409,    -5,    -2,   -18,     5,     6,    34,   -50,   -50,
-     -50,   409,   409,   409,   409,   409,   409,   -50,   409,   -50,
-      49,    87,  1126,   246,  1484,   -17,   -50,   -50,   436,    10,
-     350,   164,   465,    17,  1550,   302,  1431,  1511,  1513,   -14,
-     -50,   -13,   409,   409,   409,   409,  1431,  1511,  1522,   -22,
-     -22,    18,    44,   -22,    18,   -22,    18,   638,   117,  1449,
-     405,   409,   -50,   409,   -50,   409,   409,   409,   409,   409,
-     409,   409,   409,   409,   409,   409,   409,   409,   409,   409,
-     409,   409,   409,   -50,   409,   409,   409,   409,   409,   409,
-     409,   -50,     3,     3,     3,     3,     3,     3,     3,     3,
-       3,   409,   -50,   409,   409,   409,   409,   409,   409,   409,
-     -50,   409,   -50,   409,   -50,   -50,   409,   -50,   409,   -50,
-     -50,   -50,   409,   409,   -50,   409,   -50,  1293,  1316,  1339,
-    1362,   -50,   -50,   -50,   -50,  1431,  1511,  1431,  1511,  1385,
-    1568,  1568,  1568,  1582,  1582,  1582,  1582,   305,   305,   305,
-      19,    18,    19,    20,    20,    20,    20,   751,  1408,   260,
-     205,   129,    67,   -35,   -35,    19,   776,     3,     3,   112,
-     112,   112,   112,   112,   112,    60,    44,    44,   801,   268,
-     268,    62,    62,    62,    62,   -50,   494,   177,  1150,  1467,
-    1174,  1476,   523,  1198,   -50,   -50,   -50,   -50,   409,   409,
-     -50,   409,   409,   409,   409,   -50,    44,   128,   409,   -50,
-     409,   -50,   -50,   409,   -50,   409,   -50,    98,   -50,   409,
-    1532,   826,  1532,  1511,  1532,  1511,  1522,   851,   876,  1222,
-     666,   552,    86,   581,   409,   -50,   409,   -50,   409,   -50,
-     409,   -50,   409,   -50,   103,   106,   -50,   901,   926,   951,
-     694,  1246,    59,    68,   409,   -50,   409,   -50,   409,   -50,
-     -50,   409,   -50,   -50,   976,  1001,  1026,   610,   409,   -50,
-     409,   -50,   409,   -50,   409,   -50,  1051,  1076,  1101,  1270,
-     -50,   -50,   -50,   409,   722,   -50
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+static const yytype_int16 yypact[] =
+{
+     -41,   316,   -41,   -40,   -41,   -41,   -41,   -41,   -41,   369,
+     423,   423,    -5,    15,    -4,    27,    36,    38,    40,    41,
+     -41,   -41,   -41,   423,   423,   423,   423,   423,   423,   -41,
+     423,   -41,    -7,    10,  1226,    81,  1646,    83,   -41,   -41,
+     450,   116,   309,    12,   479,   185,   152,   222,  1593,  1673,
+    1675,   -19,   -41,    13,   -18,   -41,     6,   423,   423,   423,
+     423,  1593,  1673,  1684,    17,    17,    19,    24,    17,    19,
+      17,    19,   710,  1253,  1611,   365,   423,   -41,   423,   -41,
+     423,   423,   423,   423,   423,   423,   423,   423,   423,   423,
+     423,   423,   423,   423,   423,   423,   423,   423,   -41,   423,
+     423,   423,   423,   423,   423,   423,   -41,    -2,    -2,    -2,
+      -2,    -2,    -2,    -2,    -2,    -2,   423,   -41,   423,   423,
+     423,   423,   423,   423,   423,   -41,   423,   -41,   423,   -41,
+     -41,   423,   -41,   423,   -41,   -41,   -41,   423,   423,   -41,
+     423,   423,   -41,   423,   -41,  1455,  1478,  1501,  1524,   -41,
+     -41,   -41,   -41,  1593,  1673,  1593,  1673,  1547,  1712,  1712,
+    1712,  1726,  1726,  1726,  1726,   368,   368,   368,    28,    19,
+      28,     5,     5,     5,     5,   851,  1570,   425,   260,   128,
+     -20,    14,    14,    28,   876,    -2,    -2,   -25,   -25,   -25,
+     -25,   -25,   -25,   -36,    24,    24,   901,   140,   140,    39,
+      39,    39,    39,   -41,   508,   738,  1258,  1288,  1629,  1312,
+    1638,   537,  1336,   566,  1360,   -41,   -41,   -41,   -41,   423,
+     423,   -41,   423,   423,   423,   423,   -41,    24,   189,   423,
+     -41,   423,   -41,   -41,   -41,   423,   -41,   423,   -41,    93,
+     -41,   423,    94,   -41,   423,  1694,   926,  1694,  1673,  1694,
+    1673,  1684,   951,   976,  1384,   766,   595,    79,   624,    80,
+     653,   423,   -41,   423,   -41,   423,   -41,   423,   -41,   423,
+     -41,   100,   101,   -41,   117,   118,   -41,  1001,  1026,  1051,
+     794,  1408,    72,   111,    85,    99,   423,   -41,   423,   -41,
+     423,   -41,   -41,   423,   -41,   129,   -41,   -41,  1076,  1101,
+    1126,   682,   104,   423,   -41,   423,   -41,   423,   -41,   423,
+     -41,   -41,  1151,  1176,  1201,  1432,   -41,   -41,   -41,   423,
+     822,   -41
 };
 
-  /* FFDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
-     Performed when FFTABLE does not specify something else to do.  Zero
-     means the default is an error.  */
-static const fftype_uint8 ffdefact[] =
-{
-       2,     0,     1,     0,    71,    31,    32,   120,    18,     0,
-       0,     0,     0,     0,    33,    72,   121,    19,    35,    36,
-     123,     0,     0,     0,     0,     0,     0,     4,     0,     3,
-       0,     0,     0,     0,     0,     0,     9,    54,     0,     0,
+/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE does not specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       2,     0,     1,     0,    72,    31,    32,   127,    18,     0,
+       0,     0,     0,     0,     0,     0,    33,    73,   128,    19,
+      35,    36,   130,     0,     0,     0,     0,     0,     0,     4,
+       0,     3,     0,     0,     0,     0,     0,     0,     9,    54,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-     106,     0,     0,     0,     0,     0,    12,    10,     0,    46,
-      47,   118,    29,    67,    68,    69,    70,     0,     0,     0,
-       0,     0,    17,     0,    16,     0,     0,     0,     0,     0,
+       0,     0,   107,     0,     0,   113,     0,     0,     0,     0,
+       0,    12,    10,     0,    46,    47,   125,    29,    68,    69,
+      70,    71,     0,     0,     0,     0,     0,    17,     0,    16,
        0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     5,     0,     0,     0,     0,     0,     0,
-       0,     6,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     8,     0,     0,     0,     0,     0,     0,     0,
-       7,     0,    58,     0,    55,    57,     0,    56,     0,    99,
-     100,   101,     0,     0,   107,     0,   110,     0,     0,     0,
-       0,    48,   119,    30,   124,    15,    11,    13,    14,     0,
-      85,    86,    84,    80,    81,    83,    82,    38,    39,    37,
-      40,    49,    41,    43,    42,    44,    45,     0,     0,     0,
-       0,    94,    93,    95,    96,    50,     0,     0,     0,    74,
-      75,    78,    76,    77,    79,    23,    22,    21,     0,    87,
-      88,    89,    91,    92,    90,   125,     0,     0,     0,     0,
-       0,     0,     0,     0,    34,    73,   122,    20,     0,     0,
-      62,     0,     0,     0,     0,   113,    29,     0,     0,    24,
-       0,    60,   102,     0,   127,     0,    59,     0,   108,     0,
-      97,     0,    51,    53,    52,    98,   126,     0,     0,     0,
-       0,     0,     0,     0,     0,    63,     0,   114,     0,    25,
-       0,   128,     0,   103,     0,     0,   111,     0,     0,     0,
-       0,     0,     0,     0,     0,    64,     0,   115,     0,    26,
-      61,     0,   109,   112,     0,     0,     0,     0,     0,    65,
-       0,   116,     0,    27,     0,   104,     0,     0,     0,     0,
-      66,   117,    28,     0,     0,   105
+       0,     0,     0,     0,     0,     0,     0,     0,     5,     0,
+       0,     0,     0,     0,     0,     0,     6,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     8,     0,     0,
+       0,     0,     0,     0,     0,     7,     0,    59,     0,    55,
+      58,     0,    57,     0,   100,   101,   102,     0,     0,   108,
+       0,     0,   114,     0,   117,     0,     0,     0,     0,    48,
+     126,    30,   131,    15,    11,    13,    14,     0,    86,    87,
+      85,    81,    82,    84,    83,    38,    39,    37,    40,    49,
+      41,    43,    42,    44,    45,     0,     0,     0,     0,    95,
+      94,    96,    97,    50,     0,     0,     0,    75,    76,    79,
+      77,    78,    80,    23,    22,    21,     0,    88,    89,    90,
+      92,    93,    91,   132,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    34,    74,   129,    20,     0,
+       0,    63,     0,     0,     0,     0,   120,    29,     0,     0,
+      24,     0,    61,    56,   103,     0,   134,     0,    60,     0,
+     109,     0,     0,   115,     0,    98,     0,    51,    53,    52,
+      99,   133,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    64,     0,   121,     0,    25,     0,   135,     0,
+     104,     0,     0,   111,     0,     0,   118,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    65,     0,   122,
+       0,    26,    62,     0,   110,     0,   116,   119,     0,     0,
+       0,     0,     0,     0,    66,     0,   123,     0,    27,     0,
+     105,   112,     0,     0,     0,     0,    67,   124,    28,     0,
+       0,   106
 };
 
-  /* FFPGOTO[NTERM-NUM].  */
-static const fftype_int16 ffpgoto[] =
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
 {
-     -50,   -50,   -50,   -50,   -50,    -1,    93,   150,    22
+     -41,   -41,   -41,   -41,   -41,    -1,   170,    96,    30
 };
 
-  /* FFDEFGOTO[NTERM-NUM].  */
-static const fftype_int8 ffdefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
 {
-      -1,     1,    29,    30,    31,    46,    47,    44,    58
+       0,     1,    31,    32,    33,    48,    49,    46,    63
 };
 
-  /* FFTABLE[FFPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
-     positive, shift that token.  If negative, reduce the rule whose
-     number is the opposite.  If FFTABLE_NINF, syntax error.  */
-static const fftype_uint16 fftable[] =
-{
-      32,    49,    36,    99,    51,    52,   133,   135,    38,    42,
-       8,   113,   114,   100,   115,   116,   117,   118,   119,    17,
-      56,    59,    60,    35,    63,    65,    92,    67,    53,    54,
-     123,    41,    45,    48,   120,    94,    95,    96,    97,    98,
-     134,   136,    94,    95,    96,    97,    98,   177,    99,    50,
-      70,   137,   138,   139,   140,    99,   178,    55,   100,    88,
-      89,    90,    91,    91,   124,   100,   100,    92,    92,    71,
-     145,   130,   147,    72,   149,   150,   151,   152,   153,   154,
-     155,   156,   157,   158,   159,   160,   162,   163,   164,   165,
-     166,   167,   111,   168,    33,    97,    98,   119,   175,   176,
-     109,   110,    39,    43,   242,    99,   254,    73,   111,   262,
-     188,    74,   263,   272,    57,   100,   170,    61,    64,    66,
-     196,    68,   273,     0,     0,   198,     0,   200,     0,     0,
-       0,     0,   202,     0,   203,   189,   190,   191,   192,   193,
-     194,   195,    94,    95,    96,    97,    98,   108,   199,     0,
-       0,    34,   109,   110,   201,    99,    96,    97,    98,    40,
-     111,     0,     0,   108,   146,   100,   148,    99,   109,   110,
-       0,   142,     0,     0,    62,     0,   111,   100,    69,   161,
-       0,     0,   143,     0,   126,     0,     0,   169,   171,   172,
-     173,   174,   113,   114,     0,   115,   116,   117,   118,   119,
-       0,     0,    94,    95,    96,    97,    98,   230,   231,     0,
-     232,   234,     0,   237,     0,    99,   197,   238,   127,   239,
-       0,     0,   240,     0,   241,   100,     0,   213,   243,     0,
-       0,   222,     0,   113,   114,   236,   115,   116,   117,   118,
-     119,     0,     0,   257,     0,   258,     0,   259,     0,   260,
-       0,   261,   179,   180,   181,   182,   183,   184,   185,   186,
-     187,     0,     0,   274,     0,   275,     0,   276,     0,     0,
-     277,    94,    95,    96,    97,    98,     0,   286,     0,   287,
-       0,   288,   212,   289,    99,    94,    95,    96,    97,    98,
-       0,     0,   294,     0,   100,     0,     0,   101,    99,   115,
-     116,   117,   118,   119,   233,   235,     2,     3,   100,     4,
+/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule whose
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int16 yytable[] =
+{
+      34,    51,    54,   138,   141,     8,   114,   115,    40,    44,
+     102,   103,   113,    38,   116,    76,    19,   114,   115,    77,
+     104,    53,    61,    64,    65,   116,    68,    70,   143,    72,
+     105,    37,    78,    56,   131,   140,    79,   139,   142,    43,
+      47,    50,   118,   119,   185,   120,   121,   122,   123,   124,
+      96,    52,    55,   186,   104,    97,   145,   146,   147,   148,
+      75,    57,   144,    58,   105,    59,    60,    97,   132,   105,
+      93,    94,    95,    96,   116,   153,   124,   155,    97,   157,
+     158,   159,   160,   161,   162,   163,   164,   165,   166,   167,
+     168,   170,   171,   172,   173,   174,   175,    36,   176,   257,
+     259,   271,   274,   183,   184,    42,   282,   283,    99,   100,
+     101,   102,   103,   118,   119,   196,   120,   121,   122,   123,
+     124,   104,    67,   284,   285,   204,    74,   205,   294,   178,
+     207,   105,   209,   295,   106,   302,   125,   211,   128,   212,
+     213,   296,   214,    99,   100,   101,   102,   103,   197,   198,
+     199,   200,   201,   202,   203,   297,   104,   101,   102,   103,
+     311,   208,     0,     0,     0,     0,   105,   210,   104,     0,
+       0,    35,   129,   120,   121,   122,   123,   124,   105,    41,
+      45,     0,   107,   108,     0,   109,   110,   111,   112,   113,
+       0,     0,     0,    62,   114,   115,    66,    69,    71,     0,
+      73,     0,   116,   187,   188,   189,   190,   191,   192,   193,
+     194,   195,    99,   100,   101,   102,   103,     0,   245,   246,
+       0,   247,   249,     0,   252,   104,   113,     0,   253,     0,
+     254,   114,   115,     0,   255,   105,   256,     0,     0,   116,
+     258,   135,     0,   260,     0,   151,   154,     0,   156,     0,
+       0,     0,   118,   119,   251,   120,   121,   122,   123,   124,
+     277,   169,   278,     0,   279,     0,   280,     0,   281,   177,
+     179,   180,   181,   182,     0,     0,     0,     0,   136,     0,
+       0,   227,   228,     0,   224,   298,     0,   299,     0,   300,
+     118,   119,   301,   120,   121,   122,   123,   124,   206,     0,
+       0,     0,   312,     0,   313,     0,   314,     0,   315,     0,
+       0,     0,     0,     0,     0,     0,     2,     3,   320,     4,
        5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,     0,   216,   217,    21,
-     113,   114,     0,   115,   116,   117,   118,   119,     0,     0,
-       0,    22,    23,    86,    87,    88,    89,    90,    91,     0,
-      24,    25,    26,    92,     0,     0,   131,    27,     0,    28,
-       4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    20,     0,   102,   103,
-      21,   104,   105,   106,   107,   108,     0,     0,     0,     0,
-     109,   110,    22,    23,     0,     0,     0,     0,   111,     0,
-       0,    24,    25,    26,   125,     0,     0,     0,     0,     0,
-      28,    37,     4,     5,     6,     7,     8,     9,    10,    11,
-      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
-       0,     0,    21,   113,   114,     0,   115,   116,   117,   118,
-     119,     0,     0,     0,    22,    23,     0,     0,     0,     0,
-       0,     0,     0,    24,    25,    26,   121,    75,     0,   144,
-       0,     0,    28,     0,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,     0,     0,     0,    92,   128,    75,     0,     0,     0,
-     122,     0,     0,    76,    77,    78,    79,    80,    81,    82,
-      83,    84,    85,    86,    87,    88,    89,    90,    91,     0,
-       0,     0,     0,    92,   220,    75,     0,     0,     0,   129,
-       0,     0,    76,    77,    78,    79,    80,    81,    82,    83,
-      84,    85,    86,    87,    88,    89,    90,    91,     0,     0,
-       0,     0,    92,   227,    75,     0,     0,     0,   221,     0,
-       0,    76,    77,    78,    79,    80,    81,    82,    83,    84,
-      85,    86,    87,    88,    89,    90,    91,     0,     0,     0,
-       0,    92,   252,    75,     0,     0,     0,   228,     0,     0,
-      76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
-      86,    87,    88,    89,    90,    91,     0,     0,     0,     0,
-      92,   255,    75,     0,     0,     0,   253,     0,     0,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,     0,     0,     0,    92,
-     284,    75,     0,     0,     0,   256,     0,     0,    76,    77,
-      78,    79,    80,    81,    82,    83,    84,    85,    86,    87,
-      88,    89,    90,    91,     0,     0,     0,     0,    92,    75,
-       0,     0,     0,     0,   285,     0,    76,    77,    78,    79,
-      80,    81,    82,    83,    84,    85,    86,    87,    88,    89,
-      90,    91,     0,     0,     0,     0,    92,    75,     0,     0,
-       0,     0,   141,     0,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,     0,     0,     0,    92,    75,     0,     0,     0,     0,
-     251,     0,    76,    77,    78,    79,    80,    81,    82,    83,
-      84,    85,    86,    87,    88,    89,    90,    91,     0,     0,
-       0,     0,    92,    75,     0,     0,     0,     0,   270,     0,
-      76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
-      86,    87,    88,    89,    90,    91,     0,     0,     0,     0,
-      92,   209,    75,     0,     0,     0,   295,     0,     0,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,   214,    75,     0,    92,
-       0,     0,     0,   210,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,   218,    75,     0,    92,     0,     0,     0,   215,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,   244,    75,     0,    92,
-       0,     0,     0,   219,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,   246,    75,     0,    92,     0,     0,     0,   245,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,   248,    75,     0,    92,
-       0,     0,     0,   247,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,   264,    75,     0,    92,     0,     0,     0,   249,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,   266,    75,     0,    92,
-       0,     0,     0,   265,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,   268,    75,     0,    92,     0,     0,     0,   267,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,   278,    75,     0,    92,
-       0,     0,     0,   269,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,   280,    75,     0,    92,     0,     0,     0,   279,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,   282,    75,     0,    92,
-       0,     0,     0,   281,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,     0,    75,     0,    92,     0,     0,     0,   283,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,     0,    75,     0,    92,
-       0,     0,     0,   290,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-       0,     0,    75,     0,    92,     0,     0,     0,   291,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,     0,    75,     0,    92,
-       0,     0,     0,   292,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-     223,    75,     0,     0,    92,     0,     0,    93,    76,    77,
-      78,    79,    80,    81,    82,    83,    84,    85,    86,    87,
-      88,    89,    90,    91,   225,    75,     0,     0,    92,     0,
-       0,     0,    76,    77,    78,    79,    80,    81,    82,    83,
-      84,    85,    86,    87,    88,    89,    90,    91,   229,    75,
-       0,     0,    92,     0,     0,     0,    76,    77,    78,    79,
-      80,    81,    82,    83,    84,    85,    86,    87,    88,    89,
-      90,    91,   250,    75,     0,     0,    92,     0,     0,     0,
-      76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
-      86,    87,    88,    89,    90,    91,   271,    75,     0,     0,
-      92,     0,     0,     0,    76,    77,    78,    79,    80,    81,
-      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-     293,    75,     0,     0,    92,     0,     0,     0,    76,    77,
-      78,    79,    80,    81,    82,    83,    84,    85,    86,    87,
-      88,    89,    90,    91,    75,     0,     0,   204,    92,     0,
-       0,    76,    77,    78,    79,    80,    81,    82,    83,    84,
-      85,    86,    87,    88,    89,    90,    91,    75,     0,     0,
-     205,    92,     0,     0,    76,    77,    78,    79,    80,    81,
+      15,    16,    17,    18,    19,    20,    21,    22,     0,   107,
+     108,    23,   109,   110,   111,   112,   113,     0,     0,     0,
+       0,   114,   115,    24,    25,     0,     0,     0,     0,   116,
+       0,     0,    26,    27,    28,   130,     0,     0,     0,    29,
+       0,    30,     4,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
+      22,     0,   248,   250,    23,   118,   119,     0,   120,   121,
+     122,   123,   124,     0,     0,     0,    24,    25,    91,    92,
+      93,    94,    95,    96,     0,    26,    27,    28,    97,     0,
+       0,   152,     0,     0,    30,    39,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,     0,     0,     0,    23,   223,
+       0,     0,    99,   100,   101,   102,   103,     0,     0,     0,
+      24,    25,     0,     0,     0,   104,     0,     0,     0,    26,
+      27,    28,   126,    80,     0,   105,     0,     0,    30,     0,
+      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,    92,    93,    94,    95,    96,     0,     0,     0,     0,
+      97,   133,    80,     0,     0,     0,   127,     0,     0,    81,
       82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
-      75,     0,     0,   206,    92,     0,     0,    76,    77,    78,
-      79,    80,    81,    82,    83,    84,    85,    86,    87,    88,
-      89,    90,    91,    75,     0,     0,   207,    92,     0,     0,
-      76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
-      86,    87,    88,    89,    90,    91,    75,   208,     0,     0,
-      92,     0,     0,    76,    77,    78,    79,    80,    81,    82,
-      83,    84,    85,    86,    87,    88,    89,    90,    91,    75,
-     211,     0,     0,    92,     0,     0,    76,    77,    78,    79,
-      80,    81,    82,    83,    84,    85,    86,    87,    88,    89,
-      90,    91,    75,     0,     0,     0,    92,     0,     0,    76,
-      77,    78,    79,    80,    81,    82,    83,    84,    85,    86,
-      87,    88,    89,    90,    91,     0,     0,   102,   103,    92,
-     104,   105,   106,   107,   108,     0,     0,     0,     0,   109,
-     110,     0,     0,     0,     0,   113,   114,   111,   115,   116,
-     117,   118,   119,   143,   113,   114,     0,   115,   116,   117,
-     118,   119,   102,   103,     0,   104,   105,   106,   107,   108,
-       0,   224,     0,     0,   109,   110,     0,     0,     0,     0,
-     226,     0,   111,   132,     0,   112,    94,    95,    96,    97,
-      98,   113,   114,     0,   115,   116,   117,   118,   119,    99,
-     113,   114,     0,   115,   116,   117,   118,   119,     0,   100,
-      76,    77,    78,    79,    80,    81,    82,    83,    84,    85,
-      86,    87,    88,    89,    90,    91,     0,     0,   102,   103,
-      92,   104,   105,   106,   107,   108,     0,     0,     0,     0,
-     109,   110,     0,     0,     0,     0,     0,     0,   111,    79,
-      80,    81,    82,    83,    84,    85,    86,    87,    88,    89,
-      90,    91,     0,     0,     0,     0,    92,    83,    84,    85,
-      86,    87,    88,    89,    90,    91,     0,     0,     0,     0,
-      92
+      92,    93,    94,    95,    96,     0,     0,     0,     0,    97,
+     231,    80,     0,     0,     0,   134,     0,     0,    81,    82,
+      83,    84,    85,    86,    87,    88,    89,    90,    91,    92,
+      93,    94,    95,    96,     0,     0,     0,     0,    97,   239,
+      80,     0,     0,     0,   232,     0,     0,    81,    82,    83,
+      84,    85,    86,    87,    88,    89,    90,    91,    92,    93,
+      94,    95,    96,     0,     0,     0,     0,    97,   242,    80,
+       0,     0,     0,   240,     0,     0,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,     0,     0,     0,    97,   269,    80,     0,
+       0,     0,   243,     0,     0,    81,    82,    83,    84,    85,
+      86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
+      96,     0,     0,     0,     0,    97,   272,    80,     0,     0,
+       0,   270,     0,     0,    81,    82,    83,    84,    85,    86,
+      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+       0,     0,     0,     0,    97,   275,    80,     0,     0,     0,
+     273,     0,     0,    81,    82,    83,    84,    85,    86,    87,
+      88,    89,    90,    91,    92,    93,    94,    95,    96,     0,
+       0,     0,     0,    97,   309,    80,     0,     0,     0,   276,
+       0,     0,    81,    82,    83,    84,    85,    86,    87,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,     0,     0,
+       0,     0,    97,    80,     0,     0,     0,     0,   310,     0,
+      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,    92,    93,    94,    95,    96,     0,     0,     0,     0,
+      97,    80,     0,     0,     0,     0,   149,     0,    81,    82,
+      83,    84,    85,    86,    87,    88,    89,    90,    91,    92,
+      93,    94,    95,    96,     0,     0,     0,     0,    97,    80,
+       0,     0,     0,     0,   233,     0,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,     0,     0,     0,    97,    80,     0,     0,
+       0,     0,   268,     0,    81,    82,    83,    84,    85,    86,
+      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+       0,     0,     0,     0,    97,    80,     0,     0,     0,     0,
+     292,     0,    81,    82,    83,    84,    85,    86,    87,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,     0,     0,
+       0,     0,    97,   220,    80,     0,     0,     0,   321,     0,
+       0,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,   225,    80,
+       0,    97,     0,     0,     0,   221,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,   229,    80,     0,    97,     0,     0,     0,
+     226,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,   261,    80,
+       0,    97,     0,     0,     0,   230,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,   263,    80,     0,    97,     0,     0,     0,
+     262,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,   265,    80,
+       0,    97,     0,     0,     0,   264,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,   286,    80,     0,    97,     0,     0,     0,
+     266,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,   288,    80,
+       0,    97,     0,     0,     0,   287,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,   290,    80,     0,    97,     0,     0,     0,
+     289,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,   303,    80,
+       0,    97,     0,     0,     0,   291,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,   305,    80,     0,    97,     0,     0,     0,
+     304,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,   307,    80,
+       0,    97,     0,     0,     0,   306,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,     0,    80,     0,    97,     0,     0,     0,
+     308,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,     0,    80,
+       0,    97,     0,     0,     0,   316,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,     0,    80,     0,    97,     0,     0,     0,
+     317,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,     0,     0,    80,
+       0,    97,     0,     0,     0,   318,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,     0,     0,     0,    97,     0,     0,    98,
+      99,   100,   101,   102,   103,    99,   100,   101,   102,   103,
+       0,     0,     0,   104,     0,     0,     0,     0,   104,     0,
+       0,     0,     0,   105,     0,     0,     0,     0,   105,   150,
+     235,    80,     0,     0,   234,     0,     0,     0,    81,    82,
+      83,    84,    85,    86,    87,    88,    89,    90,    91,    92,
+      93,    94,    95,    96,   237,    80,     0,     0,    97,     0,
+       0,     0,    81,    82,    83,    84,    85,    86,    87,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,   241,    80,
+       0,     0,    97,     0,     0,     0,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,   244,    80,     0,     0,    97,     0,     0,     0,
+      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,    92,    93,    94,    95,    96,   267,    80,     0,     0,
+      97,     0,     0,     0,    81,    82,    83,    84,    85,    86,
+      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+     293,    80,     0,     0,    97,     0,     0,     0,    81,    82,
+      83,    84,    85,    86,    87,    88,    89,    90,    91,    92,
+      93,    94,    95,    96,   319,    80,     0,     0,    97,     0,
+       0,     0,    81,    82,    83,    84,    85,    86,    87,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,    80,     0,
+       0,   215,    97,     0,     0,    81,    82,    83,    84,    85,
+      86,    87,    88,    89,    90,    91,    92,    93,    94,    95,
+      96,    80,     0,     0,   216,    97,     0,     0,    81,    82,
+      83,    84,    85,    86,    87,    88,    89,    90,    91,    92,
+      93,    94,    95,    96,    80,     0,     0,   217,    97,     0,
+       0,    81,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,    92,    93,    94,    95,    96,    80,     0,     0,
+     218,    97,     0,     0,    81,    82,    83,    84,    85,    86,
+      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+      80,   219,     0,     0,    97,     0,     0,    81,    82,    83,
+      84,    85,    86,    87,    88,    89,    90,    91,    92,    93,
+      94,    95,    96,    80,   222,     0,     0,    97,     0,     0,
+      81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,    92,    93,    94,    95,    96,    80,     0,     0,     0,
+      97,     0,     0,    81,    82,    83,    84,    85,    86,    87,
+      88,    89,    90,    91,    92,    93,    94,    95,    96,     0,
+       0,   107,   108,    97,   109,   110,   111,   112,   113,     0,
+       0,     0,     0,   114,   115,     0,     0,     0,     0,   118,
+     119,   116,   120,   121,   122,   123,   124,   151,   118,   119,
+       0,   120,   121,   122,   123,   124,   107,   108,     0,   109,
+     110,   111,   112,   113,     0,   236,     0,     0,   114,   115,
+       0,     0,     0,     0,   238,     0,   116,   137,     0,   117,
+      99,   100,   101,   102,   103,   118,   119,     0,   120,   121,
+     122,   123,   124,   104,   118,   119,     0,   120,   121,   122,
+     123,   124,     0,   105,    81,    82,    83,    84,    85,    86,
+      87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
+       0,     0,     0,     0,    97,    84,    85,    86,    87,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,     0,     0,
+       0,     0,    97,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,     0,     0,     0,     0,    97
 };
 
-static const fftype_int16 ffcheck[] =
+static const yytype_int16 yycheck[] =
 {
-       1,     6,    51,    38,     6,    23,    20,    20,     9,    10,
-       7,    28,    29,    48,    31,    32,    33,    34,    35,    16,
-      21,    22,    23,     1,    25,    26,    48,    28,    23,    23,
-      20,     9,    10,    11,    51,    25,    26,    27,    28,    29,
-      54,    54,    25,    26,    27,    28,    29,    44,    38,    54,
-      28,    52,    53,    54,    55,    38,    53,    23,    48,    40,
-      41,    42,    43,    43,    54,    48,    48,    48,    48,    20,
-      71,    54,    73,    24,    75,    76,    77,    78,    79,    80,
+       1,     6,     6,    22,    22,     7,    42,    43,     9,    10,
+      30,    31,    37,    53,    50,    22,    18,    42,    43,    26,
+      40,     6,    23,    24,    25,    50,    27,    28,    22,    30,
+      50,     1,    22,     6,    22,    22,    26,    56,    56,     9,
+      10,    11,    30,    31,    46,    33,    34,    35,    36,    37,
+      45,    56,    56,    55,    40,    50,    57,    58,    59,    60,
+      30,    25,    56,    25,    50,    25,    25,    50,    56,    50,
+      42,    43,    44,    45,    50,    76,    37,    78,    50,    80,
       81,    82,    83,    84,    85,    86,    87,    88,    89,    90,
-      91,    92,    48,    94,     1,    28,    29,    35,    99,   100,
-      40,    41,     9,    10,     6,    38,    20,    20,    48,     6,
-     111,    24,     6,    54,    21,    48,    94,    24,    25,    26,
-     121,    28,    54,    -1,    -1,   126,    -1,   128,    -1,    -1,
-      -1,    -1,   133,    -1,   135,   113,   114,   115,   116,   117,
-     118,   119,    25,    26,    27,    28,    29,    35,   126,    -1,
-      -1,     1,    40,    41,   132,    38,    27,    28,    29,     9,
-      48,    -1,    -1,    35,    71,    48,    73,    38,    40,    41,
-      -1,    54,    -1,    -1,    24,    -1,    48,    48,    28,    86,
-      -1,    -1,    54,    -1,    20,    -1,    -1,    94,    95,    96,
-      97,    98,    28,    29,    -1,    31,    32,    33,    34,    35,
-      -1,    -1,    25,    26,    27,    28,    29,   208,   209,    -1,
-     211,   212,    -1,   214,    -1,    38,   123,   218,    54,   220,
-      -1,    -1,   223,    -1,   225,    48,    -1,    22,   229,    -1,
-      -1,    54,    -1,    28,    29,   213,    31,    32,    33,    34,
-      35,    -1,    -1,   244,    -1,   246,    -1,   248,    -1,   250,
-      -1,   252,   102,   103,   104,   105,   106,   107,   108,   109,
-     110,    -1,    -1,   264,    -1,   266,    -1,   268,    -1,    -1,
-     271,    25,    26,    27,    28,    29,    -1,   278,    -1,   280,
-      -1,   282,    22,   284,    38,    25,    26,    27,    28,    29,
-      -1,    -1,   293,    -1,    48,    -1,    -1,    51,    38,    31,
-      32,    33,    34,    35,   211,   212,     0,     1,    48,     3,
+      91,    92,    93,    94,    95,    96,    97,     1,    99,     6,
+       6,    22,    22,   104,   105,     9,     6,     6,    27,    28,
+      29,    30,    31,    30,    31,   116,    33,    34,    35,    36,
+      37,    40,    26,     6,     6,   126,    30,   128,    56,    99,
+     131,    50,   133,    22,    53,     6,    53,   138,    22,   140,
+     141,    56,   143,    27,    28,    29,    30,    31,   118,   119,
+     120,   121,   122,   123,   124,    56,    40,    29,    30,    31,
+      56,   131,    -1,    -1,    -1,    -1,    50,   137,    40,    -1,
+      -1,     1,    56,    33,    34,    35,    36,    37,    50,     9,
+      10,    -1,    30,    31,    -1,    33,    34,    35,    36,    37,
+      -1,    -1,    -1,    23,    42,    43,    26,    27,    28,    -1,
+      30,    -1,    50,   107,   108,   109,   110,   111,   112,   113,
+     114,   115,    27,    28,    29,    30,    31,    -1,   219,   220,
+      -1,   222,   223,    -1,   225,    40,    37,    -1,   229,    -1,
+     231,    42,    43,    -1,   235,    50,   237,    -1,    -1,    50,
+     241,    56,    -1,   244,    -1,    56,    76,    -1,    78,    -1,
+      -1,    -1,    30,    31,   224,    33,    34,    35,    36,    37,
+     261,    91,   263,    -1,   265,    -1,   267,    -1,   269,    99,
+     100,   101,   102,   103,    -1,    -1,    -1,    -1,    56,    -1,
+      -1,   185,   186,    -1,    24,   286,    -1,   288,    -1,   290,
+      30,    31,   293,    33,    34,    35,    36,    37,   128,    -1,
+      -1,    -1,   303,    -1,   305,    -1,   307,    -1,   309,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,     0,     1,   319,     3,
        4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
-      14,    15,    16,    17,    18,    19,    -1,   177,   178,    23,
-      28,    29,    -1,    31,    32,    33,    34,    35,    -1,    -1,
-      -1,    35,    36,    38,    39,    40,    41,    42,    43,    -1,
-      44,    45,    46,    48,    -1,    -1,    54,    51,    -1,    53,
-       3,     4,     5,     6,     7,     8,     9,    10,    11,    12,
-      13,    14,    15,    16,    17,    18,    19,    -1,    28,    29,
-      23,    31,    32,    33,    34,    35,    -1,    -1,    -1,    -1,
-      40,    41,    35,    36,    -1,    -1,    -1,    -1,    48,    -1,
-      -1,    44,    45,    46,    54,    -1,    -1,    -1,    -1,    -1,
-      53,    54,     3,     4,     5,     6,     7,     8,     9,    10,
-      11,    12,    13,    14,    15,    16,    17,    18,    19,    -1,
-      -1,    -1,    23,    28,    29,    -1,    31,    32,    33,    34,
-      35,    -1,    -1,    -1,    35,    36,    -1,    -1,    -1,    -1,
-      -1,    -1,    -1,    44,    45,    46,    20,    21,    -1,    54,
-      -1,    -1,    53,    -1,    28,    29,    30,    31,    32,    33,
+      14,    15,    16,    17,    18,    19,    20,    21,    -1,    30,
+      31,    25,    33,    34,    35,    36,    37,    -1,    -1,    -1,
+      -1,    42,    43,    37,    38,    -1,    -1,    -1,    -1,    50,
+      -1,    -1,    46,    47,    48,    56,    -1,    -1,    -1,    53,
+      -1,    55,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
+      21,    -1,   222,   223,    25,    30,    31,    -1,    33,    34,
+      35,    36,    37,    -1,    -1,    -1,    37,    38,    40,    41,
+      42,    43,    44,    45,    -1,    46,    47,    48,    50,    -1,
+      -1,    56,    -1,    -1,    55,    56,     3,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,    21,    -1,    -1,    -1,    25,    24,
+      -1,    -1,    27,    28,    29,    30,    31,    -1,    -1,    -1,
+      37,    38,    -1,    -1,    -1,    40,    -1,    -1,    -1,    46,
+      47,    48,    22,    23,    -1,    50,    -1,    -1,    55,    -1,
+      30,    31,    32,    33,    34,    35,    36,    37,    38,    39,
+      40,    41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,
+      50,    22,    23,    -1,    -1,    -1,    56,    -1,    -1,    30,
+      31,    32,    33,    34,    35,    36,    37,    38,    39,    40,
+      41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,    50,
+      22,    23,    -1,    -1,    -1,    56,    -1,    -1,    30,    31,
+      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
+      42,    43,    44,    45,    -1,    -1,    -1,    -1,    50,    22,
+      23,    -1,    -1,    -1,    56,    -1,    -1,    30,    31,    32,
+      33,    34,    35,    36,    37,    38,    39,    40,    41,    42,
+      43,    44,    45,    -1,    -1,    -1,    -1,    50,    22,    23,
+      -1,    -1,    -1,    56,    -1,    -1,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    -1,    -1,    -1,    48,    20,    21,    -1,    -1,    -1,
-      54,    -1,    -1,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,    41,    42,    43,    -1,
-      -1,    -1,    -1,    48,    20,    21,    -1,    -1,    -1,    54,
-      -1,    -1,    28,    29,    30,    31,    32,    33,    34,    35,
-      36,    37,    38,    39,    40,    41,    42,    43,    -1,    -1,
-      -1,    -1,    48,    20,    21,    -1,    -1,    -1,    54,    -1,
-      -1,    28,    29,    30,    31,    32,    33,    34,    35,    36,
-      37,    38,    39,    40,    41,    42,    43,    -1,    -1,    -1,
-      -1,    48,    20,    21,    -1,    -1,    -1,    54,    -1,    -1,
-      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
-      38,    39,    40,    41,    42,    43,    -1,    -1,    -1,    -1,
-      48,    20,    21,    -1,    -1,    -1,    54,    -1,    -1,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    -1,    -1,    -1,    48,
-      20,    21,    -1,    -1,    -1,    54,    -1,    -1,    28,    29,
+      44,    45,    -1,    -1,    -1,    -1,    50,    22,    23,    -1,
+      -1,    -1,    56,    -1,    -1,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    -1,    -1,    -1,    -1,    50,    22,    23,    -1,    -1,
+      -1,    56,    -1,    -1,    30,    31,    32,    33,    34,    35,
+      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
+      -1,    -1,    -1,    -1,    50,    22,    23,    -1,    -1,    -1,
+      56,    -1,    -1,    30,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    41,    42,    43,    44,    45,    -1,
+      -1,    -1,    -1,    50,    22,    23,    -1,    -1,    -1,    56,
+      -1,    -1,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    -1,    -1,
+      -1,    -1,    50,    23,    -1,    -1,    -1,    -1,    56,    -1,
       30,    31,    32,    33,    34,    35,    36,    37,    38,    39,
-      40,    41,    42,    43,    -1,    -1,    -1,    -1,    48,    21,
-      -1,    -1,    -1,    -1,    54,    -1,    28,    29,    30,    31,
+      40,    41,    42,    43,    44,    45,    -1,    -1,    -1,    -1,
+      50,    23,    -1,    -1,    -1,    -1,    56,    -1,    30,    31,
       32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
-      42,    43,    -1,    -1,    -1,    -1,    48,    21,    -1,    -1,
-      -1,    -1,    54,    -1,    28,    29,    30,    31,    32,    33,
+      42,    43,    44,    45,    -1,    -1,    -1,    -1,    50,    23,
+      -1,    -1,    -1,    -1,    56,    -1,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    -1,    -1,    -1,    48,    21,    -1,    -1,    -1,    -1,
-      54,    -1,    28,    29,    30,    31,    32,    33,    34,    35,
-      36,    37,    38,    39,    40,    41,    42,    43,    -1,    -1,
-      -1,    -1,    48,    21,    -1,    -1,    -1,    -1,    54,    -1,
-      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
-      38,    39,    40,    41,    42,    43,    -1,    -1,    -1,    -1,
-      48,    20,    21,    -1,    -1,    -1,    54,    -1,    -1,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    20,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    -1,    -1,    -1,    50,    23,    -1,    -1,
+      -1,    -1,    56,    -1,    30,    31,    32,    33,    34,    35,
+      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
+      -1,    -1,    -1,    -1,    50,    23,    -1,    -1,    -1,    -1,
+      56,    -1,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    -1,    -1,
+      -1,    -1,    50,    22,    23,    -1,    -1,    -1,    56,    -1,
+      -1,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    22,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    20,    21,    -1,    48,    -1,    -1,    -1,    52,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    20,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    22,    23,    -1,    50,    -1,    -1,    -1,
+      54,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    22,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    20,    21,    -1,    48,    -1,    -1,    -1,    52,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    20,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    22,    23,    -1,    50,    -1,    -1,    -1,
+      54,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    22,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    20,    21,    -1,    48,    -1,    -1,    -1,    52,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    20,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    22,    23,    -1,    50,    -1,    -1,    -1,
+      54,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    22,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    20,    21,    -1,    48,    -1,    -1,    -1,    52,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    20,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    22,    23,    -1,    50,    -1,    -1,    -1,
+      54,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    22,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    20,    21,    -1,    48,    -1,    -1,    -1,    52,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    20,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    22,    23,    -1,    50,    -1,    -1,    -1,
+      54,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    22,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    -1,    21,    -1,    48,    -1,    -1,    -1,    52,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    -1,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    -1,    23,    -1,    50,    -1,    -1,    -1,
+      54,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    -1,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      -1,    -1,    21,    -1,    48,    -1,    -1,    -1,    52,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    -1,    21,    -1,    48,
-      -1,    -1,    -1,    52,    28,    29,    30,    31,    32,    33,
+      44,    45,    -1,    -1,    23,    -1,    50,    -1,    -1,    -1,
+      54,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    -1,    -1,    23,
+      -1,    50,    -1,    -1,    -1,    54,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      20,    21,    -1,    -1,    48,    -1,    -1,    51,    28,    29,
-      30,    31,    32,    33,    34,    35,    36,    37,    38,    39,
-      40,    41,    42,    43,    20,    21,    -1,    -1,    48,    -1,
-      -1,    -1,    28,    29,    30,    31,    32,    33,    34,    35,
-      36,    37,    38,    39,    40,    41,    42,    43,    20,    21,
-      -1,    -1,    48,    -1,    -1,    -1,    28,    29,    30,    31,
+      44,    45,    -1,    -1,    -1,    -1,    50,    -1,    -1,    53,
+      27,    28,    29,    30,    31,    27,    28,    29,    30,    31,
+      -1,    -1,    -1,    40,    -1,    -1,    -1,    -1,    40,    -1,
+      -1,    -1,    -1,    50,    -1,    -1,    -1,    -1,    50,    56,
+      22,    23,    -1,    -1,    56,    -1,    -1,    -1,    30,    31,
       32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
-      42,    43,    20,    21,    -1,    -1,    48,    -1,    -1,    -1,
-      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
-      38,    39,    40,    41,    42,    43,    20,    21,    -1,    -1,
-      48,    -1,    -1,    -1,    28,    29,    30,    31,    32,    33,
+      42,    43,    44,    45,    22,    23,    -1,    -1,    50,    -1,
+      -1,    -1,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    22,    23,
+      -1,    -1,    50,    -1,    -1,    -1,    30,    31,    32,    33,
       34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      20,    21,    -1,    -1,    48,    -1,    -1,    -1,    28,    29,
+      44,    45,    22,    23,    -1,    -1,    50,    -1,    -1,    -1,
       30,    31,    32,    33,    34,    35,    36,    37,    38,    39,
-      40,    41,    42,    43,    21,    -1,    -1,    24,    48,    -1,
-      -1,    28,    29,    30,    31,    32,    33,    34,    35,    36,
-      37,    38,    39,    40,    41,    42,    43,    21,    -1,    -1,
-      24,    48,    -1,    -1,    28,    29,    30,    31,    32,    33,
-      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
-      21,    -1,    -1,    24,    48,    -1,    -1,    28,    29,    30,
-      31,    32,    33,    34,    35,    36,    37,    38,    39,    40,
-      41,    42,    43,    21,    -1,    -1,    24,    48,    -1,    -1,
-      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
-      38,    39,    40,    41,    42,    43,    21,    22,    -1,    -1,
-      48,    -1,    -1,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,    41,    42,    43,    21,
-      22,    -1,    -1,    48,    -1,    -1,    28,    29,    30,    31,
+      40,    41,    42,    43,    44,    45,    22,    23,    -1,    -1,
+      50,    -1,    -1,    -1,    30,    31,    32,    33,    34,    35,
+      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
+      22,    23,    -1,    -1,    50,    -1,    -1,    -1,    30,    31,
       32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
-      42,    43,    21,    -1,    -1,    -1,    48,    -1,    -1,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-      39,    40,    41,    42,    43,    -1,    -1,    28,    29,    48,
-      31,    32,    33,    34,    35,    -1,    -1,    -1,    -1,    40,
-      41,    -1,    -1,    -1,    -1,    28,    29,    48,    31,    32,
-      33,    34,    35,    54,    28,    29,    -1,    31,    32,    33,
-      34,    35,    28,    29,    -1,    31,    32,    33,    34,    35,
-      -1,    54,    -1,    -1,    40,    41,    -1,    -1,    -1,    -1,
-      54,    -1,    48,    20,    -1,    51,    25,    26,    27,    28,
-      29,    28,    29,    -1,    31,    32,    33,    34,    35,    38,
-      28,    29,    -1,    31,    32,    33,    34,    35,    -1,    48,
-      28,    29,    30,    31,    32,    33,    34,    35,    36,    37,
-      38,    39,    40,    41,    42,    43,    -1,    -1,    28,    29,
-      48,    31,    32,    33,    34,    35,    -1,    -1,    -1,    -1,
-      40,    41,    -1,    -1,    -1,    -1,    -1,    -1,    48,    31,
+      42,    43,    44,    45,    22,    23,    -1,    -1,    50,    -1,
+      -1,    -1,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    23,    -1,
+      -1,    26,    50,    -1,    -1,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    23,    -1,    -1,    26,    50,    -1,    -1,    30,    31,
       32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
-      42,    43,    -1,    -1,    -1,    -1,    48,    35,    36,    37,
-      38,    39,    40,    41,    42,    43,    -1,    -1,    -1,    -1,
-      48
+      42,    43,    44,    45,    23,    -1,    -1,    26,    50,    -1,
+      -1,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    23,    -1,    -1,
+      26,    50,    -1,    -1,    30,    31,    32,    33,    34,    35,
+      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
+      23,    24,    -1,    -1,    50,    -1,    -1,    30,    31,    32,
+      33,    34,    35,    36,    37,    38,    39,    40,    41,    42,
+      43,    44,    45,    23,    24,    -1,    -1,    50,    -1,    -1,
+      30,    31,    32,    33,    34,    35,    36,    37,    38,    39,
+      40,    41,    42,    43,    44,    45,    23,    -1,    -1,    -1,
+      50,    -1,    -1,    30,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    41,    42,    43,    44,    45,    -1,
+      -1,    30,    31,    50,    33,    34,    35,    36,    37,    -1,
+      -1,    -1,    -1,    42,    43,    -1,    -1,    -1,    -1,    30,
+      31,    50,    33,    34,    35,    36,    37,    56,    30,    31,
+      -1,    33,    34,    35,    36,    37,    30,    31,    -1,    33,
+      34,    35,    36,    37,    -1,    56,    -1,    -1,    42,    43,
+      -1,    -1,    -1,    -1,    56,    -1,    50,    22,    -1,    53,
+      27,    28,    29,    30,    31,    30,    31,    -1,    33,    34,
+      35,    36,    37,    40,    30,    31,    -1,    33,    34,    35,
+      36,    37,    -1,    50,    30,    31,    32,    33,    34,    35,
+      36,    37,    38,    39,    40,    41,    42,    43,    44,    45,
+      -1,    -1,    -1,    -1,    50,    33,    34,    35,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    -1,    -1,
+      -1,    -1,    50,    37,    38,    39,    40,    41,    42,    43,
+      44,    45,    -1,    -1,    -1,    -1,    50
 };
 
-  /* FFSTOS[STATE-NUM] -- The (internal number of the) accessing
-     symbol of state STATE-NUM.  */
-static const fftype_uint8 ffstos[] =
+/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
+   state STATE-NUM.  */
+static const yytype_int8 yystos[] =
 {
-       0,    56,     0,     1,     3,     4,     5,     6,     7,     8,
+       0,    58,     0,     1,     3,     4,     5,     6,     7,     8,
        9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
-      19,    23,    35,    36,    44,    45,    46,    51,    53,    57,
-      58,    59,    60,    61,    62,    63,    51,    54,    60,    61,
-      62,    63,    60,    61,    62,    63,    60,    61,    63,     6,
-      54,     6,    23,    23,    23,    23,    60,    61,    63,    60,
-      60,    61,    62,    60,    61,    60,    61,    60,    61,    62,
-      63,    20,    24,    20,    24,    21,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
-      42,    43,    48,    51,    25,    26,    27,    28,    29,    38,
-      48,    51,    28,    29,    31,    32,    33,    34,    35,    40,
-      41,    48,    51,    28,    29,    31,    32,    33,    34,    35,
-      51,    20,    54,    20,    54,    54,    20,    54,    20,    54,
-      54,    54,    20,    20,    54,    20,    54,    60,    60,    60,
-      60,    54,    54,    54,    54,    60,    61,    60,    61,    60,
-      60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
-      60,    61,    60,    60,    60,    60,    60,    60,    60,    61,
-      63,    61,    61,    61,    61,    60,    60,    44,    53,    62,
-      62,    62,    62,    62,    62,    62,    62,    62,    60,    63,
-      63,    63,    63,    63,    63,    63,    60,    61,    60,    63,
-      60,    63,    60,    60,    24,    24,    24,    24,    22,    20,
-      52,    22,    22,    22,    20,    52,    62,    62,    20,    52,
-      20,    54,    54,    20,    54,    20,    54,    20,    54,    20,
-      60,    60,    60,    61,    60,    61,    63,    60,    60,    60,
-      60,    60,     6,    60,    20,    52,    20,    52,    20,    52,
-      20,    54,    20,    54,    20,    20,    54,    60,    60,    60,
-      60,    60,     6,     6,    20,    52,    20,    52,    20,    52,
-      54,    20,    54,    54,    60,    60,    60,    60,    20,    52,
-      20,    52,    20,    52,    20,    54,    60,    60,    60,    60,
-      52,    52,    52,    20,    60,    54
+      19,    20,    21,    25,    37,    38,    46,    47,    48,    53,
+      55,    59,    60,    61,    62,    63,    64,    65,    53,    56,
+      62,    63,    64,    65,    62,    63,    64,    65,    62,    63,
+      65,     6,    56,     6,     6,    56,     6,    25,    25,    25,
+      25,    62,    63,    65,    62,    62,    63,    64,    62,    63,
+      62,    63,    62,    63,    64,    65,    22,    26,    22,    26,
+      23,    30,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    50,    53,    27,
+      28,    29,    30,    31,    40,    50,    53,    30,    31,    33,
+      34,    35,    36,    37,    42,    43,    50,    53,    30,    31,
+      33,    34,    35,    36,    37,    53,    22,    56,    22,    56,
+      56,    22,    56,    22,    56,    56,    56,    22,    22,    56,
+      22,    22,    56,    22,    56,    62,    62,    62,    62,    56,
+      56,    56,    56,    62,    63,    62,    63,    62,    62,    62,
+      62,    62,    62,    62,    62,    62,    62,    62,    62,    63,
+      62,    62,    62,    62,    62,    62,    62,    63,    65,    63,
+      63,    63,    63,    62,    62,    46,    55,    64,    64,    64,
+      64,    64,    64,    64,    64,    64,    62,    65,    65,    65,
+      65,    65,    65,    65,    62,    62,    63,    62,    65,    62,
+      65,    62,    62,    62,    62,    26,    26,    26,    26,    24,
+      22,    54,    24,    24,    24,    22,    54,    64,    64,    22,
+      54,    22,    56,    56,    56,    22,    56,    22,    56,    22,
+      56,    22,    22,    56,    22,    62,    62,    62,    63,    62,
+      63,    65,    62,    62,    62,    62,    62,     6,    62,     6,
+      62,    22,    54,    22,    54,    22,    54,    22,    56,    22,
+      56,    22,    22,    56,    22,    22,    56,    62,    62,    62,
+      62,    62,     6,     6,     6,     6,    22,    54,    22,    54,
+      22,    54,    56,    22,    56,    22,    56,    56,    62,    62,
+      62,    62,     6,    22,    54,    22,    54,    22,    54,    22,
+      56,    56,    62,    62,    62,    62,    54,    54,    54,    22,
+      62,    56
 };
 
-  /* FFR1[FFN] -- Symbol number of symbol that rule FFN derives.  */
-static const fftype_uint8 ffr1[] =
+/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr1[] =
 {
-       0,    55,    56,    56,    57,    57,    57,    57,    57,    57,
-      58,    58,    59,    59,    59,    59,    60,    61,    62,    62,
+       0,    57,    58,    58,    59,    59,    59,    59,    59,    59,
+      60,    60,    61,    61,    61,    61,    62,    63,    64,    64,
+      64,    64,    64,    64,    64,    64,    64,    64,    64,    64,
+      64,    62,    62,    62,    62,    62,    62,    62,    62,    62,
       62,    62,    62,    62,    62,    62,    62,    62,    62,    62,
-      62,    60,    60,    60,    60,    60,    60,    60,    60,    60,
-      60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
-      60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
-      60,    60,    60,    60,    60,    60,    60,    60,    60,    60,
-      60,    61,    61,    61,    61,    61,    61,    61,    61,    61,
-      61,    61,    61,    61,    61,    61,    61,    61,    61,    61,
-      61,    61,    61,    61,    61,    61,    61,    61,    61,    61,
-      61,    61,    61,    61,    61,    61,    61,    61,    61,    61,
-      61,    61,    61,    61,    61,    61,    61,    61,    61,    61,
-      63,    63,    63,    63,    63,    63,    63,    63,    63
+      62,    62,    62,    62,    62,    62,    62,    62,    62,    62,
+      62,    62,    62,    62,    62,    62,    62,    62,    62,    62,
+      62,    62,    63,    63,    63,    63,    63,    63,    63,    63,
+      63,    63,    63,    63,    63,    63,    63,    63,    63,    63,
+      63,    63,    63,    63,    63,    63,    63,    63,    63,    63,
+      63,    63,    63,    63,    63,    63,    63,    63,    63,    63,
+      63,    63,    63,    63,    63,    63,    63,    63,    63,    63,
+      63,    63,    63,    63,    63,    63,    63,    65,    65,    65,
+      65,    65,    65,    65,    65,    65
 };
 
-  /* FFR2[FFN] -- Number of symbols on the right hand side of rule FFN.  */
-static const fftype_uint8 ffr2[] =
+/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr2[] =
 {
        0,     2,     0,     2,     1,     2,     2,     2,     2,     2,
        2,     3,     2,     3,     3,     3,     2,     2,     1,     1,
        4,     3,     3,     3,     4,     6,     8,    10,    12,     2,
        3,     1,     1,     1,     4,     1,     1,     3,     3,     3,
        3,     3,     3,     3,     3,     3,     2,     2,     3,     3,
-       3,     5,     5,     5,     2,     3,     3,     3,     3,     5,
-       5,     9,     4,     6,     8,    10,    12,     2,     2,     2,
-       2,     1,     1,     4,     3,     3,     3,     3,     3,     3,
+       3,     5,     5,     5,     2,     3,     5,     3,     3,     3,
+       5,     5,     9,     4,     6,     8,    10,    12,     2,     2,
+       2,     2,     1,     1,     4,     3,     3,     3,     3,     3,
        3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
-       3,     3,     3,     3,     3,     3,     3,     5,     5,     3,
-       3,     3,     5,     7,    11,    15,     2,     3,     5,     9,
-       3,     7,     9,     4,     6,     8,    10,    12,     2,     3,
-       1,     1,     4,     1,     3,     3,     5,     5,     7
+       3,     3,     3,     3,     3,     3,     3,     3,     5,     5,
+       3,     3,     3,     5,     7,    11,    15,     2,     3,     5,
+       9,     7,    11,     2,     3,     5,     9,     3,     7,     9,
+       4,     6,     8,    10,    12,     2,     3,     1,     1,     4,
+       1,     3,     3,     5,     5,     7
 };
 
 
-#define fferrok         (fferrstatus = 0)
-#define ffclearin       (ffchar = FFEMPTY)
-#define FFEMPTY         (-2)
-#define FFEOF           0
-
-#define FFACCEPT        goto ffacceptlab
-#define FFABORT         goto ffabortlab
-#define FFERROR         goto fferrorlab
-
-
-#define FFRECOVERING()  (!!fferrstatus)
-
-#define FFBACKUP(Token, Value)                                  \
-do                                                              \
-  if (ffchar == FFEMPTY)                                        \
-    {                                                           \
-      ffchar = (Token);                                         \
-      fflval = (Value);                                         \
-      FFPOPSTACK (fflen);                                       \
-      ffstate = *ffssp;                                         \
-      goto ffbackup;                                            \
-    }                                                           \
-  else                                                          \
-    {                                                           \
-      fferror (FF_("syntax error: cannot back up")); \
-      FFERROR;                                                  \
-    }                                                           \
-while (0)
-
-/* Error token number */
-#define FFTERROR        1
-#define FFERRCODE       256
+enum { YYENOMEM = -2 };
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = FITS_PARSER_YYEMPTY)
 
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+#define YYNOMEM         goto yyexhaustedlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == FITS_PARSER_YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (scanner, lParse, YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Backward compatibility with an undocumented macro.
+   Use FITS_PARSER_YYerror or FITS_PARSER_YYUNDEF. */
+#define YYERRCODE FITS_PARSER_YYUNDEF
 
 
 /* Enable debugging if requested.  */
-#if FFDEBUG
+#if FITS_PARSER_YYDEBUG
 
-# ifndef FFFPRINTF
+# ifndef YYFPRINTF
 #  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define FFFPRINTF fprintf
+#  define YYFPRINTF fprintf
 # endif
 
-# define FFDPRINTF(Args)                        \
+# define YYDPRINTF(Args)                        \
 do {                                            \
-  if (ffdebug)                                  \
-    FFFPRINTF Args;                             \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
 } while (0)
 
-/* This macro is provided for backward compatibility. */
-#ifndef FF_LOCATION_PRINT
-# define FF_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
 
 
-# define FF_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
 do {                                                                      \
-  if (ffdebug)                                                            \
+  if (yydebug)                                                            \
     {                                                                     \
-      FFFPRINTF (stderr, "%s ", Title);                                   \
-      ff_symbol_print (stderr,                                            \
-                  Type, Value); \
-      FFFPRINTF (stderr, "\n");                                           \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Kind, Value, scanner, lParse); \
+      YYFPRINTF (stderr, "\n");                                           \
     }                                                                     \
 } while (0)
 
 
-/*----------------------------------------.
-| Print this symbol's value on FFOUTPUT.  |
-`----------------------------------------*/
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
 
 static void
-ff_symbol_value_print (FILE *ffoutput, int fftype, FFSTYPE const * const ffvaluep)
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, yyscan_t scanner, ParseData *lParse)
 {
-  FILE *ffo = ffoutput;
-  FFUSE (ffo);
-  if (!ffvaluep)
+  FILE *yyoutput = yyo;
+  YY_USE (yyoutput);
+  YY_USE (scanner);
+  YY_USE (lParse);
+  if (!yyvaluep)
     return;
-# ifdef FFPRINT
-  if (fftype < FFNTOKENS)
-    FFPRINT (ffoutput, fftoknum[fftype], *ffvaluep);
-# endif
-  FFUSE (fftype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
-/*--------------------------------.
-| Print this symbol on FFOUTPUT.  |
-`--------------------------------*/
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
 
 static void
-ff_symbol_print (FILE *ffoutput, int fftype, FFSTYPE const * const ffvaluep)
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, yyscan_t scanner, ParseData *lParse)
 {
-  FFFPRINTF (ffoutput, "%s %s (",
-             fftype < FFNTOKENS ? "token" : "nterm", fftname[fftype]);
+  YYFPRINTF (yyo, "%s %s (",
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
 
-  ff_symbol_value_print (ffoutput, fftype, ffvaluep);
-  FFFPRINTF (ffoutput, ")");
+  yy_symbol_value_print (yyo, yykind, yyvaluep, scanner, lParse);
+  YYFPRINTF (yyo, ")");
 }
 
 /*------------------------------------------------------------------.
-| ff_stack_print -- Print the state stack from its BOTTOM up to its |
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
 static void
-ff_stack_print (fftype_int16 *ffbottom, fftype_int16 *fftop)
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
 {
-  FFFPRINTF (stderr, "Stack now");
-  for (; ffbottom <= fftop; ffbottom++)
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
     {
-      int ffbot = *ffbottom;
-      FFFPRINTF (stderr, " %d", ffbot);
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
     }
-  FFFPRINTF (stderr, "\n");
+  YYFPRINTF (stderr, "\n");
 }
 
-# define FF_STACK_PRINT(Bottom, Top)                            \
+# define YY_STACK_PRINT(Bottom, Top)                            \
 do {                                                            \
-  if (ffdebug)                                                  \
-    ff_stack_print ((Bottom), (Top));                           \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
 } while (0)
 
 
 /*------------------------------------------------.
-| Report that the FFRULE is going to be reduced.  |
+| Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
 static void
-ff_reduce_print (fftype_int16 *ffssp, FFSTYPE *ffvsp, int ffrule)
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
+                 int yyrule, yyscan_t scanner, ParseData *lParse)
 {
-  unsigned long int fflno = ffrline[ffrule];
-  int ffnrhs = ffr2[ffrule];
-  int ffi;
-  FFFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-             ffrule - 1, fflno);
+  int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
+             yyrule - 1, yylno);
   /* The symbols being reduced.  */
-  for (ffi = 0; ffi < ffnrhs; ffi++)
+  for (yyi = 0; yyi < yynrhs; yyi++)
     {
-      FFFPRINTF (stderr, "   $%d = ", ffi + 1);
-      ff_symbol_print (stderr,
-                       ffstos[ffssp[ffi + 1 - ffnrhs]],
-                       &(ffvsp[(ffi + 1) - (ffnrhs)])
-                                              );
-      FFFPRINTF (stderr, "\n");
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)], scanner, lParse);
+      YYFPRINTF (stderr, "\n");
     }
 }
 
-# define FF_REDUCE_PRINT(Rule)          \
+# define YY_REDUCE_PRINT(Rule)          \
 do {                                    \
-  if (ffdebug)                          \
-    ff_reduce_print (ffssp, ffvsp, Rule); \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule, scanner, lParse); \
 } while (0)
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
-int ffdebug;
-#else /* !FFDEBUG */
-# define FFDPRINTF(Args)
-# define FF_SYMBOL_PRINT(Title, Type, Value, Location)
-# define FF_STACK_PRINT(Bottom, Top)
-# define FF_REDUCE_PRINT(Rule)
-#endif /* !FFDEBUG */
+int yydebug;
+#else /* !FITS_PARSER_YYDEBUG */
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !FITS_PARSER_YYDEBUG */
 
 
-/* FFINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef FFINITDEPTH
-# define FFINITDEPTH 200
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
 #endif
 
-/* FFMAXDEPTH -- maximum size the stacks can grow to (effective only
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   FFSTACK_ALLOC_MAXIMUM < FFSTACK_BYTES (FFMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#ifndef FFMAXDEPTH
-# define FFMAXDEPTH 10000
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
 #endif
 
 
-#if FFERROR_VERBOSE
-
-# ifndef ffstrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define ffstrlen strlen
-#  else
-/* Return the length of FFSTR.  */
-static FFSIZE_T
-ffstrlen (const char *ffstr)
-{
-  FFSIZE_T fflen;
-  for (fflen = 0; ffstr[fflen]; fflen++)
-    continue;
-  return fflen;
-}
-#  endif
-# endif
-
-# ifndef ffstpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define ffstpcpy stpcpy
-#  else
-/* Copy FFSRC to FFDEST, returning the address of the terminating '\0' in
-   FFDEST.  */
-static char *
-ffstpcpy (char *ffdest, const char *ffsrc)
-{
-  char *ffd = ffdest;
-  const char *ffs = ffsrc;
-
-  while ((*ffd++ = *ffs++) != '\0')
-    continue;
-
-  return ffd - 1;
-}
-#  endif
-# endif
-
-# ifndef fftnamerr
-/* Copy to FFRES the contents of FFSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for fferror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  FFSTR is taken from fftname.  If FFRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static FFSIZE_T
-fftnamerr (char *ffres, const char *ffstr)
-{
-  if (*ffstr == '"')
-    {
-      FFSIZE_T ffn = 0;
-      char const *ffp = ffstr;
-
-      for (;;)
-        switch (*++ffp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++ffp != '\\')
-              goto do_not_strip_quotes;
-            /* Fall through.  */
-          default:
-            if (ffres)
-              ffres[ffn] = *ffp;
-            ffn++;
-            break;
 
-          case '"':
-            if (ffres)
-              ffres[ffn] = '\0';
-            return ffn;
-          }
-    do_not_strip_quotes: ;
-    }
 
-  if (! ffres)
-    return ffstrlen (ffstr);
 
-  return ffstpcpy (ffres, ffstr) - ffres;
-}
-# endif
-
-/* Copy into *FFMSG, which is of size *FFMSG_ALLOC, an error message
-   about the unexpected token FFTOKEN for the state stack whose top is
-   FFSSP.
-
-   Return 0 if *FFMSG was successfully written.  Return 1 if *FFMSG is
-   not large enough to hold the message.  In that case, also set
-   *FFMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-ffsyntax_error (FFSIZE_T *ffmsg_alloc, char **ffmsg,
-                fftype_int16 *ffssp, int fftoken)
-{
-  FFSIZE_T ffsize0 = fftnamerr (FF_NULLPTR, fftname[fftoken]);
-  FFSIZE_T ffsize = ffsize0;
-  enum { FFERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *ffformat = FF_NULLPTR;
-  /* Arguments of ffformat. */
-  char const *ffarg[FFERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int ffcount = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in ffchar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated ffchar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (fftoken != FFEMPTY)
-    {
-      int ffn = ffpact[*ffssp];
-      ffarg[ffcount++] = fftname[fftoken];
-      if (!ffpact_value_is_default (ffn))
-        {
-          /* Start FFX at -FFN if negative to avoid negative indexes in
-             FFCHECK.  In other words, skip the first -FFN actions for
-             this state because they are default actions.  */
-          int ffxbegin = ffn < 0 ? -ffn : 0;
-          /* Stay within bounds of both ffcheck and fftname.  */
-          int ffchecklim = FFLAST - ffn + 1;
-          int ffxend = ffchecklim < FFNTOKENS ? ffchecklim : FFNTOKENS;
-          int ffx;
-
-          for (ffx = ffxbegin; ffx < ffxend; ++ffx)
-            if (ffcheck[ffx + ffn] == ffx && ffx != FFTERROR
-                && !fftable_value_is_error (fftable[ffx + ffn]))
-              {
-                if (ffcount == FFERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    ffcount = 1;
-                    ffsize = ffsize0;
-                    break;
-                  }
-                ffarg[ffcount++] = fftname[ffx];
-                {
-                  FFSIZE_T ffsize1 = ffsize + fftnamerr (FF_NULLPTR, fftname[ffx]);
-                  if (! (ffsize <= ffsize1
-                         && ffsize1 <= FFSTACK_ALLOC_MAXIMUM))
-                    return 2;
-                  ffsize = ffsize1;
-                }
-              }
-        }
-    }
-
-  switch (ffcount)
-    {
-# define FFCASE_(N, S)                      \
-      case N:                               \
-        ffformat = S;                       \
-      break
-    default: /* Avoid compiler warnings. */
-      FFCASE_(0, FF_("syntax error"));
-      FFCASE_(1, FF_("syntax error, unexpected %s"));
-      FFCASE_(2, FF_("syntax error, unexpected %s, expecting %s"));
-      FFCASE_(3, FF_("syntax error, unexpected %s, expecting %s or %s"));
-      FFCASE_(4, FF_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      FFCASE_(5, FF_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef FFCASE_
-    }
-
-  {
-    FFSIZE_T ffsize1 = ffsize + ffstrlen (ffformat);
-    if (! (ffsize <= ffsize1 && ffsize1 <= FFSTACK_ALLOC_MAXIMUM))
-      return 2;
-    ffsize = ffsize1;
-  }
-
-  if (*ffmsg_alloc < ffsize)
-    {
-      *ffmsg_alloc = 2 * ffsize;
-      if (! (ffsize <= *ffmsg_alloc
-             && *ffmsg_alloc <= FFSTACK_ALLOC_MAXIMUM))
-        *ffmsg_alloc = FFSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *ffp = *ffmsg;
-    int ffi = 0;
-    while ((*ffp = *ffformat) != '\0')
-      if (*ffp == '%' && ffformat[1] == 's' && ffi < ffcount)
-        {
-          ffp += fftnamerr (ffp, ffarg[ffi++]);
-          ffformat += 2;
-        }
-      else
-        {
-          ffp++;
-          ffformat++;
-        }
-  }
-  return 0;
-}
-#endif /* FFERROR_VERBOSE */
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
 static void
-ffdestruct (const char *ffmsg, int fftype, FFSTYPE *ffvaluep)
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, yyscan_t scanner, ParseData *lParse)
 {
-  FFUSE (ffvaluep);
-  if (!ffmsg)
-    ffmsg = "Deleting";
-  FF_SYMBOL_PRINT (ffmsg, fftype, ffvaluep, fflocationp);
-
-  FF_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  FFUSE (fftype);
-  FF_IGNORE_MAYBE_UNINITIALIZED_END
+  YY_USE (yyvaluep);
+  YY_USE (scanner);
+  YY_USE (lParse);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
 
 
-/* The lookahead symbol.  */
-int ffchar;
-
-/* The semantic value of the lookahead symbol.  */
-FFSTYPE fflval;
-/* Number of syntax errors so far.  */
-int ffnerrs;
 
 
 /*----------.
-| ffparse.  |
+| yyparse.  |
 `----------*/
 
 int
-ffparse (void)
+yyparse (yyscan_t scanner, ParseData *lParse)
 {
-    int ffstate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int fferrstatus;
+/* Lookahead token kind.  */
+int yychar;
+
+
+/* The semantic value of the lookahead symbol.  */
+/* Default value used for initialization, for pacifying older GCCs
+   or non-GCC compilers.  */
+YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
+YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
+
+    /* Number of syntax errors so far.  */
+    int yynerrs = 0;
 
-    /* The stacks and their tools:
-       'ffss': related to states.
-       'ffvs': related to semantic values.
+    yy_state_fast_t yystate = 0;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus = 0;
 
-       Refer to the stacks through separate pointers, to allow ffoverflow
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
-    /* The state stack.  */
-    fftype_int16 ffssa[FFINITDEPTH];
-    fftype_int16 *ffss;
-    fftype_int16 *ffssp;
-
-    /* The semantic value stack.  */
-    FFSTYPE ffvsa[FFINITDEPTH];
-    FFSTYPE *ffvs;
-    FFSTYPE *ffvsp;
-
-    FFSIZE_T ffstacksize;
-
-  int ffn;
-  int ffresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int fftoken = 0;
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
+
+    /* The state stack: array, bottom, top.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
+
+    /* The semantic value stack: array, bottom, top.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
+
+  int yyn;
+  /* The return value of yyparse.  */
+  int yyresult;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
   /* The variables used to return semantic value and location from the
      action routines.  */
-  FFSTYPE ffval;
+  YYSTYPE yyval;
+
 
-#if FFERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char ffmsgbuf[128];
-  char *ffmsg = ffmsgbuf;
-  FFSIZE_T ffmsg_alloc = sizeof ffmsgbuf;
-#endif
 
-#define FFPOPSTACK(N)   (ffvsp -= (N), ffssp -= (N))
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   /* The number of symbols on the RHS of the reduced rule.
      Keep to zero when no symbol should be popped.  */
-  int fflen = 0;
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yychar = FITS_PARSER_YYEMPTY; /* Cause a token to be read.  */
+
+  goto yysetstate;
 
-  ffssp = ffss = ffssa;
-  ffvsp = ffvs = ffvsa;
-  ffstacksize = FFINITDEPTH;
-
-  FFDPRINTF ((stderr, "Starting parse\n"));
-
-  ffstate = 0;
-  fferrstatus = 0;
-  ffnerrs = 0;
-  ffchar = FFEMPTY; /* Cause a token to be read.  */
-  goto ffsetstate;
 
 /*------------------------------------------------------------.
-| ffnewstate -- Push a new state, which is found in ffstate.  |
+| yynewstate -- push a new state, which is found in yystate.  |
 `------------------------------------------------------------*/
- ffnewstate:
+yynewstate:
   /* In all cases, when you get here, the value and location stacks
      have just been pushed.  So pushing a state here evens the stacks.  */
-  ffssp++;
+  yyssp++;
 
- ffsetstate:
-  *ffssp = ffstate;
 
-  if (ffss + ffstacksize - 1 <= ffssp)
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
+
+  if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    YYNOMEM;
+#else
     {
       /* Get the current used size of the three stacks, in elements.  */
-      FFSIZE_T ffsize = ffssp - ffss + 1;
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
 
-#ifdef ffoverflow
+# if defined yyoverflow
       {
         /* Give user a chance to reallocate the stack.  Use copies of
            these so that the &'s don't force the real ones into
            memory.  */
-        FFSTYPE *ffvs1 = ffvs;
-        fftype_int16 *ffss1 = ffss;
+        yy_state_t *yyss1 = yyss;
+        YYSTYPE *yyvs1 = yyvs;
 
         /* Each stack pointer address is followed by the size of the
            data in use in that stack, in bytes.  This used to be a
            conditional around just the two extra args, but that might
-           be undefined if ffoverflow is a macro.  */
-        ffoverflow (FF_("memory exhausted"),
-                    &ffss1, ffsize * sizeof (*ffssp),
-                    &ffvs1, ffsize * sizeof (*ffvsp),
-                    &ffstacksize);
-
-        ffss = ffss1;
-        ffvs = ffvs1;
-      }
-#else /* no ffoverflow */
-# ifndef FFSTACK_RELOCATE
-      goto ffexhaustedlab;
-# else
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
+                    &yystacksize);
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+# else /* defined YYSTACK_RELOCATE */
       /* Extend the stack our own way.  */
-      if (FFMAXDEPTH <= ffstacksize)
-        goto ffexhaustedlab;
-      ffstacksize *= 2;
-      if (FFMAXDEPTH < ffstacksize)
-        ffstacksize = FFMAXDEPTH;
+      if (YYMAXDEPTH <= yystacksize)
+        YYNOMEM;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
 
       {
-        fftype_int16 *ffss1 = ffss;
-        union ffalloc *ffptr =
-          (union ffalloc *) FFSTACK_ALLOC (FFSTACK_BYTES (ffstacksize));
-        if (! ffptr)
-          goto ffexhaustedlab;
-        FFSTACK_RELOCATE (ffss_alloc, ffss);
-        FFSTACK_RELOCATE (ffvs_alloc, ffvs);
-#  undef FFSTACK_RELOCATE
-        if (ffss1 != ffssa)
-          FFSTACK_FREE (ffss1);
+        yy_state_t *yyss1 = yyss;
+        union yyalloc *yyptr =
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
+        if (! yyptr)
+          YYNOMEM;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
       }
 # endif
-#endif /* no ffoverflow */
 
-      ffssp = ffss + ffsize - 1;
-      ffvsp = ffvs + ffsize - 1;
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
 
-      FFDPRINTF ((stderr, "Stack size increased to %lu\n",
-                  (unsigned long int) ffstacksize));
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
 
-      if (ffss + ffstacksize - 1 <= ffssp)
-        FFABORT;
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
     }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
+
 
-  FFDPRINTF ((stderr, "Entering state %d\n", ffstate));
+  if (yystate == YYFINAL)
+    YYACCEPT;
 
-  if (ffstate == FFFINAL)
-    FFACCEPT;
+  goto yybackup;
 
-  goto ffbackup;
 
 /*-----------.
-| ffbackup.  |
+| yybackup.  |
 `-----------*/
-ffbackup:
-
+yybackup:
   /* Do appropriate processing given the current state.  Read a
      lookahead token if we need one and don't already have one.  */
 
   /* First try to decide what to do without reference to lookahead token.  */
-  ffn = ffpact[ffstate];
-  if (ffpact_value_is_default (ffn))
-    goto ffdefault;
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* FFCHAR is either FFEMPTY or FFEOF or a valid lookahead symbol.  */
-  if (ffchar == FFEMPTY)
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
+  if (yychar == FITS_PARSER_YYEMPTY)
     {
-      FFDPRINTF ((stderr, "Reading a token: "));
-      ffchar = fflex ();
+      YYDPRINTF ((stderr, "Reading a token\n"));
+      yychar = yylex (&yylval, scanner);
     }
 
-  if (ffchar <= FFEOF)
+  if (yychar <= FITS_PARSER_YYEOF)
+    {
+      yychar = FITS_PARSER_YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else if (yychar == FITS_PARSER_YYerror)
     {
-      ffchar = fftoken = FFEOF;
-      FFDPRINTF ((stderr, "Now at end of input.\n"));
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = FITS_PARSER_YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      goto yyerrlab1;
     }
   else
     {
-      fftoken = FFTRANSLATE (ffchar);
-      FF_SYMBOL_PRINT ("Next token is", fftoken, &fflval, &fflloc);
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  /* If the proper action on seeing token FFTOKEN is to reduce or to
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
      detect an error, take that action.  */
-  ffn += fftoken;
-  if (ffn < 0 || FFLAST < ffn || ffcheck[ffn] != fftoken)
-    goto ffdefault;
-  ffn = fftable[ffn];
-  if (ffn <= 0)
-    {
-      if (fftable_value_is_error (ffn))
-        goto fferrlab;
-      ffn = -ffn;
-      goto ffreduce;
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
     }
 
   /* Count tokens shifted since error; after three, turn off error
      status.  */
-  if (fferrstatus)
-    fferrstatus--;
+  if (yyerrstatus)
+    yyerrstatus--;
 
   /* Shift the lookahead token.  */
-  FF_SYMBOL_PRINT ("Shifting", fftoken, &fflval, &fflloc);
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 
   /* Discard the shifted token.  */
-  ffchar = FFEMPTY;
-
-  ffstate = ffn;
-  FF_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++ffvsp = fflval;
-  FF_IGNORE_MAYBE_UNINITIALIZED_END
-
-  goto ffnewstate;
+  yychar = FITS_PARSER_YYEMPTY;
+  goto yynewstate;
 
 
 /*-----------------------------------------------------------.
-| ffdefault -- do the default action for the current state.  |
+| yydefault -- do the default action for the current state.  |
 `-----------------------------------------------------------*/
-ffdefault:
-  ffn = ffdefact[ffstate];
-  if (ffn == 0)
-    goto fferrlab;
-  goto ffreduce;
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
 
 
 /*-----------------------------.
-| ffreduce -- Do a reduction.  |
+| yyreduce -- do a reduction.  |
 `-----------------------------*/
-ffreduce:
-  /* ffn is the number of a rule to reduce with.  */
-  fflen = ffr2[ffn];
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
 
-  /* If FFLEN is nonzero, implement the default value of the action:
+  /* If YYLEN is nonzero, implement the default value of the action:
      '$$ = $1'.
 
-     Otherwise, the following line sets FFVAL to garbage.
+     Otherwise, the following line sets YYVAL to garbage.
      This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to FFVAL
+     users should not rely upon it.  Assigning to YYVAL
      unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that FFVAL may be used uninitialized.  */
-  ffval = ffvsp[1-fflen];
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
 
 
-  FF_REDUCE_PRINT (ffn);
-  switch (ffn)
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
     {
-        case 4:
-#line 248 "eval.y" /* yacc.c:1648  */
-    {}
-#line 1922 "y.tab.c" /* yacc.c:1648  */
+  case 4: /* line: '\n'  */
+#line 270 "eval.y"
+                     {}
+#line 1821 "eval_y.c"
     break;
 
-  case 5:
-#line 250 "eval.y" /* yacc.c:1648  */
-    { if( (ffvsp[-1].Node)<0 ) {
-		     fferror("Couldn't build node structure: out of memory?");
-		     FFERROR;  }
-                  gParse.resultNode = (ffvsp[-1].Node);
+  case 5: /* line: expr '\n'  */
+#line 272 "eval.y"
+                { if( (yyvsp[-1].Node)<0 ) {
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
+		     YYERROR;  }
+                  lParse->resultNode = (yyvsp[-1].Node);
 		}
-#line 1932 "y.tab.c" /* yacc.c:1648  */
+#line 1831 "eval_y.c"
     break;
 
-  case 6:
-#line 256 "eval.y" /* yacc.c:1648  */
-    { if( (ffvsp[-1].Node)<0 ) {
-		     fferror("Couldn't build node structure: out of memory?");
-		     FFERROR;  }
-                  gParse.resultNode = (ffvsp[-1].Node);
+  case 6: /* line: bexpr '\n'  */
+#line 278 "eval.y"
+                { if( (yyvsp[-1].Node)<0 ) {
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
+		     YYERROR;  }
+                  lParse->resultNode = (yyvsp[-1].Node);
 		}
-#line 1942 "y.tab.c" /* yacc.c:1648  */
+#line 1841 "eval_y.c"
     break;
 
-  case 7:
-#line 262 "eval.y" /* yacc.c:1648  */
-    { if( (ffvsp[-1].Node)<0 ) {
-		     fferror("Couldn't build node structure: out of memory?");
-		     FFERROR;  } 
-                  gParse.resultNode = (ffvsp[-1].Node);
+  case 7: /* line: sexpr '\n'  */
+#line 284 "eval.y"
+                { if( (yyvsp[-1].Node)<0 ) {
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
+		     YYERROR;  } 
+                  lParse->resultNode = (yyvsp[-1].Node);
 		}
-#line 1952 "y.tab.c" /* yacc.c:1648  */
+#line 1851 "eval_y.c"
     break;
 
-  case 8:
-#line 268 "eval.y" /* yacc.c:1648  */
-    { if( (ffvsp[-1].Node)<0 ) {
-		     fferror("Couldn't build node structure: out of memory?");
-		     FFERROR;  }
-                  gParse.resultNode = (ffvsp[-1].Node);
+  case 8: /* line: bits '\n'  */
+#line 290 "eval.y"
+                { if( (yyvsp[-1].Node)<0 ) {
+		     yyerror(scanner, lParse, "Couldn't build node structure: out of memory?");
+		     YYERROR;  }
+                  lParse->resultNode = (yyvsp[-1].Node);
 		}
-#line 1962 "y.tab.c" /* yacc.c:1648  */
+#line 1861 "eval_y.c"
     break;
 
-  case 9:
-#line 273 "eval.y" /* yacc.c:1648  */
-    {  fferrok;  }
-#line 1968 "y.tab.c" /* yacc.c:1648  */
+  case 9: /* line: error '\n'  */
+#line 295 "eval.y"
+                     {  yyerrok;  }
+#line 1867 "eval_y.c"
     break;
 
-  case 10:
-#line 277 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Vector( (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 1974 "y.tab.c" /* yacc.c:1648  */
+  case 10: /* bvector: '{' bexpr  */
+#line 299 "eval.y"
+                { (yyval.Node) = New_Vector(lParse,  (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 1873 "eval_y.c"
     break;
 
-  case 11:
-#line 279 "eval.y" /* yacc.c:1648  */
-    {
-                  if( gParse.Nodes[(ffvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
-		     (ffvsp[-2].Node) = Close_Vec( (ffvsp[-2].Node) ); TEST((ffvsp[-2].Node));
-		     (ffval.Node) = New_Vector( (ffvsp[-2].Node) ); TEST((ffval.Node));
+  case 11: /* bvector: bvector ',' bexpr  */
+#line 301 "eval.y"
+                {
+                  if( lParse->Nodes[(yyvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
+		     (yyvsp[-2].Node) = Close_Vec(lParse,  (yyvsp[-2].Node) ); TEST((yyvsp[-2].Node));
+		     (yyval.Node) = New_Vector(lParse,  (yyvsp[-2].Node) ); TEST((yyval.Node));
                   } else {
-                     (ffval.Node) = (ffvsp[-2].Node);
+                     (yyval.Node) = (yyvsp[-2].Node);
                   }
-		  gParse.Nodes[(ffval.Node)].SubNodes[ gParse.Nodes[(ffval.Node)].nSubNodes++ ]
-		     = (ffvsp[0].Node);
+		  lParse->Nodes[(yyval.Node)].SubNodes[ lParse->Nodes[(yyval.Node)].nSubNodes++ ]
+		     = (yyvsp[0].Node);
                 }
-#line 1989 "y.tab.c" /* yacc.c:1648  */
+#line 1888 "eval_y.c"
     break;
 
-  case 12:
-#line 292 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Vector( (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 1995 "y.tab.c" /* yacc.c:1648  */
+  case 12: /* vector: '{' expr  */
+#line 314 "eval.y"
+                { (yyval.Node) = New_Vector(lParse,  (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 1894 "eval_y.c"
     break;
 
-  case 13:
-#line 294 "eval.y" /* yacc.c:1648  */
-    {
-                  if( TYPE((ffvsp[-2].Node)) < TYPE((ffvsp[0].Node)) )
-                     TYPE((ffvsp[-2].Node)) = TYPE((ffvsp[0].Node));
-                  if( gParse.Nodes[(ffvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
-		     (ffvsp[-2].Node) = Close_Vec( (ffvsp[-2].Node) ); TEST((ffvsp[-2].Node));
-		     (ffval.Node) = New_Vector( (ffvsp[-2].Node) ); TEST((ffval.Node));
+  case 13: /* vector: vector ',' expr  */
+#line 316 "eval.y"
+                {
+                  if( TYPE((yyvsp[-2].Node)) < TYPE((yyvsp[0].Node)) )
+                     TYPE((yyvsp[-2].Node)) = TYPE((yyvsp[0].Node));
+                  if( lParse->Nodes[(yyvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
+		     (yyvsp[-2].Node) = Close_Vec(lParse,  (yyvsp[-2].Node) ); TEST((yyvsp[-2].Node));
+		     (yyval.Node) = New_Vector(lParse,  (yyvsp[-2].Node) ); TEST((yyval.Node));
                   } else {
-                     (ffval.Node) = (ffvsp[-2].Node);
+                     (yyval.Node) = (yyvsp[-2].Node);
                   }
-		  gParse.Nodes[(ffval.Node)].SubNodes[ gParse.Nodes[(ffval.Node)].nSubNodes++ ]
-		     = (ffvsp[0].Node);
+		  lParse->Nodes[(yyval.Node)].SubNodes[ lParse->Nodes[(yyval.Node)].nSubNodes++ ]
+		     = (yyvsp[0].Node);
                 }
-#line 2012 "y.tab.c" /* yacc.c:1648  */
+#line 1911 "eval_y.c"
     break;
 
-  case 14:
-#line 307 "eval.y" /* yacc.c:1648  */
-    {
-                  if( gParse.Nodes[(ffvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
-		     (ffvsp[-2].Node) = Close_Vec( (ffvsp[-2].Node) ); TEST((ffvsp[-2].Node));
-		     (ffval.Node) = New_Vector( (ffvsp[-2].Node) ); TEST((ffval.Node));
+  case 14: /* vector: vector ',' bexpr  */
+#line 329 "eval.y"
+                {
+                  if( lParse->Nodes[(yyvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
+		     (yyvsp[-2].Node) = Close_Vec(lParse,  (yyvsp[-2].Node) ); TEST((yyvsp[-2].Node));
+		     (yyval.Node) = New_Vector(lParse,  (yyvsp[-2].Node) ); TEST((yyval.Node));
                   } else {
-                     (ffval.Node) = (ffvsp[-2].Node);
+                     (yyval.Node) = (yyvsp[-2].Node);
                   }
-		  gParse.Nodes[(ffval.Node)].SubNodes[ gParse.Nodes[(ffval.Node)].nSubNodes++ ]
-		     = (ffvsp[0].Node);
+		  lParse->Nodes[(yyval.Node)].SubNodes[ lParse->Nodes[(yyval.Node)].nSubNodes++ ]
+		     = (yyvsp[0].Node);
                 }
-#line 2027 "y.tab.c" /* yacc.c:1648  */
+#line 1926 "eval_y.c"
     break;
 
-  case 15:
-#line 318 "eval.y" /* yacc.c:1648  */
-    {
-                  TYPE((ffvsp[-2].Node)) = TYPE((ffvsp[0].Node));
-                  if( gParse.Nodes[(ffvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
-		     (ffvsp[-2].Node) = Close_Vec( (ffvsp[-2].Node) ); TEST((ffvsp[-2].Node));
-		     (ffval.Node) = New_Vector( (ffvsp[-2].Node) ); TEST((ffval.Node));
+  case 15: /* vector: bvector ',' expr  */
+#line 340 "eval.y"
+                {
+                  TYPE((yyvsp[-2].Node)) = TYPE((yyvsp[0].Node));
+                  if( lParse->Nodes[(yyvsp[-2].Node)].nSubNodes >= MAXSUBS ) {
+		     (yyvsp[-2].Node) = Close_Vec(lParse,  (yyvsp[-2].Node) ); TEST((yyvsp[-2].Node));
+		     (yyval.Node) = New_Vector(lParse,  (yyvsp[-2].Node) ); TEST((yyval.Node));
                   } else {
-                     (ffval.Node) = (ffvsp[-2].Node);
+                     (yyval.Node) = (yyvsp[-2].Node);
                   }
-		  gParse.Nodes[(ffval.Node)].SubNodes[ gParse.Nodes[(ffval.Node)].nSubNodes++ ]
-		     = (ffvsp[0].Node);
+		  lParse->Nodes[(yyval.Node)].SubNodes[ lParse->Nodes[(yyval.Node)].nSubNodes++ ]
+		     = (yyvsp[0].Node);
                 }
-#line 2043 "y.tab.c" /* yacc.c:1648  */
+#line 1942 "eval_y.c"
     break;
 
-  case 16:
-#line 332 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = Close_Vec( (ffvsp[-1].Node) ); TEST((ffval.Node)); }
-#line 2049 "y.tab.c" /* yacc.c:1648  */
+  case 16: /* expr: vector '}'  */
+#line 354 "eval.y"
+                { (yyval.Node) = Close_Vec(lParse,  (yyvsp[-1].Node) ); TEST((yyval.Node)); }
+#line 1948 "eval_y.c"
     break;
 
-  case 17:
-#line 336 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = Close_Vec( (ffvsp[-1].Node) ); TEST((ffval.Node)); }
-#line 2055 "y.tab.c" /* yacc.c:1648  */
+  case 17: /* bexpr: bvector '}'  */
+#line 358 "eval.y"
+                { (yyval.Node) = Close_Vec(lParse,  (yyvsp[-1].Node) ); TEST((yyval.Node)); }
+#line 1954 "eval_y.c"
     break;
 
-  case 18:
-#line 340 "eval.y" /* yacc.c:1648  */
-    {
-                  (ffval.Node) = New_Const( BITSTR, (ffvsp[0].str), strlen((ffvsp[0].str))+1 ); TEST((ffval.Node));
-		  SIZE((ffval.Node)) = strlen((ffvsp[0].str)); }
-#line 2063 "y.tab.c" /* yacc.c:1648  */
+  case 18: /* bits: BITSTR  */
+#line 362 "eval.y"
+                {
+                  (yyval.Node) = New_Const(lParse,  BITSTR, (yyvsp[0].str), strlen((yyvsp[0].str))+1 ); TEST((yyval.Node));
+		  SIZE((yyval.Node)) = strlen((yyvsp[0].str)); }
+#line 1962 "eval_y.c"
     break;
 
-  case 19:
-#line 344 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Column( (ffvsp[0].lng) ); TEST((ffval.Node)); }
-#line 2069 "y.tab.c" /* yacc.c:1648  */
+  case 19: /* bits: BITCOL  */
+#line 366 "eval.y"
+                { (yyval.Node) = New_Column(lParse,  (yyvsp[0].lng) ); TEST((yyval.Node)); }
+#line 1968 "eval_y.c"
     break;
 
-  case 20:
-#line 346 "eval.y" /* yacc.c:1648  */
-    {
-                  if( TYPE((ffvsp[-1].Node)) != LONG
-		      || OPER((ffvsp[-1].Node)) != CONST_OP ) {
-		     fferror("Offset argument must be a constant integer");
-		     FFERROR;
+  case 20: /* bits: BITCOL '{' expr '}'  */
+#line 368 "eval.y"
+                {
+                  if( TYPE((yyvsp[-1].Node)) != LONG
+		      || OPER((yyvsp[-1].Node)) != CONST_OP ) {
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
+		     YYERROR;
 		  }
-                  (ffval.Node) = New_Offset( (ffvsp[-3].lng), (ffvsp[-1].Node) ); TEST((ffval.Node));
+                  (yyval.Node) = New_Offset(lParse,  (yyvsp[-3].lng), (yyvsp[-1].Node) ); TEST((yyval.Node));
                 }
-#line 2082 "y.tab.c" /* yacc.c:1648  */
+#line 1981 "eval_y.c"
     break;
 
-  case 21:
-#line 355 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BITSTR, (ffvsp[-2].Node), '&', (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = ( SIZE((ffvsp[-2].Node))>SIZE((ffvsp[0].Node)) ? SIZE((ffvsp[-2].Node)) : SIZE((ffvsp[0].Node)) );  }
-#line 2089 "y.tab.c" /* yacc.c:1648  */
+  case 21: /* bits: bits '&' bits  */
+#line 377 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BITSTR, (yyvsp[-2].Node), '&', (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = ( SIZE((yyvsp[-2].Node))>SIZE((yyvsp[0].Node)) ? SIZE((yyvsp[-2].Node)) : SIZE((yyvsp[0].Node)) );  }
+#line 1988 "eval_y.c"
     break;
 
-  case 22:
-#line 358 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BITSTR, (ffvsp[-2].Node), '|', (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = ( SIZE((ffvsp[-2].Node))>SIZE((ffvsp[0].Node)) ? SIZE((ffvsp[-2].Node)) : SIZE((ffvsp[0].Node)) );  }
-#line 2096 "y.tab.c" /* yacc.c:1648  */
+  case 22: /* bits: bits '|' bits  */
+#line 380 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BITSTR, (yyvsp[-2].Node), '|', (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = ( SIZE((yyvsp[-2].Node))>SIZE((yyvsp[0].Node)) ? SIZE((yyvsp[-2].Node)) : SIZE((yyvsp[0].Node)) );  }
+#line 1995 "eval_y.c"
     break;
 
-  case 23:
-#line 361 "eval.y" /* yacc.c:1648  */
-    { 
-		  if (SIZE((ffvsp[-2].Node))+SIZE((ffvsp[0].Node)) >= MAX_STRLEN) {
-		    fferror("Combined bit string size exceeds " MAX_STRLEN_S " bits");
-		    FFERROR;
+  case 23: /* bits: bits '+' bits  */
+#line 383 "eval.y"
+                { 
+		  if (SIZE((yyvsp[-2].Node))+SIZE((yyvsp[0].Node)) >= MAX_STRLEN) {
+		    yyerror(scanner, lParse, "Combined bit string size exceeds " MAX_STRLEN_S " bits");
+		    YYERROR;
 		  }
-		  (ffval.Node) = New_BinOp( BITSTR, (ffvsp[-2].Node), '+', (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = SIZE((ffvsp[-2].Node)) + SIZE((ffvsp[0].Node)); 
+		  (yyval.Node) = New_BinOp(lParse,  BITSTR, (yyvsp[-2].Node), '+', (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = SIZE((yyvsp[-2].Node)) + SIZE((yyvsp[0].Node)); 
 		}
-#line 2109 "y.tab.c" /* yacc.c:1648  */
+#line 2008 "eval_y.c"
     break;
 
-  case 24:
-#line 370 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-3].Node), 1, (ffvsp[-1].Node),  0,  0,  0,   0 ); TEST((ffval.Node)); }
-#line 2115 "y.tab.c" /* yacc.c:1648  */
+  case 24: /* bits: bits '[' expr ']'  */
+#line 392 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-3].Node), 1, (yyvsp[-1].Node),  0,  0,  0,   0 ); TEST((yyval.Node)); }
+#line 2014 "eval_y.c"
     break;
 
-  case 25:
-#line 372 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-5].Node), 2, (ffvsp[-3].Node), (ffvsp[-1].Node),  0,  0,   0 ); TEST((ffval.Node)); }
-#line 2121 "y.tab.c" /* yacc.c:1648  */
+  case 25: /* bits: bits '[' expr ',' expr ']'  */
+#line 394 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-5].Node), 2, (yyvsp[-3].Node), (yyvsp[-1].Node),  0,  0,   0 ); TEST((yyval.Node)); }
+#line 2020 "eval_y.c"
     break;
 
-  case 26:
-#line 374 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-7].Node), 3, (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),  0,   0 ); TEST((ffval.Node)); }
-#line 2127 "y.tab.c" /* yacc.c:1648  */
+  case 26: /* bits: bits '[' expr ',' expr ',' expr ']'  */
+#line 396 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-7].Node), 3, (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),  0,   0 ); TEST((yyval.Node)); }
+#line 2026 "eval_y.c"
     break;
 
-  case 27:
-#line 376 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-9].Node), 4, (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),   0 ); TEST((ffval.Node)); }
-#line 2133 "y.tab.c" /* yacc.c:1648  */
+  case 27: /* bits: bits '[' expr ',' expr ',' expr ',' expr ']'  */
+#line 398 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-9].Node), 4, (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),   0 ); TEST((yyval.Node)); }
+#line 2032 "eval_y.c"
     break;
 
-  case 28:
-#line 378 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-11].Node), 5, (ffvsp[-9].Node), (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node) ); TEST((ffval.Node)); }
-#line 2139 "y.tab.c" /* yacc.c:1648  */
+  case 28: /* bits: bits '[' expr ',' expr ',' expr ',' expr ',' expr ']'  */
+#line 400 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-11].Node), 5, (yyvsp[-9].Node), (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node) ); TEST((yyval.Node)); }
+#line 2038 "eval_y.c"
     break;
 
-  case 29:
-#line 380 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Unary( BITSTR, NOT, (ffvsp[0].Node) ); TEST((ffval.Node));     }
-#line 2145 "y.tab.c" /* yacc.c:1648  */
+  case 29: /* bits: NOT bits  */
+#line 402 "eval.y"
+                { (yyval.Node) = New_Unary(lParse,  BITSTR, NOT, (yyvsp[0].Node) ); TEST((yyval.Node));     }
+#line 2044 "eval_y.c"
     break;
 
-  case 30:
-#line 383 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = (ffvsp[-1].Node); }
-#line 2151 "y.tab.c" /* yacc.c:1648  */
+  case 30: /* bits: '(' bits ')'  */
+#line 405 "eval.y"
+                { (yyval.Node) = (yyvsp[-1].Node); }
+#line 2050 "eval_y.c"
     break;
 
-  case 31:
-#line 387 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Const( LONG,   &((ffvsp[0].lng)), sizeof(long)   ); TEST((ffval.Node)); }
-#line 2157 "y.tab.c" /* yacc.c:1648  */
+  case 31: /* expr: LONG  */
+#line 409 "eval.y"
+                { (yyval.Node) = New_Const(lParse,  LONG,   &((yyvsp[0].lng)), sizeof(long)   ); TEST((yyval.Node)); }
+#line 2056 "eval_y.c"
     break;
 
-  case 32:
-#line 389 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Const( DOUBLE, &((ffvsp[0].dbl)), sizeof(double) ); TEST((ffval.Node)); }
-#line 2163 "y.tab.c" /* yacc.c:1648  */
+  case 32: /* expr: DOUBLE  */
+#line 411 "eval.y"
+                { (yyval.Node) = New_Const(lParse,  DOUBLE, &((yyvsp[0].dbl)), sizeof(double) ); TEST((yyval.Node)); }
+#line 2062 "eval_y.c"
     break;
 
-  case 33:
-#line 391 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Column( (ffvsp[0].lng) ); TEST((ffval.Node)); }
-#line 2169 "y.tab.c" /* yacc.c:1648  */
+  case 33: /* expr: COLUMN  */
+#line 413 "eval.y"
+                { (yyval.Node) = New_Column(lParse,  (yyvsp[0].lng) ); TEST((yyval.Node)); }
+#line 2068 "eval_y.c"
     break;
 
-  case 34:
-#line 393 "eval.y" /* yacc.c:1648  */
-    {
-                  if( TYPE((ffvsp[-1].Node)) != LONG
-		      || OPER((ffvsp[-1].Node)) != CONST_OP ) {
-		     fferror("Offset argument must be a constant integer");
-		     FFERROR;
+  case 34: /* expr: COLUMN '{' expr '}'  */
+#line 415 "eval.y"
+                {
+                  if( TYPE((yyvsp[-1].Node)) != LONG
+		      || OPER((yyvsp[-1].Node)) != CONST_OP ) {
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
+		     YYERROR;
 		  }
-                  (ffval.Node) = New_Offset( (ffvsp[-3].lng), (ffvsp[-1].Node) ); TEST((ffval.Node));
+                  (yyval.Node) = New_Offset(lParse,  (yyvsp[-3].lng), (yyvsp[-1].Node) ); TEST((yyval.Node));
                 }
-#line 2182 "y.tab.c" /* yacc.c:1648  */
+#line 2081 "eval_y.c"
     break;
 
-  case 35:
-#line 402 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Func( LONG, row_fct,  0, 0, 0, 0, 0, 0, 0, 0 ); }
-#line 2188 "y.tab.c" /* yacc.c:1648  */
+  case 35: /* expr: ROWREF  */
+#line 424 "eval.y"
+                { (yyval.Node) = New_Func(lParse,  LONG, row_fct,  0, 0, 0, 0, 0, 0, 0, 0 ); }
+#line 2087 "eval_y.c"
     break;
 
-  case 36:
-#line 404 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Func( LONG, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
-#line 2194 "y.tab.c" /* yacc.c:1648  */
+  case 36: /* expr: NULLREF  */
+#line 426 "eval.y"
+                { (yyval.Node) = New_Func(lParse,  LONG, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
+#line 2093 "eval_y.c"
     break;
 
-  case 37:
-#line 406 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '%', (ffvsp[0].Node) );
-		  TEST((ffval.Node));                                                }
-#line 2201 "y.tab.c" /* yacc.c:1648  */
+  case 37: /* expr: expr '%' expr  */
+#line 428 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '%', (yyvsp[0].Node) );
+		  TEST((yyval.Node));                                                }
+#line 2100 "eval_y.c"
     break;
 
-  case 38:
-#line 409 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '+', (ffvsp[0].Node) );
-		  TEST((ffval.Node));                                                }
-#line 2208 "y.tab.c" /* yacc.c:1648  */
+  case 38: /* expr: expr '+' expr  */
+#line 431 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '+', (yyvsp[0].Node) );
+		  TEST((yyval.Node));                                                }
+#line 2107 "eval_y.c"
     break;
 
-  case 39:
-#line 412 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '-', (ffvsp[0].Node) ); 
-		  TEST((ffval.Node));                                                }
-#line 2215 "y.tab.c" /* yacc.c:1648  */
+  case 39: /* expr: expr '-' expr  */
+#line 434 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '-', (yyvsp[0].Node) ); 
+		  TEST((yyval.Node));                                                }
+#line 2114 "eval_y.c"
     break;
 
-  case 40:
-#line 415 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '*', (ffvsp[0].Node) ); 
-		  TEST((ffval.Node));                                                }
-#line 2222 "y.tab.c" /* yacc.c:1648  */
+  case 40: /* expr: expr '*' expr  */
+#line 437 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '*', (yyvsp[0].Node) ); 
+		  TEST((yyval.Node));                                                }
+#line 2121 "eval_y.c"
     break;
 
-  case 41:
-#line 418 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '/', (ffvsp[0].Node) ); 
-		  TEST((ffval.Node));                                                }
-#line 2229 "y.tab.c" /* yacc.c:1648  */
+  case 41: /* expr: expr '/' expr  */
+#line 440 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '/', (yyvsp[0].Node) ); 
+		  TEST((yyval.Node));                                                }
+#line 2128 "eval_y.c"
     break;
 
-  case 42:
-#line 421 "eval.y" /* yacc.c:1648  */
-    { 
-                   if (TYPE((ffvsp[-2].Node)) != LONG ||
-		       TYPE((ffvsp[0].Node)) != LONG) {
-                     fferror("Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
-                      FFERROR;
+  case 42: /* expr: expr '&' expr  */
+#line 443 "eval.y"
+                { 
+                   if (TYPE((yyvsp[-2].Node)) != LONG ||
+		       TYPE((yyvsp[0].Node)) != LONG) {
+                     yyerror(scanner, lParse, "Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
+                      YYERROR;
                    }
-                   (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '&', (ffvsp[0].Node) );
+                   (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '&', (yyvsp[0].Node) );
                 }
-#line 2242 "y.tab.c" /* yacc.c:1648  */
+#line 2141 "eval_y.c"
     break;
 
-  case 43:
-#line 430 "eval.y" /* yacc.c:1648  */
-    { 
-                   if (TYPE((ffvsp[-2].Node)) != LONG ||
-		       TYPE((ffvsp[0].Node)) != LONG) {
-                     fferror("Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
-                      FFERROR;
+  case 43: /* expr: expr '|' expr  */
+#line 452 "eval.y"
+                { 
+                   if (TYPE((yyvsp[-2].Node)) != LONG ||
+		       TYPE((yyvsp[0].Node)) != LONG) {
+                     yyerror(scanner, lParse, "Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
+                      YYERROR;
                    }
-                   (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '|', (ffvsp[0].Node) );
+                   (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '|', (yyvsp[0].Node) );
                 }
-#line 2255 "y.tab.c" /* yacc.c:1648  */
+#line 2154 "eval_y.c"
     break;
 
-  case 44:
-#line 439 "eval.y" /* yacc.c:1648  */
-    { 
-                   if (TYPE((ffvsp[-2].Node)) != LONG ||
-		       TYPE((ffvsp[0].Node)) != LONG) {
-                     fferror("Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
-                      FFERROR;
+  case 44: /* expr: expr XOR expr  */
+#line 461 "eval.y"
+                { 
+                   if (TYPE((yyvsp[-2].Node)) != LONG ||
+		       TYPE((yyvsp[0].Node)) != LONG) {
+                     yyerror(scanner, lParse, "Bitwise operations with incompatible types; only (bit OP bit) and (int OP int) are allowed");
+                      YYERROR;
                    }
-                   (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '^', (ffvsp[0].Node) );
+                   (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '^', (yyvsp[0].Node) );
                 }
-#line 2268 "y.tab.c" /* yacc.c:1648  */
+#line 2167 "eval_y.c"
     break;
 
-  case 45:
-#line 448 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), POWER, (ffvsp[0].Node) );
-		  TEST((ffval.Node));                                                }
-#line 2275 "y.tab.c" /* yacc.c:1648  */
+  case 45: /* expr: expr POWER expr  */
+#line 470 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), POWER, (yyvsp[0].Node) );
+		  TEST((yyval.Node));                                                }
+#line 2174 "eval_y.c"
     break;
 
-  case 46:
-#line 451 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = (ffvsp[0].Node); }
-#line 2281 "y.tab.c" /* yacc.c:1648  */
+  case 46: /* expr: '+' expr  */
+#line 473 "eval.y"
+                { (yyval.Node) = (yyvsp[0].Node); }
+#line 2180 "eval_y.c"
     break;
 
-  case 47:
-#line 453 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Unary( TYPE((ffvsp[0].Node)), UMINUS, (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 2287 "y.tab.c" /* yacc.c:1648  */
+  case 47: /* expr: '-' expr  */
+#line 475 "eval.y"
+                { (yyval.Node) = New_Unary(lParse,  TYPE((yyvsp[0].Node)), UMINUS, (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 2186 "eval_y.c"
     break;
 
-  case 48:
-#line 455 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = (ffvsp[-1].Node); }
-#line 2293 "y.tab.c" /* yacc.c:1648  */
+  case 48: /* expr: '(' expr ')'  */
+#line 477 "eval.y"
+                { (yyval.Node) = (yyvsp[-1].Node); }
+#line 2192 "eval_y.c"
     break;
 
-  case 49:
-#line 457 "eval.y" /* yacc.c:1648  */
-    { (ffvsp[0].Node) = New_Unary( TYPE((ffvsp[-2].Node)), 0, (ffvsp[0].Node) );
-                  (ffval.Node) = New_BinOp( TYPE((ffvsp[-2].Node)), (ffvsp[-2].Node), '*', (ffvsp[0].Node) ); 
-		  TEST((ffval.Node));                                }
-#line 2301 "y.tab.c" /* yacc.c:1648  */
+  case 49: /* expr: expr '*' bexpr  */
+#line 479 "eval.y"
+                { (yyvsp[0].Node) = New_Unary(lParse,  TYPE((yyvsp[-2].Node)), 0, (yyvsp[0].Node) );
+                  (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[-2].Node)), (yyvsp[-2].Node), '*', (yyvsp[0].Node) ); 
+		  TEST((yyval.Node));                                }
+#line 2200 "eval_y.c"
     break;
 
-  case 50:
-#line 461 "eval.y" /* yacc.c:1648  */
-    { (ffvsp[-2].Node) = New_Unary( TYPE((ffvsp[0].Node)), 0, (ffvsp[-2].Node) );
-                  (ffval.Node) = New_BinOp( TYPE((ffvsp[0].Node)), (ffvsp[-2].Node), '*', (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                }
-#line 2309 "y.tab.c" /* yacc.c:1648  */
+  case 50: /* expr: bexpr '*' expr  */
+#line 483 "eval.y"
+                { (yyvsp[-2].Node) = New_Unary(lParse,  TYPE((yyvsp[0].Node)), 0, (yyvsp[-2].Node) );
+                  (yyval.Node) = New_BinOp(lParse,  TYPE((yyvsp[0].Node)), (yyvsp[-2].Node), '*', (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                }
+#line 2208 "eval_y.c"
     break;
 
-  case 51:
-#line 465 "eval.y" /* yacc.c:1648  */
-    {
-                  PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node));
-                  if( ! Test_Dims((ffvsp[-2].Node),(ffvsp[0].Node)) ) {
-                     fferror("Incompatible dimensions in '?:' arguments");
-		     FFERROR;
+  case 51: /* expr: bexpr '?' expr ':' expr  */
+#line 487 "eval.y"
+                {
+                  PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node));
+                  if( ! Test_Dims( lParse, (yyvsp[-2].Node),(yyvsp[0].Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
+		     YYERROR;
                   }
-                  (ffval.Node) = New_Func( 0, ifthenelse_fct, 3, (ffvsp[-2].Node), (ffvsp[0].Node), (ffvsp[-4].Node),
+                  (yyval.Node) = New_Func(lParse,  0, ifthenelse_fct, 3, (yyvsp[-2].Node), (yyvsp[0].Node), (yyvsp[-4].Node),
                                  0, 0, 0, 0 );
-                  TEST((ffval.Node));
-                  if( SIZE((ffvsp[-2].Node))<SIZE((ffvsp[0].Node)) )  Copy_Dims((ffval.Node), (ffvsp[0].Node));
-                  TYPE((ffvsp[-4].Node)) = TYPE((ffvsp[-2].Node));
-                  if( ! Test_Dims((ffvsp[-4].Node),(ffval.Node)) ) {
-                     fferror("Incompatible dimensions in '?:' condition");
-		     FFERROR;
+                  TEST((yyval.Node));
+                  if( SIZE((yyvsp[-2].Node))<SIZE((yyvsp[0].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[0].Node));
+                  TYPE((yyvsp[-4].Node)) = TYPE((yyvsp[-2].Node));
+                  if( ! Test_Dims( lParse, (yyvsp[-4].Node),(yyval.Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
+		     YYERROR;
                   }
-                  TYPE((ffvsp[-4].Node)) = BOOLEAN;
-                  if( SIZE((ffval.Node))<SIZE((ffvsp[-4].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-4].Node));
+                  TYPE((yyvsp[-4].Node)) = BOOLEAN;
+                  if( SIZE((yyval.Node))<SIZE((yyvsp[-4].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-4].Node));
                 }
-#line 2332 "y.tab.c" /* yacc.c:1648  */
+#line 2231 "eval_y.c"
     break;
 
-  case 52:
-#line 484 "eval.y" /* yacc.c:1648  */
-    {
-                  PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node));
-                  if( ! Test_Dims((ffvsp[-2].Node),(ffvsp[0].Node)) ) {
-                     fferror("Incompatible dimensions in '?:' arguments");
-		     FFERROR;
+  case 52: /* expr: bexpr '?' bexpr ':' expr  */
+#line 506 "eval.y"
+                {
+                  PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node));
+                  if( ! Test_Dims( lParse, (yyvsp[-2].Node),(yyvsp[0].Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
+		     YYERROR;
                   }
-                  (ffval.Node) = New_Func( 0, ifthenelse_fct, 3, (ffvsp[-2].Node), (ffvsp[0].Node), (ffvsp[-4].Node),
+                  (yyval.Node) = New_Func(lParse,  0, ifthenelse_fct, 3, (yyvsp[-2].Node), (yyvsp[0].Node), (yyvsp[-4].Node),
                                  0, 0, 0, 0 );
-                  TEST((ffval.Node));
-                  if( SIZE((ffvsp[-2].Node))<SIZE((ffvsp[0].Node)) )  Copy_Dims((ffval.Node), (ffvsp[0].Node));
-                  TYPE((ffvsp[-4].Node)) = TYPE((ffvsp[-2].Node));
-                  if( ! Test_Dims((ffvsp[-4].Node),(ffval.Node)) ) {
-                     fferror("Incompatible dimensions in '?:' condition");
-		     FFERROR;
+                  TEST((yyval.Node));
+                  if( SIZE((yyvsp[-2].Node))<SIZE((yyvsp[0].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[0].Node));
+                  TYPE((yyvsp[-4].Node)) = TYPE((yyvsp[-2].Node));
+                  if( ! Test_Dims( lParse, (yyvsp[-4].Node),(yyval.Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
+		     YYERROR;
                   }
-                  TYPE((ffvsp[-4].Node)) = BOOLEAN;
-                  if( SIZE((ffval.Node))<SIZE((ffvsp[-4].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-4].Node));
+                  TYPE((yyvsp[-4].Node)) = BOOLEAN;
+                  if( SIZE((yyval.Node))<SIZE((yyvsp[-4].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-4].Node));
                 }
-#line 2355 "y.tab.c" /* yacc.c:1648  */
+#line 2254 "eval_y.c"
     break;
 
-  case 53:
-#line 503 "eval.y" /* yacc.c:1648  */
-    {
-                  PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node));
-                  if( ! Test_Dims((ffvsp[-2].Node),(ffvsp[0].Node)) ) {
-                     fferror("Incompatible dimensions in '?:' arguments");
-		     FFERROR;
+  case 53: /* expr: bexpr '?' expr ':' bexpr  */
+#line 525 "eval.y"
+                {
+                  PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node));
+                  if( ! Test_Dims( lParse, (yyvsp[-2].Node),(yyvsp[0].Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
+		     YYERROR;
                   }
-                  (ffval.Node) = New_Func( 0, ifthenelse_fct, 3, (ffvsp[-2].Node), (ffvsp[0].Node), (ffvsp[-4].Node),
+                  (yyval.Node) = New_Func(lParse,  0, ifthenelse_fct, 3, (yyvsp[-2].Node), (yyvsp[0].Node), (yyvsp[-4].Node),
                                  0, 0, 0, 0 );
-                  TEST((ffval.Node));
-                  if( SIZE((ffvsp[-2].Node))<SIZE((ffvsp[0].Node)) )  Copy_Dims((ffval.Node), (ffvsp[0].Node));
-                  TYPE((ffvsp[-4].Node)) = TYPE((ffvsp[-2].Node));
-                  if( ! Test_Dims((ffvsp[-4].Node),(ffval.Node)) ) {
-                     fferror("Incompatible dimensions in '?:' condition");
-		     FFERROR;
+                  TEST((yyval.Node));
+                  if( SIZE((yyvsp[-2].Node))<SIZE((yyvsp[0].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[0].Node));
+                  TYPE((yyvsp[-4].Node)) = TYPE((yyvsp[-2].Node));
+                  if( ! Test_Dims( lParse, (yyvsp[-4].Node),(yyval.Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
+		     YYERROR;
                   }
-                  TYPE((ffvsp[-4].Node)) = BOOLEAN;
-                  if( SIZE((ffval.Node))<SIZE((ffvsp[-4].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-4].Node));
+                  TYPE((yyvsp[-4].Node)) = BOOLEAN;
+                  if( SIZE((yyval.Node))<SIZE((yyvsp[-4].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-4].Node));
                 }
-#line 2378 "y.tab.c" /* yacc.c:1648  */
+#line 2277 "eval_y.c"
     break;
 
-  case 54:
-#line 522 "eval.y" /* yacc.c:1648  */
-    { if (FSTRCMP((ffvsp[-1].str),"RANDOM(") == 0) {  /* Scalar RANDOM() */
-                     (ffval.Node) = New_Func( DOUBLE, rnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
-		  } else if (FSTRCMP((ffvsp[-1].str),"RANDOMN(") == 0) {/*Scalar RANDOMN()*/
-		     (ffval.Node) = New_Func( DOUBLE, gasrnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
+  case 54: /* expr: FUNCTION ')'  */
+#line 544 "eval.y"
+                { if (FSTRCMP((yyvsp[-1].str),"RANDOM(") == 0) {  /* Scalar RANDOM() */
+                     (yyval.Node) = New_Func(lParse,  DOUBLE, rnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
+		  } else if (FSTRCMP((yyvsp[-1].str),"RANDOMN(") == 0) {/*Scalar RANDOMN()*/
+		     (yyval.Node) = New_Func(lParse,  DOUBLE, gasrnd_fct, 0, 0, 0, 0, 0, 0, 0, 0 );
                   } else {
-                     fferror("Function() not supported");
-		     FFERROR;
+                     yyerror(scanner, lParse, "Function() not supported");
+		     YYERROR;
 		  }
-                  TEST((ffval.Node)); 
+                  TEST((yyval.Node)); 
                 }
-#line 2393 "y.tab.c" /* yacc.c:1648  */
+#line 2292 "eval_y.c"
     break;
 
-  case 55:
-#line 533 "eval.y" /* yacc.c:1648  */
-    { if (FSTRCMP((ffvsp[-2].str),"SUM(") == 0) {
-		     (ffval.Node) = New_Func( LONG, sum_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-                  } else if (FSTRCMP((ffvsp[-2].str),"NELEM(") == 0) {
-                     (ffval.Node) = New_Const( LONG, &( SIZE((ffvsp[-1].Node)) ), sizeof(long) );
-                  } else if (FSTRCMP((ffvsp[-2].str),"ACCUM(") == 0) {
+  case 55: /* expr: FUNCTION bexpr ')'  */
+#line 555 "eval.y"
+                { if (FSTRCMP((yyvsp[-2].str),"SUM(") == 0) {
+		     (yyval.Node) = New_Func(lParse,  LONG, sum_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+                  } else if (FSTRCMP((yyvsp[-2].str),"NELEM(") == 0) {
+                     (yyval.Node) = New_Const(lParse,  LONG, &( SIZE((yyvsp[-1].Node)) ), sizeof(long) );
+                  } else if (FSTRCMP((yyvsp[-2].str),"ACCUM(") == 0) {
 		    long zero = 0;
-		    (ffval.Node) = New_BinOp( LONG , (ffvsp[-1].Node), ACCUM, New_Const( LONG, &zero, sizeof(zero) ));
+		    (yyval.Node) = New_BinOp(lParse,  LONG , (yyvsp[-1].Node), ACCUM, New_Const(lParse,  LONG, &zero, sizeof(zero) ));
 		  } else {
-                     fferror("Function(bool) not supported");
-		     FFERROR;
+                     yyerror(scanner, lParse, "Function(bool) not supported");
+		     YYERROR;
 		  }
-                  TEST((ffval.Node)); 
+                  TEST((yyval.Node)); 
 		}
-#line 2411 "y.tab.c" /* yacc.c:1648  */
+#line 2310 "eval_y.c"
     break;
 
-  case 56:
-#line 547 "eval.y" /* yacc.c:1648  */
-    { if (FSTRCMP((ffvsp[-2].str),"NELEM(") == 0) {
-                     (ffval.Node) = New_Const( LONG, &( SIZE((ffvsp[-1].Node)) ), sizeof(long) );
-		  } else if (FSTRCMP((ffvsp[-2].str),"NVALID(") == 0) {
-		     (ffval.Node) = New_Func( LONG, nonnull_fct, 1, (ffvsp[-1].Node),
+  case 56: /* expr: FUNCTION bexpr ',' expr ')'  */
+#line 569 "eval.y"
+                { if (FSTRCMP((yyvsp[-4].str),"AXISELEM(") == 0) {  /* AXISELEM(V,n) */
+		     if (OPER((yyvsp[-1].Node)) != CONST_OP
+			 || SIZE((yyvsp[-1].Node)) != 1) {
+		       yyerror(scanner, lParse, "AXISELEM second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER((yyvsp[-3].Node)) == CONST_OP) {
+		       long one = 1;
+		       (yyval.Node) = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {
+		       if ( TYPE((yyvsp[-1].Node)) != LONG ) (yyvsp[-1].Node) = New_Unary(lParse, LONG, 0, (yyvsp[-1].Node));
+		       (yyval.Node) = New_Func(lParse, 0, axiselem_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0, 0, 0, 0, 0 );
+		       TEST((yyval.Node));
+		       TYPE((yyval.Node)) = LONG;
+		     }
+		   } else if (FSTRCMP((yyvsp[-4].str),"NAXES(") == 0) {  /* NAXES(V,n) */
+		     if (OPER((yyvsp[-1].Node)) != CONST_OP
+			 || SIZE((yyvsp[-1].Node)) != 1) {
+		       yyerror(scanner, lParse, "NAXES second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER((yyvsp[-3].Node)) == CONST_OP) { /* if V is constant, return 1 in every case */
+		       long one = 1;
+		       (yyval.Node) = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {                    /* determine now the dimension of the expression */
+		       long iaxis;
+		       int naxis;
+		       if ( TYPE((yyvsp[-1].Node)) != LONG ) (yyvsp[-1].Node) = New_Unary(lParse, LONG, 0, (yyvsp[-1].Node));
+		       /* Since it is already constant, we can extract long value directly */
+		       iaxis = (lParse->Nodes[(yyvsp[-1].Node)].value.data.lng);
+		       naxis = lParse->Nodes[(yyvsp[-3].Node)].value.naxis;
+
+		       if (iaxis == 0)          iaxis = naxis;   /* NAXIS(V,0) = NAXIS */
+		       else if (iaxis <= naxis) iaxis = lParse->Nodes[(yyvsp[-3].Node)].value.naxes[iaxis-1]; /* NAXIS(V,n) = NAXISn */
+		       else                     iaxis = 1;       /* Out of bounds use 1 */
+
+		       (yyval.Node) = New_Const(lParse,  LONG, &iaxis, sizeof(iaxis) );
+		       TEST((yyval.Node));
+		     }
+		   } else if (FSTRCMP((yyvsp[-4].str),"ARRAY(") == 0) {  /* NAXES(bexpr,n) */
+		     (yyval.Node) = New_Array(lParse, (yyvsp[-3].Node), (yyvsp[-1].Node));
+		     TEST((yyval.Node));
+		  } else {
+                     yyerror(scanner, lParse, "Function(bool,expr) not supported");
+		     YYERROR;
+		  }
+                  TEST((yyval.Node)); 
+		}
+#line 2363 "eval_y.c"
+    break;
+
+  case 57: /* expr: FUNCTION sexpr ')'  */
+#line 618 "eval.y"
+                { if (FSTRCMP((yyvsp[-2].str),"NELEM(") == 0) {
+                     (yyval.Node) = New_Const(lParse,  LONG, &( SIZE((yyvsp[-1].Node)) ), sizeof(long) );
+		  } else if (FSTRCMP((yyvsp[-2].str),"NVALID(") == 0) {
+		     (yyval.Node) = New_Func(lParse,  LONG, nonnull_fct, 1, (yyvsp[-1].Node),
 				    0, 0, 0, 0, 0, 0 );
 		  } else {
-                     fferror("Function(str) not supported");
-		     FFERROR;
+                     yyerror(scanner, lParse, "Function(str) not supported");
+		     YYERROR;
 		  }
-                  TEST((ffval.Node)); 
+                  TEST((yyval.Node)); 
 		}
-#line 2427 "y.tab.c" /* yacc.c:1648  */
+#line 2379 "eval_y.c"
     break;
 
-  case 57:
-#line 559 "eval.y" /* yacc.c:1648  */
-    { if (FSTRCMP((ffvsp[-2].str),"NELEM(") == 0) {
-                     (ffval.Node) = New_Const( LONG, &( SIZE((ffvsp[-1].Node)) ), sizeof(long) );
-		} else if (FSTRCMP((ffvsp[-2].str),"NVALID(") == 0) { /* Bit arrays do not have NULL */
-                     (ffval.Node) = New_Const( LONG, &( SIZE((ffvsp[-1].Node)) ), sizeof(long) );
-		} else if (FSTRCMP((ffvsp[-2].str),"SUM(") == 0) {
-		     (ffval.Node) = New_Func( LONG, sum_fct, 1, (ffvsp[-1].Node),
+  case 58: /* expr: FUNCTION bits ')'  */
+#line 630 "eval.y"
+                { if (FSTRCMP((yyvsp[-2].str),"NELEM(") == 0) {
+                     (yyval.Node) = New_Const(lParse,  LONG, &( SIZE((yyvsp[-1].Node)) ), sizeof(long) );
+		} else if (FSTRCMP((yyvsp[-2].str),"NVALID(") == 0) { /* Bit arrays do not have NULL */
+                     (yyval.Node) = New_Const(lParse,  LONG, &( SIZE((yyvsp[-1].Node)) ), sizeof(long) );
+		} else if (FSTRCMP((yyvsp[-2].str),"SUM(") == 0) {
+		     (yyval.Node) = New_Func(lParse,  LONG, sum_fct, 1, (yyvsp[-1].Node),
 				    0, 0, 0, 0, 0, 0 );
-		} else if (FSTRCMP((ffvsp[-2].str),"MIN(") == 0) {
-		     (ffval.Node) = New_Func( TYPE((ffvsp[-1].Node)),  /* Force 1D result */
-				    min1_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		} else if (FSTRCMP((yyvsp[-2].str),"MIN(") == 0) {
+		     (yyval.Node) = New_Func(lParse,  TYPE((yyvsp[-1].Node)),  /* Force 1D result */
+				    min1_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
 		     /* Note: $2 is a vector so the result can never
 		        be a constant.  Therefore it will never be set
 		        inside New_Func(), and it is safe to set SIZE() */
-		     SIZE((ffval.Node)) = 1;
-		} else if (FSTRCMP((ffvsp[-2].str),"ACCUM(") == 0) {
+		     SIZE((yyval.Node)) = 1;
+		} else if (FSTRCMP((yyvsp[-2].str),"ACCUM(") == 0) {
 		    long zero = 0;
-		    (ffval.Node) = New_BinOp( LONG , (ffvsp[-1].Node), ACCUM, New_Const( LONG, &zero, sizeof(zero) ));
-		} else if (FSTRCMP((ffvsp[-2].str),"MAX(") == 0) {
-		     (ffval.Node) = New_Func( TYPE((ffvsp[-1].Node)),  /* Force 1D result */
-				    max1_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		    (yyval.Node) = New_BinOp(lParse,  LONG , (yyvsp[-1].Node), ACCUM, New_Const(lParse,  LONG, &zero, sizeof(zero) ));
+		} else if (FSTRCMP((yyvsp[-2].str),"MAX(") == 0) {
+		     (yyval.Node) = New_Func(lParse,  TYPE((yyvsp[-1].Node)),  /* Force 1D result */
+				    max1_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
 		     /* Note: $2 is a vector so the result can never
 		        be a constant.  Therefore it will never be set
 		        inside New_Func(), and it is safe to set SIZE() */
-		     SIZE((ffval.Node)) = 1;
+		     SIZE((yyval.Node)) = 1;
 		} else {
-                     fferror("Function(bits) not supported");
-		     FFERROR;
+                     yyerror(scanner, lParse, "Function(bits) not supported");
+		     YYERROR;
 		  }
-                  TEST((ffval.Node)); 
+                  TEST((yyval.Node)); 
 		}
-#line 2462 "y.tab.c" /* yacc.c:1648  */
+#line 2414 "eval_y.c"
     break;
 
-  case 58:
-#line 590 "eval.y" /* yacc.c:1648  */
-    { if (FSTRCMP((ffvsp[-2].str),"SUM(") == 0)
-		     (ffval.Node) = New_Func( TYPE((ffvsp[-1].Node)), sum_fct, 1, (ffvsp[-1].Node),
+  case 59: /* expr: FUNCTION expr ')'  */
+#line 661 "eval.y"
+                { if (FSTRCMP((yyvsp[-2].str),"SUM(") == 0)
+		     (yyval.Node) = New_Func(lParse,  TYPE((yyvsp[-1].Node)), sum_fct, 1, (yyvsp[-1].Node),
 				    0, 0, 0, 0, 0, 0 );
-		  else if (FSTRCMP((ffvsp[-2].str),"AVERAGE(") == 0)
-		     (ffval.Node) = New_Func( DOUBLE, average_fct, 1, (ffvsp[-1].Node),
+		  else if (FSTRCMP((yyvsp[-2].str),"AVERAGE(") == 0)
+		     (yyval.Node) = New_Func(lParse,  DOUBLE, average_fct, 1, (yyvsp[-1].Node),
 				    0, 0, 0, 0, 0, 0 );
-		  else if (FSTRCMP((ffvsp[-2].str),"STDDEV(") == 0)
-		     (ffval.Node) = New_Func( DOUBLE, stddev_fct, 1, (ffvsp[-1].Node),
+		  else if (FSTRCMP((yyvsp[-2].str),"STDDEV(") == 0)
+		     (yyval.Node) = New_Func(lParse,  DOUBLE, stddev_fct, 1, (yyvsp[-1].Node),
 				    0, 0, 0, 0, 0, 0 );
-		  else if (FSTRCMP((ffvsp[-2].str),"MEDIAN(") == 0)
-		     (ffval.Node) = New_Func( TYPE((ffvsp[-1].Node)), median_fct, 1, (ffvsp[-1].Node),
+		  else if (FSTRCMP((yyvsp[-2].str),"MEDIAN(") == 0)
+		     (yyval.Node) = New_Func(lParse,  TYPE((yyvsp[-1].Node)), median_fct, 1, (yyvsp[-1].Node),
 				    0, 0, 0, 0, 0, 0 );
-		  else if (FSTRCMP((ffvsp[-2].str),"NELEM(") == 0)
-                     (ffval.Node) = New_Const( LONG, &( SIZE((ffvsp[-1].Node)) ), sizeof(long) );
-		  else if (FSTRCMP((ffvsp[-2].str),"NVALID(") == 0)
-		     (ffval.Node) = New_Func( LONG, nonnull_fct, 1, (ffvsp[-1].Node),
+		  else if (FSTRCMP((yyvsp[-2].str),"NELEM(") == 0)
+                     (yyval.Node) = New_Const(lParse,  LONG, &( SIZE((yyvsp[-1].Node)) ), sizeof(long) );
+		  else if (FSTRCMP((yyvsp[-2].str),"NVALID(") == 0)
+		     (yyval.Node) = New_Func(lParse,  LONG, nonnull_fct, 1, (yyvsp[-1].Node),
 				    0, 0, 0, 0, 0, 0 );
-		  else if   ((FSTRCMP((ffvsp[-2].str),"ACCUM(") == 0) && (TYPE((ffvsp[-1].Node)) == LONG)) {
+		  else if   ((FSTRCMP((yyvsp[-2].str),"ACCUM(") == 0) && (TYPE((yyvsp[-1].Node)) == LONG)) {
 		    long zero = 0;
-		    (ffval.Node) = New_BinOp( LONG ,   (ffvsp[-1].Node), ACCUM, New_Const( LONG,   &zero, sizeof(zero) ));
-		  } else if ((FSTRCMP((ffvsp[-2].str),"ACCUM(") == 0) && (TYPE((ffvsp[-1].Node)) == DOUBLE)) {
+		    (yyval.Node) = New_BinOp(lParse,  LONG ,   (yyvsp[-1].Node), ACCUM, New_Const(lParse,  LONG,   &zero, sizeof(zero) ));
+		  } else if ((FSTRCMP((yyvsp[-2].str),"ACCUM(") == 0) && (TYPE((yyvsp[-1].Node)) == DOUBLE)) {
 		    double zero = 0;
-		    (ffval.Node) = New_BinOp( DOUBLE , (ffvsp[-1].Node), ACCUM, New_Const( DOUBLE, &zero, sizeof(zero) ));
-		  } else if ((FSTRCMP((ffvsp[-2].str),"SEQDIFF(") == 0) && (TYPE((ffvsp[-1].Node)) == LONG)) {
+		    (yyval.Node) = New_BinOp(lParse,  DOUBLE , (yyvsp[-1].Node), ACCUM, New_Const(lParse,  DOUBLE, &zero, sizeof(zero) ));
+		  } else if ((FSTRCMP((yyvsp[-2].str),"SEQDIFF(") == 0) && (TYPE((yyvsp[-1].Node)) == LONG)) {
 		    long zero = 0;
-		    (ffval.Node) = New_BinOp( LONG ,   (ffvsp[-1].Node), DIFF, New_Const( LONG,   &zero, sizeof(zero) ));
-		  } else if ((FSTRCMP((ffvsp[-2].str),"SEQDIFF(") == 0) && (TYPE((ffvsp[-1].Node)) == DOUBLE)) {
+		    (yyval.Node) = New_BinOp(lParse,  LONG ,   (yyvsp[-1].Node), DIFF, New_Const(lParse,  LONG,   &zero, sizeof(zero) ));
+		  } else if ((FSTRCMP((yyvsp[-2].str),"SEQDIFF(") == 0) && (TYPE((yyvsp[-1].Node)) == DOUBLE)) {
 		    double zero = 0;
-		    (ffval.Node) = New_BinOp( DOUBLE , (ffvsp[-1].Node), DIFF, New_Const( DOUBLE, &zero, sizeof(zero) ));
-		  } else if (FSTRCMP((ffvsp[-2].str),"ABS(") == 0)
-		     (ffval.Node) = New_Func( 0, abs_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
- 		  else if (FSTRCMP((ffvsp[-2].str),"MIN(") == 0)
-		     (ffval.Node) = New_Func( TYPE((ffvsp[-1].Node)),  /* Force 1D result */
-				    min1_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		  else if (FSTRCMP((ffvsp[-2].str),"MAX(") == 0)
-		     (ffval.Node) = New_Func( TYPE((ffvsp[-1].Node)),  /* Force 1D result */
-				    max1_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		  else if (FSTRCMP((ffvsp[-2].str),"RANDOM(") == 0) { /* Vector RANDOM() */
-                     (ffval.Node) = New_Func( 0, rnd_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     TEST((ffval.Node));
-		     TYPE((ffval.Node)) = DOUBLE;
-		  } else if (FSTRCMP((ffvsp[-2].str),"RANDOMN(") == 0) {
-		     (ffval.Node) = New_Func( 0, gasrnd_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     TEST((ffval.Node));
-		     TYPE((ffval.Node)) = DOUBLE;
+		    (yyval.Node) = New_BinOp(lParse,  DOUBLE , (yyvsp[-1].Node), DIFF, New_Const(lParse,  DOUBLE, &zero, sizeof(zero) ));
+		  } else if (FSTRCMP((yyvsp[-2].str),"ABS(") == 0)
+		     (yyval.Node) = New_Func(lParse,  0, abs_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+ 		  else if (FSTRCMP((yyvsp[-2].str),"MIN(") == 0)
+		     (yyval.Node) = New_Func(lParse,  TYPE((yyvsp[-1].Node)),  /* Force 1D result */
+				    min1_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		  else if (FSTRCMP((yyvsp[-2].str),"MAX(") == 0)
+		     (yyval.Node) = New_Func(lParse,  TYPE((yyvsp[-1].Node)),  /* Force 1D result */
+				    max1_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		  else if (FSTRCMP((yyvsp[-2].str),"RANDOM(") == 0) { /* Vector RANDOM() */
+                     (yyval.Node) = New_Func(lParse,  0, rnd_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     TEST((yyval.Node));
+		     TYPE((yyval.Node)) = DOUBLE;
+		  } else if (FSTRCMP((yyvsp[-2].str),"RANDOMN(") == 0) {
+		     (yyval.Node) = New_Func(lParse,  0, gasrnd_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     TEST((yyval.Node));
+		     TYPE((yyval.Node)) = DOUBLE;
+		  } else if (FSTRCMP((yyvsp[-2].str),"ELEMENTNUM(") == 0) {
+		     if (OPER((yyvsp[-1].Node)) == CONST_OP) {
+		       long one = 1;
+		       (yyval.Node) = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {
+		       (yyval.Node) = New_Func(lParse,  0, elemnum_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		       TEST((yyval.Node));
+		       TYPE((yyval.Node)) = LONG;
+		     }
+		  } else if (FSTRCMP((yyvsp[-2].str),"NAXIS(") == 0) {  /* NAXIS(V) */
+		     if (OPER((yyvsp[-1].Node)) == CONST_OP) { /* if V is constant, return 1 in every case */
+		       long one = 1;
+		       (yyval.Node) = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {                    /* determine now the dimension of the expression */
+		       long naxis = lParse->Nodes[(yyvsp[-1].Node)].value.naxis;
+
+		       (yyval.Node) = New_Const(lParse,  LONG, &naxis, sizeof(naxis) );
+		       TEST((yyval.Node));
+		     }
                   } 
   		  else {  /*  These all take DOUBLE arguments  */
-		     if( TYPE((ffvsp[-1].Node)) != DOUBLE ) (ffvsp[-1].Node) = New_Unary( DOUBLE, 0, (ffvsp[-1].Node) );
-                     if (FSTRCMP((ffvsp[-2].str),"SIN(") == 0)
-			(ffval.Node) = New_Func( 0, sin_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"COS(") == 0)
-			(ffval.Node) = New_Func( 0, cos_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"TAN(") == 0)
-			(ffval.Node) = New_Func( 0, tan_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"ARCSIN(") == 0
-			      || FSTRCMP((ffvsp[-2].str),"ASIN(") == 0)
-			(ffval.Node) = New_Func( 0, asin_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"ARCCOS(") == 0
-			      || FSTRCMP((ffvsp[-2].str),"ACOS(") == 0)
-			(ffval.Node) = New_Func( 0, acos_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"ARCTAN(") == 0
-			      || FSTRCMP((ffvsp[-2].str),"ATAN(") == 0)
-			(ffval.Node) = New_Func( 0, atan_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"SINH(") == 0)
-			(ffval.Node) = New_Func( 0, sinh_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"COSH(") == 0)
-			(ffval.Node) = New_Func( 0, cosh_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"TANH(") == 0)
-			(ffval.Node) = New_Func( 0, tanh_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"EXP(") == 0)
-			(ffval.Node) = New_Func( 0, exp_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"LOG(") == 0)
-			(ffval.Node) = New_Func( 0, log_fct,  1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"LOG10(") == 0)
-			(ffval.Node) = New_Func( 0, log10_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"SQRT(") == 0)
-			(ffval.Node) = New_Func( 0, sqrt_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"ROUND(") == 0)
-			(ffval.Node) = New_Func( 0, round_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"FLOOR(") == 0)
-			(ffval.Node) = New_Func( 0, floor_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"CEIL(") == 0)
-			(ffval.Node) = New_Func( 0, ceil_fct, 1, (ffvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
-		     else if (FSTRCMP((ffvsp[-2].str),"RANDOMP(") == 0) {
-		       (ffval.Node) = New_Func( 0, poirnd_fct, 1, (ffvsp[-1].Node), 
+		     if( TYPE((yyvsp[-1].Node)) != DOUBLE ) (yyvsp[-1].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-1].Node) );
+                     if (FSTRCMP((yyvsp[-2].str),"SIN(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, sin_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"COS(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, cos_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"TAN(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, tan_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"ARCSIN(") == 0
+			      || FSTRCMP((yyvsp[-2].str),"ASIN(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, asin_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"ARCCOS(") == 0
+			      || FSTRCMP((yyvsp[-2].str),"ACOS(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, acos_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"ARCTAN(") == 0
+			      || FSTRCMP((yyvsp[-2].str),"ATAN(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, atan_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"SINH(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, sinh_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"COSH(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, cosh_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"TANH(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, tanh_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"EXP(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, exp_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"LOG(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, log_fct,  1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"LOG10(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, log10_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"SQRT(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, sqrt_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"ROUND(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, round_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"FLOOR(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, floor_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"CEIL(") == 0)
+			(yyval.Node) = New_Func(lParse,  0, ceil_fct, 1, (yyvsp[-1].Node), 0, 0, 0, 0, 0, 0 );
+		     else if (FSTRCMP((yyvsp[-2].str),"RANDOMP(") == 0) {
+		       (yyval.Node) = New_Func(lParse,  0, poirnd_fct, 1, (yyvsp[-1].Node), 
 				      0, 0, 0, 0, 0, 0 );
-		       TYPE((ffval.Node)) = LONG;
+		       TYPE((yyval.Node)) = LONG;
 		     } else {
-			fferror("Function(expr) not supported");
-			FFERROR;
+			yyerror(scanner, lParse, "Function(expr) not supported");
+			YYERROR;
 		     }
 		  }
-                  TEST((ffval.Node)); 
+                  TEST((yyval.Node)); 
                 }
-#line 2561 "y.tab.c" /* yacc.c:1648  */
+#line 2532 "eval_y.c"
     break;
 
-  case 59:
-#line 685 "eval.y" /* yacc.c:1648  */
-    { 
-		  if (FSTRCMP((ffvsp[-4].str),"STRSTR(") == 0) {
-		    (ffval.Node) = New_Func( LONG, strpos_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0, 
+  case 60: /* expr: IFUNCTION sexpr ',' sexpr ')'  */
+#line 775 "eval.y"
+                { 
+		  if (FSTRCMP((yyvsp[-4].str),"STRSTR(") == 0) {
+		    (yyval.Node) = New_Func(lParse,  LONG, strpos_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0, 
 				   0, 0, 0, 0 );
-		    TEST((ffval.Node));
+		    TEST((yyval.Node));
 		  }
                 }
-#line 2573 "y.tab.c" /* yacc.c:1648  */
+#line 2544 "eval_y.c"
     break;
 
-  case 60:
-#line 693 "eval.y" /* yacc.c:1648  */
-    { 
-		   if (FSTRCMP((ffvsp[-4].str),"DEFNULL(") == 0) {
-		      if( SIZE((ffvsp[-3].Node))>=SIZE((ffvsp[-1].Node)) && Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) ) ) {
-			 PROMOTE((ffvsp[-3].Node),(ffvsp[-1].Node));
-			 (ffval.Node) = New_Func( 0, defnull_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0,
+  case 61: /* expr: FUNCTION expr ',' expr ')'  */
+#line 783 "eval.y"
+                { 
+		   if (FSTRCMP((yyvsp[-4].str),"DEFNULL(") == 0) {
+		      if( SIZE((yyvsp[-3].Node))>=SIZE((yyvsp[-1].Node)) && Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) {
+			 PROMOTE((yyvsp[-3].Node),(yyvsp[-1].Node));
+			 (yyval.Node) = New_Func(lParse,  0, defnull_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0,
 					0, 0, 0, 0 );
-			 TEST((ffval.Node)); 
+			 TEST((yyval.Node)); 
 		      } else {
-			 fferror("Dimensions of DEFNULL arguments "
+			 yyerror(scanner, lParse, "Dimensions of DEFNULL arguments "
 				 "are not compatible");
-			 FFERROR;
+			 YYERROR;
 		      }
-		   } else if (FSTRCMP((ffvsp[-4].str),"ARCTAN2(") == 0) {
-		     if( TYPE((ffvsp[-3].Node)) != DOUBLE ) (ffvsp[-3].Node) = New_Unary( DOUBLE, 0, (ffvsp[-3].Node) );
-		     if( TYPE((ffvsp[-1].Node)) != DOUBLE ) (ffvsp[-1].Node) = New_Unary( DOUBLE, 0, (ffvsp[-1].Node) );
-		     if( Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) ) ) {
-			(ffval.Node) = New_Func( 0, atan2_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0, 0, 0, 0, 0 );
-			TEST((ffval.Node)); 
-			if( SIZE((ffvsp[-3].Node))<SIZE((ffvsp[-1].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-1].Node));
+		   } else if (FSTRCMP((yyvsp[-4].str),"ARCTAN2(") == 0) {
+		     if( TYPE((yyvsp[-3].Node)) != DOUBLE ) (yyvsp[-3].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-3].Node) );
+		     if( TYPE((yyvsp[-1].Node)) != DOUBLE ) (yyvsp[-1].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-1].Node) );
+		     if( Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) {
+			(yyval.Node) = New_Func(lParse,  0, atan2_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0, 0, 0, 0, 0 );
+			TEST((yyval.Node)); 
+			if( SIZE((yyvsp[-3].Node))<SIZE((yyvsp[-1].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-1].Node));
 		     } else {
-			fferror("Dimensions of arctan2 arguments "
+			yyerror(scanner, lParse, "Dimensions of arctan2 arguments "
 				"are not compatible");
-			FFERROR;
+			YYERROR;
 		     }
-		   } else if (FSTRCMP((ffvsp[-4].str),"MIN(") == 0) {
-		      PROMOTE( (ffvsp[-3].Node), (ffvsp[-1].Node) );
-		      if( Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) ) ) {
-			(ffval.Node) = New_Func( 0, min2_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0, 0, 0, 0, 0 );
-			TEST((ffval.Node));
-			if( SIZE((ffvsp[-3].Node))<SIZE((ffvsp[-1].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-1].Node));
+		   } else if (FSTRCMP((yyvsp[-4].str),"MIN(") == 0) {
+		      PROMOTE( (yyvsp[-3].Node), (yyvsp[-1].Node) );
+		      if( Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) {
+			(yyval.Node) = New_Func(lParse,  0, min2_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0, 0, 0, 0, 0 );
+			TEST((yyval.Node));
+			if( SIZE((yyvsp[-3].Node))<SIZE((yyvsp[-1].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-1].Node));
 		      } else {
-			fferror("Dimensions of min(a,b) arguments "
+			yyerror(scanner, lParse, "Dimensions of min(a,b) arguments "
 				"are not compatible");
-			FFERROR;
+			YYERROR;
 		      }
-		   } else if (FSTRCMP((ffvsp[-4].str),"MAX(") == 0) {
-		      PROMOTE( (ffvsp[-3].Node), (ffvsp[-1].Node) );
-		      if( Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) ) ) {
-			(ffval.Node) = New_Func( 0, max2_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0, 0, 0, 0, 0 );
-			TEST((ffval.Node));
-			if( SIZE((ffvsp[-3].Node))<SIZE((ffvsp[-1].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-1].Node));
+		   } else if (FSTRCMP((yyvsp[-4].str),"MAX(") == 0) {
+		      PROMOTE( (yyvsp[-3].Node), (yyvsp[-1].Node) );
+		      if( Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) {
+			(yyval.Node) = New_Func(lParse,  0, max2_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0, 0, 0, 0, 0 );
+			TEST((yyval.Node));
+			if( SIZE((yyvsp[-3].Node))<SIZE((yyvsp[-1].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-1].Node));
 		      } else {
-			fferror("Dimensions of max(a,b) arguments "
+			yyerror(scanner, lParse, "Dimensions of max(a,b) arguments "
 				"are not compatible");
-			FFERROR;
+			YYERROR;
 		      }
-#if 0
-		   } else if (FSTRCMP((ffvsp[-4].str),"STRSTR(") == 0) {
-		     if( TYPE((ffvsp[-3].Node)) != STRING || TYPE((ffvsp[-1].Node)) != STRING) {
-		       fferror("Arguments to strstr(s,r) must be strings");
-		       FFERROR;
-		     }
-		     (ffval.Node) = New_Func( LONG, strpos_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0, 
-				    0, 0, 0, 0 );
-		     TEST((ffval.Node));
-#endif
+		   } else if (FSTRCMP((yyvsp[-4].str),"SETNULL(") == 0) {
+		     if (OPER((yyvsp[-3].Node)) != CONST_OP
+			 || SIZE((yyvsp[-3].Node)) != 1) {
+		       yyerror(scanner, lParse, "SETNULL first argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     /* Make sure first arg is same type as second arg */
+		     if ( TYPE((yyvsp[-3].Node)) != TYPE((yyvsp[-1].Node)) ) (yyvsp[-3].Node) = New_Unary(lParse,  TYPE((yyvsp[-1].Node)), 0, (yyvsp[-3].Node) );
+		     (yyval.Node) = New_Func(lParse,  0, setnull_fct, 2, (yyvsp[-1].Node), (yyvsp[-3].Node), 0, 0, 0, 0, 0 );
+		   } else if (FSTRCMP((yyvsp[-4].str),"AXISELEM(") == 0) {  /* AXISELEM(V,n) */
+		     if (OPER((yyvsp[-1].Node)) != CONST_OP
+			 || SIZE((yyvsp[-1].Node)) != 1) {
+		       yyerror(scanner, lParse, "AXISELEM second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER((yyvsp[-3].Node)) == CONST_OP) {
+		       long one = 1;
+		       (yyval.Node) = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {
+		       if ( TYPE((yyvsp[-1].Node)) != LONG ) (yyvsp[-1].Node) = New_Unary(lParse, LONG, 0, (yyvsp[-1].Node));
+		       (yyval.Node) = New_Func(lParse, 0, axiselem_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0, 0, 0, 0, 0 );
+		       TEST((yyval.Node));
+		       TYPE((yyval.Node)) = LONG;
+		     }
+		   } else if (FSTRCMP((yyvsp[-4].str),"NAXES(") == 0) {  /* NAXES(V,n) */
+		     if (OPER((yyvsp[-1].Node)) != CONST_OP
+			 || SIZE((yyvsp[-1].Node)) != 1) {
+		       yyerror(scanner, lParse, "NAXES second argument must be a scalar constant");
+		       YYERROR;
+		     }
+		     if (OPER((yyvsp[-3].Node)) == CONST_OP) { /* if V is constant, return 1 in every case */
+		       long one = 1;
+		       (yyval.Node) = New_Const(lParse,  LONG, &one, sizeof(one) );
+		     } else {                    /* determine now the dimension of the expression */
+		       long iaxis;
+		       int naxis;
+		       if ( TYPE((yyvsp[-1].Node)) != LONG ) (yyvsp[-1].Node) = New_Unary(lParse, LONG, 0, (yyvsp[-1].Node));
+		       /* Since it is already constant, we can extract long value directly */
+		       iaxis = (lParse->Nodes[(yyvsp[-1].Node)].value.data.lng);
+		       naxis = lParse->Nodes[(yyvsp[-3].Node)].value.naxis;
+
+		       if (iaxis == 0)          iaxis = naxis;   /* NAXIS(V,0) = NAXIS */
+		       else if (iaxis <= naxis) iaxis = lParse->Nodes[(yyvsp[-3].Node)].value.naxes[iaxis-1]; /* NAXIS(V,n) = NAXISn */
+		       else                     iaxis = 1;       /* Out of bounds use 1 */
+
+		       (yyval.Node) = New_Const(lParse,  LONG, &iaxis, sizeof(iaxis) );
+		       TEST((yyval.Node));
+		     }
+		   } else if (FSTRCMP((yyvsp[-4].str),"ARRAY(") == 0) {  /* NAXES(expr,n) */
+		     (yyval.Node) = New_Array(lParse, (yyvsp[-3].Node), (yyvsp[-1].Node));
+		     TEST((yyval.Node));
 		   } else {
-		      fferror("Function(expr,expr) not supported");
-		      FFERROR;
+		      yyerror(scanner, lParse, "Function(expr,expr) not supported");
+		      YYERROR;
 		   }
                 }
-#line 2639 "y.tab.c" /* yacc.c:1648  */
+#line 2651 "eval_y.c"
     break;
 
-  case 61:
-#line 755 "eval.y" /* yacc.c:1648  */
-    { 
-		  if (FSTRCMP((ffvsp[-8].str),"ANGSEP(") == 0) {
-		    if( TYPE((ffvsp[-7].Node)) != DOUBLE ) (ffvsp[-7].Node) = New_Unary( DOUBLE, 0, (ffvsp[-7].Node) );
-		    if( TYPE((ffvsp[-5].Node)) != DOUBLE ) (ffvsp[-5].Node) = New_Unary( DOUBLE, 0, (ffvsp[-5].Node) );
-		    if( TYPE((ffvsp[-3].Node)) != DOUBLE ) (ffvsp[-3].Node) = New_Unary( DOUBLE, 0, (ffvsp[-3].Node) );
-		    if( TYPE((ffvsp[-1].Node)) != DOUBLE ) (ffvsp[-1].Node) = New_Unary( DOUBLE, 0, (ffvsp[-1].Node) );
-		    if( Test_Dims( (ffvsp[-7].Node), (ffvsp[-5].Node) ) && Test_Dims( (ffvsp[-5].Node), (ffvsp[-3].Node) ) && 
-			Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) ) ) {
-		      (ffval.Node) = New_Func( 0, angsep_fct, 4, (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),0,0,0 );
-		      TEST((ffval.Node)); 
-		      if( SIZE((ffvsp[-7].Node))<SIZE((ffvsp[-5].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-5].Node));
-		      if( SIZE((ffvsp[-5].Node))<SIZE((ffvsp[-3].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-3].Node));
-		      if( SIZE((ffvsp[-3].Node))<SIZE((ffvsp[-1].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-1].Node));
+  case 62: /* expr: FUNCTION expr ',' expr ',' expr ',' expr ')'  */
+#line 886 "eval.y"
+                { 
+		  if (FSTRCMP((yyvsp[-8].str),"ANGSEP(") == 0) {
+		    if( TYPE((yyvsp[-7].Node)) != DOUBLE ) (yyvsp[-7].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-7].Node) );
+		    if( TYPE((yyvsp[-5].Node)) != DOUBLE ) (yyvsp[-5].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-5].Node) );
+		    if( TYPE((yyvsp[-3].Node)) != DOUBLE ) (yyvsp[-3].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-3].Node) );
+		    if( TYPE((yyvsp[-1].Node)) != DOUBLE ) (yyvsp[-1].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-1].Node) );
+		    if( Test_Dims( lParse,  (yyvsp[-7].Node), (yyvsp[-5].Node) ) && Test_Dims( lParse,  (yyvsp[-5].Node), (yyvsp[-3].Node) ) && 
+			Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) {
+		      (yyval.Node) = New_Func(lParse,  0, angsep_fct, 4, (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),0,0,0 );
+		      TEST((yyval.Node)); 
+		      if( SIZE((yyvsp[-7].Node))<SIZE((yyvsp[-5].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-5].Node));
+		      if( SIZE((yyvsp[-5].Node))<SIZE((yyvsp[-3].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-3].Node));
+		      if( SIZE((yyvsp[-3].Node))<SIZE((yyvsp[-1].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-1].Node));
 		    } else {
-		      fferror("Dimensions of ANGSEP arguments "
+		      yyerror(scanner, lParse, "Dimensions of ANGSEP arguments "
 			      "are not compatible");
-		      FFERROR;
+		      YYERROR;
 		    }
 		   } else {
-		      fferror("Function(expr,expr,expr,expr) not supported");
-		      FFERROR;
+		      yyerror(scanner, lParse, "Function(expr,expr,expr,expr) not supported");
+		      YYERROR;
 		   }
                 }
-#line 2667 "y.tab.c" /* yacc.c:1648  */
+#line 2679 "eval_y.c"
     break;
 
-  case 62:
-#line 779 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-3].Node), 1, (ffvsp[-1].Node),  0,  0,  0,   0 ); TEST((ffval.Node)); }
-#line 2673 "y.tab.c" /* yacc.c:1648  */
+  case 63: /* expr: expr '[' expr ']'  */
+#line 910 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-3].Node), 1, (yyvsp[-1].Node),  0,  0,  0,   0 ); TEST((yyval.Node)); }
+#line 2685 "eval_y.c"
     break;
 
-  case 63:
-#line 781 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-5].Node), 2, (ffvsp[-3].Node), (ffvsp[-1].Node),  0,  0,   0 ); TEST((ffval.Node)); }
-#line 2679 "y.tab.c" /* yacc.c:1648  */
+  case 64: /* expr: expr '[' expr ',' expr ']'  */
+#line 912 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-5].Node), 2, (yyvsp[-3].Node), (yyvsp[-1].Node),  0,  0,   0 ); TEST((yyval.Node)); }
+#line 2691 "eval_y.c"
     break;
 
-  case 64:
-#line 783 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-7].Node), 3, (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),  0,   0 ); TEST((ffval.Node)); }
-#line 2685 "y.tab.c" /* yacc.c:1648  */
+  case 65: /* expr: expr '[' expr ',' expr ',' expr ']'  */
+#line 914 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-7].Node), 3, (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),  0,   0 ); TEST((yyval.Node)); }
+#line 2697 "eval_y.c"
     break;
 
-  case 65:
-#line 785 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-9].Node), 4, (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),   0 ); TEST((ffval.Node)); }
-#line 2691 "y.tab.c" /* yacc.c:1648  */
+  case 66: /* expr: expr '[' expr ',' expr ',' expr ',' expr ']'  */
+#line 916 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-9].Node), 4, (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),   0 ); TEST((yyval.Node)); }
+#line 2703 "eval_y.c"
     break;
 
-  case 66:
-#line 787 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-11].Node), 5, (ffvsp[-9].Node), (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node) ); TEST((ffval.Node)); }
-#line 2697 "y.tab.c" /* yacc.c:1648  */
+  case 67: /* expr: expr '[' expr ',' expr ',' expr ',' expr ',' expr ']'  */
+#line 918 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-11].Node), 5, (yyvsp[-9].Node), (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node) ); TEST((yyval.Node)); }
+#line 2709 "eval_y.c"
     break;
 
-  case 67:
-#line 789 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Unary( LONG,   INTCAST, (ffvsp[0].Node) );  TEST((ffval.Node));  }
-#line 2703 "y.tab.c" /* yacc.c:1648  */
+  case 68: /* expr: INTCAST expr  */
+#line 920 "eval.y"
+                { (yyval.Node) = New_Unary(lParse,  LONG,   INTCAST, (yyvsp[0].Node) );  TEST((yyval.Node));  }
+#line 2715 "eval_y.c"
     break;
 
-  case 68:
-#line 791 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Unary( LONG,   INTCAST, (ffvsp[0].Node) );  TEST((ffval.Node));  }
-#line 2709 "y.tab.c" /* yacc.c:1648  */
+  case 69: /* expr: INTCAST bexpr  */
+#line 922 "eval.y"
+                { (yyval.Node) = New_Unary(lParse,  LONG,   INTCAST, (yyvsp[0].Node) );  TEST((yyval.Node));  }
+#line 2721 "eval_y.c"
     break;
 
-  case 69:
-#line 793 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Unary( DOUBLE, FLTCAST, (ffvsp[0].Node) );  TEST((ffval.Node));  }
-#line 2715 "y.tab.c" /* yacc.c:1648  */
+  case 70: /* expr: FLTCAST expr  */
+#line 924 "eval.y"
+                { (yyval.Node) = New_Unary(lParse,  DOUBLE, FLTCAST, (yyvsp[0].Node) );  TEST((yyval.Node));  }
+#line 2727 "eval_y.c"
     break;
 
-  case 70:
-#line 795 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Unary( DOUBLE, FLTCAST, (ffvsp[0].Node) );  TEST((ffval.Node));  }
-#line 2721 "y.tab.c" /* yacc.c:1648  */
+  case 71: /* expr: FLTCAST bexpr  */
+#line 926 "eval.y"
+                { (yyval.Node) = New_Unary(lParse,  DOUBLE, FLTCAST, (yyvsp[0].Node) );  TEST((yyval.Node));  }
+#line 2733 "eval_y.c"
     break;
 
-  case 71:
-#line 799 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Const( BOOLEAN, &((ffvsp[0].log)), sizeof(char) ); TEST((ffval.Node)); }
-#line 2727 "y.tab.c" /* yacc.c:1648  */
+  case 72: /* bexpr: BOOLEAN  */
+#line 930 "eval.y"
+                { (yyval.Node) = New_Const(lParse,  BOOLEAN, &((yyvsp[0].log)), sizeof(char) ); TEST((yyval.Node)); }
+#line 2739 "eval_y.c"
     break;
 
-  case 72:
-#line 801 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Column( (ffvsp[0].lng) ); TEST((ffval.Node)); }
-#line 2733 "y.tab.c" /* yacc.c:1648  */
+  case 73: /* bexpr: BCOLUMN  */
+#line 932 "eval.y"
+                { (yyval.Node) = New_Column(lParse,  (yyvsp[0].lng) ); TEST((yyval.Node)); }
+#line 2745 "eval_y.c"
     break;
 
-  case 73:
-#line 803 "eval.y" /* yacc.c:1648  */
-    {
-                  if( TYPE((ffvsp[-1].Node)) != LONG
-		      || OPER((ffvsp[-1].Node)) != CONST_OP ) {
-		     fferror("Offset argument must be a constant integer");
-		     FFERROR;
+  case 74: /* bexpr: BCOLUMN '{' expr '}'  */
+#line 934 "eval.y"
+                {
+                  if( TYPE((yyvsp[-1].Node)) != LONG
+		      || OPER((yyvsp[-1].Node)) != CONST_OP ) {
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
+		     YYERROR;
 		  }
-                  (ffval.Node) = New_Offset( (ffvsp[-3].lng), (ffvsp[-1].Node) ); TEST((ffval.Node));
+                  (yyval.Node) = New_Offset(lParse,  (yyvsp[-3].lng), (yyvsp[-1].Node) ); TEST((yyval.Node));
                 }
-#line 2746 "y.tab.c" /* yacc.c:1648  */
+#line 2758 "eval_y.c"
     break;
 
-  case 74:
-#line 812 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), EQ,  (ffvsp[0].Node) ); TEST((ffval.Node));
-		  SIZE((ffval.Node)) = 1;                                     }
-#line 2753 "y.tab.c" /* yacc.c:1648  */
+  case 75: /* bexpr: bits EQ bits  */
+#line 943 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), EQ,  (yyvsp[0].Node) ); TEST((yyval.Node));
+		  SIZE((yyval.Node)) = 1;                                     }
+#line 2765 "eval_y.c"
     break;
 
-  case 75:
-#line 815 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), NE,  (ffvsp[0].Node) ); TEST((ffval.Node)); 
-		  SIZE((ffval.Node)) = 1;                                     }
-#line 2760 "y.tab.c" /* yacc.c:1648  */
+  case 76: /* bexpr: bits NE bits  */
+#line 946 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), NE,  (yyvsp[0].Node) ); TEST((yyval.Node)); 
+		  SIZE((yyval.Node)) = 1;                                     }
+#line 2772 "eval_y.c"
     break;
 
-  case 76:
-#line 818 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), LT,  (ffvsp[0].Node) ); TEST((ffval.Node)); 
-		  SIZE((ffval.Node)) = 1;                                     }
-#line 2767 "y.tab.c" /* yacc.c:1648  */
+  case 77: /* bexpr: bits LT bits  */
+#line 949 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), LT,  (yyvsp[0].Node) ); TEST((yyval.Node)); 
+		  SIZE((yyval.Node)) = 1;                                     }
+#line 2779 "eval_y.c"
     break;
 
-  case 77:
-#line 821 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), LTE, (ffvsp[0].Node) ); TEST((ffval.Node)); 
-		  SIZE((ffval.Node)) = 1;                                     }
-#line 2774 "y.tab.c" /* yacc.c:1648  */
+  case 78: /* bexpr: bits LTE bits  */
+#line 952 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), LTE, (yyvsp[0].Node) ); TEST((yyval.Node)); 
+		  SIZE((yyval.Node)) = 1;                                     }
+#line 2786 "eval_y.c"
     break;
 
-  case 78:
-#line 824 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), GT,  (ffvsp[0].Node) ); TEST((ffval.Node)); 
-		  SIZE((ffval.Node)) = 1;                                     }
-#line 2781 "y.tab.c" /* yacc.c:1648  */
+  case 79: /* bexpr: bits GT bits  */
+#line 955 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), GT,  (yyvsp[0].Node) ); TEST((yyval.Node)); 
+		  SIZE((yyval.Node)) = 1;                                     }
+#line 2793 "eval_y.c"
     break;
 
-  case 79:
-#line 827 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), GTE, (ffvsp[0].Node) ); TEST((ffval.Node)); 
-		  SIZE((ffval.Node)) = 1;                                     }
-#line 2788 "y.tab.c" /* yacc.c:1648  */
+  case 80: /* bexpr: bits GTE bits  */
+#line 958 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), GTE, (yyvsp[0].Node) ); TEST((yyval.Node)); 
+		  SIZE((yyval.Node)) = 1;                                     }
+#line 2800 "eval_y.c"
     break;
 
-  case 80:
-#line 830 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), GT,  (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                               }
-#line 2795 "y.tab.c" /* yacc.c:1648  */
+  case 81: /* bexpr: expr GT expr  */
+#line 961 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), GT,  (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                               }
+#line 2807 "eval_y.c"
     break;
 
-  case 81:
-#line 833 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), LT,  (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                               }
-#line 2802 "y.tab.c" /* yacc.c:1648  */
+  case 82: /* bexpr: expr LT expr  */
+#line 964 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), LT,  (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                               }
+#line 2814 "eval_y.c"
     break;
 
-  case 82:
-#line 836 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), GTE, (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                               }
-#line 2809 "y.tab.c" /* yacc.c:1648  */
+  case 83: /* bexpr: expr GTE expr  */
+#line 967 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), GTE, (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                               }
+#line 2821 "eval_y.c"
     break;
 
-  case 83:
-#line 839 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), LTE, (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                               }
-#line 2816 "y.tab.c" /* yacc.c:1648  */
+  case 84: /* bexpr: expr LTE expr  */
+#line 970 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), LTE, (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                               }
+#line 2828 "eval_y.c"
     break;
 
-  case 84:
-#line 842 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), '~', (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                               }
-#line 2823 "y.tab.c" /* yacc.c:1648  */
+  case 85: /* bexpr: expr '~' expr  */
+#line 973 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), '~', (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                               }
+#line 2835 "eval_y.c"
     break;
 
-  case 85:
-#line 845 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), EQ,  (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                               }
-#line 2830 "y.tab.c" /* yacc.c:1648  */
+  case 86: /* bexpr: expr EQ expr  */
+#line 976 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), EQ,  (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                               }
+#line 2842 "eval_y.c"
     break;
 
-  case 86:
-#line 848 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node)); (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), NE,  (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                               }
-#line 2837 "y.tab.c" /* yacc.c:1648  */
+  case 87: /* bexpr: expr NE expr  */
+#line 979 "eval.y"
+                { PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node)); (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), NE,  (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                               }
+#line 2849 "eval_y.c"
     break;
 
-  case 87:
-#line 851 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), EQ,  (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = 1; }
-#line 2844 "y.tab.c" /* yacc.c:1648  */
+  case 88: /* bexpr: sexpr EQ sexpr  */
+#line 982 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), EQ,  (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = 1; }
+#line 2856 "eval_y.c"
     break;
 
-  case 88:
-#line 854 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), NE,  (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = 1; }
-#line 2851 "y.tab.c" /* yacc.c:1648  */
+  case 89: /* bexpr: sexpr NE sexpr  */
+#line 985 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), NE,  (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = 1; }
+#line 2863 "eval_y.c"
     break;
 
-  case 89:
-#line 857 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), GT,  (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = 1; }
-#line 2858 "y.tab.c" /* yacc.c:1648  */
+  case 90: /* bexpr: sexpr GT sexpr  */
+#line 988 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), GT,  (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = 1; }
+#line 2870 "eval_y.c"
     break;
 
-  case 90:
-#line 860 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), GTE, (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = 1; }
-#line 2865 "y.tab.c" /* yacc.c:1648  */
+  case 91: /* bexpr: sexpr GTE sexpr  */
+#line 991 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), GTE, (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = 1; }
+#line 2877 "eval_y.c"
     break;
 
-  case 91:
-#line 863 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), LT,  (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = 1; }
-#line 2872 "y.tab.c" /* yacc.c:1648  */
+  case 92: /* bexpr: sexpr LT sexpr  */
+#line 994 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), LT,  (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = 1; }
+#line 2884 "eval_y.c"
     break;
 
-  case 92:
-#line 866 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), LTE, (ffvsp[0].Node) ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = 1; }
-#line 2879 "y.tab.c" /* yacc.c:1648  */
+  case 93: /* bexpr: sexpr LTE sexpr  */
+#line 997 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), LTE, (yyvsp[0].Node) ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = 1; }
+#line 2891 "eval_y.c"
     break;
 
-  case 93:
-#line 869 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), AND, (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 2885 "y.tab.c" /* yacc.c:1648  */
+  case 94: /* bexpr: bexpr AND bexpr  */
+#line 1000 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), AND, (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 2897 "eval_y.c"
     break;
 
-  case 94:
-#line 871 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), OR,  (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 2891 "y.tab.c" /* yacc.c:1648  */
+  case 95: /* bexpr: bexpr OR bexpr  */
+#line 1002 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), OR,  (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 2903 "eval_y.c"
     break;
 
-  case 95:
-#line 873 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), EQ,  (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 2897 "y.tab.c" /* yacc.c:1648  */
+  case 96: /* bexpr: bexpr EQ bexpr  */
+#line 1004 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), EQ,  (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 2909 "eval_y.c"
     break;
 
-  case 96:
-#line 875 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), NE,  (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 2903 "y.tab.c" /* yacc.c:1648  */
+  case 97: /* bexpr: bexpr NE bexpr  */
+#line 1006 "eval.y"
+                { (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), NE,  (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 2915 "eval_y.c"
     break;
 
-  case 97:
-#line 878 "eval.y" /* yacc.c:1648  */
-    { PROMOTE((ffvsp[-4].Node),(ffvsp[-2].Node)); PROMOTE((ffvsp[-4].Node),(ffvsp[0].Node)); PROMOTE((ffvsp[-2].Node),(ffvsp[0].Node));
-		  (ffvsp[-2].Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), LTE, (ffvsp[-4].Node) );
-                  (ffvsp[0].Node) = New_BinOp( BOOLEAN, (ffvsp[-4].Node), LTE, (ffvsp[0].Node) );
-                  (ffval.Node) = New_BinOp( BOOLEAN, (ffvsp[-2].Node), AND, (ffvsp[0].Node) );
-                  TEST((ffval.Node));                                         }
-#line 2913 "y.tab.c" /* yacc.c:1648  */
+  case 98: /* bexpr: expr '=' expr ':' expr  */
+#line 1009 "eval.y"
+                { PROMOTE((yyvsp[-4].Node),(yyvsp[-2].Node)); PROMOTE((yyvsp[-4].Node),(yyvsp[0].Node)); PROMOTE((yyvsp[-2].Node),(yyvsp[0].Node));
+		  (yyvsp[-2].Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), LTE, (yyvsp[-4].Node) );
+                  (yyvsp[0].Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-4].Node), LTE, (yyvsp[0].Node) );
+                  (yyval.Node) = New_BinOp(lParse,  BOOLEAN, (yyvsp[-2].Node), AND, (yyvsp[0].Node) );
+                  TEST((yyval.Node));                                         }
+#line 2925 "eval_y.c"
     break;
 
-  case 98:
-#line 885 "eval.y" /* yacc.c:1648  */
-    {
-                  if( ! Test_Dims((ffvsp[-2].Node),(ffvsp[0].Node)) ) {
-                     fferror("Incompatible dimensions in '?:' arguments");
-		     FFERROR;
+  case 99: /* bexpr: bexpr '?' bexpr ':' bexpr  */
+#line 1016 "eval.y"
+                {
+                  if( ! Test_Dims( lParse, (yyvsp[-2].Node),(yyvsp[0].Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' arguments");
+		     YYERROR;
                   }
-                  (ffval.Node) = New_Func( 0, ifthenelse_fct, 3, (ffvsp[-2].Node), (ffvsp[0].Node), (ffvsp[-4].Node),
+                  (yyval.Node) = New_Func(lParse,  0, ifthenelse_fct, 3, (yyvsp[-2].Node), (yyvsp[0].Node), (yyvsp[-4].Node),
                                  0, 0, 0, 0 );
-                  TEST((ffval.Node));
-                  if( SIZE((ffvsp[-2].Node))<SIZE((ffvsp[0].Node)) )  Copy_Dims((ffval.Node), (ffvsp[0].Node));
-                  if( ! Test_Dims((ffvsp[-4].Node),(ffval.Node)) ) {
-                     fferror("Incompatible dimensions in '?:' condition");
-		     FFERROR;
+                  TEST((yyval.Node));
+                  if( SIZE((yyvsp[-2].Node))<SIZE((yyvsp[0].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[0].Node));
+                  if( ! Test_Dims( lParse, (yyvsp[-4].Node),(yyval.Node)) ) {
+                     yyerror(scanner, lParse, "Incompatible dimensions in '?:' condition");
+		     YYERROR;
                   }
-                  if( SIZE((ffval.Node))<SIZE((ffvsp[-4].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-4].Node));
+                  if( SIZE((yyval.Node))<SIZE((yyvsp[-4].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-4].Node));
                 }
-#line 2933 "y.tab.c" /* yacc.c:1648  */
+#line 2945 "eval_y.c"
     break;
 
-  case 99:
-#line 902 "eval.y" /* yacc.c:1648  */
-    {
-		   if (FSTRCMP((ffvsp[-2].str),"ISNULL(") == 0) {
-		      (ffval.Node) = New_Func( 0, isnull_fct, 1, (ffvsp[-1].Node), 0, 0,
+  case 100: /* bexpr: BFUNCTION expr ')'  */
+#line 1033 "eval.y"
+                {
+		   if (FSTRCMP((yyvsp[-2].str),"ISNULL(") == 0) {
+		      (yyval.Node) = New_Func(lParse,  0, isnull_fct, 1, (yyvsp[-1].Node), 0, 0,
 				     0, 0, 0, 0 );
-		      TEST((ffval.Node)); 
+		      TEST((yyval.Node)); 
                       /* Use expression's size, but return BOOLEAN */
-		      TYPE((ffval.Node)) = BOOLEAN;
+		      TYPE((yyval.Node)) = BOOLEAN;
 		   } else {
-		      fferror("Boolean Function(expr) not supported");
-		      FFERROR;
+		      yyerror(scanner, lParse, "Boolean Function(expr) not supported");
+		      YYERROR;
 		   }
 		}
-#line 2950 "y.tab.c" /* yacc.c:1648  */
+#line 2962 "eval_y.c"
     break;
 
-  case 100:
-#line 915 "eval.y" /* yacc.c:1648  */
-    {
-		   if (FSTRCMP((ffvsp[-2].str),"ISNULL(") == 0) {
-		      (ffval.Node) = New_Func( 0, isnull_fct, 1, (ffvsp[-1].Node), 0, 0,
+  case 101: /* bexpr: BFUNCTION bexpr ')'  */
+#line 1046 "eval.y"
+                {
+		   if (FSTRCMP((yyvsp[-2].str),"ISNULL(") == 0) {
+		      (yyval.Node) = New_Func(lParse,  0, isnull_fct, 1, (yyvsp[-1].Node), 0, 0,
 				     0, 0, 0, 0 );
-		      TEST((ffval.Node)); 
+		      TEST((yyval.Node)); 
                       /* Use expression's size, but return BOOLEAN */
-		      TYPE((ffval.Node)) = BOOLEAN;
+		      TYPE((yyval.Node)) = BOOLEAN;
 		   } else {
-		      fferror("Boolean Function(expr) not supported");
-		      FFERROR;
+		      yyerror(scanner, lParse, "Boolean Function(expr) not supported");
+		      YYERROR;
 		   }
 		}
-#line 2967 "y.tab.c" /* yacc.c:1648  */
+#line 2979 "eval_y.c"
     break;
 
-  case 101:
-#line 928 "eval.y" /* yacc.c:1648  */
-    {
-		   if (FSTRCMP((ffvsp[-2].str),"ISNULL(") == 0) {
-		      (ffval.Node) = New_Func( BOOLEAN, isnull_fct, 1, (ffvsp[-1].Node), 0, 0,
+  case 102: /* bexpr: BFUNCTION sexpr ')'  */
+#line 1059 "eval.y"
+                {
+		   if (FSTRCMP((yyvsp[-2].str),"ISNULL(") == 0) {
+		      (yyval.Node) = New_Func(lParse,  BOOLEAN, isnull_fct, 1, (yyvsp[-1].Node), 0, 0,
 				     0, 0, 0, 0 );
-		      TEST((ffval.Node)); 
+		      TEST((yyval.Node)); 
 		   } else {
-		      fferror("Boolean Function(expr) not supported");
-		      FFERROR;
+		      yyerror(scanner, lParse, "Boolean Function(expr) not supported");
+		      YYERROR;
 		   }
 		}
-#line 2982 "y.tab.c" /* yacc.c:1648  */
+#line 2994 "eval_y.c"
     break;
 
-  case 102:
-#line 939 "eval.y" /* yacc.c:1648  */
-    {
-		   if (FSTRCMP((ffvsp[-4].str),"DEFNULL(") == 0) {
-		      if( SIZE((ffvsp[-3].Node))>=SIZE((ffvsp[-1].Node)) && Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) ) ) {
-			 (ffval.Node) = New_Func( 0, defnull_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0,
+  case 103: /* bexpr: FUNCTION bexpr ',' bexpr ')'  */
+#line 1070 "eval.y"
+                {
+		   if (FSTRCMP((yyvsp[-4].str),"DEFNULL(") == 0) {
+		      if( SIZE((yyvsp[-3].Node))>=SIZE((yyvsp[-1].Node)) && Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) {
+			 (yyval.Node) = New_Func(lParse,  0, defnull_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0,
 					0, 0, 0, 0 );
-			 TEST((ffval.Node)); 
+			 TEST((yyval.Node)); 
 		      } else {
-			 fferror("Dimensions of DEFNULL arguments are not compatible");
-			 FFERROR;
+			 yyerror(scanner, lParse, "Dimensions of DEFNULL arguments are not compatible");
+			 YYERROR;
 		      }
 		   } else {
-		      fferror("Boolean Function(expr,expr) not supported");
-		      FFERROR;
+		      yyerror(scanner, lParse, "Boolean Function(expr,expr) not supported");
+		      YYERROR;
 		   }
 		}
-#line 3002 "y.tab.c" /* yacc.c:1648  */
+#line 3014 "eval_y.c"
     break;
 
-  case 103:
-#line 955 "eval.y" /* yacc.c:1648  */
-    {
-		   if( TYPE((ffvsp[-5].Node)) != DOUBLE ) (ffvsp[-5].Node) = New_Unary( DOUBLE, 0, (ffvsp[-5].Node) );
-		   if( TYPE((ffvsp[-3].Node)) != DOUBLE ) (ffvsp[-3].Node) = New_Unary( DOUBLE, 0, (ffvsp[-3].Node) );
-		   if( TYPE((ffvsp[-1].Node)) != DOUBLE ) (ffvsp[-1].Node) = New_Unary( DOUBLE, 0, (ffvsp[-1].Node) );
-		   if( ! (Test_Dims( (ffvsp[-5].Node), (ffvsp[-3].Node) ) && Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) ) ) ) {
-		       fferror("Dimensions of NEAR arguments "
+  case 104: /* bexpr: BFUNCTION expr ',' expr ',' expr ')'  */
+#line 1086 "eval.y"
+                {
+		   if( TYPE((yyvsp[-5].Node)) != DOUBLE ) (yyvsp[-5].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-5].Node) );
+		   if( TYPE((yyvsp[-3].Node)) != DOUBLE ) (yyvsp[-3].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-3].Node) );
+		   if( TYPE((yyvsp[-1].Node)) != DOUBLE ) (yyvsp[-1].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-1].Node) );
+		   if( ! (Test_Dims( lParse,  (yyvsp[-5].Node), (yyvsp[-3].Node) ) && Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) ) {
+		       yyerror(scanner, lParse, "Dimensions of NEAR arguments "
 			       "are not compatible");
-		       FFERROR;
+		       YYERROR;
 		   } else {
-		     if (FSTRCMP((ffvsp[-6].str),"NEAR(") == 0) {
-		       (ffval.Node) = New_Func( BOOLEAN, near_fct, 3, (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),
+		     if (FSTRCMP((yyvsp[-6].str),"NEAR(") == 0) {
+		       (yyval.Node) = New_Func(lParse,  BOOLEAN, near_fct, 3, (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),
 				      0, 0, 0, 0 );
 		     } else {
-		       fferror("Boolean Function not supported");
-		       FFERROR;
+		       yyerror(scanner, lParse, "Boolean Function not supported");
+		       YYERROR;
 		     }
-		     TEST((ffval.Node)); 
+		     TEST((yyval.Node)); 
 
-		     if( SIZE((ffval.Node))<SIZE((ffvsp[-5].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-5].Node));
-		     if( SIZE((ffvsp[-5].Node))<SIZE((ffvsp[-3].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-3].Node));
-		     if( SIZE((ffvsp[-3].Node))<SIZE((ffvsp[-1].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-1].Node));
+		     if( SIZE((yyval.Node))<SIZE((yyvsp[-5].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-5].Node));
+		     if( SIZE((yyvsp[-5].Node))<SIZE((yyvsp[-3].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-3].Node));
+		     if( SIZE((yyvsp[-3].Node))<SIZE((yyvsp[-1].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-1].Node));
 		   }
 		}
-#line 3030 "y.tab.c" /* yacc.c:1648  */
+#line 3042 "eval_y.c"
     break;
 
-  case 104:
-#line 979 "eval.y" /* yacc.c:1648  */
-    {
-		   if( TYPE((ffvsp[-9].Node)) != DOUBLE ) (ffvsp[-9].Node) = New_Unary( DOUBLE, 0, (ffvsp[-9].Node) );
-		   if( TYPE((ffvsp[-7].Node)) != DOUBLE ) (ffvsp[-7].Node) = New_Unary( DOUBLE, 0, (ffvsp[-7].Node) );
-		   if( TYPE((ffvsp[-5].Node)) != DOUBLE ) (ffvsp[-5].Node) = New_Unary( DOUBLE, 0, (ffvsp[-5].Node) );
-		   if( TYPE((ffvsp[-3].Node)) != DOUBLE ) (ffvsp[-3].Node) = New_Unary( DOUBLE, 0, (ffvsp[-3].Node) );
-		   if( TYPE((ffvsp[-1].Node))!= DOUBLE ) (ffvsp[-1].Node)= New_Unary( DOUBLE, 0, (ffvsp[-1].Node));
-		   if( ! (Test_Dims( (ffvsp[-9].Node), (ffvsp[-7].Node) ) && Test_Dims( (ffvsp[-7].Node), (ffvsp[-5].Node) ) && 
-			  Test_Dims( (ffvsp[-5].Node), (ffvsp[-3].Node) ) && Test_Dims( (ffvsp[-3].Node), (ffvsp[-1].Node) )) ) {
-		     fferror("Dimensions of CIRCLE arguments "
+  case 105: /* bexpr: BFUNCTION expr ',' expr ',' expr ',' expr ',' expr ')'  */
+#line 1110 "eval.y"
+                {
+		   if( TYPE((yyvsp[-9].Node)) != DOUBLE ) (yyvsp[-9].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-9].Node) );
+		   if( TYPE((yyvsp[-7].Node)) != DOUBLE ) (yyvsp[-7].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-7].Node) );
+		   if( TYPE((yyvsp[-5].Node)) != DOUBLE ) (yyvsp[-5].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-5].Node) );
+		   if( TYPE((yyvsp[-3].Node)) != DOUBLE ) (yyvsp[-3].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-3].Node) );
+		   if( TYPE((yyvsp[-1].Node))!= DOUBLE ) (yyvsp[-1].Node)= New_Unary(lParse,  DOUBLE, 0, (yyvsp[-1].Node));
+		   if( ! (Test_Dims( lParse,  (yyvsp[-9].Node), (yyvsp[-7].Node) ) && Test_Dims( lParse,  (yyvsp[-7].Node), (yyvsp[-5].Node) ) && 
+			  Test_Dims( lParse,  (yyvsp[-5].Node), (yyvsp[-3].Node) ) && Test_Dims( lParse,  (yyvsp[-3].Node), (yyvsp[-1].Node) )) ) {
+		     yyerror(scanner, lParse, "Dimensions of CIRCLE arguments "
 			     "are not compatible");
-		     FFERROR;
+		     YYERROR;
 		   } else {
-		     if (FSTRCMP((ffvsp[-10].str),"CIRCLE(") == 0) {
-		       (ffval.Node) = New_Func( BOOLEAN, circle_fct, 5, (ffvsp[-9].Node), (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node),
-				      (ffvsp[-1].Node), 0, 0 );
+		     if (FSTRCMP((yyvsp[-10].str),"CIRCLE(") == 0) {
+		       (yyval.Node) = New_Func(lParse,  BOOLEAN, circle_fct, 5, (yyvsp[-9].Node), (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node),
+				      (yyvsp[-1].Node), 0, 0 );
 		     } else {
-		       fferror("Boolean Function not supported");
-		       FFERROR;
+		       yyerror(scanner, lParse, "Boolean Function not supported");
+		       YYERROR;
 		     }
-		     TEST((ffval.Node)); 
-		     if( SIZE((ffval.Node))<SIZE((ffvsp[-9].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-9].Node));
-		     if( SIZE((ffvsp[-9].Node))<SIZE((ffvsp[-7].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-7].Node));
-		     if( SIZE((ffvsp[-7].Node))<SIZE((ffvsp[-5].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-5].Node));
-		     if( SIZE((ffvsp[-5].Node))<SIZE((ffvsp[-3].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-3].Node));
-		     if( SIZE((ffvsp[-3].Node))<SIZE((ffvsp[-1].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-1].Node));
+		     TEST((yyval.Node)); 
+		     if( SIZE((yyval.Node))<SIZE((yyvsp[-9].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-9].Node));
+		     if( SIZE((yyvsp[-9].Node))<SIZE((yyvsp[-7].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-7].Node));
+		     if( SIZE((yyvsp[-7].Node))<SIZE((yyvsp[-5].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-5].Node));
+		     if( SIZE((yyvsp[-5].Node))<SIZE((yyvsp[-3].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-3].Node));
+		     if( SIZE((yyvsp[-3].Node))<SIZE((yyvsp[-1].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-1].Node));
 		   }
 		}
-#line 3062 "y.tab.c" /* yacc.c:1648  */
+#line 3074 "eval_y.c"
     break;
 
-  case 105:
-#line 1007 "eval.y" /* yacc.c:1648  */
-    {
-		   if( TYPE((ffvsp[-13].Node)) != DOUBLE ) (ffvsp[-13].Node) = New_Unary( DOUBLE, 0, (ffvsp[-13].Node) );
-		   if( TYPE((ffvsp[-11].Node)) != DOUBLE ) (ffvsp[-11].Node) = New_Unary( DOUBLE, 0, (ffvsp[-11].Node) );
-		   if( TYPE((ffvsp[-9].Node)) != DOUBLE ) (ffvsp[-9].Node) = New_Unary( DOUBLE, 0, (ffvsp[-9].Node) );
-		   if( TYPE((ffvsp[-7].Node)) != DOUBLE ) (ffvsp[-7].Node) = New_Unary( DOUBLE, 0, (ffvsp[-7].Node) );
-		   if( TYPE((ffvsp[-5].Node))!= DOUBLE ) (ffvsp[-5].Node)= New_Unary( DOUBLE, 0, (ffvsp[-5].Node));
-		   if( TYPE((ffvsp[-3].Node))!= DOUBLE ) (ffvsp[-3].Node)= New_Unary( DOUBLE, 0, (ffvsp[-3].Node));
-		   if( TYPE((ffvsp[-1].Node))!= DOUBLE ) (ffvsp[-1].Node)= New_Unary( DOUBLE, 0, (ffvsp[-1].Node));
-		   if( ! (Test_Dims( (ffvsp[-13].Node), (ffvsp[-11].Node) ) && Test_Dims( (ffvsp[-11].Node), (ffvsp[-9].Node) ) && 
-			  Test_Dims( (ffvsp[-9].Node), (ffvsp[-7].Node) ) && Test_Dims( (ffvsp[-7].Node), (ffvsp[-5].Node) ) &&
-			  Test_Dims((ffvsp[-5].Node),(ffvsp[-3].Node) ) && Test_Dims((ffvsp[-3].Node), (ffvsp[-1].Node) ) ) ) {
-		     fferror("Dimensions of BOX or ELLIPSE arguments "
+  case 106: /* bexpr: BFUNCTION expr ',' expr ',' expr ',' expr ',' expr ',' expr ',' expr ')'  */
+#line 1138 "eval.y"
+                {
+		   if( TYPE((yyvsp[-13].Node)) != DOUBLE ) (yyvsp[-13].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-13].Node) );
+		   if( TYPE((yyvsp[-11].Node)) != DOUBLE ) (yyvsp[-11].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-11].Node) );
+		   if( TYPE((yyvsp[-9].Node)) != DOUBLE ) (yyvsp[-9].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-9].Node) );
+		   if( TYPE((yyvsp[-7].Node)) != DOUBLE ) (yyvsp[-7].Node) = New_Unary(lParse,  DOUBLE, 0, (yyvsp[-7].Node) );
+		   if( TYPE((yyvsp[-5].Node))!= DOUBLE ) (yyvsp[-5].Node)= New_Unary(lParse,  DOUBLE, 0, (yyvsp[-5].Node));
+		   if( TYPE((yyvsp[-3].Node))!= DOUBLE ) (yyvsp[-3].Node)= New_Unary(lParse,  DOUBLE, 0, (yyvsp[-3].Node));
+		   if( TYPE((yyvsp[-1].Node))!= DOUBLE ) (yyvsp[-1].Node)= New_Unary(lParse,  DOUBLE, 0, (yyvsp[-1].Node));
+		   if( ! (Test_Dims( lParse,  (yyvsp[-13].Node), (yyvsp[-11].Node) ) && Test_Dims( lParse,  (yyvsp[-11].Node), (yyvsp[-9].Node) ) && 
+			  Test_Dims( lParse,  (yyvsp[-9].Node), (yyvsp[-7].Node) ) && Test_Dims( lParse,  (yyvsp[-7].Node), (yyvsp[-5].Node) ) &&
+			  Test_Dims( lParse, (yyvsp[-5].Node),(yyvsp[-3].Node) ) && Test_Dims( lParse, (yyvsp[-3].Node), (yyvsp[-1].Node) ) ) ) {
+		     yyerror(scanner, lParse, "Dimensions of BOX or ELLIPSE arguments "
 			     "are not compatible");
-		     FFERROR;
+		     YYERROR;
 		   } else {
-		     if (FSTRCMP((ffvsp[-14].str),"BOX(") == 0) {
-		       (ffval.Node) = New_Func( BOOLEAN, box_fct, 7, (ffvsp[-13].Node), (ffvsp[-11].Node), (ffvsp[-9].Node), (ffvsp[-7].Node),
-				      (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node) );
-		     } else if (FSTRCMP((ffvsp[-14].str),"ELLIPSE(") == 0) {
-		       (ffval.Node) = New_Func( BOOLEAN, elps_fct, 7, (ffvsp[-13].Node), (ffvsp[-11].Node), (ffvsp[-9].Node), (ffvsp[-7].Node),
-				      (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node) );
+		     if (FSTRCMP((yyvsp[-14].str),"BOX(") == 0) {
+		       (yyval.Node) = New_Func(lParse,  BOOLEAN, box_fct, 7, (yyvsp[-13].Node), (yyvsp[-11].Node), (yyvsp[-9].Node), (yyvsp[-7].Node),
+				      (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node) );
+		     } else if (FSTRCMP((yyvsp[-14].str),"ELLIPSE(") == 0) {
+		       (yyval.Node) = New_Func(lParse,  BOOLEAN, elps_fct, 7, (yyvsp[-13].Node), (yyvsp[-11].Node), (yyvsp[-9].Node), (yyvsp[-7].Node),
+				      (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node) );
 		     } else {
-		       fferror("SAO Image Function not supported");
-		       FFERROR;
+		       yyerror(scanner, lParse, "SAO Image Function not supported");
+		       YYERROR;
 		     }
-		     TEST((ffval.Node)); 
-		     if( SIZE((ffval.Node))<SIZE((ffvsp[-13].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-13].Node));
-		     if( SIZE((ffvsp[-13].Node))<SIZE((ffvsp[-11].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-11].Node));
-		     if( SIZE((ffvsp[-11].Node))<SIZE((ffvsp[-9].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-9].Node));
-		     if( SIZE((ffvsp[-9].Node))<SIZE((ffvsp[-7].Node)) )  Copy_Dims((ffval.Node), (ffvsp[-7].Node));
-		     if( SIZE((ffvsp[-7].Node))<SIZE((ffvsp[-5].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-5].Node));
-		     if( SIZE((ffvsp[-5].Node))<SIZE((ffvsp[-3].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-3].Node));
-		     if( SIZE((ffvsp[-3].Node))<SIZE((ffvsp[-1].Node)) ) Copy_Dims((ffval.Node), (ffvsp[-1].Node));
+		     TEST((yyval.Node)); 
+		     if( SIZE((yyval.Node))<SIZE((yyvsp[-13].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-13].Node));
+		     if( SIZE((yyvsp[-13].Node))<SIZE((yyvsp[-11].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-11].Node));
+		     if( SIZE((yyvsp[-11].Node))<SIZE((yyvsp[-9].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-9].Node));
+		     if( SIZE((yyvsp[-9].Node))<SIZE((yyvsp[-7].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[-7].Node));
+		     if( SIZE((yyvsp[-7].Node))<SIZE((yyvsp[-5].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-5].Node));
+		     if( SIZE((yyvsp[-5].Node))<SIZE((yyvsp[-3].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-3].Node));
+		     if( SIZE((yyvsp[-3].Node))<SIZE((yyvsp[-1].Node)) ) Copy_Dims( lParse,(yyval.Node), (yyvsp[-1].Node));
 		   }
 		}
-#line 3102 "y.tab.c" /* yacc.c:1648  */
+#line 3114 "eval_y.c"
     break;
 
-  case 106:
-#line 1044 "eval.y" /* yacc.c:1648  */
-    { /* Use defaults for all elements */
-                   (ffval.Node) = New_GTI( "", -99, "*START*", "*STOP*" );
-                   TEST((ffval.Node));                                        }
-#line 3110 "y.tab.c" /* yacc.c:1648  */
+  case 107: /* bexpr: GTIFILTER ')'  */
+#line 1175 "eval.y"
+                { /* Use defaults for all elements */
+		   (yyval.Node) = New_GTI(lParse, gtifilt_fct,  "", -99, -99, "*START*", "*STOP*" );
+                   TEST((yyval.Node));                                        }
+#line 3122 "eval_y.c"
     break;
 
-  case 107:
-#line 1048 "eval.y" /* yacc.c:1648  */
-    { /* Use defaults for all except filename */
-                   (ffval.Node) = New_GTI( (ffvsp[-1].str), -99, "*START*", "*STOP*" );
-                   TEST((ffval.Node));                                        }
-#line 3118 "y.tab.c" /* yacc.c:1648  */
+  case 108: /* bexpr: GTIFILTER STRING ')'  */
+#line 1179 "eval.y"
+                { /* Use defaults for all except filename */
+		  (yyval.Node) = New_GTI(lParse, gtifilt_fct,  (yyvsp[-1].str), -99, -99, "*START*", "*STOP*" );
+                   TEST((yyval.Node));                                        }
+#line 3130 "eval_y.c"
     break;
 
-  case 108:
-#line 1052 "eval.y" /* yacc.c:1648  */
-    {  (ffval.Node) = New_GTI( (ffvsp[-3].str), (ffvsp[-1].Node), "*START*", "*STOP*" );
-                   TEST((ffval.Node));                                        }
-#line 3125 "y.tab.c" /* yacc.c:1648  */
+  case 109: /* bexpr: GTIFILTER STRING ',' expr ')'  */
+#line 1183 "eval.y"
+                {  (yyval.Node) = New_GTI(lParse, gtifilt_fct,  (yyvsp[-3].str), (yyvsp[-1].Node), -99, "*START*", "*STOP*" );
+                   TEST((yyval.Node));                                        }
+#line 3137 "eval_y.c"
     break;
 
-  case 109:
-#line 1055 "eval.y" /* yacc.c:1648  */
-    {  (ffval.Node) = New_GTI( (ffvsp[-7].str), (ffvsp[-5].Node), (ffvsp[-3].str), (ffvsp[-1].str) );
-                   TEST((ffval.Node));                                        }
-#line 3132 "y.tab.c" /* yacc.c:1648  */
+  case 110: /* bexpr: GTIFILTER STRING ',' expr ',' STRING ',' STRING ')'  */
+#line 1186 "eval.y"
+                {  (yyval.Node) = New_GTI(lParse, gtifilt_fct,  (yyvsp[-7].str), (yyvsp[-5].Node), -99, (yyvsp[-3].str), (yyvsp[-1].str) );
+                   TEST((yyval.Node));                                        }
+#line 3144 "eval_y.c"
     break;
 
-  case 110:
-#line 1059 "eval.y" /* yacc.c:1648  */
-    { /* Use defaults for all except filename */
-                   (ffval.Node) = New_REG( (ffvsp[-1].str), -99, -99, "" );
-                   TEST((ffval.Node));                                        }
-#line 3140 "y.tab.c" /* yacc.c:1648  */
+  case 111: /* bexpr: GTIOVERLAP STRING ',' expr ',' expr ')'  */
+#line 1191 "eval.y"
+                {  (yyval.Node) = New_GTI(lParse, gtiover_fct,  (yyvsp[-5].str), (yyvsp[-3].Node), (yyvsp[-1].Node), "*START*", "*STOP*");
+                   TEST((yyval.Node));                                        }
+#line 3151 "eval_y.c"
     break;
 
-  case 111:
-#line 1063 "eval.y" /* yacc.c:1648  */
-    {  (ffval.Node) = New_REG( (ffvsp[-5].str), (ffvsp[-3].Node), (ffvsp[-1].Node), "" );
-                   TEST((ffval.Node));                                        }
-#line 3147 "y.tab.c" /* yacc.c:1648  */
+  case 112: /* bexpr: GTIOVERLAP STRING ',' expr ',' expr ',' STRING ',' STRING ')'  */
+#line 1194 "eval.y"
+                {  (yyval.Node) = New_GTI(lParse, gtiover_fct,  (yyvsp[-9].str), (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].str), (yyvsp[-1].str) );
+                   TEST((yyval.Node));                                        }
+#line 3158 "eval_y.c"
     break;
 
-  case 112:
-#line 1066 "eval.y" /* yacc.c:1648  */
-    {  (ffval.Node) = New_REG( (ffvsp[-7].str), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].str) );
-                   TEST((ffval.Node));                                        }
-#line 3154 "y.tab.c" /* yacc.c:1648  */
+  case 113: /* bexpr: GTIFIND ')'  */
+#line 1199 "eval.y"
+                { /* Use defaults for all elements */
+		   (yyval.Node) = New_GTI(lParse, gtifind_fct,  "", -99, -99, "*START*", "*STOP*" );
+                   TEST((yyval.Node));                                        }
+#line 3166 "eval_y.c"
     break;
 
-  case 113:
-#line 1070 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-3].Node), 1, (ffvsp[-1].Node),  0,  0,  0,   0 ); TEST((ffval.Node)); }
-#line 3160 "y.tab.c" /* yacc.c:1648  */
+  case 114: /* bexpr: GTIFIND STRING ')'  */
+#line 1203 "eval.y"
+                { /* Use defaults for all except filename */
+		  (yyval.Node) = New_GTI(lParse, gtifind_fct,  (yyvsp[-1].str), -99, -99, "*START*", "*STOP*" );
+                   TEST((yyval.Node));                                        }
+#line 3174 "eval_y.c"
     break;
 
-  case 114:
-#line 1072 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-5].Node), 2, (ffvsp[-3].Node), (ffvsp[-1].Node),  0,  0,   0 ); TEST((ffval.Node)); }
-#line 3166 "y.tab.c" /* yacc.c:1648  */
+  case 115: /* bexpr: GTIFIND STRING ',' expr ')'  */
+#line 1207 "eval.y"
+                {  (yyval.Node) = New_GTI(lParse, gtifind_fct,  (yyvsp[-3].str), (yyvsp[-1].Node), -99, "*START*", "*STOP*" );
+                   TEST((yyval.Node));                                        }
+#line 3181 "eval_y.c"
     break;
 
-  case 115:
-#line 1074 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-7].Node), 3, (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),  0,   0 ); TEST((ffval.Node)); }
-#line 3172 "y.tab.c" /* yacc.c:1648  */
+  case 116: /* bexpr: GTIFIND STRING ',' expr ',' STRING ',' STRING ')'  */
+#line 1210 "eval.y"
+                {  (yyval.Node) = New_GTI(lParse, gtifind_fct,  (yyvsp[-7].str), (yyvsp[-5].Node), -99, (yyvsp[-3].str), (yyvsp[-1].str) );
+                   TEST((yyval.Node));                                        }
+#line 3188 "eval_y.c"
     break;
 
-  case 116:
-#line 1076 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-9].Node), 4, (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node),   0 ); TEST((ffval.Node)); }
-#line 3178 "y.tab.c" /* yacc.c:1648  */
+  case 117: /* bexpr: REGFILTER STRING ')'  */
+#line 1215 "eval.y"
+                { /* Use defaults for all except filename */
+                   (yyval.Node) = New_REG(lParse,  (yyvsp[-1].str), -99, -99, "" );
+                   TEST((yyval.Node));                                        }
+#line 3196 "eval_y.c"
     break;
 
-  case 117:
-#line 1078 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Deref( (ffvsp[-11].Node), 5, (ffvsp[-9].Node), (ffvsp[-7].Node), (ffvsp[-5].Node), (ffvsp[-3].Node), (ffvsp[-1].Node) ); TEST((ffval.Node)); }
-#line 3184 "y.tab.c" /* yacc.c:1648  */
+  case 118: /* bexpr: REGFILTER STRING ',' expr ',' expr ')'  */
+#line 1219 "eval.y"
+                {  (yyval.Node) = New_REG(lParse,  (yyvsp[-5].str), (yyvsp[-3].Node), (yyvsp[-1].Node), "" );
+                   TEST((yyval.Node));                                        }
+#line 3203 "eval_y.c"
     break;
 
-  case 118:
-#line 1080 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Unary( BOOLEAN, NOT, (ffvsp[0].Node) ); TEST((ffval.Node)); }
-#line 3190 "y.tab.c" /* yacc.c:1648  */
+  case 119: /* bexpr: REGFILTER STRING ',' expr ',' expr ',' STRING ')'  */
+#line 1222 "eval.y"
+                {  (yyval.Node) = New_REG(lParse,  (yyvsp[-7].str), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].str) );
+                   TEST((yyval.Node));                                        }
+#line 3210 "eval_y.c"
     break;
 
-  case 119:
-#line 1082 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = (ffvsp[-1].Node); }
-#line 3196 "y.tab.c" /* yacc.c:1648  */
+  case 120: /* bexpr: bexpr '[' expr ']'  */
+#line 1226 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-3].Node), 1, (yyvsp[-1].Node),  0,  0,  0,   0 ); TEST((yyval.Node)); }
+#line 3216 "eval_y.c"
     break;
 
-  case 120:
-#line 1086 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Const( STRING, (ffvsp[0].str), strlen((ffvsp[0].str))+1 ); TEST((ffval.Node));
-                  SIZE((ffval.Node)) = strlen((ffvsp[0].str)); }
-#line 3203 "y.tab.c" /* yacc.c:1648  */
+  case 121: /* bexpr: bexpr '[' expr ',' expr ']'  */
+#line 1228 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-5].Node), 2, (yyvsp[-3].Node), (yyvsp[-1].Node),  0,  0,   0 ); TEST((yyval.Node)); }
+#line 3222 "eval_y.c"
     break;
 
-  case 121:
-#line 1089 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Column( (ffvsp[0].lng) ); TEST((ffval.Node)); }
-#line 3209 "y.tab.c" /* yacc.c:1648  */
+  case 122: /* bexpr: bexpr '[' expr ',' expr ',' expr ']'  */
+#line 1230 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-7].Node), 3, (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),  0,   0 ); TEST((yyval.Node)); }
+#line 3228 "eval_y.c"
     break;
 
-  case 122:
-#line 1091 "eval.y" /* yacc.c:1648  */
-    {
-                  if( TYPE((ffvsp[-1].Node)) != LONG
-		      || OPER((ffvsp[-1].Node)) != CONST_OP ) {
-		     fferror("Offset argument must be a constant integer");
-		     FFERROR;
+  case 123: /* bexpr: bexpr '[' expr ',' expr ',' expr ',' expr ']'  */
+#line 1232 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-9].Node), 4, (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node),   0 ); TEST((yyval.Node)); }
+#line 3234 "eval_y.c"
+    break;
+
+  case 124: /* bexpr: bexpr '[' expr ',' expr ',' expr ',' expr ',' expr ']'  */
+#line 1234 "eval.y"
+                { (yyval.Node) = New_Deref(lParse,  (yyvsp[-11].Node), 5, (yyvsp[-9].Node), (yyvsp[-7].Node), (yyvsp[-5].Node), (yyvsp[-3].Node), (yyvsp[-1].Node) ); TEST((yyval.Node)); }
+#line 3240 "eval_y.c"
+    break;
+
+  case 125: /* bexpr: NOT bexpr  */
+#line 1236 "eval.y"
+                { (yyval.Node) = New_Unary(lParse,  BOOLEAN, NOT, (yyvsp[0].Node) ); TEST((yyval.Node)); }
+#line 3246 "eval_y.c"
+    break;
+
+  case 126: /* bexpr: '(' bexpr ')'  */
+#line 1238 "eval.y"
+                { (yyval.Node) = (yyvsp[-1].Node); }
+#line 3252 "eval_y.c"
+    break;
+
+  case 127: /* sexpr: STRING  */
+#line 1242 "eval.y"
+                { (yyval.Node) = New_Const(lParse,  STRING, (yyvsp[0].str), strlen((yyvsp[0].str))+1 ); TEST((yyval.Node));
+                  SIZE((yyval.Node)) = strlen((yyvsp[0].str)); }
+#line 3259 "eval_y.c"
+    break;
+
+  case 128: /* sexpr: SCOLUMN  */
+#line 1245 "eval.y"
+                { (yyval.Node) = New_Column(lParse,  (yyvsp[0].lng) ); TEST((yyval.Node)); }
+#line 3265 "eval_y.c"
+    break;
+
+  case 129: /* sexpr: SCOLUMN '{' expr '}'  */
+#line 1247 "eval.y"
+                {
+                  if( TYPE((yyvsp[-1].Node)) != LONG
+		      || OPER((yyvsp[-1].Node)) != CONST_OP ) {
+		     yyerror(scanner, lParse, "Offset argument must be a constant integer");
+		     YYERROR;
 		  }
-                  (ffval.Node) = New_Offset( (ffvsp[-3].lng), (ffvsp[-1].Node) ); TEST((ffval.Node));
+                  (yyval.Node) = New_Offset(lParse,  (yyvsp[-3].lng), (yyvsp[-1].Node) ); TEST((yyval.Node));
                 }
-#line 3222 "y.tab.c" /* yacc.c:1648  */
+#line 3278 "eval_y.c"
     break;
 
-  case 123:
-#line 1100 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = New_Func( STRING, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
-#line 3228 "y.tab.c" /* yacc.c:1648  */
+  case 130: /* sexpr: SNULLREF  */
+#line 1256 "eval.y"
+                { (yyval.Node) = New_Func(lParse,  STRING, null_fct, 0, 0, 0, 0, 0, 0, 0, 0 ); }
+#line 3284 "eval_y.c"
     break;
 
-  case 124:
-#line 1102 "eval.y" /* yacc.c:1648  */
-    { (ffval.Node) = (ffvsp[-1].Node); }
-#line 3234 "y.tab.c" /* yacc.c:1648  */
+  case 131: /* sexpr: '(' sexpr ')'  */
+#line 1258 "eval.y"
+                { (yyval.Node) = (yyvsp[-1].Node); }
+#line 3290 "eval_y.c"
     break;
 
-  case 125:
-#line 1104 "eval.y" /* yacc.c:1648  */
-    { 
-		  if (SIZE((ffvsp[-2].Node))+SIZE((ffvsp[0].Node)) >= MAX_STRLEN) {
-		    fferror("Combined string size exceeds " MAX_STRLEN_S " characters");
-		    FFERROR;
+  case 132: /* sexpr: sexpr '+' sexpr  */
+#line 1260 "eval.y"
+                { 
+		  if (SIZE((yyvsp[-2].Node))+SIZE((yyvsp[0].Node)) >= MAX_STRLEN) {
+		    yyerror(scanner, lParse, "Combined string size exceeds " MAX_STRLEN_S " characters");
+		    YYERROR;
 		  }
-		  (ffval.Node) = New_BinOp( STRING, (ffvsp[-2].Node), '+', (ffvsp[0].Node) );  TEST((ffval.Node));
-		  SIZE((ffval.Node)) = SIZE((ffvsp[-2].Node)) + SIZE((ffvsp[0].Node));
+		  (yyval.Node) = New_BinOp(lParse,  STRING, (yyvsp[-2].Node), '+', (yyvsp[0].Node) );  TEST((yyval.Node));
+		  SIZE((yyval.Node)) = SIZE((yyvsp[-2].Node)) + SIZE((yyvsp[0].Node));
 		}
-#line 3247 "y.tab.c" /* yacc.c:1648  */
+#line 3303 "eval_y.c"
     break;
 
-  case 126:
-#line 1113 "eval.y" /* yacc.c:1648  */
-    {
+  case 133: /* sexpr: bexpr '?' sexpr ':' sexpr  */
+#line 1269 "eval.y"
+                {
 		  int outSize;
-                  if( SIZE((ffvsp[-4].Node))!=1 ) {
-                     fferror("Cannot have a vector string column");
-		     FFERROR;
+                  if( SIZE((yyvsp[-4].Node))!=1 ) {
+                     yyerror(scanner, lParse, "Cannot have a vector string column");
+		     YYERROR;
                   }
 		  /* Since the output can be calculated now, as a constant
 		     scalar, we must precalculate the output size, in
 		     order to avoid an overflow. */
-		  outSize = SIZE((ffvsp[-2].Node));
-		  if (SIZE((ffvsp[0].Node)) > outSize) outSize = SIZE((ffvsp[0].Node));
-                  (ffval.Node) = New_FuncSize( 0, ifthenelse_fct, 3, (ffvsp[-2].Node), (ffvsp[0].Node), (ffvsp[-4].Node),
+		  outSize = SIZE((yyvsp[-2].Node));
+		  if (SIZE((yyvsp[0].Node)) > outSize) outSize = SIZE((yyvsp[0].Node));
+                  (yyval.Node) = New_FuncSize(lParse,  0, ifthenelse_fct, 3, (yyvsp[-2].Node), (yyvsp[0].Node), (yyvsp[-4].Node),
 				     0, 0, 0, 0, outSize);
 		  
-                  TEST((ffval.Node));
-                  if( SIZE((ffvsp[-2].Node))<SIZE((ffvsp[0].Node)) )  Copy_Dims((ffval.Node), (ffvsp[0].Node));
+                  TEST((yyval.Node));
+                  if( SIZE((yyvsp[-2].Node))<SIZE((yyvsp[0].Node)) )  Copy_Dims( lParse,(yyval.Node), (yyvsp[0].Node));
                 }
-#line 3269 "y.tab.c" /* yacc.c:1648  */
+#line 3325 "eval_y.c"
     break;
 
-  case 127:
-#line 1132 "eval.y" /* yacc.c:1648  */
-    { 
-		  if (FSTRCMP((ffvsp[-4].str),"DEFNULL(") == 0) {
+  case 134: /* sexpr: FUNCTION sexpr ',' sexpr ')'  */
+#line 1288 "eval.y"
+                { 
+		  if (FSTRCMP((yyvsp[-4].str),"DEFNULL(") == 0) {
 		     int outSize;
 		     /* Since the output can be calculated now, as a constant
 			scalar, we must precalculate the output size, in
 			order to avoid an overflow. */
-		     outSize = SIZE((ffvsp[-3].Node));
-		     if (SIZE((ffvsp[-1].Node)) > outSize) outSize = SIZE((ffvsp[-1].Node));
+		     outSize = SIZE((yyvsp[-3].Node));
+		     if (SIZE((yyvsp[-1].Node)) > outSize) outSize = SIZE((yyvsp[-1].Node));
 		     
-		     (ffval.Node) = New_FuncSize( 0, defnull_fct, 2, (ffvsp[-3].Node), (ffvsp[-1].Node), 0,
+		     (yyval.Node) = New_FuncSize(lParse,  0, defnull_fct, 2, (yyvsp[-3].Node), (yyvsp[-1].Node), 0,
 					0, 0, 0, 0, outSize );
-		     TEST((ffval.Node)); 
-		     if( SIZE((ffvsp[-1].Node))>SIZE((ffvsp[-3].Node)) ) SIZE((ffval.Node)) = SIZE((ffvsp[-1].Node));
+		     TEST((yyval.Node)); 
+		     if( SIZE((yyvsp[-1].Node))>SIZE((yyvsp[-3].Node)) ) SIZE((yyval.Node)) = SIZE((yyvsp[-1].Node));
 		  } else {
-		     fferror("Function(string,string) not supported");
-		     FFERROR;
+		     yyerror(scanner, lParse, "Function(string,string) not supported");
+		     YYERROR;
 		  }
 		}
-#line 3292 "y.tab.c" /* yacc.c:1648  */
+#line 3348 "eval_y.c"
     break;
 
-  case 128:
-#line 1151 "eval.y" /* yacc.c:1648  */
-    { 
-		  if (FSTRCMP((ffvsp[-6].str),"STRMID(") == 0) {
+  case 135: /* sexpr: FUNCTION sexpr ',' expr ',' expr ')'  */
+#line 1307 "eval.y"
+                { 
+		  if (FSTRCMP((yyvsp[-6].str),"STRMID(") == 0) {
 		    int len;
-		    if( TYPE((ffvsp[-3].Node)) != LONG || SIZE((ffvsp[-3].Node)) != 1 ||
-			TYPE((ffvsp[-1].Node)) != LONG || SIZE((ffvsp[-1].Node)) != 1) {
-		      fferror("When using STRMID(S,P,N), P and N must be integers (and not vector columns)");
-		      FFERROR;
+		    if( TYPE((yyvsp[-3].Node)) != LONG || SIZE((yyvsp[-3].Node)) != 1 ||
+			TYPE((yyvsp[-1].Node)) != LONG || SIZE((yyvsp[-1].Node)) != 1) {
+		      yyerror(scanner, lParse, "When using STRMID(S,P,N), P and N must be integers (and not vector columns)");
+		      YYERROR;
 		    }
-		    if (OPER((ffvsp[-1].Node)) == CONST_OP) {
+		    if (OPER((yyvsp[-1].Node)) == CONST_OP) {
 		      /* Constant value: use that directly */
-		      len = (gParse.Nodes[(ffvsp[-1].Node)].value.data.lng);
+		      len = (lParse->Nodes[(yyvsp[-1].Node)].value.data.lng);
 		    } else {
 		      /* Variable value: use the maximum possible (from $2) */
-		      len = SIZE((ffvsp[-5].Node));
+		      len = SIZE((yyvsp[-5].Node));
 		    }
 		    if (len <= 0 || len >= MAX_STRLEN) {
-		      fferror("STRMID(S,P,N), N must be 1-" MAX_STRLEN_S);
-		      FFERROR;
+		      yyerror(scanner, lParse, "STRMID(S,P,N), N must be 1-" MAX_STRLEN_S);
+		      YYERROR;
 		    }
-		    (ffval.Node) = New_FuncSize( 0, strmid_fct, 3, (ffvsp[-5].Node), (ffvsp[-3].Node),(ffvsp[-1].Node),0,0,0,0,len);
-		    TEST((ffval.Node));
+		    (yyval.Node) = New_FuncSize(lParse,  0, strmid_fct, 3, (yyvsp[-5].Node), (yyvsp[-3].Node),(yyvsp[-1].Node),0,0,0,0,len);
+		    TEST((yyval.Node));
 		  } else {
-		     fferror("Function(string,expr,expr) not supported");
-		     FFERROR;
+		     yyerror(scanner, lParse, "Function(string,expr,expr) not supported");
+		     YYERROR;
 		  }
 		}
-#line 3323 "y.tab.c" /* yacc.c:1648  */
+#line 3379 "eval_y.c"
     break;
 
 
-#line 3327 "y.tab.c" /* yacc.c:1648  */
+#line 3383 "eval_y.c"
+
       default: break;
     }
-  /* User semantic actions sometimes alter ffchar, and that requires
-     that fftoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of fftoken.
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
      One alternative is translating here after every semantic action,
      but that translation would be missed if the semantic action invokes
-     FFABORT, FFACCEPT, or FFERROR immediately after altering ffchar or
-     if it invokes FFBACKUP.  In the case of FFABORT or FFACCEPT, an
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
      incorrect destructor might then be invoked immediately.  In the
-     case of FFERROR or FFBACKUP, subsequent parser actions might lead
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
      to an incorrect destructor call or verbose syntax error message
      before the lookahead is translated.  */
-  FF_SYMBOL_PRINT ("-> $$ =", ffr1[ffn], &ffval, &ffloc);
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 
-  FFPOPSTACK (fflen);
-  fflen = 0;
-  FF_STACK_PRINT (ffss, ffssp);
+  YYPOPSTACK (yylen);
+  yylen = 0;
 
-  *++ffvsp = ffval;
+  *++yyvsp = yyval;
 
   /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
 
-  ffn = ffr1[ffn];
-
-  ffstate = ffpgoto[ffn - FFNTOKENS] + *ffssp;
-  if (0 <= ffstate && ffstate <= FFLAST && ffcheck[ffstate] == *ffssp)
-    ffstate = fftable[ffstate];
-  else
-    ffstate = ffdefgoto[ffn - FFNTOKENS];
-
-  goto ffnewstate;
+  goto yynewstate;
 
 
 /*--------------------------------------.
-| fferrlab -- here on detecting error.  |
+| yyerrlab -- here on detecting error.  |
 `--------------------------------------*/
-fferrlab:
+yyerrlab:
   /* Make sure we have latest lookahead translation.  See comments at
      user semantic actions for why this is necessary.  */
-  fftoken = ffchar == FFEMPTY ? FFEMPTY : FFTRANSLATE (ffchar);
-
+  yytoken = yychar == FITS_PARSER_YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
   /* If not already recovering from an error, report this error.  */
-  if (!fferrstatus)
+  if (!yyerrstatus)
     {
-      ++ffnerrs;
-#if ! FFERROR_VERBOSE
-      fferror (FF_("syntax error"));
-#else
-# define FFSYNTAX_ERROR ffsyntax_error (&ffmsg_alloc, &ffmsg, \
-                                        ffssp, fftoken)
-      {
-        char const *ffmsgp = FF_("syntax error");
-        int ffsyntax_error_status;
-        ffsyntax_error_status = FFSYNTAX_ERROR;
-        if (ffsyntax_error_status == 0)
-          ffmsgp = ffmsg;
-        else if (ffsyntax_error_status == 1)
-          {
-            if (ffmsg != ffmsgbuf)
-              FFSTACK_FREE (ffmsg);
-            ffmsg = (char *) FFSTACK_ALLOC (ffmsg_alloc);
-            if (!ffmsg)
-              {
-                ffmsg = ffmsgbuf;
-                ffmsg_alloc = sizeof ffmsgbuf;
-                ffsyntax_error_status = 2;
-              }
-            else
-              {
-                ffsyntax_error_status = FFSYNTAX_ERROR;
-                ffmsgp = ffmsg;
-              }
-          }
-        fferror (ffmsgp);
-        if (ffsyntax_error_status == 2)
-          goto ffexhaustedlab;
-      }
-# undef FFSYNTAX_ERROR
-#endif
+      ++yynerrs;
+      yyerror (scanner, lParse, YY_("syntax error"));
     }
 
-
-
-  if (fferrstatus == 3)
+  if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
          error, discard it.  */
 
-      if (ffchar <= FFEOF)
+      if (yychar <= FITS_PARSER_YYEOF)
         {
           /* Return failure if at end of input.  */
-          if (ffchar == FFEOF)
-            FFABORT;
+          if (yychar == FITS_PARSER_YYEOF)
+            YYABORT;
         }
       else
         {
-          ffdestruct ("Error: discarding",
-                      fftoken, &fflval);
-          ffchar = FFEMPTY;
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval, scanner, lParse);
+          yychar = FITS_PARSER_YYEMPTY;
         }
     }
 
   /* Else will try to reuse lookahead token after shifting the error
      token.  */
-  goto fferrlab1;
+  goto yyerrlab1;
 
 
 /*---------------------------------------------------.
-| fferrorlab -- error raised explicitly by FFERROR.  |
+| yyerrorlab -- error raised explicitly by YYERROR.  |
 `---------------------------------------------------*/
-fferrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     FFERROR and the label fferrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto fferrorlab;
+yyerrorlab:
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+  ++yynerrs;
 
   /* Do not reclaim the symbols of the rule whose action triggered
-     this FFERROR.  */
-  FFPOPSTACK (fflen);
-  fflen = 0;
-  FF_STACK_PRINT (ffss, ffssp);
-  ffstate = *ffssp;
-  goto fferrlab1;
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
 
 
 /*-------------------------------------------------------------.
-| fferrlab1 -- common code for both syntax error and FFERROR.  |
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
 `-------------------------------------------------------------*/
-fferrlab1:
-  fferrstatus = 3;      /* Each real token shifted decrements this.  */
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
+  /* Pop stack until we find a state that shifts the error token.  */
   for (;;)
     {
-      ffn = ffpact[ffstate];
-      if (!ffpact_value_is_default (ffn))
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
         {
-          ffn += FFTERROR;
-          if (0 <= ffn && ffn <= FFLAST && ffcheck[ffn] == FFTERROR)
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
             {
-              ffn = fftable[ffn];
-              if (0 < ffn)
+              yyn = yytable[yyn];
+              if (0 < yyn)
                 break;
             }
         }
 
       /* Pop the current state because it cannot handle the error token.  */
-      if (ffssp == ffss)
-        FFABORT;
+      if (yyssp == yyss)
+        YYABORT;
 
 
-      ffdestruct ("Error: popping",
-                  ffstos[ffstate], ffvsp);
-      FFPOPSTACK (1);
-      ffstate = *ffssp;
-      FF_STACK_PRINT (ffss, ffssp);
+      yydestruct ("Error: popping",
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp, scanner, lParse);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
     }
 
-  FF_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  *++ffvsp = fflval;
-  FF_IGNORE_MAYBE_UNINITIALIZED_END
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 
 
   /* Shift the error token.  */
-  FF_SYMBOL_PRINT ("Shifting", ffstos[ffn], ffvsp, fflsp);
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 
-  ffstate = ffn;
-  goto ffnewstate;
+  yystate = yyn;
+  goto yynewstate;
 
 
 /*-------------------------------------.
-| ffacceptlab -- FFACCEPT comes here.  |
+| yyacceptlab -- YYACCEPT comes here.  |
 `-------------------------------------*/
-ffacceptlab:
-  ffresult = 0;
-  goto ffreturn;
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturnlab;
+
 
 /*-----------------------------------.
-| ffabortlab -- FFABORT comes here.  |
+| yyabortlab -- YYABORT comes here.  |
 `-----------------------------------*/
-ffabortlab:
-  ffresult = 1;
-  goto ffreturn;
-
-#if !defined ffoverflow || FFERROR_VERBOSE
-/*-------------------------------------------------.
-| ffexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-ffexhaustedlab:
-  fferror (FF_("memory exhausted"));
-  ffresult = 2;
-  /* Fall through.  */
-#endif
+yyabortlab:
+  yyresult = 1;
+  goto yyreturnlab;
 
-ffreturn:
-  if (ffchar != FFEMPTY)
+
+/*-----------------------------------------------------------.
+| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
+`-----------------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (scanner, lParse, YY_("memory exhausted"));
+  yyresult = 2;
+  goto yyreturnlab;
+
+
+/*----------------------------------------------------------.
+| yyreturnlab -- parsing is finished, clean up and return.  |
+`----------------------------------------------------------*/
+yyreturnlab:
+  if (yychar != FITS_PARSER_YYEMPTY)
     {
       /* Make sure we have latest lookahead translation.  See comments at
          user semantic actions for why this is necessary.  */
-      fftoken = FFTRANSLATE (ffchar);
-      ffdestruct ("Cleanup: discarding lookahead",
-                  fftoken, &fflval);
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval, scanner, lParse);
     }
   /* Do not reclaim the symbols of the rule whose action triggered
-     this FFABORT or FFACCEPT.  */
-  FFPOPSTACK (fflen);
-  FF_STACK_PRINT (ffss, ffssp);
-  while (ffssp != ffss)
-    {
-      ffdestruct ("Cleanup: popping",
-                  ffstos[*ffssp], ffvsp);
-      FFPOPSTACK (1);
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp, scanner, lParse);
+      YYPOPSTACK (1);
     }
-#ifndef ffoverflow
-  if (ffss != ffssa)
-    FFSTACK_FREE (ffss);
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
 #endif
-#if FFERROR_VERBOSE
-  if (ffmsg != ffmsgbuf)
-    FFSTACK_FREE (ffmsg);
-#endif
-  return ffresult;
+
+  return yyresult;
 }
-#line 1180 "eval.y" /* yacc.c:1907  */
+
+#line 1336 "eval.y"
 
 
 /*************************************************************************/
 /*  Start of "New" routines which build the expression Nodal structure   */
 /*************************************************************************/
 
-static int Alloc_Node( void )
+static int Alloc_Node( ParseData *lParse )
 {
                       /* Use this for allocation to guarantee *Nodes */
    Node *newNodePtr;  /* survives on failure, making it still valid  */
                       /* while working our way out of this error     */
 
-   if( gParse.nNodes == gParse.nNodesAlloc ) {
-      if( gParse.Nodes ) {
-	 gParse.nNodesAlloc += gParse.nNodesAlloc;
-	 newNodePtr = (Node *)realloc( gParse.Nodes,
-				       sizeof(Node)*gParse.nNodesAlloc );
+   if( lParse->nNodes == lParse->nNodesAlloc ) {
+      if( lParse->Nodes ) {
+	 lParse->nNodesAlloc += lParse->nNodesAlloc;
+	 newNodePtr = (Node *)realloc( lParse->Nodes,
+				       sizeof(Node)*lParse->nNodesAlloc );
       } else {
-	 gParse.nNodesAlloc = 100;
-	 newNodePtr = (Node *)malloc ( sizeof(Node)*gParse.nNodesAlloc );
+	 lParse->nNodesAlloc = 100;
+	 newNodePtr = (Node *)malloc ( sizeof(Node)*lParse->nNodesAlloc );
       }	 
 
       if( newNodePtr ) {
-	 gParse.Nodes = newNodePtr;
+	 lParse->Nodes = newNodePtr;
       } else {
-	 gParse.status = MEMORY_ALLOCATION;
+	 lParse->status = MEMORY_ALLOCATION;
 	 return( -1 );
       }
    }
 
-   return ( gParse.nNodes++ );
+   return ( lParse->nNodes++ );
 }
 
-static void Free_Last_Node( void )
+static void Free_Last_Node( ParseData *lParse )
 {
-   if( gParse.nNodes ) gParse.nNodes--;
+   if( lParse->nNodes ) lParse->nNodes--;
 }
 
-static int New_Const( int returnType, void *value, long len )
+static int New_Const( ParseData *lParse, int returnType, void *value, long len )
 {
    Node *this;
    int n;
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this             = gParse.Nodes + n;
+      this             = lParse->Nodes + n;
       this->operation  = CONST_OP;             /* Flag a constant */
       this->DoOp       = NULL;
       this->nSubNodes  = 0;
       this->type       = returnType;
       memcpy( &(this->value.data), value, len );
       this->value.undef = NULL;
       this->value.nelem = 1;
       this->value.naxis = 1;
       this->value.naxes[0] = 1;
    }
    return(n);
 }
 
-static int New_Column( int ColNum )
+static int New_Column( ParseData *lParse, int ColNum )
 {
    Node *this;
    int  n, i;
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = -ColNum;
       this->DoOp        = NULL;
       this->nSubNodes   = 0;
-      this->type        = gParse.varData[ColNum].type;
-      this->value.nelem = gParse.varData[ColNum].nelem;
-      this->value.naxis = gParse.varData[ColNum].naxis;
-      for( i=0; i<gParse.varData[ColNum].naxis; i++ )
-	 this->value.naxes[i] = gParse.varData[ColNum].naxes[i];
+      this->type        = lParse->varData[ColNum].type;
+      this->value.nelem = lParse->varData[ColNum].nelem;
+      this->value.naxis = lParse->varData[ColNum].naxis;
+      for( i=0; i<lParse->varData[ColNum].naxis; i++ )
+	 this->value.naxes[i] = lParse->varData[ColNum].naxes[i];
    }
    return(n);
 }
 
-static int New_Offset( int ColNum, int offsetNode )
+static int New_Offset( ParseData *lParse, int ColNum, int offsetNode )
 {
    Node *this;
    int  n, i, colNode;
 
-   colNode = New_Column( ColNum );
+   colNode = New_Column( lParse, ColNum );
    if( colNode<0 ) return(-1);
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = '{';
       this->DoOp        = Do_Offset;
       this->nSubNodes   = 2;
       this->SubNodes[0] = colNode;
       this->SubNodes[1] = offsetNode;
-      this->type        = gParse.varData[ColNum].type;
-      this->value.nelem = gParse.varData[ColNum].nelem;
-      this->value.naxis = gParse.varData[ColNum].naxis;
-      for( i=0; i<gParse.varData[ColNum].naxis; i++ )
-	 this->value.naxes[i] = gParse.varData[ColNum].naxes[i];
+      this->type        = lParse->varData[ColNum].type;
+      this->value.nelem = lParse->varData[ColNum].nelem;
+      this->value.naxis = lParse->varData[ColNum].naxis;
+      for( i=0; i<lParse->varData[ColNum].naxis; i++ )
+	 this->value.naxes[i] = lParse->varData[ColNum].naxes[i];
    }
    return(n);
 }
 
-static int New_Unary( int returnType, int Op, int Node1 )
+static int New_Unary( ParseData *lParse, int returnType, int Op, int Node1 )
 {
    Node *this, *that;
    int  i,n;
 
    if( Node1<0 ) return(-1);
-   that = gParse.Nodes + Node1;
+   that = lParse->Nodes + Node1;
 
    if( !Op ) Op = returnType;
 
    if( (Op==DOUBLE || Op==FLTCAST) && that->type==DOUBLE  ) return( Node1 );
    if( (Op==LONG   || Op==INTCAST) && that->type==LONG    ) return( Node1 );
    if( (Op==BOOLEAN              ) && that->type==BOOLEAN ) return( Node1 );
    
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = Op;
       this->DoOp        = Do_Unary;
       this->nSubNodes   = 1;
       this->SubNodes[0] = Node1;
       this->type        = returnType;
 
-      that              = gParse.Nodes + Node1; /* Reset in case .Nodes mv'd */
+      that              = lParse->Nodes + Node1; /* Reset in case .Nodes mv'd */
       this->value.nelem = that->value.nelem;
       this->value.naxis = that->value.naxis;
       for( i=0; i<that->value.naxis; i++ )
 	 this->value.naxes[i] = that->value.naxes[i];
 
-      if( that->operation==CONST_OP ) this->DoOp( this );
+      if( that->operation==CONST_OP ) this->DoOp( lParse, this );
    }
    return( n );
 }
 
-static int New_BinOp( int returnType, int Node1, int Op, int Node2 )
+static int New_BinOp( ParseData *lParse, int returnType, int Node1, int Op, int Node2 )
 {
    Node *this,*that1,*that2;
    int  n,i,constant;
 
    if( Node1<0 || Node2<0 ) return(-1);
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this             = gParse.Nodes + n;
+      this             = lParse->Nodes + n;
       this->operation  = Op;
       this->nSubNodes  = 2;
       this->SubNodes[0]= Node1;
       this->SubNodes[1]= Node2;
       this->type       = returnType;
 
-      that1            = gParse.Nodes + Node1;
-      that2            = gParse.Nodes + Node2;
+      that1            = lParse->Nodes + Node1;
+      that2            = lParse->Nodes + Node2;
       constant         = (that1->operation==CONST_OP
                           && that2->operation==CONST_OP);
       if( that1->type!=STRING && that1->type!=BITSTR )
-	 if( !Test_Dims( Node1, Node2 ) ) {
-	    Free_Last_Node();
-	    fferror("Array sizes/dims do not match for binary operator");
+	if( !Test_Dims( lParse, Node1, Node2 ) ) {
+	    Free_Last_Node(lParse);
+	    yyerror(0, lParse, "Array sizes/dims do not match for binary operator");
 	    return(-1);
 	 }
       if( that1->value.nelem == 1 ) that1 = that2;
 
       this->value.nelem = that1->value.nelem;
       this->value.naxis = that1->value.naxis;
       for( i=0; i<that1->value.naxis; i++ )
@@ -3734,43 +3755,46 @@
       switch( that1->type ) {
       case BITSTR:  this->DoOp = Do_BinOp_bit;  break;
       case STRING:  this->DoOp = Do_BinOp_str;  break;
       case BOOLEAN: this->DoOp = Do_BinOp_log;  break;
       case LONG:    this->DoOp = Do_BinOp_lng;  break;
       case DOUBLE:  this->DoOp = Do_BinOp_dbl;  break;
       }
-      if( constant ) this->DoOp( this );
+      if( constant ) this->DoOp( lParse, this );
    }
    return( n );
 }
 
-static int New_Func( int returnType, funcOp Op, int nNodes,
+static int New_Func( ParseData *lParse,
+		     int returnType, funcOp Op, int nNodes,
 		     int Node1, int Node2, int Node3, int Node4, 
 		     int Node5, int Node6, int Node7 )
 {
-  return New_FuncSize(returnType, Op, nNodes,
+  return New_FuncSize(lParse,
+		      returnType, Op, nNodes,
 		      Node1, Node2, Node3, Node4, 
 		      Node5, Node6, Node7, 0);
 }
 
-static int New_FuncSize( int returnType, funcOp Op, int nNodes,
-		     int Node1, int Node2, int Node3, int Node4, 
+static int New_FuncSize( ParseData *lParse,
+			 int returnType, funcOp Op, int nNodes,
+			 int Node1, int Node2, int Node3, int Node4, 
 			 int Node5, int Node6, int Node7, int Size )
 /* If returnType==0 , use Node1's type and vector sizes as returnType, */
 /* else return a single value of type returnType                       */
 {
    Node *this, *that;
    int  i,n,constant;
 
    if( Node1<0 || Node2<0 || Node3<0 || Node4<0 || 
        Node5<0 || Node6<0 || Node7<0 ) return(-1);
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->operation   = (int)Op;
       this->DoOp        = Do_Func;
       this->nSubNodes   = nNodes;
       this->SubNodes[0] = Node1;
       this->SubNodes[1] = Node2;
       this->SubNodes[2] = Node3;
       this->SubNodes[3] = Node4;
@@ -3785,66 +3809,66 @@
       
       if( returnType ) {
 	 this->type           = returnType;
 	 this->value.nelem    = 1;
 	 this->value.naxis    = 1;
 	 this->value.naxes[0] = 1;
       } else {
-	 that              = gParse.Nodes + Node1;
+	 that              = lParse->Nodes + Node1;
 	 this->type        = that->type;
 	 this->value.nelem = that->value.nelem;
 	 this->value.naxis = that->value.naxis;
 	 for( i=0; i<that->value.naxis; i++ )
 	    this->value.naxes[i] = that->value.naxes[i];
       }
       /* Force explicit size before evaluating */
       if (Size > 0) this->value.nelem = Size;
 
-      if( constant ) this->DoOp( this );
+      if( constant ) this->DoOp( lParse, this );
    }
    return( n );
 }
 
-static int New_Deref( int Var,  int nDim,
+static int New_Deref( ParseData *lParse, int Var,  int nDim,
 		      int Dim1, int Dim2, int Dim3, int Dim4, int Dim5 )
 {
    int n, idx, constant;
    long elem=0;
    Node *this, *theVar, *theDim[MAXDIMS];
 
    if( Var<0 || Dim1<0 || Dim2<0 || Dim3<0 || Dim4<0 || Dim5<0 ) return(-1);
 
-   theVar = gParse.Nodes + Var;
+   theVar = lParse->Nodes + Var;
    if( theVar->operation==CONST_OP || theVar->value.nelem==1 ) {
-      fferror("Cannot index a scalar value");
+      yyerror(0, lParse, "Cannot index a scalar value");
       return(-1);
    }
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n>=0 ) {
-      this              = gParse.Nodes + n;
+      this              = lParse->Nodes + n;
       this->nSubNodes   = nDim+1;
-      theVar            = gParse.Nodes + (this->SubNodes[0]=Var);
-      theDim[0]         = gParse.Nodes + (this->SubNodes[1]=Dim1);
-      theDim[1]         = gParse.Nodes + (this->SubNodes[2]=Dim2);
-      theDim[2]         = gParse.Nodes + (this->SubNodes[3]=Dim3);
-      theDim[3]         = gParse.Nodes + (this->SubNodes[4]=Dim4);
-      theDim[4]         = gParse.Nodes + (this->SubNodes[5]=Dim5);
+      theVar            = lParse->Nodes + (this->SubNodes[0]=Var);
+      theDim[0]         = lParse->Nodes + (this->SubNodes[1]=Dim1);
+      theDim[1]         = lParse->Nodes + (this->SubNodes[2]=Dim2);
+      theDim[2]         = lParse->Nodes + (this->SubNodes[3]=Dim3);
+      theDim[3]         = lParse->Nodes + (this->SubNodes[4]=Dim4);
+      theDim[4]         = lParse->Nodes + (this->SubNodes[5]=Dim5);
       constant          = theVar->operation==CONST_OP;
       for( idx=0; idx<nDim; idx++ )
 	 constant = (constant && theDim[idx]->operation==CONST_OP);
 
       for( idx=0; idx<nDim; idx++ )
 	 if( theDim[idx]->value.nelem>1 ) {
-	    Free_Last_Node();
-	    fferror("Cannot use an array as an index value");
+	    Free_Last_Node(lParse);
+	    yyerror(0, lParse, "Cannot use an array as an index value");
 	    return(-1);
 	 } else if( theDim[idx]->type!=LONG ) {
-	    Free_Last_Node();
-	    fferror("Index value must be an integer type");
+	    Free_Last_Node(lParse);
+	    yyerror(0, lParse, "Index value must be an integer type");
 	    return(-1);
 	 }
 
       this->operation   = '[';
       this->DoOp        = Do_Deref;
       this->type        = theVar->type;
 
@@ -3856,53 +3880,66 @@
 	 elem=1;
 	 this->value.naxis = theVar->value.naxis-1;
 	 for( idx=0; idx<this->value.naxis; idx++ ) {
 	    elem *= ( this->value.naxes[idx] = theVar->value.naxes[idx] );
 	 }
 	 this->value.nelem = elem;
       } else {
-	 Free_Last_Node();
-	 fferror("Must specify just one or all indices for vector");
+	 Free_Last_Node(lParse);
+	 yyerror(0, lParse, "Must specify just one or all indices for vector");
 	 return(-1);
       }
-      if( constant ) this->DoOp( this );
+      if( constant ) this->DoOp( lParse, this );
    }
    return(n);
 }
 
-extern int ffGetVariable( char *varName, FFSTYPE *varVal );
+extern int fits_parser_yyGetVariable( ParseData *lParse, char *varName, YYSTYPE *varVal );
 
-static int New_GTI( char *fname, int Node1, char *start, char *stop )
+static int New_GTI( ParseData *lParse, funcOp Op, char *fname, int Node1, int Node2, char *start, char *stop )
 {
    fitsfile *fptr;
-   Node *this, *that0, *that1;
+   Node *this, *that0, *that1, *that2;
    int  type,i,n, startCol, stopCol, Node0;
    int  hdutype, hdunum, evthdu, samefile, extvers, movetotype, tstat;
    char extname[100];
    long nrows;
    double timeZeroI[2], timeZeroF[2], dt, timeSpan;
    char xcol[20], xexpr[20];
-   FFSTYPE colVal;
+   YYSTYPE colVal;
 
-   if( Node1==-99 ) {
-      type = ffGetVariable( "TIME", &colVal );
+   if( (Op == gtifilt_fct || Op == gtifind_fct) && Node1==-99 ) {
+      type = fits_parser_yyGetVariable( lParse,  "TIME", &colVal );
       if( type==COLUMN ) {
-	 Node1 = New_Column( (int)colVal.lng );
+	 Node1 = New_Column( lParse, (int)colVal.lng );
       } else {
-	 fferror("Could not build TIME column for GTIFILTER");
+	 yyerror(0, lParse, "Could not build TIME column for GTIFILTER/GTIFIND");
 	 return(-1);
       }
    }
-   Node1 = New_Unary( DOUBLE, 0, Node1 );
-   Node0 = Alloc_Node(); /* This will hold the START/STOP times */
+
+   if (Op == gtiover_fct) {
+     if (Node1 == -99 || Node2 == -99) {
+       yyerror(0, lParse, "startExpr and stopExpr values must be defined for GTIOVERLAP");
+       return(-1);
+     }
+     /* Also case TIME_STOP to double precision */
+     Node2 = New_Unary( lParse, DOUBLE, 0, Node2 );
+     if (Node2 < 0) return(-1);
+
+   }
+
+   /* Type cast TIME to double precision */
+   Node1 = New_Unary( lParse, DOUBLE, 0, Node1 );
+   Node0 = Alloc_Node(lParse); /* This will hold the START/STOP times */
    if( Node1<0 || Node0<0 ) return(-1);
 
    /*  Record current HDU number in case we need to move within this file  */
 
-   fptr = gParse.def_fptr;
+   fptr = lParse->def_fptr;
    ffghdn( fptr, &evthdu );
 
    /*  Look for TIMEZERO keywords in current extension  */
 
    tstat = 0;
    if( ffgkyd( fptr, "TIMEZERO", timeZeroI, NULL, &tstat ) ) {
       tstat = 0;
@@ -3926,71 +3963,71 @@
       samefile = 1;
       i = 1;
       while( fname[i] != '\0' && fname[i] != ']' ) i++;
       if( fname[i] ) {
 	 fname[i] = '\0';
 	 fname++;
 	 ffexts( fname, &hdunum, extname, &extvers, &movetotype,
-		 xcol, xexpr, &gParse.status );
+		 xcol, xexpr, &lParse->status );
          if( *extname ) {
-	    ffmnhd( fptr, movetotype, extname, extvers, &gParse.status );
+	    ffmnhd( fptr, movetotype, extname, extvers, &lParse->status );
 	    ffghdn( fptr, &hdunum );
 	 } else if( hdunum ) {
-	    ffmahd( fptr, ++hdunum, &hdutype, &gParse.status );
-	 } else if( !gParse.status ) {
-	    fferror("Cannot use primary array for GTI filter");
+	    ffmahd( fptr, ++hdunum, &hdutype, &lParse->status );
+	 } else if( !lParse->status ) {
+	    yyerror(0, lParse, "Cannot use primary array for GTI filter");
 	    return( -1 );
 	 }
       } else {
-	 fferror("File extension specifier lacks closing ']'");
+	 yyerror(0, lParse, "File extension specifier lacks closing ']'");
 	 return( -1 );
       }
       break;
    case '+':
       samefile = 1;
       hdunum = atoi( fname ) + 1;
       if( hdunum>1 )
-	 ffmahd( fptr, hdunum, &hdutype, &gParse.status );
+	 ffmahd( fptr, hdunum, &hdutype, &lParse->status );
       else {
-	 fferror("Cannot use primary array for GTI filter");
+	 yyerror(0, lParse, "Cannot use primary array for GTI filter / GTIFIND");
 	 return( -1 );
       }
       break;
    default:
       samefile = 0;
-      if( ! ffopen( &fptr, fname, READONLY, &gParse.status ) )
+      if( ! ffopen( &fptr, fname, READONLY, &lParse->status ) )
 	 ffghdn( fptr, &hdunum );
       break;
    }
-   if( gParse.status ) return(-1);
+   if( lParse->status ) return(-1);
 
    /*  If at primary, search for GTI extension  */
 
    if( hdunum==1 ) {
       while( 1 ) {
 	 hdunum++;
-	 if( ffmahd( fptr, hdunum, &hdutype, &gParse.status ) ) break;
+	 if( ffmahd( fptr, hdunum, &hdutype, &lParse->status ) ) break;
 	 if( hdutype==IMAGE_HDU ) continue;
 	 tstat = 0;
 	 if( ffgkys( fptr, "EXTNAME", extname, NULL, &tstat ) ) continue;
 	 ffupch( extname );
 	 if( strstr( extname, "GTI" ) ) break;
       }
-      if( gParse.status ) {
-	 if( gParse.status==END_OF_FILE )
-	    fferror("GTI extension not found in this file");
+      if( lParse->status ) {
+	 if( lParse->status==END_OF_FILE )
+	    yyerror(0, lParse, "GTI extension not found in this file");
 	 return(-1);
       }
    }
 
    /*  Locate START/STOP Columns  */
 
-   ffgcno( fptr, CASEINSEN, start, &startCol, &gParse.status );
-   ffgcno( fptr, CASEINSEN, stop,  &stopCol,  &gParse.status );
-   if( gParse.status ) return(-1);
+   ffgcno( fptr, CASEINSEN, start, &startCol, &lParse->status );
+   ffgcno( fptr, CASEINSEN, stop,  &stopCol,  &lParse->status );
+   if( lParse->status ) return(-1);
 
    /*  Look for TIMEZERO keywords in GTI extension  */
 
    tstat = 0;
    if( ffgkyd( fptr, "TIMEZERO", timeZeroI+1, NULL, &tstat ) ) {
       tstat = 0;
       if( ffgkyd( fptr, "TIMEZERI", timeZeroI+1, NULL, &tstat ) ) {
@@ -3998,54 +4035,72 @@
       } else if( ffgkyd( fptr, "TIMEZERF", timeZeroF+1, NULL, &tstat ) ) {
 	 timeZeroF[1] = 0.0;
       }
    } else {
       timeZeroF[1] = 0.0;
    }
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n >= 0 ) {
-      this                 = gParse.Nodes + n;
-      this->nSubNodes      = 2;
+      this                 = lParse->Nodes + n;
       this->SubNodes[1]    = Node1;
-      this->operation      = (int)gtifilt_fct;
-      this->DoOp           = Do_GTI;
-      this->type           = BOOLEAN;
-      that1                = gParse.Nodes + Node1;
+      this->operation      = (int) Op;
+      if (Op == gtifilt_fct) {
+	this->nSubNodes      = 2;
+	this->DoOp           = Do_GTI;
+	this->type           = BOOLEAN;
+      } else if (Op == gtifind_fct) {
+	this->nSubNodes      = 2;
+	this->DoOp           = Do_GTI;
+	this->type           = LONG;
+      } else {
+	this->nSubNodes      = 3;
+	this->DoOp           = Do_GTI_Over;
+	this->type           = DOUBLE;
+      }
+      that1                = lParse->Nodes + Node1;
       this->value.nelem    = that1->value.nelem;
       this->value.naxis    = that1->value.naxis;
       for( i=0; i < that1->value.naxis; i++ )
 	 this->value.naxes[i] = that1->value.naxes[i];
+      if (Op == gtiover_fct) {
+	this->SubNodes[2]  = Node2;
+	that2 = lParse->Nodes + Node2;
+	if (that1->value.nelem != that2->value.nelem) {
+	  yyerror(0, lParse, "Dimensions of TIME and TIME_STOP must match for GTIOVERLAP");
+	  return(-1);
+	}
+      }
 
       /* Init START/STOP node to be treated as a "constant" */
 
       this->SubNodes[0]    = Node0;
-      that0                = gParse.Nodes + Node0;
+      that0                = lParse->Nodes + Node0;
       that0->operation     = CONST_OP;
       that0->DoOp          = NULL;
       that0->value.data.ptr= NULL;
 
       /*  Read in START/STOP times  */
 
-      if( ffgkyj( fptr, "NAXIS2", &nrows, NULL, &gParse.status ) )
+      if( ffgkyj( fptr, "NAXIS2", &nrows, NULL, &lParse->status ) )
 	 return(-1);
       that0->value.nelem = nrows;
       if( nrows ) {
 
 	 that0->value.data.dblptr = (double*)malloc( 2*nrows*sizeof(double) );
 	 if( !that0->value.data.dblptr ) {
-	    gParse.status = MEMORY_ALLOCATION;
+	    lParse->status = MEMORY_ALLOCATION;
 	    return(-1);
 	 }
 	 
 	 ffgcvd( fptr, startCol, 1L, 1L, nrows, 0.0,
-		 that0->value.data.dblptr, &i, &gParse.status );
+		 that0->value.data.dblptr, &i, &lParse->status );
 	 ffgcvd( fptr, stopCol, 1L, 1L, nrows, 0.0,
-		 that0->value.data.dblptr+nrows, &i, &gParse.status );
-	 if( gParse.status ) {
+		 that0->value.data.dblptr+nrows, &i, &lParse->status );
+	 if( lParse->status ) {
 	    free( that0->value.data.dblptr );
 	    return(-1);
 	 }
 
 	 /*  Test for fully time-ordered GTI... both START && STOP  */
 
 	 that0->type = 1; /*  Assume yes  */
@@ -4054,96 +4109,106 @@
 	    if(    that0->value.data.dblptr[i-1]
                    >= that0->value.data.dblptr[i]
 		|| that0->value.data.dblptr[i-1+nrows]
 		   >= that0->value.data.dblptr[i+nrows] ) {
 	       that0->type = 0;
 	       break;
 	    }
+
+	 /* GTIOVERLAP() requires ordered GTI */
+	 if (that0->type != 1 && Op == gtiover_fct) {
+	   yyerror(0, lParse, "Input GTI must be time-ordered for GTIOVERLAP");
+	   return(-1);
+	 }
 	 
 	 /*  Handle TIMEZERO offset, if any  */
 	 
 	 dt = (timeZeroI[1] - timeZeroI[0]) + (timeZeroF[1] - timeZeroF[0]);
 	 timeSpan = that0->value.data.dblptr[nrows+nrows-1]
 	    - that0->value.data.dblptr[0];
+	 if (timeSpan == 0) timeSpan = 1.0;
 	 
 	 if( fabs( dt / timeSpan ) > 1e-12 ) {
 	    for( i=0; i<(nrows+nrows); i++ )
 	       that0->value.data.dblptr[i] += dt;
 	 }
       }
-      if( OPER(Node1)==CONST_OP )
-	 this->DoOp( this );
+      /* If Node1 is constant (gtifilt_fct) or
+	 Node1 and Node2 are constant (gtiover_fct), then evaluate now */
+      if( OPER(Node1)==CONST_OP && (Op == gtifilt_fct || OPER(Node2)==CONST_OP)) {
+	this->DoOp( lParse, this );
+      }
    }
 
    if( samefile )
-      ffmahd( fptr, evthdu, &hdutype, &gParse.status );
+      ffmahd( fptr, evthdu, &hdutype, &lParse->status );
    else
-      ffclos( fptr, &gParse.status );
+      ffclos( fptr, &lParse->status );
 
    return( n );
 }
 
-static int New_REG( char *fname, int NodeX, int NodeY, char *colNames )
+static int New_REG( ParseData *lParse, char *fname, int NodeX, int NodeY, char *colNames )
 {
    Node *this, *that0;
    int  type, n, Node0;
    int  Xcol, Ycol, tstat;
    WCSdata wcs;
    SAORegion *Rgn;
    char *cX, *cY;
-   FFSTYPE colVal;
+   YYSTYPE colVal;
 
    if( NodeX==-99 ) {
-      type = ffGetVariable( "X", &colVal );
+      type = fits_parser_yyGetVariable( lParse,  "X", &colVal );
       if( type==COLUMN ) {
-	 NodeX = New_Column( (int)colVal.lng );
+	 NodeX = New_Column( lParse, (int)colVal.lng );
       } else {
-	 fferror("Could not build X column for REGFILTER");
+	 yyerror(0, lParse, "Could not build X column for REGFILTER");
 	 return(-1);
       }
    }
    if( NodeY==-99 ) {
-      type = ffGetVariable( "Y", &colVal );
+      type = fits_parser_yyGetVariable( lParse, "Y", &colVal );
       if( type==COLUMN ) {
-	 NodeY = New_Column( (int)colVal.lng );
+ 	 NodeY = New_Column( lParse, (int)colVal.lng );
       } else {
-	 fferror("Could not build Y column for REGFILTER");
+	 yyerror(0, lParse, "Could not build Y column for REGFILTER");
 	 return(-1);
       }
    }
-   NodeX = New_Unary( DOUBLE, 0, NodeX );
-   NodeY = New_Unary( DOUBLE, 0, NodeY );
-   Node0 = Alloc_Node(); /* This will hold the Region Data */
+   NodeX = New_Unary( lParse, DOUBLE, 0, NodeX );
+   NodeY = New_Unary( lParse, DOUBLE, 0, NodeY );
+   Node0 = Alloc_Node(lParse); /* This will hold the Region Data */
    if( NodeX<0 || NodeY<0 || Node0<0 ) return(-1);
 
-   if( ! (Test_Dims( NodeX, NodeY ) ) ) {
-     fferror("Dimensions of REGFILTER arguments are not compatible");
+   if( ! (Test_Dims( lParse, NodeX, NodeY ) ) ) {
+     yyerror(0, lParse, "Dimensions of REGFILTER arguments are not compatible");
      return (-1);
    }
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n >= 0 ) {
-      this                 = gParse.Nodes + n;
+      this                 = lParse->Nodes + n;
       this->nSubNodes      = 3;
       this->SubNodes[0]    = Node0;
       this->SubNodes[1]    = NodeX;
       this->SubNodes[2]    = NodeY;
       this->operation      = (int)regfilt_fct;
       this->DoOp           = Do_REG;
       this->type           = BOOLEAN;
       this->value.nelem    = 1;
       this->value.naxis    = 1;
       this->value.naxes[0] = 1;
       
-      Copy_Dims(n, NodeX);
-      if( SIZE(NodeX)<SIZE(NodeY) )  Copy_Dims(n, NodeY);
+      Copy_Dims(lParse, n, NodeX);
+      if( SIZE(NodeX)<SIZE(NodeY) )  Copy_Dims(lParse, n, NodeY);
 
       /* Init Region node to be treated as a "constant" */
 
-      that0                = gParse.Nodes + Node0;
+      that0                = lParse->Nodes + Node0;
       that0->operation     = CONST_OP;
       that0->DoOp          = NULL;
 
       /*  Identify what columns to use for WCS information  */
 
       Xcol = Ycol = 0;
       if( *colNames ) {
@@ -4151,167 +4216,242 @@
 	 while( *colNames==' ' ) colNames++;
 	 cX = cY = colNames;
 	 while( *cY && *cY!=' ' && *cY!=',' ) cY++;
 	 if( *cY )
 	    *(cY++) = '\0';
 	 while( *cY==' ' ) cY++;
 	 if( !*cY ) {
-	    fferror("Could not extract valid pair of column names from REGFILTER");
-	    Free_Last_Node();
+	    yyerror(0, lParse, "Could not extract valid pair of column names from REGFILTER");
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 }
-	 fits_get_colnum( gParse.def_fptr, CASEINSEN, cX, &Xcol,
-			  &gParse.status );
-	 fits_get_colnum( gParse.def_fptr, CASEINSEN, cY, &Ycol,
-			  &gParse.status );
-	 if( gParse.status ) {
-	    fferror("Could not locate columns indicated for WCS info");
-	    Free_Last_Node();
+	 fits_get_colnum( lParse->def_fptr, CASEINSEN, cX, &Xcol,
+			  &lParse->status );
+	 fits_get_colnum( lParse->def_fptr, CASEINSEN, cY, &Ycol,
+			  &lParse->status );
+	 if( lParse->status ) {
+	    yyerror(0, lParse, "Could not locate columns indicated for WCS info");
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 }
 
       } else {
 	 /*  Try to find columns used in X/Y expressions  */
-	 Xcol = Locate_Col( gParse.Nodes + NodeX );
-	 Ycol = Locate_Col( gParse.Nodes + NodeY );
+	 Xcol = Locate_Col( lParse, lParse->Nodes + NodeX );
+	 Ycol = Locate_Col( lParse, lParse->Nodes + NodeY );
 	 if( Xcol<0 || Ycol<0 ) {
-	    fferror("Found multiple X/Y column references in REGFILTER");
-	    Free_Last_Node();
+	    yyerror(0, lParse, "Found multiple X/Y column references in REGFILTER");
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 }
       }
 
       /*  Now, get the WCS info, if it exists, from the indicated columns  */
       wcs.exists = 0;
       if( Xcol>0 && Ycol>0 ) {
 	 tstat = 0;
-	 ffgtcs( gParse.def_fptr, Xcol, Ycol,
+	 ffgtcs( lParse->def_fptr, Xcol, Ycol,
 		 &wcs.xrefval, &wcs.yrefval,
 		 &wcs.xrefpix, &wcs.yrefpix,
 		 &wcs.xinc,    &wcs.yinc,
 		 &wcs.rot,      wcs.type,
 		 &tstat );
 	 if( tstat==NO_WCS_KEY ) {
 	    wcs.exists = 0;
 	 } else if( tstat ) {
-	    gParse.status = tstat;
-	    Free_Last_Node();
+	    lParse->status = tstat;
+	    Free_Last_Node(lParse);
 	    return( -1 );
 	 } else {
 	    wcs.exists = 1;
 	 }
       }
 
       /*  Read in Region file  */
 
-      fits_read_rgnfile( fname, &wcs, &Rgn, &gParse.status );
-      if( gParse.status ) {
-	 Free_Last_Node();
+      fits_read_rgnfile( fname, &wcs, &Rgn, &lParse->status );
+      if( lParse->status ) {
+	 Free_Last_Node(lParse);
 	 return( -1 );
       }
 
       that0->value.data.ptr = Rgn;
 
       if( OPER(NodeX)==CONST_OP && OPER(NodeY)==CONST_OP )
-	 this->DoOp( this );
+	 this->DoOp( lParse, this );
    }
 
    return( n );
 }
 
-static int New_Vector( int subNode )
+static int New_Vector( ParseData *lParse, int subNode )
 {
    Node *this, *that;
    int n;
 
-   n = Alloc_Node();
+   n = Alloc_Node(lParse);
    if( n >= 0 ) {
-      this              = gParse.Nodes + n;
-      that              = gParse.Nodes + subNode;
+      this              = lParse->Nodes + n;
+      that              = lParse->Nodes + subNode;
       this->type        = that->type;
       this->nSubNodes   = 1;
       this->SubNodes[0] = subNode;
       this->operation   = '{';
       this->DoOp        = Do_Vector;
    }
 
    return( n );
 }
 
-static int Close_Vec( int vecNode )
+static int Close_Vec( ParseData *lParse, int vecNode )
 {
    Node *this;
    int n, nelem=0;
 
-   this = gParse.Nodes + vecNode;
+   this = lParse->Nodes + vecNode;
    for( n=0; n < this->nSubNodes; n++ ) {
       if( TYPE( this->SubNodes[n] ) != this->type ) {
-	 this->SubNodes[n] = New_Unary( this->type, 0, this->SubNodes[n] );
+	 this->SubNodes[n] = New_Unary( lParse, this->type, 0, this->SubNodes[n] );
 	 if( this->SubNodes[n]<0 ) return(-1);
       }
       nelem += SIZE(this->SubNodes[n]);
    }
    this->value.naxis    = 1;
    this->value.nelem    = nelem;
    this->value.naxes[0] = nelem;
 
    return( vecNode );
 }
 
-static int Locate_Col( Node *this )
+static int New_Array( ParseData *lParse, int valueNode, int dimNode )
+{
+  Node *dims;
+  long naxis, nelem;
+  long naxes[MAXDIMS];
+  Node *this;
+  int  n,i;
+
+   if( valueNode<0 || dimNode<0 ) return(-1);
+
+   /* Check that dimensions are {a,b,c,d}
+        - vector
+	- every element is constant integer
+	- 5 or fewer dimensions 
+   */
+
+   if (SIZE(valueNode) > 1) {
+     yyerror(0, lParse, "ARRAY(V,n) value V must have vector dimension of 1");
+     return (-1);
+   }
+
+   dims = &(lParse->Nodes[dimNode]);
+   for (i=0; i<MAXDIMS; i++) naxes[i] = 1;
+
+   if (OPER(dimNode) == CONST_OP) { /* ARRAY(V,n) is a constant integer */
+     if ( TYPE(dimNode) != LONG ) dimNode = New_Unary(lParse, LONG, 0, dimNode);
+     if (dimNode < 0) return (-1);
+     naxis = 1;
+     naxes[0] = lParse->Nodes[dimNode].value.data.lng;
+
+   } else if (OPER(dimNode) == '{') { /* ARRAY(V,{a,b,c,d,e}) up to 5 dimensions */
+     if (dims->nSubNodes > MAXDIMS) {
+       yyerror(0, lParse, "ARRAY(V,{...}) number of dimensions must not exceed 5");
+       return (-1);
+     }
+     naxis = dims->nSubNodes;
+     for (i=0; i<dims->nSubNodes; i++) {
+       if ( TYPE(dims->SubNodes[i]) != LONG ) {
+	 dims->SubNodes[i] = New_Unary(lParse, LONG, 0, dims->SubNodes[i]);
+	 if (dims->SubNodes[i] < 0) return (-1);
+       }
+       naxes[i] = lParse->Nodes[ dims->SubNodes[i] ].value.data.lng;
+     }
+   } else {
+     yyerror(0, lParse, "ARRAY(V,dims) dims must be either integer or const vector");
+     return (-1);
+   }
+
+   nelem = 1;
+   for (i=0; i<naxis; i++) {
+     if (naxes[i] <= 0) {
+       yyerror(0, lParse, "ARRAY(V,dims) must have positive dimensions");
+       return (-1);
+     }
+     nelem *= naxes[i];
+   }
+
+   n = Alloc_Node(lParse);
+   if( n>=0 ) {
+      this             = lParse->Nodes + n;
+      this->operation  = array_fct;
+      this->nSubNodes  = 1;
+      this->SubNodes[0]= valueNode;
+      this->type       = TYPE(valueNode);
+
+      this->value.nelem = nelem;
+      this->value.naxis = naxis;
+      for( i=0; i<naxis; i++ )
+	this->value.naxes[i] = naxes[i];
+
+      this->DoOp = Do_Array;
+   }
+   return( n );
+}
+
+static int Locate_Col( ParseData *lParse, Node *this )
 /*  Locate the TABLE column number of any columns in "this" calculation.  */
 /*  Return ZERO if none found, or negative if more than 1 found.          */
 {
    Node *that;
    int  i, col=0, newCol, nfound=0;
    
    if( this->nSubNodes==0
        && this->operation<=0 && this->operation!=CONST_OP )
-      return gParse.colData[ - this->operation].colnum;
+      return lParse->colData[ - this->operation].colnum;
 
    for( i=0; i<this->nSubNodes; i++ ) {
-      that = gParse.Nodes + this->SubNodes[i];
+      that = lParse->Nodes + this->SubNodes[i];
       if( that->operation>0 ) {
-	 newCol = Locate_Col( that );
+	 newCol = Locate_Col( lParse, that );
 	 if( newCol<=0 ) {
 	    nfound += -newCol;
 	 } else {
 	    if( !nfound ) {
 	       col = newCol;
 	       nfound++;
 	    } else if( col != newCol ) {
 	       nfound++;
 	    }
 	 }
       } else if( that->operation!=CONST_OP ) {
 	 /*  Found a Column  */
-	 newCol = gParse.colData[- that->operation].colnum;
+	 newCol = lParse->colData[- that->operation].colnum;
 	 if( !nfound ) {
 	    col = newCol;
 	    nfound++;
 	 } else if( col != newCol ) {
 	    nfound++;
 	 }
       }
    }
    if( nfound!=1 )
       return( - nfound );
    else
       return( col );
 }
 
-static int Test_Dims( int Node1, int Node2 )
+static int Test_Dims( ParseData *lParse, int Node1, int Node2 )
 {
    Node *that1, *that2;
    int valid, i;
 
    if( Node1<0 || Node2<0 ) return(0);
 
-   that1 = gParse.Nodes + Node1;
-   that2 = gParse.Nodes + Node2;
+   that1 = lParse->Nodes + Node1;
+   that2 = lParse->Nodes + Node2;
 
    if( that1->value.nelem==1 || that2->value.nelem==1 )
       valid = 1;
    else if( that1->type==that2->type
 	    && that1->value.nelem==that2->value.nelem
 	    && that1->value.naxis==that2->value.naxis ) {
       valid = 1;
@@ -4320,35 +4460,35 @@
 	    valid = 0;
       }
    } else
       valid = 0;
    return( valid );
 }   
 
-static void Copy_Dims( int Node1, int Node2 )
+static void Copy_Dims( ParseData *lParse, int Node1, int Node2 )
 {
    Node *that1, *that2;
    int i;
 
    if( Node1<0 || Node2<0 ) return;
 
-   that1 = gParse.Nodes + Node1;
-   that2 = gParse.Nodes + Node2;
+   that1 = lParse->Nodes + Node1;
+   that2 = lParse->Nodes + Node2;
 
    that1->value.nelem = that2->value.nelem;
    that1->value.naxis = that2->value.naxis;
    for( i=0; i<that2->value.naxis; i++ )
       that1->value.naxes[i] = that2->value.naxes[i];
 }
 
 /********************************************************************/
 /*    Routines for actually evaluating the expression start here    */
 /********************************************************************/
 
-void Evaluate_Parser( long firstRow, long nRows )
+void Evaluate_Parser( ParseData *lParse, long firstRow, long nRows )
     /***********************************************************************/
     /*  Reset the parser for processing another batch of data...           */
     /*    firstRow:  Row number of the first element to evaluate           */
     /*    nRows:     Number of rows to be processed                        */
     /*  Initialize each COLUMN node so that its UNDEF and DATA pointers    */
     /*  point to the appropriate column arrays.                            */
     /*  Finally, call Evaluate_Node for final node.                        */
@@ -4360,137 +4500,137 @@
 
    /* Initialize the random number generator once and only once */
    if (rand_initialized == 0) {
      simplerng_srand( (unsigned int) time(NULL) );
      rand_initialized = 1;
    }
 
-   gParse.firstRow = firstRow;
-   gParse.nRows    = nRows;
+   lParse->firstRow = firstRow;
+   lParse->nRows    = nRows;
 
    /*  Reset Column Nodes' pointers to point to right data and UNDEF arrays  */
 
-   rowOffset = firstRow - gParse.firstDataRow;
-   for( i=0; i<gParse.nNodes; i++ ) {
+   rowOffset = firstRow - lParse->firstDataRow;
+   for( i=0; i<lParse->nNodes; i++ ) {
      if(    OPER(i) >  0 || OPER(i) == CONST_OP ) continue;
 
       column = -OPER(i);
-      offset = gParse.varData[column].nelem * rowOffset;
+      offset = lParse->varData[column].nelem * rowOffset;
 
-      gParse.Nodes[i].value.undef = gParse.varData[column].undef + offset;
+      lParse->Nodes[i].value.undef = lParse->varData[column].undef + offset;
 
-      switch( gParse.Nodes[i].type ) {
+      switch( lParse->Nodes[i].type ) {
       case BITSTR:
-	 gParse.Nodes[i].value.data.strptr =
-	    (char**)gParse.varData[column].data + rowOffset;
-	 gParse.Nodes[i].value.undef       = NULL;
+	 lParse->Nodes[i].value.data.strptr =
+	    (char**)lParse->varData[column].data + rowOffset;
+	 lParse->Nodes[i].value.undef       = NULL;
 	 break;
       case STRING:
-	 gParse.Nodes[i].value.data.strptr = 
-	    (char**)gParse.varData[column].data + rowOffset;
-	 gParse.Nodes[i].value.undef = gParse.varData[column].undef + rowOffset;
+	 lParse->Nodes[i].value.data.strptr = 
+	    (char**)lParse->varData[column].data + rowOffset;
+	 lParse->Nodes[i].value.undef = lParse->varData[column].undef + rowOffset;
 	 break;
       case BOOLEAN:
-	 gParse.Nodes[i].value.data.logptr = 
-	    (char*)gParse.varData[column].data + offset;
+	 lParse->Nodes[i].value.data.logptr = 
+	    (char*)lParse->varData[column].data + offset;
 	 break;
       case LONG:
-	 gParse.Nodes[i].value.data.lngptr = 
-	    (long*)gParse.varData[column].data + offset;
+	 lParse->Nodes[i].value.data.lngptr = 
+	    (long*)lParse->varData[column].data + offset;
 	 break;
       case DOUBLE:
-	 gParse.Nodes[i].value.data.dblptr = 
-	    (double*)gParse.varData[column].data + offset;
+	 lParse->Nodes[i].value.data.dblptr = 
+	    (double*)lParse->varData[column].data + offset;
 	 break;
       }
    }
 
-   Evaluate_Node( gParse.resultNode );
+   Evaluate_Node( lParse, lParse->resultNode );
 }
 
-static void Evaluate_Node( int thisNode )
+static void Evaluate_Node( ParseData *lParse, int thisNode )
     /**********************************************************************/
     /*  Recursively evaluate thisNode's subNodes, then call one of the    */
     /*  Do_<Action> functions pointed to by thisNode's DoOp element.      */
     /**********************************************************************/
 {
    Node *this;
    int i;
    
-   if( gParse.status ) return;
+   if( lParse->status ) return;
 
-   this = gParse.Nodes + thisNode;
+   this = lParse->Nodes + thisNode;
    if( this->operation>0 ) {  /* <=0 indicate constants and columns */
       i = this->nSubNodes;
       while( i-- ) {
-	 Evaluate_Node( this->SubNodes[i] );
-	 if( gParse.status ) return;
+	 Evaluate_Node( lParse, this->SubNodes[i] );
+	 if( lParse->status ) return;
       }
-      this->DoOp( this );
+      this->DoOp( lParse, this );
    }
 }
 
-static void Allocate_Ptrs( Node *this )
+static void Allocate_Ptrs( ParseData *lParse, Node *this )
 {
    long elem, row, size;
 
    if( this->type==BITSTR || this->type==STRING ) {
 
-      this->value.data.strptr = (char**)malloc( gParse.nRows
+      this->value.data.strptr = (char**)malloc( lParse->nRows
 						* sizeof(char*) );
       if( this->value.data.strptr ) {
-	 this->value.data.strptr[0] = (char*)malloc( gParse.nRows
+	 this->value.data.strptr[0] = (char*)malloc( lParse->nRows
 						     * (this->value.nelem+2)
 						     * sizeof(char) );
 	 if( this->value.data.strptr[0] ) {
 	    row = 0;
-	    while( (++row)<gParse.nRows ) {
+	    while( (++row)<lParse->nRows ) {
 	       this->value.data.strptr[row] =
 		  this->value.data.strptr[row-1] + this->value.nelem+1;
 	    }
 	    if( this->type==STRING ) {
 	       this->value.undef = this->value.data.strptr[row-1]
                                    + this->value.nelem+1;
 	    } else {
 	       this->value.undef = NULL;  /* BITSTRs don't use undef array */
 	    }
 	 } else {
-	    gParse.status = MEMORY_ALLOCATION;
+	    lParse->status = MEMORY_ALLOCATION;
 	    free( this->value.data.strptr );
 	 }
       } else {
-	 gParse.status = MEMORY_ALLOCATION;
+	 lParse->status = MEMORY_ALLOCATION;
       }
 
    } else {
 
-      elem = this->value.nelem * gParse.nRows;
+      elem = this->value.nelem * lParse->nRows;
       switch( this->type ) {
       case DOUBLE:  size = sizeof( double ); break;
       case LONG:    size = sizeof( long   ); break;
       case BOOLEAN: size = sizeof( char   ); break;
       default:      size = 1;                break;
       }
 
       this->value.data.ptr = calloc(size+1, elem);
 
       if( this->value.data.ptr==NULL ) {
-	 gParse.status = MEMORY_ALLOCATION;
+	 lParse->status = MEMORY_ALLOCATION;
       } else {
 	 this->value.undef = (char *)this->value.data.ptr + elem*size;
       }
    }
 }
 
-static void Do_Unary( Node *this )
+static void Do_Unary( ParseData *lParse, Node *this )
 {
    Node *that;
    long elem;
 
-   that = gParse.Nodes + this->SubNodes[0];
+   that = lParse->Nodes + this->SubNodes[0];
 
    if( that->operation==CONST_OP ) {  /* Operating on a constant! */
       switch( this->operation ) {
       case DOUBLE:
       case FLTCAST:
 	 if( that->type==LONG )
 	    this->value.data.dbl = (double)that->value.data.lng;
@@ -4523,27 +4663,27 @@
 	    bitnot( this->value.data.str, that->value.data.str );
 	 break;
       }
       this->operation = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
 	 if( this->type!=BITSTR ) {
-	    elem = gParse.nRows;
+	    elem = lParse->nRows;
 	    if( this->type!=STRING )
 	       elem *= this->value.nelem;
 	    while( elem-- )
 	       this->value.undef[elem] = that->value.undef[elem];
 	 }
 
-	 elem = gParse.nRows * this->value.nelem;
+	 elem = lParse->nRows * this->value.nelem;
 
 	 switch( this->operation ) {
 
 	 case BOOLEAN:
 	    if( that->type==DOUBLE )
 	       while( elem-- )
 		  this->value.data.logptr[elem] =
@@ -4592,56 +4732,56 @@
 
 	 case NOT:
 	    if( that->type==BOOLEAN ) {
 	       while( elem-- )
 		  this->value.data.logptr[elem] =
 		     ( ! that->value.data.logptr[elem] );
 	    } else if( that->type==BITSTR ) {
-	       elem = gParse.nRows;
+	       elem = lParse->nRows;
 	       while( elem-- )
 		  bitnot( this->value.data.strptr[elem],
 			  that->value.data.strptr[elem] );
 	    }
 	    break;
 	 }
       }
    }
 
    if( that->operation>0 ) {
       free( that->value.data.ptr );
    }
 }
 
-static void Do_Offset( Node *this )
+static void Do_Offset( ParseData *lParse, Node *this )
 {
    Node *col;
    long fRow, nRowOverlap, nRowReload, rowOffset;
    long nelem, elem, offset, nRealElem;
    int status;
 
-   col       = gParse.Nodes + this->SubNodes[0];
-   rowOffset = gParse.Nodes[  this->SubNodes[1] ].value.data.lng;
+   col       = lParse->Nodes + this->SubNodes[0];
+   rowOffset = lParse->Nodes[  this->SubNodes[1] ].value.data.lng;
 
-   Allocate_Ptrs( this );
+   Allocate_Ptrs( lParse, this );
 
-   fRow   = gParse.firstRow + rowOffset;
+   fRow   = lParse->firstRow + rowOffset;
    if( this->type==STRING || this->type==BITSTR )
       nRealElem = 1;
    else
       nRealElem = this->value.nelem;
 
    nelem = nRealElem;
 
-   if( fRow < gParse.firstDataRow ) {
+   if( fRow < lParse->firstDataRow ) {
 
       /* Must fill in data at start of array */
 
-      nRowReload = gParse.firstDataRow - fRow;
-      if( nRowReload > gParse.nRows ) nRowReload = gParse.nRows;
-      nRowOverlap = gParse.nRows - nRowReload;
+      nRowReload = lParse->firstDataRow - fRow;
+      if( nRowReload > lParse->nRows ) nRowReload = lParse->nRows;
+      nRowOverlap = lParse->nRows - nRowReload;
 
       offset = 0;
 
       /*  NULLify any values falling out of bounds  */
 
       while( fRow<1 && nRowReload>0 ) {
 	 if( this->type == BITSTR ) {
@@ -4654,32 +4794,32 @@
 	       this->value.undef[offset++] = 1;
 	 }
 	 nelem = nRealElem;
 	 fRow++;
 	 nRowReload--;
       }
 
-   } else if( fRow + gParse.nRows > gParse.firstDataRow + gParse.nDataRows ) {
+   } else if( fRow + lParse->nRows > lParse->firstDataRow + lParse->nDataRows ) {
 
       /* Must fill in data at end of array */
 
-      nRowReload = (fRow+gParse.nRows) - (gParse.firstDataRow+gParse.nDataRows);
-      if( nRowReload>gParse.nRows ) {
-	 nRowReload = gParse.nRows;
+      nRowReload = (fRow+lParse->nRows) - (lParse->firstDataRow+lParse->nDataRows);
+      if( nRowReload>lParse->nRows ) {
+	 nRowReload = lParse->nRows;
       } else {
-	 fRow = gParse.firstDataRow + gParse.nDataRows;
+	 fRow = lParse->firstDataRow + lParse->nDataRows;
       }
-      nRowOverlap = gParse.nRows - nRowReload;
+      nRowOverlap = lParse->nRows - nRowReload;
 
       offset = nRowOverlap * nelem;
 
       /*  NULLify any values falling out of bounds  */
 
-      elem = gParse.nRows * nelem;
-      while( fRow+nRowReload>gParse.totalRows && nRowReload>0 ) {
+      elem = lParse->nRows * nelem;
+      while( fRow+nRowReload>lParse->totalRows && nRowReload>0 ) {
 	 if( this->type == BITSTR ) {
 	    nelem = this->value.nelem;
 	    elem--;
 	    this->value.data.strptr[elem][ nelem ] = '\0';
 	    while( nelem-- ) this->value.data.strptr[elem][nelem] = '0';
 	 } else {
 	    while( nelem-- )
@@ -4688,57 +4828,57 @@
 	 nelem = nRealElem;
 	 nRowReload--;
       }
 
    } else {
 
       nRowReload  = 0;
-      nRowOverlap = gParse.nRows;
+      nRowOverlap = lParse->nRows;
       offset      = 0;
 
    }
 
    if( nRowReload>0 ) {
       switch( this->type ) {
       case BITSTR:
       case STRING:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.strptr+offset,
 				      this->value.undef+offset );
 	 break;
       case BOOLEAN:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.logptr+offset,
 				      this->value.undef+offset );
 	 break;
       case LONG:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.lngptr+offset,
 				      this->value.undef+offset );
 	 break;
       case DOUBLE:
-	 status = (*gParse.loadData)( -col->operation, fRow, nRowReload,
+	 status = (*lParse->loadData)( lParse, -col->operation, fRow, nRowReload,
 				      this->value.data.dblptr+offset,
 				      this->value.undef+offset );
 	 break;
       }
    }
 
    /*  Now copy over the overlapping region, if any  */
 
    if( nRowOverlap <= 0 ) return;
 
    if( rowOffset>0 )
       elem = nRowOverlap * nelem;
    else
-      elem = gParse.nRows * nelem;
+      elem = lParse->nRows * nelem;
 
    offset = nelem * rowOffset;
-   while( nRowOverlap-- && !gParse.status ) {
-      while( nelem-- && !gParse.status ) {
+   while( nRowOverlap-- && !lParse->status ) {
+      while( nelem-- && !lParse->status ) {
 	 elem--;
 	 if( this->type != BITSTR )
 	    this->value.undef[elem] = col->value.undef[elem+offset];
 	 switch( this->type ) {
 	 case BITSTR:
 	    strcpy( this->value.data.strptr[elem       ],
                      col->value.data.strptr[elem+offset] );
@@ -4758,23 +4898,23 @@
 	    break;
 	 }
       }
       nelem = nRealElem;
    }
 }
 
-static void Do_BinOp_bit( Node *this )
+static void Do_BinOp_bit( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    char *sptr1=NULL, *sptr2=NULL;
    int  const1, const2;
    long rows;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    const1 = ( that1->operation==CONST_OP );
    const2 = ( that2->operation==CONST_OP );
    sptr1  = ( const1 ? that1->value.data.str : NULL );
    sptr2  = ( const2 ? that2->value.data.str : NULL );
 
    if( const1 && const2 ) {
@@ -4810,18 +4950,18 @@
 	break;
 	
       }
       this->operation = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
-
-      if( !gParse.status ) {
-	 rows  = gParse.nRows;
+      Allocate_Ptrs( lParse, this );
+     
+      if( !lParse->status ) {
+	 rows  = lParse->nRows;
 	 switch( this->operation ) {
 
 	    /*  BITSTR comparisons  */
 
 	 case NE:
 	 case EQ:
 	 case GT:
@@ -4903,23 +5043,23 @@
    }
    if( that2->operation>0 ) {
       free( that2->value.data.strptr[0] );
       free( that2->value.data.strptr    );
    }
 }
 
-static void Do_BinOp_str( Node *this )
+static void Do_BinOp_str( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    char *sptr1, *sptr2, null1=0, null2=0;
    int const1, const2, val;
    long rows;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    const1 = ( that1->operation==CONST_OP );
    const2 = ( that2->operation==CONST_OP );
    sptr1  = ( const1 ? that1->value.data.str : NULL );
    sptr2  = ( const2 ? that2->value.data.str : NULL );
 
    if( const1 && const2 ) {  /*  Result is a constant  */
@@ -4952,19 +5092,19 @@
 	 strcat( this->value.data.str, sptr2 );
 	 break;
       }
       this->operation = CONST_OP;
 
    } else {  /*  Not a constant  */
 
-      Allocate_Ptrs( this );
+     Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
-	 rows = gParse.nRows;
+	 rows = lParse->nRows;
 	 switch( this->operation ) {
 
 	    /*  Compare Strings  */
 
 	 case NE:
 	 case EQ:
 	    while( rows-- ) {
@@ -5038,23 +5178,23 @@
    }
    if( that2->operation>0 ) {
       free( that2->value.data.strptr[0] );
       free( that2->value.data.strptr );
    }
 }
 
-static void Do_BinOp_log( Node *this )
+static void Do_BinOp_log( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    int vector1, vector2;
    char val1=0, val2=0, null1=0, null2=0;
    long rows, nelem, elem;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    vector1 = ( that1->operation!=CONST_OP );
    if( vector1 )
       vector1 = that1->value.nelem;
    else {
       val1  = that1->value.data.log;
    }
@@ -5083,21 +5223,21 @@
       case ACCUM:
 	 this->value.data.lng = val1;
 	 break;
       }
       this->operation=CONST_OP;
    } else if (this->operation == ACCUM) {
       long i, previous, curr;
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
       
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
       
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	previous = that2->value.data.lng;
 	
 	/* Cumulative sum of this chunk */
 	for (i=0; i<elem; i++) {
 	  if (!that1->value.undef[i]) {
 	    curr = that1->value.data.logptr[i];
 	    previous += curr;
@@ -5107,21 +5247,21 @@
 	}
 	
 	/* Store final cumulant for next pass */
 	that2->value.data.lng = previous;
       }
       
    } else {
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	
 	 if (this->operation == ACCUM) {
 	   long i, previous, curr;
 	   
 	   previous = that2->value.data.lng;
 	   
 	   /* Cumulative sum of this chunk */
@@ -5207,24 +5347,24 @@
       free( that1->value.data.ptr );
    }
    if( that2->operation>0 ) {
       free( that2->value.data.ptr );
    }
 }
 
-static void Do_BinOp_lng( Node *this )
+static void Do_BinOp_lng( ParseData *lParse, Node *this )
 {
    Node *that1, *that2;
    int  vector1, vector2;
    long val1=0, val2=0;
    char null1=0, null2=0;
    long rows, nelem, elem;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    vector1 = ( that1->operation!=CONST_OP );
    if( vector1 )
       vector1 = that1->value.nelem;
    else {
       val1  = that1->value.data.lng;
    }
@@ -5253,19 +5393,19 @@
 
       case '&':   this->value.data.lng = (val1  & val2);   break;
       case '|':   this->value.data.lng = (val1  | val2);   break;
       case '^':   this->value.data.lng = (val1  ^ val2);   break;
 
       case '%':
 	 if( val2 ) this->value.data.lng = (val1 % val2);
-	 else       fferror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case '/': 
 	 if( val2 ) this->value.data.lng = (val1 / val2); 
-	 else       fferror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case POWER:
 	 this->value.data.lng = (long)pow((double)val1,(double)val2);
 	 break;
       case ACCUM:
 	 this->value.data.lng = val1;
 	 break;
@@ -5274,21 +5414,21 @@
 	 break;
       }
       this->operation=CONST_OP;
 
    } else if ((this->operation == ACCUM) || (this->operation == DIFF)) {
       long i, previous, curr;
       long undef;
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
       
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
       
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	previous = that2->value.data.lng;
 	undef    = (long) that2->value.undef;
 	
 	if (this->operation == ACCUM) {
 	  /* Cumulative sum of this chunk */
 	  for (i=0; i<elem; i++) {
 	    if (!that1->value.undef[i]) {
@@ -5320,22 +5460,22 @@
 	/* Store final cumulant for next pass */
 	that2->value.data.lng = previous;
 	that2->value.undef    = (char *) undef; /* XXX evil, but no harm here */
       }
       
    } else {
 
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      while( rows-- && !gParse.status ) {
-	 while( nelem-- && !gParse.status ) {
+      while( rows-- && !lParse->status ) {
+	 while( nelem-- && !lParse->status ) {
 	    elem--;
 
 	    if( vector1>1 ) {
 	       val1  = that1->value.data.lngptr[elem];
 	       null1 = that1->value.undef[elem];
 	    } else if( vector1 ) {
 	       val1  = that1->value.data.lngptr[rows];
@@ -5395,24 +5535,24 @@
       free( that1->value.data.ptr );
    }
    if( that2->operation>0 ) {
       free( that2->value.data.ptr );
    }
 }
 
-static void Do_BinOp_dbl( Node *this )
+static void Do_BinOp_dbl( ParseData *lParse, Node *this )
 {
    Node   *that1, *that2;
    int    vector1, vector2;
    double val1=0.0, val2=0.0;
    char   null1=0, null2=0;
    long   rows, nelem, elem;
 
-   that1 = gParse.Nodes + this->SubNodes[0];
-   that2 = gParse.Nodes + this->SubNodes[1];
+   that1 = lParse->Nodes + this->SubNodes[0];
+   that2 = lParse->Nodes + this->SubNodes[1];
 
    vector1 = ( that1->operation!=CONST_OP );
    if( vector1 )
       vector1 = that1->value.nelem;
    else {
       val1  = that1->value.data.dbl;
    }
@@ -5437,19 +5577,19 @@
 
       case '+':   this->value.data.dbl = (val1  + val2);   break;
       case '-':   this->value.data.dbl = (val1  - val2);   break;
       case '*':   this->value.data.dbl = (val1  * val2);   break;
 
       case '%':
 	 if( val2 ) this->value.data.dbl = val1 - val2*((int)(val1/val2));
-	 else       fferror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case '/': 
 	 if( val2 ) this->value.data.dbl = (val1 / val2); 
-	 else       fferror("Divide by Zero");
+	 else       yyerror(0, lParse, "Divide by Zero");
 	 break;
       case POWER:
 	 this->value.data.dbl = (double)pow(val1,val2);
 	 break;
       case ACCUM:
 	 this->value.data.dbl = val1;
 	 break;
@@ -5459,21 +5599,21 @@
       }
       this->operation=CONST_OP;
 
    } else if ((this->operation == ACCUM) || (this->operation == DIFF)) {
       long i;
       long undef;
       double previous, curr;
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
       
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
       
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	previous = that2->value.data.dbl;
 	undef    = (long) that2->value.undef;
 	
 	if (this->operation == ACCUM) {
 	  /* Cumulative sum of this chunk */
 	  for (i=0; i<elem; i++) {
 	    if (!that1->value.undef[i]) {
@@ -5505,22 +5645,22 @@
 	/* Store final cumulant for next pass */
 	that2->value.data.dbl = previous;
 	that2->value.undef    = (char *) undef; /* XXX evil, but no harm here */
       }
       
    } else {
 
-      rows  = gParse.nRows;
+      rows  = lParse->nRows;
       nelem = this->value.nelem;
       elem  = this->value.nelem * rows;
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      while( rows-- && !gParse.status ) {
-	 while( nelem-- && !gParse.status ) {
+      while( rows-- && !lParse->status ) {
+	 while( nelem-- && !lParse->status ) {
 	    elem--;
 
 	    if( vector1>1 ) {
 	       val1  = that1->value.data.dblptr[elem];
 	       null1 = that1->value.undef[elem];
 	    } else if( vector1 ) {
 	       val1  = that1->value.data.dblptr[rows];
@@ -5766,29 +5906,29 @@
   /* Sanity checking to avoid a range error in the sqrt()'s below */
   if (a < 0) { a = 0; }
   if (a > 1) { a = 1; }
 
   return 2.0*atan2(sqrt(a), sqrt(1.0 - a)) / deg;
 }
 
-static void Do_Func( Node *this )
+static void Do_Func( ParseData *lParse, Node *this )
 {
    Node *theParams[MAXSUBS];
    int  vector[MAXSUBS], allConst;
    lval pVals[MAXSUBS];
    char pNull[MAXSUBS];
    long   ival;
    double dval;
    int  i, valInit;
    long row, elem, nelem;
 
    i = this->nSubNodes;
    allConst = 1;
    while( i-- ) {
-      theParams[i] = gParse.Nodes + this->SubNodes[i];
+      theParams[i] = lParse->Nodes + this->SubNodes[i];
       vector[i]   = ( theParams[i]->operation!=CONST_OP );
       if( vector[i] ) {
 	 allConst = 0;
 	 vector[i] = theParams[i]->value.nelem;
       } else {
 	 if( theParams[i]->type==DOUBLE ) {
 	    pVals[i].data.dbl = theParams[i]->value.data.dbl;
@@ -5873,14 +6013,20 @@
             else if( this->type==LONG )
 	       this->value.data.lng = pVals[0].data.lng;
             else if( this->type==DOUBLE )
 	       this->value.data.dbl = pVals[0].data.dbl;
             else if( this->type==STRING )
 	       strcpy(this->value.data.str,pVals[0].data.str);
 	    break;
+        case setnull_fct: /* Only defined for numeric expressions */
+            if( this->type==LONG )
+ 	      this->value.data.lng = pVals[0].data.lng;
+            else if( this->type==DOUBLE )
+	       this->value.data.dbl = pVals[0].data.dbl;
+	    break;
 
 	    /* Math functions with 1 double argument */
 
 	 case sin_fct:
 	    this->value.data.dbl = sin( pVals[0].data.dbl );
 	    break;
 	 case cos_fct:
@@ -5888,22 +6034,22 @@
 	    break;
 	 case tan_fct:
 	    this->value.data.dbl = tan( pVals[0].data.dbl );
 	    break;
 	 case asin_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<-1.0 || dval>1.0 )
-	       fferror("Out of range argument to arcsin");
+	       yyerror(0, lParse, "Out of range argument to arcsin");
 	    else
 	       this->value.data.dbl = asin( dval );
 	    break;
 	 case acos_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<-1.0 || dval>1.0 )
-	       fferror("Out of range argument to arccos");
+	       yyerror(0, lParse, "Out of range argument to arccos");
 	    else
 	       this->value.data.dbl = acos( dval );
 	    break;
 	 case atan_fct:
 	    this->value.data.dbl = atan( pVals[0].data.dbl );
 	    break;
 	 case sinh_fct:
@@ -5917,29 +6063,29 @@
 	    break;
 	 case exp_fct:
 	    this->value.data.dbl = exp( pVals[0].data.dbl );
 	    break;
 	 case log_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<=0.0 )
-	       fferror("Out of range argument to log");
+	       yyerror(0, lParse, "Out of range argument to log");
 	    else
 	       this->value.data.dbl = log( dval );
 	    break;
 	 case log10_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<=0.0 )
-	       fferror("Out of range argument to log10");
+	       yyerror(0, lParse, "Out of range argument to log10");
 	    else
 	       this->value.data.dbl = log10( dval );
 	    break;
 	 case sqrt_fct:
 	    dval = pVals[0].data.dbl;
 	    if( dval<0.0 )
-	       fferror("Out of range argument to sqrt");
+	       yyerror(0, lParse, "Out of range argument to sqrt");
 	    else
 	       this->value.data.dbl = sqrt( dval );
 	    break;
 	 case ceil_fct:
 	    this->value.data.dbl = ceil( pVals[0].data.dbl );
 	    break;
 	 case floor_fct:
@@ -6046,15 +6192,16 @@
                                               pVals[1].data.str ) );
                break;
             }
             break;
 
 	    /* String functions */
          case strmid_fct:
-	   cstrmid(this->value.data.str, this->value.nelem, 
+	   cstrmid(lParse, 
+		   this->value.data.str, this->value.nelem, 
 		   pVals[0].data.str,    pVals[0].nelem,
 		   pVals[1].data.lng);
 	   break;
          case strpos_fct:
 	   {
 	     char *res = strstr(pVals[0].data.str, pVals[1].data.str);
 	     if (res == NULL) {
@@ -6066,27 +6213,27 @@
 	   }
 
       }
       this->operation = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+     Allocate_Ptrs( lParse, this );
 
-      row  = gParse.nRows;
+      row  = lParse->nRows;
       elem = row * this->value.nelem;
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 	 switch( this->operation ) {
 
 	    /* Special functions with no arguments */
 
 	 case row_fct:
 	    while( row-- ) {
-	       this->value.data.lngptr[row] = gParse.firstRow + row;
+	       this->value.data.lngptr[row] = lParse->firstRow + row;
 	       this->value.undef[row] = 0;
 	    }
 	    break;
 	 case null_fct:
             if( this->type==LONG ) {
                while( row-- ) {
                   this->value.data.lngptr[row] = 0;
@@ -6095,14 +6242,57 @@
             } else if( this->type==STRING ) {
                while( row-- ) {
                   this->value.data.strptr[row][0] = '\0';
                   this->value.undef[row] = 1;
                }
             }
 	    break;
+	 case axiselem_fct:
+	   {
+	     long ielem;
+	     long iaxis[MAXDIMS] = {1, 1, 1, 1, 1};
+	     long ipos = pVals[1].data.lng - 1; /* This should be a constant long value */
+	     int naxis = this->value.naxis;
+	     int j;
+	     if (ipos < 0 || ipos >= MAXDIMS) {
+	         yyerror(0, lParse, "AXISELEM(V,n) n value exceeded maximum dimension");
+		 free( this->value.data.ptr );
+		 break;
+	     }
+
+	     for (ielem = 0; ielem<elem; ielem++) {
+	       this->value.data.lngptr[ielem] = iaxis[ipos];
+	       this->value.undef[ielem] = 0;
+	       iaxis[0]++;
+	       for (j = 0; j < naxis; j++) {
+		 if (iaxis[j] > this->value.naxes[j]) { 
+		   iaxis[j] = 1; 
+		   if (j < (naxis-1)) iaxis[j+1]++;
+		 } else {
+		   break;
+		 }
+	       }
+
+	     }
+	   }
+	   break;
+	 case elemnum_fct:
+	   {
+	     long ielem;
+	     long elemnum = 1;
+	     int j;
+
+	     for (ielem = 0; ielem<elem; ielem++) {
+	       this->value.data.lngptr[ielem] = elemnum;
+	       this->value.undef[ielem] = 0;
+	       elemnum ++;
+	       if (elemnum > this->value.nelem) elemnum = 1;
+	     }
+	   }
+	   break;
 	 case rnd_fct:
 	   while( elem-- ) {
 	     this->value.data.dblptr[elem] = simplerng_getuniform();
 	     this->value.undef[elem] = 0;
 	    }
 	    break;
 
@@ -6353,15 +6543,15 @@
 	       char *uptr = theParams[0]->value.undef;
 	       long *mptr = (long *) malloc(sizeof(long)*nelem);
 	       int irow;
 
 	       /* Allocate temporary storage for this row, since the
                   quickselect function will scramble the contents */
 	       if (mptr == 0) {
-		 fferror("Could not allocate temporary memory in median function");
+		 yyerror(0, lParse, "Could not allocate temporary memory in median function");
 		 free( this->value.data.ptr );
 		 break;
 	       }
 
 	       for (irow=0; irow<row; irow++) {
 		  long *p = mptr;
 		  int nelem1 = nelem;
@@ -6392,15 +6582,15 @@
 	       char   *uptr = theParams[0]->value.undef;
 	       double *mptr = (double *) malloc(sizeof(double)*nelem);
 	       int irow;
 
 	       /* Allocate temporary storage for this row, since the
                   quickselect function will scramble the contents */
 	       if (mptr == 0) {
-		 fferror("Could not allocate temporary memory in median function");
+		 yyerror(0, lParse, "Could not allocate temporary memory in median function");
 		 free( this->value.data.ptr );
 		 break;
 	       }
 
 	       for (irow=0; irow<row; irow++) {
 		  double *p = mptr;
 		  int nelem1 = nelem;
@@ -6556,14 +6746,42 @@
 		  } else {
 		     this->value.undef[elem] = 0;
 		     strcpy(this->value.data.strptr[row],pVals[0].data.str);
 		  }
 	       }
 	    }
 	    break;
+         case setnull_fct:
+	    switch( this->type ) {
+	    case LONG:
+	      while( elem-- ) {
+		if ( theParams[1]->value.data.lng == 
+		     theParams[0]->value.data.lngptr[elem] ) {
+		  this->value.data.lngptr[elem] = 0;
+		  this->value.undef[elem] = 1;
+		} else {
+		  this->value.data.lngptr[elem] = theParams[0]->value.data.lngptr[elem];
+		  this->value.undef[elem] = theParams[0]->value.undef[elem];
+		}
+	      }
+	      break;
+	    case DOUBLE:
+	      while( elem-- ) {
+		if ( theParams[1]->value.data.dbl == 
+		     theParams[0]->value.data.dblptr[elem] ) {
+		  this->value.data.dblptr[elem] = 0;
+		  this->value.undef[elem] = 1;
+		} else {
+		  this->value.data.dblptr[elem] = theParams[0]->value.data.dblptr[elem];
+		  this->value.undef[elem] = theParams[0]->value.undef[elem];
+		}
+	      }
+	      break;
+	    }
+	    break;
 
 	    /* Math functions with 1 double argument */
 
 	 case sin_fct:
 	    while( elem-- )
 	       if( !(this->value.undef[elem] = theParams[0]->value.undef[elem]) ) {
 		  this->value.data.dblptr[elem] = 
@@ -7282,15 +7500,16 @@
 		  } else {
 		    len = theParams[2]->value.data.lngptr[row];
 		    if (theParams[2]->value.undef[row]) undef = 1;
 		  }
 		  this->value.data.strptr[row][0] = '\0';
 		  if (pos == 0) undef = 1;
 		  if (! undef ) {
-		    if (cstrmid(this->value.data.strptr[row], len,
+		    if (cstrmid(lParse,
+				this->value.data.strptr[row], len,
 				str, src_len, pos) < 0) break;
 		  }
 		  this->value.undef[row] = undef;
 		}
 	      }		      
 	      break;
 
@@ -7329,40 +7548,40 @@
 		  this->value.undef[row] = undef;
 		}
 	      }
 	      break;
 
 		    
 	 } /* End switch(this->operation) */
-      } /* End if (!gParse.status) */
+      } /* End if (!lParse->status) */
    } /* End non-constant operations */
 
    i = this->nSubNodes;
    while( i-- ) {
       if( theParams[i]->operation>0 ) {
 	 /*  Currently only numeric params allowed  */
 	 free( theParams[i]->value.data.ptr );
       }
    }
 }
 
-static void Do_Deref( Node *this )
+static void Do_Deref( ParseData *lParse, Node *this )
 {
    Node *theVar, *theDims[MAXDIMS];
    int  isConst[MAXDIMS], allConst;
    long dimVals[MAXDIMS];
    int  i, nDims;
    long row, elem, dsize;
 
-   theVar = gParse.Nodes + this->SubNodes[0];
+   theVar = lParse->Nodes + this->SubNodes[0];
 
    i = nDims = this->nSubNodes-1;
    allConst = 1;
    while( i-- ) {
-      theDims[i] = gParse.Nodes + this->SubNodes[i+1];
+      theDims[i] = lParse->Nodes + this->SubNodes[i+1];
       isConst[i] = ( theDims[i]->operation==CONST_OP );
       if( isConst[i] )
 	 dimVals[i] = theDims[i]->value.data.lng;
       else
 	 allConst = 0;
    }
 
@@ -7371,30 +7590,30 @@
    } else if( this->type==LONG ) {
       dsize = sizeof( long );
    } else if( this->type==BOOLEAN ) {
       dsize = sizeof( char );
    } else
       dsize = 0;
 
-   Allocate_Ptrs( this );
+   Allocate_Ptrs( lParse, this );
 
-   if( !gParse.status ) {
+   if( !lParse->status ) {
 
       if( allConst && theVar->value.naxis==nDims ) {
 
 	 /* Dereference completely using constant indices */
 
 	 elem = 0;
 	 i    = nDims;
 	 while( i-- ) {
 	    if( dimVals[i]<1 || dimVals[i]>theVar->value.naxes[i] ) break;
 	    elem = theVar->value.naxes[i]*elem + dimVals[i]-1;
 	 }
 	 if( i<0 ) {
-	    for( row=0; row<gParse.nRows; row++ ) {
+	    for( row=0; row<lParse->nRows; row++ ) {
 	       if( this->type==STRING )
 		 this->value.undef[row] = theVar->value.undef[row];
 	       else if( this->type==BITSTR ) 
 		 this->value.undef;  /* Dummy - BITSTRs do not have undefs */
 	       else 
 		 this->value.undef[row] = theVar->value.undef[elem];
 
@@ -7415,42 +7634,42 @@
 		  this->value.data.strptr[row][0] = 
 		     theVar->value.data.strptr[0][elem+row];
 		  this->value.data.strptr[row][1] = 0;  /* Null terminate */
 	       }
 	       elem += theVar->value.nelem;
 	    }
 	 } else {
-	    fferror("Index out of range");
+	    yyerror(0, lParse, "Index out of range");
 	    free( this->value.data.ptr );
 	 }
 	 
       } else if( allConst && nDims==1 ) {
 	 
 	 /* Reduce dimensions by 1, using a constant index */
 	 
 	 if( dimVals[0] < 1 ||
 	     dimVals[0] > theVar->value.naxes[ theVar->value.naxis-1 ] ) {
-	    fferror("Index out of range");
+	    yyerror(0, lParse, "Index out of range");
 	    free( this->value.data.ptr );
 	 } else if ( this->type == BITSTR || this->type == STRING ) {
 	    elem = this->value.nelem * (dimVals[0]-1);
-	    for( row=0; row<gParse.nRows; row++ ) {
+	    for( row=0; row<lParse->nRows; row++ ) {
 	      if (this->value.undef) 
 		this->value.undef[row] = theVar->value.undef[row];
 	      memcpy( (char*)this->value.data.strptr[0]
 		      + row*sizeof(char)*(this->value.nelem+1),
 		      (char*)theVar->value.data.strptr[0] + elem*sizeof(char),
 		      this->value.nelem * sizeof(char) );
 	      /* Null terminate */
 	      this->value.data.strptr[row][this->value.nelem] = 0;
 	      elem += theVar->value.nelem+1;
 	    }	       
 	 } else {
 	    elem = this->value.nelem * (dimVals[0]-1);
-	    for( row=0; row<gParse.nRows; row++ ) {
+	    for( row=0; row<lParse->nRows; row++ ) {
 	       memcpy( this->value.undef + row*this->value.nelem,
 		       theVar->value.undef + elem,
 		       this->value.nelem * sizeof(char) );
 	       memcpy( (char*)this->value.data.ptr
 		       + row*dsize*this->value.nelem,
 		       (char*)theVar->value.data.ptr + elem*dsize,
 		       this->value.nelem * dsize );
@@ -7458,27 +7677,27 @@
 	    }	       
 	 }
       
       } else if( theVar->value.naxis==nDims ) {
 
 	 /* Dereference completely using an expression for the indices */
 
-	 for( row=0; row<gParse.nRows; row++ ) {
+	 for( row=0; row<lParse->nRows; row++ ) {
 
 	    for( i=0; i<nDims; i++ ) {
 	       if( !isConst[i] ) {
 		  if( theDims[i]->value.undef[row] ) {
-		     fferror("Null encountered as vector index");
+		     yyerror(0, lParse, "Null encountered as vector index");
 		     free( this->value.data.ptr );
 		     break;
 		  } else
 		     dimVals[i] = theDims[i]->value.data.lngptr[row];
 	       }
 	    }
-	    if( gParse.status ) break;
+	    if( lParse->status ) break;
 
 	    elem = 0;
 	    i    = nDims;
 	    while( i-- ) {
 	       if( dimVals[i]<1 || dimVals[i]>theVar->value.naxes[i] ) break;
 	       elem = theVar->value.naxes[i]*elem + dimVals[i]-1;
 	    }
@@ -7507,37 +7726,37 @@
                     characters per string, followed by (nelem+1)
                     "undef" values. */
 		  this->value.data.strptr[row][0] = 
 		     theVar->value.data.strptr[0][elem+row];
 		  this->value.data.strptr[row][1] = 0;  /* Null terminate */
 	       }
 	    } else {
-	       fferror("Index out of range");
+	       yyerror(0, lParse, "Index out of range");
 	       free( this->value.data.ptr );
 	    }
 	 }
 
       } else {
 
 	 /* Reduce dimensions by 1, using a nonconstant expression */
 
-	 for( row=0; row<gParse.nRows; row++ ) {
+	 for( row=0; row<lParse->nRows; row++ ) {
 
 	    /* Index cannot be a constant */
 
 	    if( theDims[0]->value.undef[row] ) {
-	       fferror("Null encountered as vector index");
+	       yyerror(0, lParse, "Null encountered as vector index");
 	       free( this->value.data.ptr );
 	       break;
 	    } else
 	       dimVals[0] = theDims[0]->value.data.lngptr[row];
 
 	    if( dimVals[0] < 1 ||
 		dimVals[0] > theVar->value.naxes[ theVar->value.naxis-1 ] ) {
-	       fferror("Index out of range");
+	       yyerror(0, lParse, "Index out of range");
 	       free( this->value.data.ptr );
 	    } else if ( this->type == BITSTR || this->type == STRING ) {
 	      elem = this->value.nelem * (dimVals[0]-1);
 	      elem += row*(theVar->value.nelem+1);
 	      if (this->value.undef) 
 		this->value.undef[row] = theVar->value.undef[row];
 	      memcpy( (char*)this->value.data.strptr[0]
@@ -7569,120 +7788,300 @@
    }
    for( i=0; i<nDims; i++ )
       if( theDims[i]->operation>0 ) {
 	 free( theDims[i]->value.data.ptr );
       }
 }
 
-static void Do_GTI( Node *this )
+static void Do_GTI( ParseData *lParse, Node *this )
 {
    Node *theExpr, *theTimes;
    double *start, *stop, *times;
    long elem, nGTI, gti;
    int ordered;
+   int dorow = (this->operation == gtifind_fct);
 
-   theTimes = gParse.Nodes + this->SubNodes[0];
-   theExpr  = gParse.Nodes + this->SubNodes[1];
+   theTimes = lParse->Nodes + this->SubNodes[0];
+   theExpr  = lParse->Nodes + this->SubNodes[1];
 
    nGTI    = theTimes->value.nelem;
    start   = theTimes->value.data.dblptr;
    stop    = theTimes->value.data.dblptr + nGTI;
    ordered = theTimes->type;
 
    if( theExpr->operation==CONST_OP ) {
-
-      this->value.data.log = 
-	 (Search_GTI( theExpr->value.data.dbl, nGTI, start, stop, ordered )>=0);
+      gti = Search_GTI( theExpr->value.data.dbl, nGTI, start, stop, ordered, 0 );
+      if (dorow) {
+	this->value.data.lng = (gti >= 0) ? (gti+1) : -1;
+      } else {
+	this->value.data.log = (gti>=0);
+      }
       this->operation      = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
       times = theExpr->value.data.dblptr;
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
-	 elem = gParse.nRows * this->value.nelem;
+	 elem = lParse->nRows * this->value.nelem;
 	 if( nGTI ) {
 	    gti = -1;
 	    while( elem-- ) {
 	       if( (this->value.undef[elem] = theExpr->value.undef[elem]) )
 		  continue;
 
             /*  Before searching entire GTI, check the GTI found last time  */
 	       if( gti<0 || times[elem]<start[gti] || times[elem]>stop[gti] ) {
-		  gti = Search_GTI( times[elem], nGTI, start, stop, ordered );
+		 gti = Search_GTI( times[elem], nGTI, start, stop, ordered, 0 );
+	       }
+	       if (dorow) {
+		 this->value.data.lngptr[elem] = ( gti >= 0 ) ? (gti + 1) : (-1);
+		 this->value.undef[elem]  = ( gti >= 0 ) ? 0 : 1;
+	       } else {
+		 this->value.data.logptr[elem] = ( gti>=0 );
 	       }
-	       this->value.data.logptr[elem] = ( gti>=0 );
 	    }
-	 } else
-	    while( elem-- ) {
+	 } else { /* nGTI == 0 */
+
+	   if (dorow) { /* no good times so all values are undef */
+	     while( elem-- ) {
+	       this->value.undef[elem]       = 1;
+	     }
+	   } else {    /* no good times so all logicals are 0 */
+	     while( elem-- ) {
 	       this->value.data.logptr[elem] = 0;
 	       this->value.undef[elem]       = 0;
-	    }
+	     }
+	   }
+	   
+	 }
       }
    }
 
    if( theExpr->operation>0 )
       free( theExpr->value.data.ptr );
 }
 
+static void Do_GTI_Over( ParseData *lParse, Node *this )
+{
+   Node *theTimes, *theStart, *theStop;
+   double *gtiStart, *gtiStop;
+   double *evtStart, *evtStop;
+   long elem, nGTI, gti, nextGTI;
+   int ordered;
+
+   theTimes = lParse->Nodes + this->SubNodes[0]; /* GTI times */
+   theStop  = lParse->Nodes + this->SubNodes[2]; /* User start time */
+   theStart = lParse->Nodes + this->SubNodes[1]; /* User stop time */
+
+   nGTI     = theTimes->value.nelem;
+   gtiStart = theTimes->value.data.dblptr;        /* GTI start */
+   gtiStop  = theTimes->value.data.dblptr + nGTI; /* GTI stop */
+
+   if( theStart->operation==CONST_OP && theStop->operation==CONST_OP) {
+
+      this->value.data.dbl = 
+	(GTI_Over( theStart->value.data.dbl, theStop->value.data.dbl,
+		   nGTI, gtiStart, gtiStop, &gti));
+      this->operation      = CONST_OP;
+
+   } else {
+      char undefStart = 0, undefStop = 0; /* Input values are undef? */
+      double uStart, uStop;       /* User start/stop values */
+      if (theStart->operation==CONST_OP) uStart = theStart->value.data.dbl;
+      if (theStop ->operation==CONST_OP) uStop  = theStop ->value.data.dbl;
+
+      Allocate_Ptrs( lParse, this );
+
+      evtStart = theStart->value.data.dblptr;
+      evtStop  = theStop ->value.data.dblptr;
+      if( !lParse->status ) {
+
+	 elem = lParse->nRows * this->value.nelem;
+	 if( nGTI ) {
+	    double toverlap = 0.0;
+	    gti = -1;
+	    while( elem-- ) {
+	      if (theStart->operation!=CONST_OP) {
+		undefStart = theStart->value.undef[elem];
+		uStart     = evtStart[elem];
+	      }
+	      if (theStop->operation!=CONST_OP) {
+		undefStop  = theStop ->value.undef[elem];
+		uStop      = evtStop[elem];
+	      }
+	      /* This works because at least one of the values is not const */
+	      if( (this->value.undef[elem] = (undefStart||undefStop)) )
+		  continue;
+
+            /*  Before searching entire GTI, check the GTI found last time  */
+	       if( gti<0 || 
+		   uStart<gtiStart[gti] || uStart>gtiStop[gti] ||
+		   uStop <gtiStart[gti] || uStop >gtiStop[gti]) {
+		 /* Nope, need to recalculate */
+		 toverlap = GTI_Over(uStart, uStop, 
+				     nGTI, gtiStart, gtiStop, 
+				     &gti);
+	       } else {
+		 /* We are in same GTI, the overlap is just stop-start of user range */
+		 toverlap = (uStop-uStart);
+	       }
+
+	       /* This works because at least one of the values is not const */
+	       this->value.data.dblptr[elem] = toverlap;
+	    }
+	 } else
+	    /* nGTI == 0; there is no overlap so set all values to 0.0 */
+	    while( elem-- ) {
+	       this->value.data.dblptr[elem] = 0.0;
+	       this->value.undef[elem]       = 0;
+	    }
+      }
+   }
+
+   if( theStart->operation>0 ) {
+     free( theStart->value.data.ptr );
+   }
+   if( theStop->operation>0 ) {
+     free( theStop->value.data.ptr );
+   }
+}
+
+static double GTI_Over(double evtStart, double evtStop,
+		       long nGTI, double *start, double *stop,
+		       long *gtiout)
+{
+  long gti1, gti2, nextGTI1, nextGTI2;
+  long gti, nMax;
+  double overlap = 0.0;
+
+  *gtiout = -1L;
+  /* Zero or negative bin size */
+  if (evtStop <= evtStart) return 0.0;
+
+  /* Locate adjacent GTIs for evtStart and evtStop */
+  gti1 = Search_GTI(evtStart, nGTI, start, stop, 1, &nextGTI1);
+  gti2 = Search_GTI(evtStop,  nGTI, start, stop, 1, &nextGTI2);
+
+  /* evtStart is in gti1, we return that for future processing */
+  if (gti1 >= 0) *gtiout = gti1;
+
+  /* Both evtStart/evtStop are beyond the last GTI */
+  if (nextGTI1 < 0 && nextGTI2 < 0) return 0.0;
+
+  /* Both evtStart/evtStop are in the same gap between GTIs */
+  if (gti1 < 0 && gti2 < 0 && nextGTI1 == nextGTI2) return 0.0;
+
+  /* Both evtStart/evtStop are in the same GTI */
+  if (gti1 >= 0 && gti1 == gti2) return (evtStop-evtStart);
+
+  /* Count through the remaining GTIs; there will be at least one */
+  /* The largest GTI to consider is either nextGTI2-1, if it exists,
+     or nGTI-1 */
+  if (nextGTI2 < 0) nMax = nGTI-1;
+  else if (gti2 >= 0) nMax = nextGTI2;
+  else nMax = nextGTI2-1;
+  for (gti = nextGTI1; gti <= nMax; gti++) {
+    double starti = start[gti], stopi = stop[gti];
+    /* Trim the GTI by actual evtStart/Stop times */
+    if (evtStart > starti) starti = evtStart;
+    if (evtStop  < stopi ) stopi  = evtStop;
+    overlap += (stopi - starti);
+  }
+    
+  return overlap;
+}
+
+/*
+ * Search_GTI - search GTI for requested evtTime
+ * 
+ * double evtTime - requested event time
+ * long nGTI - number of entries in start[] and stop[]
+ * double start[], stop[] - start and stop of each GTI
+ * int ordered - set to 1 if time-ordered
+ * long *nextGTI0 - upon return, *nextGTI0 is either
+ *                   the GTI evtTime is inside
+ *                   the next GTI if evtTime is not inside
+ *                   -1L if there is no next GTI
+ *                   not set if nextGTI0 is a null pointer
+ *
+ * NOTE: for *nextGTI to be well-defined, the GTI must
+ *   be ordered.  This is true when called by Do_GTI.
+ *
+ * RETURNS: gti index that evtTime is located inside, or -1L
+ */
 static long Search_GTI( double evtTime, long nGTI, double *start,
-			double *stop, int ordered )
+			double *stop, int ordered, long *nextGTI0 )
 {
-   long gti, step;
+   long gti, nextGTI = -1L, step;
                              
    if( ordered && nGTI>15 ) { /*  If time-ordered and lots of GTIs,   */
                               /*  use "FAST" Binary search algorithm  */
       if( evtTime>=start[0] && evtTime<=stop[nGTI-1] ) {
 	 gti = step = (nGTI >> 1);
 	 while(1) {
 	    if( step>1L ) step >>= 1;
 	    
 	    if( evtTime>stop[gti] ) {
 	       if( evtTime>=start[gti+1] )
 		  gti += step;
 	       else {
+		  nextGTI = gti+1;
 		  gti = -1L;
 		  break;
 	       }
 	    } else if( evtTime<start[gti] ) {
 	       if( evtTime<=stop[gti-1] )
 		  gti -= step;
 	       else {
+		  nextGTI = gti;
 		  gti = -1L;
 		  break;
 	       }
 	    } else {
+	       nextGTI = gti;
 	       break;
 	    }
 	 }
-      } else
+      } else {
+	 if (start[0] > evtTime) nextGTI = 0;
 	 gti = -1L;
+      }
       
-   } else { /*  Use "SLOW" linear search  */
+   } else { /*  Use "SLOW" linear search.  Not required to be 
+	        ordered, so we have to search the whole table
+		no matter what.
+	    */
       gti = nGTI;
-      while( gti-- )
-	 if( evtTime>=start[gti] && evtTime<=stop[gti] )
+      while( gti-- ) {
+	if( stop[gti] >= evtTime ) nextGTI = gti;
+	if( evtTime>=start[gti] && evtTime<=stop[gti] )
 	    break;
+      }
    }
+
+   if (nextGTI >= nGTI) nextGTI = -1;
+   if (nextGTI0) *nextGTI0 = nextGTI;
+
    return( gti );
 }
 
-static void Do_REG( Node *this )
+static void Do_REG( ParseData *lParse, Node *this )
 {
    Node *theRegion, *theX, *theY;
    double Xval=0.0, Yval=0.0;
    char   Xnull=0, Ynull=0;
    int    Xvector, Yvector;
    long   nelem, elem, rows;
 
-   theRegion = gParse.Nodes + this->SubNodes[0];
-   theX      = gParse.Nodes + this->SubNodes[1];
-   theY      = gParse.Nodes + this->SubNodes[2];
+   theRegion = lParse->Nodes + this->SubNodes[0];
+   theX      = lParse->Nodes + this->SubNodes[1];
+   theY      = lParse->Nodes + this->SubNodes[2];
 
    Xvector = ( theX->operation!=CONST_OP );
    if( Xvector )
       Xvector = theX->value.nelem;
    else {
       Xval  = theX->value.data.dbl;
    }
@@ -7699,19 +8098,19 @@
       this->value.data.log =
 	 ( fits_in_region( Xval, Yval, (SAORegion *)theRegion->value.data.ptr )
 	   != 0 );
       this->operation      = CONST_OP;
 
    } else {
 
-      Allocate_Ptrs( this );
+      Allocate_Ptrs( lParse, this );
 
-      if( !gParse.status ) {
+      if( !lParse->status ) {
 
-	 rows  = gParse.nRows;
+	 rows  = lParse->nRows;
 	 nelem = this->value.nelem;
 	 elem  = rows*nelem;
 
 	 while( rows-- ) {
 	    while( nelem-- ) {
 	       elem--;
 
@@ -7747,31 +8146,31 @@
 
    if( theX->operation>0 )
       free( theX->value.data.ptr );
    if( theY->operation>0 )
       free( theY->value.data.ptr );
 }
 
-static void Do_Vector( Node *this )
+static void Do_Vector( ParseData *lParse, Node *this )
 {
    Node *that;
    long row, elem, idx, jdx, offset=0;
    int node;
 
-   Allocate_Ptrs( this );
+   Allocate_Ptrs( lParse, this );
 
-   if( !gParse.status ) {
+   if( !lParse->status ) {
 
       for( node=0; node<this->nSubNodes; node++ ) {
 
-	 that = gParse.Nodes + this->SubNodes[node];
+	 that = lParse->Nodes + this->SubNodes[node];
 
 	 if( that->operation == CONST_OP ) {
 
-	    idx = gParse.nRows*this->value.nelem + offset;
+	    idx = lParse->nRows*this->value.nelem + offset;
 	    while( (idx-=this->value.nelem)>=0 ) {
 	       
 	       this->value.undef[idx] = 0;
 
 	       switch( this->type ) {
 	       case BOOLEAN:
 		  this->value.data.logptr[idx] = that->value.data.log;
@@ -7783,15 +8182,15 @@
 		  this->value.data.dblptr[idx] = that->value.data.dbl;
 		  break;
 	       }
 	    }
 	    
 	 } else {
 	       
-	    row  = gParse.nRows;
+	    row  = lParse->nRows;
 	    idx  = row * that->value.nelem;
 	    while( row-- ) {
 	       elem = that->value.nelem;
 	       jdx = row*this->value.nelem + offset;
 	       while( elem-- ) {
 		  this->value.undef[jdx+elem] =
 		     that->value.undef[--idx];
@@ -7816,15 +8215,81 @@
 	 offset += that->value.nelem;
       }
 
    }
 
    for( node=0; node < this->nSubNodes; node++ )
      if( OPER(this->SubNodes[node])>0 )
-       free( gParse.Nodes[this->SubNodes[node]].value.data.ptr );
+       free( lParse->Nodes[this->SubNodes[node]].value.data.ptr );
+}
+
+static void Do_Array( ParseData *lParse, Node *this )
+{
+   Node *that;
+   long row, elem, idx, jdx, offset=0;
+   int node;
+
+   Allocate_Ptrs( lParse, this );
+
+   if( !lParse->status ) {
+
+     /* This is the item to be replicated */
+     that = lParse->Nodes + this->SubNodes[0];
+
+     if( that->operation == CONST_OP ) {
+
+       idx = lParse->nRows*this->value.nelem + offset;
+       while( (idx--)>=0 ) {
+	       
+	 this->value.undef[idx] = 0;
+
+	 switch( this->type ) {
+	 case BOOLEAN:
+	   this->value.data.logptr[idx] = that->value.data.log;
+	   break;
+	 case LONG:
+	   this->value.data.lngptr[idx] = that->value.data.lng;
+	   break;
+	 case DOUBLE:
+	   this->value.data.dblptr[idx] = that->value.data.dbl;
+	   break;
+	 }
+       }
+       
+     } else {
+       
+       row  = lParse->nRows;
+       idx  = row * this->value.nelem - 1;
+       while( row-- ) {
+	 elem = this->value.nelem;
+	 while( elem-- ) {
+	   this->value.undef[idx] = that->value.undef[row];
+
+	   switch( this->type ) {
+	   case BOOLEAN:
+	     this->value.data.logptr[idx] = that->value.data.logptr[row];
+	     break;
+	   case LONG:
+	     this->value.data.lngptr[idx] = that->value.data.lngptr[row];
+	     break;
+	   case DOUBLE:
+	     this->value.data.dblptr[idx] = that->value.data.dblptr[row];
+	     break;
+	   }
+	   idx--;
+	 }
+       }
+
+     } /* not constant */
+
+     if( OPER(this->SubNodes[0])>0 )
+       free( lParse->Nodes[this->SubNodes[0]].value.data.ptr );
+
+   }
+
 }
 
 /*****************************************************************************/
 /*  Utility routines which perform the calculations on bits and SAO regions  */
 /*****************************************************************************/
 
 static char bitlgte(char *bits1, int oper, char *bits2)
@@ -8093,25 +8558,25 @@
  else
    return ( 0 );
 }
 
 /*
  * Extract substring
  */
-int cstrmid(char *dest_str, int dest_len,
+ int cstrmid(ParseData *lParse, char *dest_str, int dest_len,
 	    char *src_str,  int src_len,
 	    int pos)
 {
   /* char fill_char = ' '; */
   char fill_char = '\0';
   if (src_len == 0) { src_len = strlen(src_str); } /* .. if constant */
 
   /* Fill destination with blanks */
   if (pos < 0) { 
-    fferror("STRMID(S,P,N) P must be 0 or greater");
+    yyerror(0, lParse, "STRMID(S,P,N) P must be 0 or greater");
     return -1;
   }
   if (pos > src_len || pos == 0) {
     /* pos==0: blank string requested */
     memset(dest_str, fill_char, dest_len);
   } else if (pos+dest_len > src_len) {
     /* Copy a subset */
@@ -8126,17 +8591,17 @@
   }
   dest_str[dest_len] = '\0'; /* Null-terminate */
 
   return 0;
 }
 
 
-static void fferror(char *s)
+static void yyerror(yyscan_t scanner, ParseData *lParse, char *s)
 {
     char msg[80];
 
-    if( !gParse.status ) gParse.status = PARSE_SYNTAX_ERR;
+    if( !lParse->status ) lParse->status = PARSE_SYNTAX_ERR;
 
     strncpy(msg, s, 80);
     msg[79] = '\0';
     ffpmsg(msg);
 }
```

### Comparing `fitsio-1.1.9/cfitsio3490/f77.inc` & `fitsio-1.2.0/cfitsio-4.2.0/f77.inc`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/f77_wrap.h` & `fitsio-1.2.0/cfitsio-4.2.0/f77_wrap.h`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,17 @@
     || (defined(mipsFortran)  && _MIPS_SZLONG==64) \
     || (defined(IBMR2Fortran) && defined(__64BIT__)) \
     ||  defined(__ia64__)  \
     ||  defined (__sparcv9) || (defined(__sparc__) && defined(__arch64__)) \
     ||  defined (__x86_64__) \
     ||  defined (_SX) \
     ||  defined (__powerpc64__)\
-    ||  defined (__s390x__)
+    ||  defined (__s390x__)\
+    || (defined(__arm64__) && defined(__APPLE__)) \
+    ||  defined(__aarch64__) 
 
 #define   LONG8BYTES_INT4BYTES
 
 #undef LONGV_cfSTR
 #undef PLONG_cfSTR
 #undef LONGVVVVVVV_cfTYPE
 #undef PLONG_cfTYPE
```

### Comparing `fitsio-1.1.9/cfitsio3490/f77_wrap1.c` & `fitsio-1.2.0/cfitsio-4.2.0/f77_wrap1.c`

 * *Files 2% similar despite different names*

```diff
@@ -49,38 +49,42 @@
 
 void Cffgiou( int *unit, int *status );
 void Cffgiou( int *unit, int *status )
 {
    int i;
 
    if( *status>0 ) return;
+   FFLOCK;
    for( i=50;i<NMAXFILES;i++ ) /* Using a unit=0 sounds bad, so start at 1 */
       if( gFitsFiles[i]==NULL ) break;
    if( i==NMAXFILES ) {
       *unit = 0;
       *status = TOO_MANY_FILES;
       ffpmsg("Cffgiou has no more available unit numbers.");
    } else {
       *unit=i;
       gFitsFiles[i] = (fitsfile *)1; /*  Flag it as taken until ftopen/init  */
                                      /*  can be called and set a real value  */
    }
+   FFUNLOCK;
 }
 FCALLSCSUB2(Cffgiou,FTGIOU,ftgiou,PINT,PINT)
 
 void Cfffiou( int unit, int *status );
 void Cfffiou( int unit, int *status )
 {
    if( *status>0 ) return;
+   FFLOCK;
    if( unit == -1 ) {
       int i; for( i=50; i<NMAXFILES; ) gFitsFiles[i++]=NULL;
    } else if( unit<1 || unit>=NMAXFILES ) {
       *status = BAD_FILEPTR;
       ffpmsg("Cfffiou was sent an unacceptable unit number.");
    } else gFitsFiles[unit]=NULL;
+   FFUNLOCK;
 }
 FCALLSCSUB2(Cfffiou,FTFIOU,ftfiou,INT,PINT)
 
 
 int CFITS2Unit( fitsfile *fptr )
      /* Utility routine to convert a fitspointer to a Fortran unit number */
      /* for use when a C program is calling a Fortran routine which could */
```

### Comparing `fitsio-1.1.9/cfitsio3490/f77_wrap2.c` & `fitsio-1.2.0/cfitsio-4.2.0/f77_wrap2.c`

 * *Files 4% similar despite different names*

```diff
@@ -50,14 +50,20 @@
 FCALLSCSUB8(ffgpvb,FTGPVB,ftgpvb,FITSUNIT,LONG,LONG,LONG,BYTE,BYTEV,PLOGICAL,PINT)
 FCALLSCSUB8(ffgpvi,FTGPVI,ftgpvi,FITSUNIT,LONG,LONG,LONG,SHORT,SHORTV,PLOGICAL,PINT)
 FCALLSCSUB8(ffgpvk,FTGPVJ,ftgpvj,FITSUNIT,LONG,LONG,LONG,INT,INTV,PLOGICAL,PINT)
 FCALLSCSUB8(ffgpvjj,FTGPVK,ftgpvk,FITSUNIT,LONG,LONG,LONG,LONGLONG,LONGLONGV,PLOGICAL,PINT)
 FCALLSCSUB8(ffgpve,FTGPVE,ftgpve,FITSUNIT,LONG,LONG,LONG,FLOAT,FLOATV,PLOGICAL,PINT)
 FCALLSCSUB8(ffgpvd,FTGPVD,ftgpvd,FITSUNIT,LONG,LONG,LONG,DOUBLE,DOUBLEV,PLOGICAL,PINT)
 
+FCALLSCSUB8(ffgpvb,FTGPVBLL,ftgpvbll,FITSUNIT,LONG,LONGLONG,LONGLONG,BYTE,BYTEV,PLOGICAL,PINT)
+FCALLSCSUB8(ffgpvi,FTGPVILL,ftgpvill,FITSUNIT,LONG,LONGLONG,LONGLONG,SHORT,SHORTV,PLOGICAL,PINT)
+FCALLSCSUB8(ffgpvk,FTGPVJLL,ftgpvjll,FITSUNIT,LONG,LONGLONG,LONGLONG,INT,INTV,PLOGICAL,PINT)
+FCALLSCSUB8(ffgpvjj,FTGPVKLL,ftgpvkll,FITSUNIT,LONG,LONGLONG,LONGLONG,LONGLONG,LONGLONGV,PLOGICAL,PINT)
+FCALLSCSUB8(ffgpve,FTGPVELL,ftgpvell,FITSUNIT,LONG,LONGLONG,LONGLONG,FLOAT,FLOATV,PLOGICAL,PINT)
+FCALLSCSUB8(ffgpvd,FTGPVDLL,ftgpvdll,FITSUNIT,LONG,LONGLONG,LONGLONG,DOUBLE,DOUBLEV,PLOGICAL,PINT)
 
 #define ftgpfb_LOGV_A6 A4
 FCALLSCSUB8(ffgpfb,FTGPFB,ftgpfb,FITSUNIT,LONG,LONG,LONG,BYTEV,LOGICALV,PLOGICAL,PINT)
 
 #define ftgpfi_LOGV_A6 A4
 FCALLSCSUB8(ffgpfi,FTGPFI,ftgpfi,FITSUNIT,LONG,LONG,LONG,SHORTV,LOGICALV,PLOGICAL,PINT)
 
@@ -567,21 +573,35 @@
 FCALLSCSUB6(ffpprb,FTPPRB,ftpprb,FITSUNIT,LONG,LONG,LONG,BYTEV,PINT)
 FCALLSCSUB6(ffppri,FTPPRI,ftppri,FITSUNIT,LONG,LONG,LONG,SHORTV,PINT)
 FCALLSCSUB6(ffpprk,FTPPRJ,ftpprj,FITSUNIT,LONG,LONG,LONG,INTV,PINT)
 FCALLSCSUB6(ffpprjj,FTPPRK,ftpprk,FITSUNIT,LONG,LONG,LONG,LONGLONGV,PINT)
 FCALLSCSUB6(ffppre,FTPPRE,ftppre,FITSUNIT,LONG,LONG,LONG,FLOATV,PINT)
 FCALLSCSUB6(ffpprd,FTPPRD,ftpprd,FITSUNIT,LONG,LONG,LONG,DOUBLEV,PINT)
 
+FCALLSCSUB6(ffpprb,FTPPRBLL,ftpprbll,FITSUNIT,LONG,LONGLONG,LONGLONG,BYTEV,PINT)
+FCALLSCSUB6(ffppri,FTPPRILL,ftpprill,FITSUNIT,LONG,LONGLONG,LONGLONG,SHORTV,PINT)
+FCALLSCSUB6(ffpprk,FTPPRJLL,ftpprjll,FITSUNIT,LONG,LONGLONG,LONGLONG,INTV,PINT)
+FCALLSCSUB6(ffpprjj,FTPPRKLL,ftpprkll,FITSUNIT,LONG,LONGLONG,LONGLONG,LONGLONGV,PINT)
+FCALLSCSUB6(ffppre,FTPPRELL,ftpprell,FITSUNIT,LONG,LONGLONG,LONGLONG,FLOATV,PINT)
+FCALLSCSUB6(ffpprd,FTPPRDLL,ftpprdll,FITSUNIT,LONG,LONGLONG,LONGLONG,DOUBLEV,PINT)
+
 FCALLSCSUB7(ffppnb,FTPPNB,ftppnb,FITSUNIT,LONG,LONG,LONG,BYTEV,BYTE,PINT)
 FCALLSCSUB7(ffppni,FTPPNI,ftppni,FITSUNIT,LONG,LONG,LONG,SHORTV,SHORT,PINT)
 FCALLSCSUB7(ffppnk,FTPPNJ,ftppnj,FITSUNIT,LONG,LONG,LONG,INTV,INT,PINT)
 FCALLSCSUB7(ffppnjj,FTPPNK,ftppnk,FITSUNIT,LONG,LONG,LONG,LONGLONGV,LONGLONG,PINT)
 FCALLSCSUB7(ffppne,FTPPNE,ftppne,FITSUNIT,LONG,LONG,LONG,FLOATV,FLOAT,PINT)
 FCALLSCSUB7(ffppnd,FTPPND,ftppnd,FITSUNIT,LONG,LONG,LONG,DOUBLEV,DOUBLE,PINT)
 
+FCALLSCSUB7(ffppnb,FTPPNBLL,ftppnbll,FITSUNIT,LONG,LONGLONG,LONGLONG,BYTEV,BYTE,PINT)
+FCALLSCSUB7(ffppni,FTPPNILL,ftppnill,FITSUNIT,LONG,LONGLONG,LONGLONG,SHORTV,SHORT,PINT)
+FCALLSCSUB7(ffppnk,FTPPNJLL,ftppnjll,FITSUNIT,LONG,LONGLONG,LONGLONG,INTV,INT,PINT)
+FCALLSCSUB7(ffppnjj,FTPPNKLL,ftppnkll,FITSUNIT,LONG,LONGLONG,LONGLONG,LONGLONGV,LONGLONG,PINT)
+FCALLSCSUB7(ffppne,FTPPNELL,ftppnell,FITSUNIT,LONG,LONGLONG,LONGLONG,FLOATV,FLOAT,PINT)
+FCALLSCSUB7(ffppnd,FTPPNDLL,ftppndll,FITSUNIT,LONG,LONGLONG,LONGLONG,DOUBLEV,DOUBLE,PINT)
+
 FCALLSCSUB7(ffp2db,FTP2DB,ftp2db,FITSUNIT,LONG,LONG,LONG,LONG,BYTEV,PINT)
 FCALLSCSUB7(ffp2di,FTP2DI,ftp2di,FITSUNIT,LONG,LONG,LONG,LONG,SHORTV,PINT)
 FCALLSCSUB7(ffp2dk,FTP2DJ,ftp2dj,FITSUNIT,LONG,LONG,LONG,LONG,INTV,PINT)
 FCALLSCSUB7(ffp2djj,FTP2DK,ftp2dk,FITSUNIT,LONG,LONG,LONG,LONG,LONGLONGV,PINT)
 FCALLSCSUB7(ffp2de,FTP2DE,ftp2de,FITSUNIT,LONG,LONG,LONG,LONG,FLOATV,PINT)
 FCALLSCSUB7(ffp2dd,FTP2DD,ftp2dd,FITSUNIT,LONG,LONG,LONG,LONG,DOUBLEV,PINT)
 
@@ -628,14 +648,17 @@
 FCALLSCSUB6(ffpgpjj,FTPGPK,ftpgpk,FITSUNIT,LONG,LONG,LONG,LONGLONGV,PINT)
 FCALLSCSUB6(ffpgpe,FTPGPE,ftpgpe,FITSUNIT,LONG,LONG,LONG,FLOATV,PINT)
 FCALLSCSUB6(ffpgpd,FTPGPD,ftpgpd,FITSUNIT,LONG,LONG,LONG,DOUBLEV,PINT)
 
 FCALLSCSUB5(ffppru,FTPPRU,ftppru,FITSUNIT,LONG,LONG,LONG,PINT)
 FCALLSCSUB4(ffpprn,FTPPRN,ftpprn,FITSUNIT,LONG,LONG,PINT)
 
+FCALLSCSUB5(ffppru,FTPPRULL,ftpprull,FITSUNIT,LONG,LONGLONG,LONGLONG,PINT)
+FCALLSCSUB4(ffpprn,FTPPRNLL,ftpprnll,FITSUNIT,LONGLONG,LONGLONG,PINT)
+
 /*--------------------- write column elements -------------*/
 #define ftpcls_STRV_A6 NUM_ELEM_ARG(5)
 FCALLSCSUB7(ffpcls,FTPCLS,ftpcls,FITSUNIT,INT,LONG,LONG,LONG,STRINGV,PINT)
 
 #define ftpcll_LOGV_A6 A5
 FCALLSCSUB7(ffpcll,FTPCLL,ftpcll,FITSUNIT,INT,LONG,LONG,LONG,LOGICALV,PINT)
 FCALLSCSUB7(ffpclb,FTPCLB,ftpclb,FITSUNIT,INT,LONG,LONG,LONG,BYTEV,PINT)
```

### Comparing `fitsio-1.1.9/cfitsio3490/f77_wrap3.c` & `fitsio-1.2.0/cfitsio-4.2.0/f77_wrap3.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/f77_wrap4.c` & `fitsio-1.2.0/cfitsio-4.2.0/f77_wrap4.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/fits_hcompress.c` & `fitsio-1.2.0/cfitsio-4.2.0/fits_hcompress.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/fits_hdecompress.c` & `fitsio-1.2.0/cfitsio-4.2.0/fits_hdecompress.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/fitscopy.c` & `fitsio-1.2.0/cfitsio-4.2.0/fitscopy.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/fitscore.c` & `fitsio-1.2.0/cfitsio-4.2.0/fitscore.c`

 * *Files 1% similar despite different names*

```diff
@@ -67,21 +67,27 @@
 int STREAM_DRIVER = 0;
 struct lconv *lcxxx;
 
 /*--------------------------------------------------------------------------*/
 float ffvers(float *version)  /* IO - version number */
 /*
   return the current version number of the FITSIO software
+  
+  Note that this method of calculation limits minor/micro fields to < 100.
 */
 {
-      *version = (float) 3.49;
+      *version = (float)CFITSIO_MAJOR + (float)(.01*CFITSIO_MINOR)
+                   + (float)(.0001*CFITSIO_MICRO);
 
-/*       Aug 2020
+/*    *version = 4.2.0      Nov 2022
 
    Previous releases:
+      *version = 4.1.0      Feb 2022
+      *version = 4.0.0      May 2021
+      *version = 3.49       Aug 2020
       *version = 3.48       Apr 2020
       *version = 3.47       May 2019
       *version = 3.46       Oct 2018
       *version = 3.45       May 2018
       *version = 3.44       Apr 2018
       *version = 3.43       Mar 2018
       *version = 3.42       Mar 2017
@@ -1369,23 +1375,32 @@
   If the card contains a quoted string value, the returned value string
   includes the enclosing quote characters.  If comm = NULL, don't return
   the comment string.
 */
 {
     int jj;
     size_t ii, cardlen, nblank, valpos;
+    char strbuf[21];
 
     if (*status > 0)
         return(*status);
 
     value[0] = '\0';
     if (comm)
         comm[0] = '\0';
 
     cardlen = strlen(card);
+    if (cardlen >= FLEN_CARD)
+    {
+       strncpy(strbuf,card,20);
+       strbuf[20]='\0';
+       ffpmsg("The card string starting with the chars below is too long:");
+       ffpmsg(strbuf); 
+       return(*status = BAD_KEYCHAR);
+    }
 
     /* support for ESO HIERARCH keywords; find the '=' */
     if (FSTRNCMP(card, "HIERARCH ", 9) == 0)
     {
       valpos = strcspn(card, "=");
 
       if (valpos == cardlen)   /* no value indicator ??? */
@@ -1484,15 +1499,15 @@
     if (card[ii] == '/' )  /* slash indicates start of the comment */
     {
          ii++;
     }
     else if (card[ii] == '\'' )  /* is this a quoted string value? */
     {
         value[0] = card[ii];
-        for (jj=1, ii++; ii < cardlen; ii++, jj++)
+        for (jj=1, ii++; ii < cardlen && jj < FLEN_VALUE-1; ii++, jj++)
         {
             if (card[ii] == '\'')  /*  is this the closing quote?  */
             {
                 if (card[ii+1] == '\'')  /* 2 successive quotes? */ 
                 {
                    value[jj] = card[ii];
                    ii++;  
@@ -1503,17 +1518,17 @@
                     value[jj] = card[ii];
                     break;   /* found the closing quote, so exit this loop  */
                 }
             }
             value[jj] = card[ii];  /* copy the next character to the output */
         }
 
-        if (ii == cardlen)
+        if (ii == cardlen || jj == FLEN_VALUE-1)
         {
-            jj = minvalue(jj, 69);  /* don't exceed 70 char string length */
+            jj = minvalue(jj, FLEN_VALUE-2);  /* don't exceed 70 char string length */
             value[jj] = '\'';  /*  close the bad value string  */
             value[jj+1] = '\0';  /*  terminate the bad value string  */
             ffpmsg("This keyword string value has no closing quote:");
             ffpmsg(card);
 	    /*  May 2008 - modified to not fail on this minor error  */
 /*            return(*status = NO_QUOTE);  */
         }
@@ -1522,29 +1537,31 @@
             value[jj+1] = '\0';  /*  terminate the good value string  */
             ii++;   /*  point to the character following the value  */
         }
     }
     else if (card[ii] == '(' )  /* is this a complex value? */
     {
         nblank = strcspn(&card[ii], ")" ); /* find closing ) */
-        if (nblank == strlen( &card[ii] ) )
+        if (nblank == strlen( &card[ii] ) || nblank >= FLEN_VALUE-1 )
         {
-            ffpmsg("This complex keyword value has no closing ')':");
+            ffpmsg("This complex keyword value has no closing ')' within range:");
             ffpmsg(card);
             return(*status = NO_QUOTE);
         }
 
         nblank++;
         strncpy(value, &card[ii], nblank);
         value[nblank] = '\0';
         ii = ii + nblank;        
     }
     else   /*  an integer, floating point, or logical FITS value string  */
     {
         nblank = strcspn(&card[ii], " /");  /* find the end of the token */
+        if (nblank >= FLEN_VALUE) /* This should not happen for correct input */
+           nblank = FLEN_VALUE-1;
         strncpy(value, &card[ii], nblank);
         value[nblank] = '\0';
         ii = ii + nblank;
     }
 
     /*  now find the comment string, if any  */
     if (comm)
@@ -1556,15 +1573,16 @@
       {
         if (card[ii] == '/')   /*  ignore the slash separator  */
         {
             ii++;
             if (card[ii] == ' ')  /*  also ignore the following space  */
                 ii++;
         }
-        strcat(comm, &card[ii]);  /*  copy the remaining characters  */
+        strncpy(comm, &card[ii],FLEN_COMMENT-1);  /*  copy the remaining characters  */
+        comm[FLEN_COMMENT-1] = '\0';
 
         jj=strlen(comm);
         for (jj--; jj >= 0; jj--)  /* replace trailing blanks with nulls */
         {
             if (comm[jj] == ' ')
                 comm[jj] = '\0';
             else
@@ -5497,19 +5515,21 @@
         LONGLONG firstelem, /* I - first element within vector (1 = 1st)    */
         LONGLONG nelem, /* I - number of elements to read or write          */
         int writemode,  /* I - = 1 if writing data, = 0 if reading data     */
                         /*     If = 2, then writing data, but don't modify  */
                         /*     the returned values of repeat and incre.     */
                         /*     If = -1, then reading data in reverse        */
                         /*     direction.                                   */
+	                /*     If writemode has 16 added, then treat        */
+	                /*        TSTRING column as TBYTE vector            */
         double *scale,  /* O - FITS scaling factor (TSCALn keyword value)   */
         double *zero,   /* O - FITS scaling zero pt (TZEROn keyword value)  */
         char *tform,    /* O - ASCII column format: value of TFORMn keyword */
         long *twidth,   /* O - width of ASCII column (characters)           */
-        int *tcode,     /* O - column datatype code: I*4=41, R*4=42, etc    */
+        int *tcode,     /* O - abs(column datatype code): I*4=41, R*4=42, etc */
         int *maxelem,   /* O - max number of elements that fit in buffer    */
         LONGLONG *startpos,/* O - offset in file to starting row & column      */
         LONGLONG *elemnum, /* O - starting element number ( 0 = 1st element)   */
         long *incre,    /* O - byte offset between elements within a row    */
         LONGLONG *repeat,  /* O - number of elements in a row (vector column)  */
         LONGLONG *rowlen,  /* O - length of a row, in bytes                    */
         int  *hdutype,  /* O - HDU type: 0, 1, 2 = primary, table, bintable */
@@ -5534,15 +5554,15 @@
         ffmahd(fptr, (fptr->HDUposition) + 1, NULL, status);
 
     } else if ((fptr->Fptr)->datastart == DATA_UNDEFINED) {
         /* rescan header if data structure is undefined */
         if ( ffrdef(fptr, status) > 0)               
             return(*status);
 
-    } else if (writemode > 0) {
+    } else if (writemode > 0 && writemode != 15) {
 
 	/* Only terminate the header with the END card if */
 	/* writing to the stdout stream (don't have random access). */
 
 	/* Initialize STREAM_DRIVER to be the device number for */
 	/* writing FITS files directly out to the stdout stream. */
 	/* This only needs to be done once and is thread safe. */
@@ -5629,14 +5649,43 @@
      /* In ASCII tables, a null value is equivalent to all spaces */
 
        strcpy(snull, "                 ");   /* maximum of 17 spaces */
        nulpos = minvalue(17, *twidth);      /* truncate to width of column */
        snull[nulpos] = '\0';
     }
 
+    /* Special case: use writemode = 15,16,17,18 to interpret TSTRING columns
+       as TBYTE vectors instead (but not for ASCII tables). 
+          writemode = 15 equivalent to writemode =-1
+          writemode = 16 equivalent to writemode = 0
+          writemode = 17 equivalent to writemode = 1
+          writemode = 18 equivalent to writemode = 2
+    */
+    if (writemode >= 15 && writemode <= 18) {
+
+      if (abs(*tcode) == TSTRING && *hdutype != ASCII_TBL ) {
+        *incre = 1;          /* each element is 1 byte wide */
+	if (*tcode < 0) *repeat = *twidth;  /* variable columns appear to put width in *twidth */
+        *twidth = 1;         /* width of each element */
+        *scale = 1.0;        /* no scaling */
+        *zero  = 0.0;
+        *tnull = NULL_UNDEFINED;  /* don't test for nulls */
+        *maxelem = DBUFFSIZE;
+
+	if (*tcode < 0) {
+	  *tcode = -TBYTE; /* variable-length */
+	} else {
+	  *tcode =  TBYTE;
+	}
+      }
+
+      /* translate to the equivalent as listed above */
+      writemode -= 16;
+    }
+
     /* Special case:  interpret writemode = -1 as reading data, but */
     /* don't do error check for exceeding the range of pixels  */
     if (writemode == -1)
     {
       writemode = 0;
       rangecheck = 0;
     }
@@ -5646,15 +5695,18 @@
     {
         *tcode  = *tcode / TBIT * TBYTE;
         *repeat = (*repeat + 7) / 8;
     }
 
     /* Special case: support the 'rAw' format in BINTABLEs */
     if (*hdutype == BINARY_TBL && *tcode == TSTRING) {
-       *repeat = *repeat / *twidth;  /* repeat = # of unit strings in field */
+       if (*twidth)
+          *repeat = *repeat / *twidth;  /* repeat = # of unit strings in field */
+       else
+          *repeat = 0;
     }
     else if (*hdutype == BINARY_TBL && *tcode == -TSTRING) {
        /* variable length string */
        *incre = 1;
        *twidth = (long) nelem;
     }
 
@@ -5680,15 +5732,19 @@
     /* allow for case where floats are 8 bytes long */
     if (abs(*tcode) == TFLOAT)
        *maxelem = DBUFFSIZE / sizeof(float);
     else if (abs(*tcode) == TDOUBLE)
        *maxelem = DBUFFSIZE / sizeof(double);
     else if (abs(*tcode) == TSTRING)
     {
-       *maxelem = (DBUFFSIZE - 1)/ *twidth; /* leave room for final \0 */
+       if (*twidth)
+          *maxelem = (DBUFFSIZE - 1)/ *twidth; /* leave room for final \0 */
+       else
+          *maxelem = DBUFFSIZE - 1;
+          
        if (*maxelem == 0) {
             snprintf(message,FLEN_ERRMSG,
         "ASCII string column is too wide: %ld; max supported width is %d",
                    *twidth,  DBUFFSIZE - 1);
             ffpmsg(message);
             return(*status = COL_TOO_WIDE);
         }
@@ -9769,7 +9825,65 @@
       if (c1 > c2) return(1);
       if (c1 == 0) return(0);
       s1++;
       s2++;
    }
    return(0);
 }
+/*
+ * fits_recalloc - an allocator/reallocator in the style of calloc and realloc 
+ * 
+ * Allocates or reallocates storage upon request.  Newly allocated
+ * storage is zeroed in the style of calloc.
+ * 
+ * Cases handled are:
+ *    ptr == 0 or old_num == 0 - use calloc to allocate new storage
+ *    new_num = 0 - frees any storage if ptr is non-NULL
+ *    new_num < old_num - uses realloc() to reduce storage allocated
+ *    new_num > old_num - uses realloc() and sets newly allocated 
+ *                        storage to zero (old portion left unchanged)
+ *
+ * void *ptr - "old" pointer, or NULL to allocate new storage
+ * size_t old_num - old number of records allocated
+ * size_t new_num  - new number of records allocated
+ * size_t size - size of record in bytes
+ *
+ * RETURNS: newly allocated storage
+ *
+ * */
+void *fits_recalloc(void *ptr, size_t old_num, size_t new_num, size_t size)
+{
+  void *newptr;
+
+  if (ptr == 0 || old_num == 0) { /* Starting from nothing */
+
+    return calloc(new_num, size);
+
+  } else if (new_num == old_num) { /* Same size, do nothing */
+    
+    return ptr;
+
+  } else if (new_num == 0) { /* Freeing */
+
+    if (ptr) free(ptr);
+    return 0;
+
+  } else if (new_num < old_num) { /* Shrinking */
+    
+    newptr = realloc(ptr, new_num*size);
+    if (!newptr) free(ptr);
+    return (newptr);
+  }
+
+  /* Growing */
+  newptr = realloc(ptr, new_num*size);
+  if (!newptr) {
+    free(ptr);
+    return newptr;
+  }
+
+  /* Zero the new portion of the array */
+  memset( (char *) newptr + old_num*size/sizeof(char), 0,
+	  (new_num - old_num)*size );
+  return (newptr);
+}
+
```

### Comparing `fitsio-1.1.9/cfitsio3490/fitsio.h` & `fitsio-1.2.0/cfitsio-4.2.0/fitsio.h`

 * *Files 0% similar despite different names*

```diff
@@ -30,18 +30,21 @@
 SERVICES PROVIDED HEREUNDER."
 
 */
 
 #ifndef _FITSIO_H
 #define _FITSIO_H
 
-#define CFITSIO_VERSION 3.49
-#define CFITSIO_MINOR 49
-#define CFITSIO_MAJOR 3
-#define CFITSIO_SONAME 9
+#define CFITSIO_VERSION 4.2.0
+/* Minor and micro numbers must not exceed 99 under current method
+   of version representataion in ffvers(). */
+#define CFITSIO_MICRO 0
+#define CFITSIO_MINOR 2
+#define CFITSIO_MAJOR 4
+#define CFITSIO_SONAME 10
 
 /* the SONAME is incremented in a new release if the binary shared */
 /* library (on linux and Mac systems) is not backward compatible */
 /* with the previous release of CFITSIO */
 
 
 /* CFITS_API is defined below for use on Windows systems.  */
@@ -476,14 +479,15 @@
     char     tdisp[70]; /* suggested display format */
 
 } iteratorCol;
 
 #define InputCol         0  /* flag for input only iterator column       */
 #define InputOutputCol   1  /* flag for input and output iterator column */
 #define OutputCol        2  /* flag for output only iterator column      */
+#define TemporaryCol     3  /* flag for temporary iterator column INTERNAL */
 
 /*=============================================================================
 *
 *       The following wtbarr typedef is used in the fits_read_wcstab() routine,
 *       which is intended for use with the WCSLIB library written by Mark
 *       Calabretta, http://www.atnf.csiro.au/~mcalabre/index.html
 *
@@ -1433,14 +1437,16 @@
 int CFITS_API ffggpd(fitsfile *fptr, long group, long firstelem, long nelem,
            double *array, int *status);
  
 /*--------------------- read column elements -------------*/
 int CFITS_API ffgcv( fitsfile *fptr, int datatype, int colnum, LONGLONG firstrow,
            LONGLONG firstelem, LONGLONG nelem, void *nulval, void *array, int *anynul,
            int  *status);
+int CFITS_API ffgcvn (fitsfile *fptr, int ncols, int *datatype, int *colnum, LONGLONG firstrow,
+	    LONGLONG nrows, void **nulval, void **array, int *anynul, int *status);
 int CFITS_API ffgcf( fitsfile *fptr, int datatype, int colnum, LONGLONG firstrow,
            LONGLONG firstelem, LONGLONG nelem, void *array, char *nullarray,
            int *anynul, int *status);
 int CFITS_API ffgcvs(fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
            LONGLONG nelem, char *nulval, char **array, int *anynul, int *status);
 int CFITS_API ffgcl (fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
            LONGLONG nelem, char *array, int  *status);
@@ -1742,14 +1748,16 @@
            int (*workFn)( long totaln, long offset, long firstn,
              long nvalues, int narrays, iteratorCol *data, void *userPointer),
            void *userPointer, int *status);
 
 /*--------------------- write column elements -------------*/
 int CFITS_API ffpcl(fitsfile *fptr, int datatype, int colnum, LONGLONG firstrow,
           LONGLONG firstelem, LONGLONG nelem, void *array, int *status);
+int CFITS_API ffpcln(fitsfile *fptr, int ncols, int *datatype, int *colnum, LONGLONG firstrow,
+	   LONGLONG nrows, void **array, void **nulval, int *status);
 int CFITS_API ffpcls(fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
            LONGLONG nelem, char **array, int *status);
 int CFITS_API ffpcll(fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
            LONGLONG nelem, char *array, int *status);
 int CFITS_API ffpclb(fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
            LONGLONG nelem, unsigned char *array, int *status);
 int CFITS_API ffpclsb(fitsfile *fptr, int colnum, LONGLONG firstrow, LONGLONG firstelem,
@@ -1834,14 +1842,16 @@
 int CFITS_API ffdcol(fitsfile *fptr, int numcol, int *status);
 int CFITS_API ffcpcl(fitsfile *infptr, fitsfile *outfptr, int incol, int outcol, 
            int create_col, int *status);
 int CFITS_API ffccls(fitsfile *infptr, fitsfile *outfptr, int incol, int outcol, 
 	   int ncols, int create_col, int *status);
 int CFITS_API ffcprw(fitsfile *infptr, fitsfile *outfptr, LONGLONG firstrow, 
            LONGLONG nrows, int *status);
+int CFITS_API ffcpsr(fitsfile *infptr, fitsfile *outfptr, LONGLONG firstrow, 
+	   LONGLONG nrows, char *row_status, int *status);
 int CFITS_API ffcpht(fitsfile *infptr, fitsfile *outfptr, LONGLONG firstrow, 
            LONGLONG nrows, int *status);
 
 /*--------------------- WCS Utilities ------------------*/
 int CFITS_API ffgics(fitsfile *fptr, double *xrval, double *yrval, double *xrpix,
            double *yrpix, double *xinc, double *yinc, double *rot,
            char *type, int *status);
```

### Comparing `fitsio-1.1.9/cfitsio3490/fitsio2.h` & `fitsio-1.2.0/cfitsio-4.2.0/fitsio2.h`

 * *Files 5% similar despite different names*

```diff
@@ -347,14 +347,15 @@
 void ffswap2(short *values, long nvalues);
 void ffswap4(INT32BIT *values, long nvalues);
 void ffswap8(double *values, long nvalues);
 int ffi2c(LONGLONG ival, char *cval, int *status);
 int ffu2c(ULONGLONG ival, char *cval, int *status);
 int ffl2c(int lval, char *cval, int *status);
 int ffs2c(const char *instr, char *outstr, int *status);
+int ffs2c_nopad(const char *instr, char *outstr, int *status);
 int ffr2f(float fval, int decim, char *cval, int *status);
 int ffr2e(float fval, int decim, char *cval, int *status);
 int ffd2f(double dval, int decim, char *cval, int *status);
 int ffd2e(double dval, int decim, char *cval, int *status);
 int ffc2ii(const char *cval, long *ival, int *status);
 int ffc2jj(const char *cval, LONGLONG *ival, int *status);
 int ffc2ujj(const char *cval, ULONGLONG *ival, int *status);
@@ -401,23 +402,54 @@
 int ffpxsz(int datatype);
 
 int ffourl(char *url, char *urltype, char *outfile, char *tmplfile,
             char *compspec, int *status);
 int ffparsecompspec(fitsfile *fptr, char *compspec, int *status);
 int ffoptplt(fitsfile *fptr, const char *tempname, int *status);
 int fits_is_this_a_copy(char *urltype);
+char *fits_find_match_delim(char *, char);
 int fits_store_Fptr(FITSfile *Fptr, int *status);
 int fits_clear_Fptr(FITSfile *Fptr, int *status);
 int fits_already_open(fitsfile **fptr, char *url, 
     char *urltype, char *infile, char *extspec, char *rowfilter,
     char *binspec, char *colspec, int  mode, int noextsyn,
     int  *isopen, int  *status);
 int ffedit_columns(fitsfile **fptr, char *outfile, char *expr, int *status);
 int fits_get_col_minmax(fitsfile *fptr, int colnum, double *datamin, 
                      double *datamax, int *status);
+/* "Extended syntax" versions of histogram binning which permit
+   expressions instead of just columns.  The existing interfaces
+   still work */
+int fits_get_expr_minmax(fitsfile *fptr, char *expr, double *datamin, 
+			 double *datamax, int *datatype, int *status);
+int ffbinse(char *binspec, int *imagetype, int *haxis, 
+	    char colname[4][FLEN_VALUE], double *minin,
+	    double *maxin, double *binsizein,
+	    char minname[4][FLEN_VALUE], char maxname[4][FLEN_VALUE],
+	    char binname[4][FLEN_VALUE], double *weight, char *wtname,
+	    int *recip, char ***exprs, int *status);
+int ffbinre(char **binspec, char *colname, char **exprbeg, char **exprend,
+	    double *minin, double *maxin, double *binsizein, char *minname,
+	    char *maxname, char *binname, int *status);
+int ffhist2e(fitsfile **fptr, char *outfile, int imagetype, int naxis,
+	     char colname[4][FLEN_VALUE], char *colexpr[4], 
+	     double *minin, double *maxin, double *binsizein, 
+	     char minname[4][FLEN_VALUE], char maxname[4][FLEN_VALUE], 
+	     char binname[4][FLEN_VALUE], 
+	     double weightin, char wtcol[FLEN_VALUE], char *wtexpr,           
+	     int recip, char *selectrow, int *status);
+int fits_calc_binningde(fitsfile *, int, char colname[4][FLEN_VALUE],
+	  char *colexpr[4], double *minin, double *maxin, double *binsizein,
+          char minname[4][FLEN_VALUE], char maxname[4][FLEN_VALUE], char binname[4][FLEN_VALUE],			       
+          int *, int *, long *, double *, double *, double *, long *, int *);
+int fits_write_keys_histoe(fitsfile *fptr,  fitsfile *histptr, 
+          int naxis, int *colnum, char colname[4][FLEN_VALUE], char *colexpr[4], int *status);  
+int fits_make_histde(fitsfile *fptr, fitsfile *histptr, int *datatypes, int bitpix,int naxis,
+     long *naxes,  int *colnum,  char *colexpr[4], double *amin,  double *amax, double *binsize,
+     double weight, int wtcolnum, char *wtexpr, int recip, char *selectrow, int *status);
 int ffwritehisto(long totaln, long offset, long firstn, long nvalues,
              int narrays, iteratorCol *imagepars, void *userPointer);
 int ffcalchist(long totalrows, long offset, long firstrow, long nrows,
              int ncols, iteratorCol *colpars, void *userPointer);
 int ffpinit(fitsfile *fptr, int *status);
 int ffainit(fitsfile *fptr, int *status);
 int ffbinit(fitsfile *fptr, int *status);
@@ -983,26 +1015,28 @@
 /*  the following 4 routines are VMS macros used on VAX or Alpha VMS */
 void ieevpd(double *inarray, double *outarray, long *nvals);
 void ieevud(double *inarray, double *outarray, long *nvals);
 void ieevpr(float *inarray, float *outarray, long *nvals);
 void ieevur(float *inarray, float *outarray, long *nvals);
 
 /*  routines related to the lexical parser  */
+typedef struct ParseData_struct ParseData;
 int  ffselect_table(fitsfile **fptr, char *outfile, char *expr,  int *status);
 int  ffiprs( fitsfile *fptr, int compressed, char *expr, int maxdim,
 	     int *datatype, long *nelem, int *naxis, long *naxes,
-	     int *status );
-void ffcprs( void );
+	     ParseData *, int *status );
+void ffcprs( ParseData * );
 int  ffcvtn( int inputType, void *input, char *undef, long ntodo,
 	     int outputType, void *nulval, void *output,
 	     int *anynull, int *status );
-int  parse_data( long totalrows, long offset, long firstrow,
+int  fits_parser_workfn( long totalrows, long offset, long firstrow,
                  long nrows, int nCols, iteratorCol *colData,
                  void *userPtr );
-int  uncompress_hkdata( fitsfile *fptr, long ntimes, 
+int  fits_uncompress_hkdata( ParseData *, 
+			fitsfile *fptr, long ntimes, 
                         double *times, int *status );
 int  ffffrw_work( long totalrows, long offset, long firstrow,
                   long nrows, int nCols, iteratorCol *colData,
                   void *userPtr );
 
 int fits_translate_pixkeyword(char *inrec, char *outrec,char *patterns[][2],
     int npat, int naxis, int *colnum, int *pat_num, int *i,
@@ -1182,14 +1216,15 @@
 int stdin_open(char *filename, int rwmode, int *handle);
 int stdin2mem(int hd);
 int stdin2file(int hd);
 int stdout_close(int handle);
 int mem_compress_openrw(char *filename, int rwmode, int *hdl);
 int mem_compress_open(char *filename, int rwmode, int *hdl);
 int mem_compress_stdin_open(char *filename, int rwmode, int *hdl);
+int mem_zuncompress_and_write(int hdl, void *buffer, long nbytes);
 int mem_iraf_open(char *filename, int rwmode, int *hdl);
 int mem_rawfile_open(char *filename, int rwmode, int *hdl);
 int mem_size(int handle, LONGLONG *filesize);
 int mem_truncate(int handle, LONGLONG filesize);
 int mem_close_free(int handle);
 int mem_close_keep(int handle);
 int mem_close_comp(int handle);
@@ -1289,10 +1324,12 @@
 #include "drvrsmem.h"
 #endif
 
 /* A hack for nonunix machines, which lack strcasecmp and strncasecmp */
 /* these functions are in fitscore.c */
 int fits_strcasecmp (const char *s1, const char *s2       );
 int fits_strncasecmp(const char *s1, const char *s2, size_t n);
+/* "recalloc" which is a reallocator in the style of calloc */
+void *fits_recalloc(void *ptr, size_t old_num, size_t new_num, size_t size);
 
 /* end of the entire "ifndef _FITSIO2_H" block */
 #endif
```

### Comparing `fitsio-1.1.9/cfitsio3490/fpack.c` & `fitsio-1.2.0/cfitsio-4.2.0/fpack.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/fpack.h` & `fitsio-1.2.0/cfitsio-4.2.0/fpack.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/fpackutil.c` & `fitsio-1.2.0/cfitsio-4.2.0/fpackutil.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/funpack.c` & `fitsio-1.2.0/cfitsio-4.2.0/funpack.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcol.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcol.c`

 * *Files 8% similar despite different names*

```diff
@@ -796,16 +796,16 @@
       *status = BAD_DATATYPE;
 
     return(*status);
 }
 /*--------------------------------------------------------------------------*/
 int ffgcv(  fitsfile *fptr,   /* I - FITS file pointer                       */
             int  datatype,    /* I - datatype of the value                   */
-            int  colnum,      /* I - number of column to write (1 = 1st col) */
-            LONGLONG  firstrow,   /* I - first row to write (1 = 1st row)        */
+            int  colnum,      /* I - number of column to read (1 = 1st col) */
+            LONGLONG  firstrow,   /* I - first row to read (1 = 1st row)        */
             LONGLONG  firstelem,  /* I - first vector element to read (1 = 1st)  */
             LONGLONG nelem,       /* I - number of values to read                */
             void *nulval,     /* I - value for undefined pixels              */
             void *array,      /* O - array of values that are returned       */
             int  *anynul,     /* O - set to 1 if any values are null; else 0 */
             int  *status)     /* IO - error status                           */
 /*
@@ -979,14 +979,131 @@
              nulval, (char **) array, cdummy, anynul, status);
     }
     else
       *status = BAD_DATATYPE;
 
     return(*status);
 }
+
+/*--------------------------------------------------------------------------*/
+int ffgcvn( fitsfile *fptr,   /* I - FITS file pointer                       */
+	    int ncols,        /* I - number of columns to read               */
+            int  *datatype,   /* I - datatypes of the values                 */
+            int  *colnum,     /* I - columns numbers to read (1 = 1st col)   */
+            LONGLONG  firstrow,   /* I - first row to read (1 = 1st row)     */
+            LONGLONG nrows,       /* I - number of rows to read              */
+            void **nulval,    /* I - array of pointers to values for undefined pixels */
+            void **array,     /* O - array of pointers to values that are returned    */
+            int  *anynul,     /* O - anynul[i] set to 1 if any values in column i are null; else 0 */
+            int  *status)     /* IO - error status                           */
+/*
+  Read arrays of values from NCOLS table columns. This is an optimization
+  to read all columns in one pass through the table.  The datatypes of the
+  input arrays are defined by the 3rd argument.  Data conversion
+  and scaling will be performed if necessary (e.g, if the datatype of
+  the FITS array is not the same as the array being read).
+  Undefined elements for column i will be set equal to *(nulval[i]), unless nulval[i]=0
+  in which case no checking for undefined values will be performed.
+  anynul[i] is returned with a value of true if any pixels in column i are undefined.
+*/
+{
+    LONGLONG ntotrows, ndone, nread, currow;
+    long nrowbuf;
+    LONGLONG *repeats = 0;
+    size_t sizes[255] = {0};
+    int icol;
+
+    sizes[TBYTE] = sizes[TSBYTE] = sizes[TLOGICAL] = sizeof(char);
+    sizes[TUSHORT] = sizes[TSHORT] = sizeof(short int);
+    sizes[TINT] = sizes[TUINT] = sizeof(int);
+    sizes[TLONG] = sizes[TULONG] = sizeof(long int);
+    sizes[TLONGLONG] = sizes[TULONGLONG] = sizeof(LONGLONG);
+    sizes[TFLOAT] = sizeof(float);
+    sizes[TDOUBLE] = sizeof(double);
+    sizes[TDBLCOMPLEX] = 2*sizeof(double);
+
+    if (*status > 0)
+        return(*status);
+
+    if (ncols <= 0) return (*status=0);
+
+    repeats = malloc(sizeof(LONGLONG)*ncols);
+    if (repeats == 0) return (*status=MEMORY_ALLOCATION);
+
+    fits_get_num_rowsll(fptr, &ntotrows, status);
+    fits_get_rowsize(fptr, &nrowbuf, status);
+
+    /* Retrieve column repeats */
+    for (icol = 0; (icol < ncols) && (icol < 1000); icol++) {
+      int typecode;
+      LONGLONG repeat, width;
+      fits_get_coltypell(fptr, colnum[icol], &typecode, 
+			 &repeat, &width, status);
+      repeats[icol] = repeat;
+
+      if (datatype[icol] == TBIT || datatype[icol] == TSTRING ||
+	  sizes[datatype[icol]] == 0) {
+	ffpmsg("Cannot read from TBIT or TSTRING datatypes (ffgcvn)");
+	*status = BAD_DATATYPE;
+      }
+      if (typecode < 0) {
+	ffpmsg("Cannot read from variable-length data (ffgcvn)");
+	*status = BAD_DIMEN;
+      }
+
+      if (*status) break;
+    }
+    if (*status) {
+      free(repeats);
+      return *status;
+    }
+
+    /* Optimize for 1 column */
+    if (ncols == 1) {
+      fits_read_col(fptr, datatype[0], colnum[0], firstrow, 1,
+		    nrows*repeats[0], nulval[0], 
+		    array[0], anynul ? &(anynul[0]) : 0, status);
+      free(repeats);
+      return *status;
+    }
+
+    /* Scan through file, in chunks of nrowbuf */
+    currow = firstrow;
+    ndone = 0;
+    while (ndone < nrows) {
+      int icol;
+      nread = (nrows-ndone);  /* Number of rows to read (not elements) */
+      if (nread > nrowbuf) nread = nrowbuf;
+
+      for (icol=0; icol<ncols; icol++) {
+	LONGLONG nelem1 = (nread*repeats[icol]);
+	char *array1 = (char *) array[icol] + repeats[icol]*ndone*sizes[datatype[icol]];
+
+	fits_read_col(fptr, datatype[icol], colnum[icol], currow, 1, 
+		      nelem1, nulval[icol], array1, 
+		      (anynul ? &(anynul[icol]) : 0), status);
+	if (*status) {
+	  char errmsg[100];
+	  sprintf(errmsg, 
+		  "Failed to read column %d data rows %lld-%lld (ffgcvn)",
+		  colnum[icol], currow, currow+nread-1);
+	  ffpmsg(errmsg);
+	  break;
+	}
+      }
+
+      if (*status) break;
+      currow += nread;
+      ndone += nread;
+    }
+
+    free(repeats);
+    return *status;
+}
+
 /*--------------------------------------------------------------------------*/
 int ffgcf(  fitsfile *fptr,   /* I - FITS file pointer                       */
             int  datatype,    /* I - datatype of the value                   */
             int  colnum,      /* I - number of column to write (1 = 1st col) */
             LONGLONG  firstrow,   /* I - first row to write (1 = 1st row)        */
             LONGLONG  firstelem,  /* I - first vector element to read (1 = 1st)  */
             LONGLONG nelem,       /* I - number of values to read                */
```

### Comparing `fitsio-1.1.9/cfitsio3490/getcolb.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcolb.c`

 * *Files 1% similar despite different names*

```diff
@@ -658,15 +658,15 @@
   and will be scaled by the FITS TSCALn and TZEROn values if necessary.
 */
 {
     double scale, zero, power = 1., dtemp;
     int tcode, maxelem2, hdutype, xcode, decimals;
     long twidth, incre, ntodo;
     long ii, xwidth;
-    int convert, nulcheck, readcheck = 0;
+    int convert, nulcheck, readcheck = 16; /* see note below on readcheck */
     LONGLONG repeat, startpos, elemnum, readptr, tnull;
     LONGLONG rowlen, rownum, remain, next, rowincre, maxelem;
     char tform[20];
     char message[FLEN_ERRMSG];
     char snull[20];   /*  the FITS null value if reading from ASCII table  */
 
     double cbuff[DBUFFSIZE / sizeof(double)]; /* align cbuff on word boundary */
@@ -688,15 +688,25 @@
     if (nultyp == 2)      
        memset(nularray, 0, (size_t) nelem);   /* initialize nullarray */
 
     /*---------------------------------------------------*/
     /*  Check input and get parameters about the column: */
     /*---------------------------------------------------*/
     if (elemincre < 0)
-        readcheck = -1;  /* don't do range checking in this case */
+        readcheck -= 1;  /* don't do range checking in this case */
+
+    /* IMPORTANT NOTE: that the special case of using this subroutine
+       to read bytes from a character column are handled internally
+       by the call to ffgcprll() below.  It will adjust the effective
+       *tcode, repeats, etc, to appear as a TBYTE column. */
+
+    /* Note that readcheck = 16 is equivalent to readcheck = 0 
+       and readcheck = 15 is equivalent to readcheck = -1, 
+       but either of those settings allow TSTRINGS to be 
+       treated as TBYTE vectors, but with full error checking */
 
     ffgcprll( fptr, colnum, firstrow, firstelem, nelem, readcheck, &scale, &zero,
          tform, &twidth, &tcode, &maxelem2, &startpos, &elemnum, &incre,
          &repeat, &rowlen, &hdutype, &tnull, snull, status);
     maxelem = maxelem2;
 
     /* special case */
@@ -705,38 +715,14 @@
         u.ucharval = nulval;
         ffgcll(fptr, colnum, firstrow, firstelem, nelem, nultyp,
                u.charval, (char *) array, nularray, anynul, status);
 
         return(*status);
     }
 
-    if (strchr(tform,'A') != NULL) 
-    {
-        if (*status == BAD_ELEM_NUM)
-        {
-            /* ignore this error message */
-            *status = 0;
-            ffcmsg();   /* clear error stack */
-        }
-
-        /*  interpret a 'A' ASCII column as a 'B' byte column ('8A' == '8B') */
-        /*  This is an undocumented 'feature' in CFITSIO */
-
-        /*  we have to reset some of the values returned by ffgcpr */
-        
-        tcode = TBYTE;
-        incre = 1;         /* each element is 1 byte wide */
-        repeat = twidth;   /* total no. of chars in the col */
-        twidth = 1;        /* width of each element */
-        scale = 1.0;       /* no scaling */
-        zero  = 0.0;
-        tnull = NULL_UNDEFINED;  /* don't test for nulls */
-        maxelem = DBUFFSIZE;
-    }
-
     if (*status > 0)
         return(*status);
         
     incre *= elemincre;   /* multiply incre to just get every nth pixel */
 
     if (tcode == TSTRING && hdutype == ASCII_TBL) /* setup for ASCII tables */
     {
```

### Comparing `fitsio-1.1.9/cfitsio3490/getcold.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcold.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcole.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcole.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcoli.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcoli.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcolj.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcolj.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcolk.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcolk.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcoll.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcoll.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcols.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcols.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcolsb.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcolsb.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcolui.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcolui.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcoluj.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcoluj.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getcoluk.c` & `fitsio-1.2.0/cfitsio-4.2.0/getcoluk.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/getkey.c` & `fitsio-1.2.0/cfitsio-4.2.0/getkey.c`

 * *Files 0% similar despite different names*

```diff
@@ -282,14 +282,15 @@
            int  *status)       /* IO - error status            */
 /*
   Read (get) the keyword value and comment from the FITS header.
   Reads a keyword value with the datatype specified by the 2nd argument.
 */
 {
     LONGLONG longval;
+    ULONGLONG ulongval;
     double doubleval;
 
     if (*status > 0)           /* inherit input status value if > 0 */
         return(*status);
 
     if (datatype == TSTRING)
     {
@@ -315,15 +316,15 @@
                 *(signed char *) value = (signed char) longval;
         }
     }
     else if (datatype == TUSHORT)
     {
         if (ffgkyjj(fptr, keyname, &longval, comm, status) <= 0)
         {
-            if (longval > (long) USHRT_MAX || longval < 0)
+            if (longval > (unsigned short) USHRT_MAX || longval < 0)
                 *status = NUM_OVERFLOW;
             else
                 *(unsigned short *) value = (unsigned short) longval;
         }
     }
     else if (datatype == TSHORT)
     {
@@ -335,15 +336,15 @@
                 *(short *) value = (short) longval;
         }
     }
     else if (datatype == TUINT)
     {
         if (ffgkyjj(fptr, keyname, &longval, comm, status) <= 0)
         {
-            if (longval > (long) UINT_MAX || longval < 0)
+            if (longval > (unsigned int) UINT_MAX || longval < 0)
                 *status = NUM_OVERFLOW;
             else
                 *(unsigned int *) value = longval;
         }
     }
     else if (datatype == TINT)
     {
@@ -357,20 +358,20 @@
     }
     else if (datatype == TLOGICAL)
     {
         ffgkyl(fptr, keyname, (int *) value, comm, status);
     }
     else if (datatype == TULONG)
     {
-        if (ffgkyjj(fptr, keyname, &longval, comm, status) <= 0)
+        if (ffgkyujj(fptr, keyname, &ulongval, comm, status) <= 0)
         {
-            if (longval > ULONG_MAX || longval < 0)
+            if (ulongval > ULONG_MAX)
                 *status = NUM_OVERFLOW;
             else
-                 *(unsigned long *) value = longval;
+                 *(unsigned long *) value = ulongval;
         }
     }
     else if (datatype == TLONG)
     {
         if (ffgkyjj(fptr, keyname, &longval, comm, status) <= 0)
         {
             if (longval > LONG_MAX || longval < LONG_MIN)
```

### Comparing `fitsio-1.1.9/cfitsio3490/group.c` & `fitsio-1.2.0/cfitsio-4.2.0/group.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/group.h` & `fitsio-1.2.0/cfitsio-4.2.0/group.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/grparser.c` & `fitsio-1.2.0/cfitsio-4.2.0/grparser.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/grparser.h` & `fitsio-1.2.0/cfitsio-4.2.0/grparser.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/histo.c` & `fitsio-1.2.0/cfitsio-4.2.0/histo.c`

 * *Files 17% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 /*   Globally defined histogram parameters */
 #include <string.h>
 #include <ctype.h>
 #include <math.h>
 #include <stdlib.h>
 #include "fitsio2.h"
+#include "eval_defs.h"
 
 typedef struct {  /*  Structure holding all the histogramming information   */
    union {        /*  the iterator work functions (ffwritehist, ffcalchist) */
       char   *b;  /*  need to do their job... passed via *userPointer.      */
       short  *i;
       int    *j;
       float  *r;
@@ -17,53 +18,92 @@
    fitsfile *tblptr;
 
    int   haxis, hcolnum[4], himagetype;
    long  haxis1, haxis2, haxis3, haxis4;
    double amin1, amin2, amin3, amin4;
    double maxbin1, maxbin2, maxbin3, maxbin4;
    double binsize1, binsize2, binsize3, binsize4;
+   long incr[5];
    int   wtrecip, wtcolnum;
+   char *wtexpr;
    double weight;
    char  *rowselector;
-
+   char *rowselector_cur;
+   long repeat;
+   int startCols[5];
+   int numIterCols;
+   iteratorCol *iterCols;
+   ParseData *parsers;
+   parseInfo *infos;
 } histType;
 
 /*--------------------------------------------------------------------------*/
-int ffbins(char *binspec,   /* I - binning specification */
+int ffbinse(char *binspec,   /* I - binning specification */
                    int *imagetype,      /* O - image type, TINT or TSHORT */
                    int *histaxis,       /* O - no. of axes in the histogram */
                    char colname[4][FLEN_VALUE],  /* column name for axis */
                    double *minin,        /* minimum value for each axis */
                    double *maxin,        /* maximum value for each axis */
                    double *binsizein,    /* size of bins on each axis */
                    char minname[4][FLEN_VALUE],  /* keyword name for min */
                    char maxname[4][FLEN_VALUE],  /* keyword name for max */
                    char binname[4][FLEN_VALUE],  /* keyword name for binsize */
                    double *wt,          /* weighting factor          */
                    char *wtname,        /* keyword or column name for weight */
                    int *recip,          /* the reciprocal of the weight? */
+	           char ***exprs,       /* returned with expressions (or 0) */
                    int *status)
 {
 /*
-   Parse the input binning specification string, returning the binning
-   parameters.  Supports up to 4 dimensions.  The binspec string has
-   one of these forms:
+   Parse the extended input binning specification string, returning
+   the binning parameters.  Supports up to 4 dimensions.  The binspec
+   string has one of these forms:
 
    bin binsize                  - 2D histogram with binsize on each axis
    bin xcol                     - 1D histogram on column xcol
    bin (xcol, ycol) = binsize   - 2D histogram with binsize on each axis
    bin x=min:max:size, y=min:max:size, z..., t... 
    bin x=:max, y=::size
    bin x=size, y=min::size
+   bin x(expr), y(expr)=min:max:size, ...
+
+   most other reasonable combinations are supported. The (expr) is an 
+   optional expression that will be calculated on the fly instead of
+   a table column name.  The name is still used for the output pixel
+   array metadata.
+
+   If expr == 0, then expressions are forbidden.  The caller does not
+   expect expressions.  
+
+   If exprs is non-zero, then upon return an array of expressions is
+   passed back to the caller.  Storage may be allocated by this routine,
+   If *exprs is non-zero upon return, the caller is responsible to
+   free(*exprs).  Upon return, the contains of exprs is,
+       (*exprs)[0] = expression for column 1 (or 0 if none)
+       (*exprs)[1] = expression for column 2 (or 0 if none)
+       (*exprs)[2] = expression for column 3 (or 0 if none)
+       (*exprs)[3] = expression for column 4 (or 0 if none)
+       (*exprs)[4] = expression for weighting (or 0 if none)
+
+   If the user specifies a column name and not an expression for bin
+   axis i, then the corresponding (*exprs)[i] will be a null pointer.
+
+   To be recognized as an expression, the weighting expression must be
+   enclosed in parentheses.
+
+   Expressions are never allowed using the bin (xcol,ycol) notation.
 
-   most other reasonable combinations are supported.        
 */
     int ii, slen, defaulttype;
     char *ptr, tmpname[FLEN_VALUE], *file_expr = NULL;
     double  dummy;
+    char *exprbeg[5] = {0}, *exprend[5] = {0};
+    int has_exprs = 0;
+
+    if (exprs) (*exprs) = 0; /* initialized output */
 
     if (*status > 0)
          return(*status);
 
     /* set the default values */
     *histaxis = 2;
     *imagetype = TINT;
@@ -193,17 +233,18 @@
         }
 
         ptr++;  /* skip over the equals sign */
         while (*ptr == ' ')  /* skip over blanks */
             ptr++;
 
         /* get the single range specification for all the columns */
+	/* Note that the extended syntax is not allowed here */
         ffbinr(&ptr, tmpname, minin,
-                                     maxin, binsizein, minname[0],
-                                     maxname[0], binname[0], status);
+	       maxin, binsizein, minname[0],
+	       maxname[0], binname[0], status);
         if (*status > 0)
         {
             ffpmsg("illegal binning specification in URL:");
             ffpmsg(binspec);
 	    if( file_expr ) free( file_expr );
             return(*status);
         }
@@ -238,18 +279,21 @@
     /* if we've reached this point, then the binning specification */
     /* must be of the form: XCOL = min:max:binsize, YCOL = ...     */
     /* where the column name followed by '=' are optional.         */
     /* If the column name is not specified, then use the default name */
 
     for (ii = 0; ii < 4; ii++) /* allow up to 4 histogram dimensions */
     {
-        ffbinr(&ptr, colname[ii], &minin[ii],
-                                     &maxin[ii], &binsizein[ii], minname[ii],
-                                     maxname[ii], binname[ii], status);
-
+        exprbeg[ii] = exprend[ii] = 0;
+        ffbinre(&ptr, colname[ii], &(exprbeg[ii]), &(exprend[ii]),
+		&minin[ii], &maxin[ii], &binsizein[ii], minname[ii],
+		maxname[ii], binname[ii], status);
+	/* Check for expressions */
+	if (exprbeg[ii]) has_exprs = 1;
+	
         if (*status > 0)
         {
             ffpmsg("illegal syntax in binning range specification in URL:");
             ffpmsg(binspec);
 	    if( file_expr ) free( file_expr );
             return(*status);
         }
@@ -306,80 +350,155 @@
     if (*ptr == ';')  /* looks like a weighting factor is given */
     {
         ptr++;
        
         while (*ptr == ' ')  /* skip over blanks */
             ptr++;
 
-        recip = 0;
+        *recip = 0;
         if (*ptr == '/')
         {
             *recip = 1;  /* the reciprocal of the weight is entered */
             ptr++;
 
             while (*ptr == ' ')  /* skip over blanks */
                 ptr++;
         }
 
         /* parse the weight as though it were a binrange. */
         /* either a column name or a numerical value will be returned */
 
-        ffbinr(&ptr, wtname, &dummy, &dummy, wt, tmpname,
-                                     tmpname, tmpname, status);
+        exprbeg[4] = exprend[4] = 0;
+        ffbinre(&ptr, wtname, &(exprbeg[4]), &(exprend[4]),
+		&dummy, &dummy, wt, tmpname,
+		tmpname, tmpname, status);
+	if (exprbeg[4]) has_exprs = 1;
 
         if (*status > 0)
         {
             ffpmsg("illegal binning weight specification in URL:");
             ffpmsg(binspec);
 	    if( file_expr ) free( file_expr );
             return(*status);
         }
 
         /* creat a float datatype histogram by default, if weight */
         /* factor is not = 1.0  */
 
-        if ( (defaulttype && *wt != 1.0) || (defaulttype && *wtname) )
-            *imagetype = TFLOAT;
+        if ( (defaulttype && *wt != 1.0) || 
+	     (defaulttype && *wtname) ||
+	     (defaulttype && exprbeg[4])) {
+	  *imagetype = TFLOAT;
+	}
     }
 
     while (*ptr == ' ')  /* skip over blanks */
          ptr++;
 
     if (*ptr != '\0')  /* should have reached the end of string */
     {
         ffpmsg("illegal syntax after binning weight specification in URL:");
         ffpmsg(binspec);
         *status = URL_PARSE_ERROR;
     }
 
     if( file_expr ) free( file_expr );
+
+    /* If we found expressions, this is where we accumulate them into 
+       something to be returned to the caller.  The start and end of
+       each expression will be found in exprbeg[] and exprend[], with
+       the 5th entry being the weight expression if any */
+    if (has_exprs) {
+      size_t nchars = 0;
+      char *ptr;
+      for (ii = 0; ii <= 4; ii++) {
+	nchars += (exprend[ii] - exprbeg[ii]) + 1; /* null terminator */
+      }
+      /* Allocate storage for 5 pointers plus the characters.  Caller
+         is responsible to free(*exprs) which will free both the 5-array
+	 and the character string data. */
+      ptr = malloc( sizeof(char *) * 5 + nchars * sizeof(char) );
+      if (!ptr) {
+	ffpmsg("ffbinse: memory allocation failure");
+        return(*status = MEMORY_ALLOCATION);
+      }
+      
+      (*exprs) = (char **) ptr;     /* Pointer array portion */
+      ptr = (char *) (&((*exprs)[5])); /* String portion starts after the pointer array */
+      for (ii = 0; ii <= 4; ii++) {
+	(*exprs)[ii] = ptr;
+	nchars = (exprend[ii]-exprbeg[ii]);
+	strncpy(ptr, exprbeg[ii], nchars);
+	ptr += nchars;
+	ptr[0] = 0; /* Ensure null terminator */
+	ptr ++; /* Advance to next string position */
+      }
+    }      
+      
     return(*status);
 }
+
 /*--------------------------------------------------------------------------*/
-int ffbinr(char **ptr, 
-                   char *colname, 
-                   double *minin,
-                   double *maxin, 
-                   double *binsizein,
-                   char *minname,
-                   char *maxname,
-                   char *binname,
+int ffbins(char *binspec,   /* I - binning specification */
+                   int *imagetype,      /* O - image type, TINT or TSHORT */
+                   int *histaxis,       /* O - no. of axes in the histogram */
+                   char colname[4][FLEN_VALUE],  /* column name for axis */
+                   double *minin,        /* minimum value for each axis */
+                   double *maxin,        /* maximum value for each axis */
+                   double *binsizein,    /* size of bins on each axis */
+                   char minname[4][FLEN_VALUE],  /* keyword name for min */
+                   char maxname[4][FLEN_VALUE],  /* keyword name for max */
+                   char binname[4][FLEN_VALUE],  /* keyword name for binsize */
+                   double *wt,          /* weighting factor          */
+                   char *wtname,        /* keyword or column name for weight */
+                   int *recip,          /* the reciprocal of the weight? */
                    int *status)
+{
+  /* Parse non-extended expression, but otherwise the same as ffbinse() */
+
+  return ffbinse(binspec, 
+		 imagetype, histaxis, colname,
+		 minin, maxin, binsizein, 
+		 minname, maxname, binname,
+		 wt, wtname, recip,
+		 0, /* No exprs pointer */
+		 status);
+		 
+}
+
+
+/*--------------------------------------------------------------------------*/
+int ffbinre(char **ptr, 
+	    char *colname, 
+	    char **exprbeg, char **exprend,
+	    double *minin,
+	    double *maxin, 
+	    double *binsizein,
+	    char *minname,
+	    char *maxname,
+	    char *binname,
+	    int *status)
 /*
    Parse the input binning range specification string, returning 
    the column name, histogram min and max values, and bin size.
+
+   This is the "extended" binning syntax that allows for an expression
+   of the form XCOL(expr).  The expression must be enclosed in parentheses.
+
+   The start and end of the expression are returned in *exprbeg and *exprend.
+   If exprbeg and exprend are null pointers then the expression is forbidden.
 */
 {
     int slen, isanumber=0;
     char *token=0;
 
     if (*status > 0)
         return(*status);
 
-    slen = fits_get_token2(ptr, " ,=:;", &token, &isanumber, status); /* get 1st token */
+    slen = fits_get_token2(ptr, " ,=:;(", &token, &isanumber, status); /* get 1st token */
 
     if ((*status) || (slen == 0 && (**ptr == '\0' || **ptr == ',' || **ptr == ';')) )
         return(*status);   /* a null range string */
         
     if (!isanumber && **ptr != ':')
     {
         /* this looks like the column name */
@@ -404,14 +523,26 @@
                strcpy(colname, token);
            free(token);
            token=0;
         }
         while (**ptr == ' ')  /* skip over blanks */
              (*ptr)++;
 
+	/* An optional expression of the form XCOL(expr) is allowed here, but only 
+	   if exprbeg and exprend are non-null */
+	if (**ptr == '(' && exprbeg && exprend) {
+	  *exprbeg = *ptr;
+	  if ((*exprend = fits_find_match_delim(*ptr+1,')')) == 0) { /* find ')' */
+              ffpmsg("bin expression syntax error (ffbinr)");
+              return(*status=PARSE_SYNTAX_ERR);
+	  }
+	  *ptr = *exprend; /* Advance pointer past delimeter */
+	}
+        while (**ptr == ' ')  (*ptr)++; /* skip over more possible blanks */
+	
         if (**ptr != '=')
             return(*status);  /* reached the end */
             
         (*ptr)++;   /* skip over the = sign */
 
         while (**ptr == ' ')  /* skip over blanks */
              (*ptr)++;
@@ -519,50 +650,83 @@
         else
             *binsizein = strtod(token, NULL);
         free(token);
     }
 
     return(*status);
 }
+
 /*--------------------------------------------------------------------------*/
-int ffhist2(fitsfile **fptr,  /* IO - pointer to table with X and Y cols;    */
+int ffbinr(char **ptr, 
+                   char *colname, 
+                   double *minin,
+                   double *maxin, 
+                   double *binsizein,
+                   char *minname,
+                   char *maxname,
+                   char *binname,
+                   int *status)
+/*
+   Parse the input binning range specification string, returning 
+   the column name, histogram min and max values, and bin size.
+
+   This is the non-extended version of the parser which disallows
+   binning expressions.  Only column names are allowed.
+*/
+{
+  return ffbinre(ptr, colname, 0, 0, 
+		 minin, maxin, binsizein,
+		 minname, maxname, binname,
+		 status);
+}
+
+/*--------------------------------------------------------------------------*/
+int ffhist2e(fitsfile **fptr,  /* IO - pointer to table with X and Y cols;    */
                              /*     on output, points to histogram image    */
            char *outfile,    /* I - name for the output histogram file      */
            int imagetype,    /* I - datatype for image: TINT, TSHORT, etc   */
            int naxis,        /* I - number of axes in the histogram image   */
            char colname[4][FLEN_VALUE],   /* I - column names               */
+	   char *colexpr[4], /* I - optionally, expression intead of colum  */
            double *minin,     /* I - minimum histogram value, for each axis */
            double *maxin,     /* I - maximum histogram value, for each axis */
            double *binsizein, /* I - bin size along each axis               */
            char minname[4][FLEN_VALUE], /* I - optional keywords for min    */
            char maxname[4][FLEN_VALUE], /* I - optional keywords for max    */
            char binname[4][FLEN_VALUE], /* I - optional keywords for binsize */
            double weightin,        /* I - binning weighting factor          */
            char wtcol[FLEN_VALUE], /* I - optional keyword or col for weight*/
+	   char *wtexpr,           /* I - optionally, weight expression     */
            int recip,              /* I - use reciprocal of the weight?     */
            char *selectrow,        /* I - optional array (length = no. of   */
                              /* rows in the table).  If the element is true */
                              /* then the corresponding row of the table will*/
                              /* be included in the histogram, otherwise the */
                              /* row will be skipped.  Ingnored if *selectrow*/
                              /* is equal to NULL.                           */
            int *status)
 {
     fitsfile *histptr;
     int   bitpix, colnum[4], wtcolnum;
     long haxes[4];
     double amin[4], amax[4], binsize[4],  weight;
+    int numIterCols = 0;
+    int datatypes[4], wtdatatype = 0;
+    long *repeat, wtrepeat = 0;
+    char errmsg[FLEN_ERRMSG];
+    long vectorRepeat;
 
     if (*status > 0)
         return(*status);
 
     if (naxis > 4)
     {
         ffpmsg("histogram has more than 4 dimensions");
-        return(*status = BAD_DIMEN);
+        *status = BAD_DIMEN;
+	goto cleanup;
     }
 
     /* reset position to the correct HDU if necessary */
     if ((*fptr)->HDUposition != ((*fptr)->Fptr)->curhdu)
         ffmahd(*fptr, ((*fptr)->HDUposition) + 1, NULL, status);
 
     if (imagetype == TBYTE)
@@ -571,104 +735,197 @@
         bitpix = SHORT_IMG;
     else if (imagetype == TINT)
         bitpix = LONG_IMG;
     else if (imagetype == TFLOAT)
         bitpix = FLOAT_IMG;
     else if (imagetype == TDOUBLE)
         bitpix = DOUBLE_IMG;
-    else
-        return(*status = BAD_DATATYPE);
-
+    else {
+        *status = BAD_DATATYPE;
+      	goto cleanup;
+    }
     
     /*    Calculate the binning parameters:    */
     /*   columm numbers, axes length, min values,  max values, and binsizes.  */
 
-    if (fits_calc_binningd(
-      *fptr, naxis, colname, minin, maxin, binsizein, minname, maxname, binname,
-      colnum,  haxes, amin, amax, binsize, status) > 0)
+    if (fits_calc_binningde(
+      *fptr, naxis, colname, colexpr, 
+      minin, maxin, binsizein, minname, maxname, binname,
+      colnum, datatypes, haxes, amin, amax, binsize, 
+      &vectorRepeat, status) > 0)
     {
         ffpmsg("failed to determine binning parameters");
-        return(*status);
+      	goto cleanup;
     }
  
     /* get the histogramming weighting factor, if any */
     if (*wtcol)
     {
         /* first, look for a keyword with the weight value */
-        if (ffgky(*fptr, TDOUBLE, wtcol, &weight, NULL, status) )
+        if (ffgky(*fptr, TDOUBLE, wtcol, &weight, NULL, status) == 0)
+	{
+	  /* Data type if keyword was found */
+	  wtdatatype = TDOUBLE;
+	  wtrepeat   = 1;
+	}
+	else
         {
             /* not a keyword, so look for column with this name */
             *status = 0;
 
             /* get the column number in the table */
             if (ffgcno(*fptr, CASEINSEN, wtcol, &wtcolnum, status) > 0)
             {
                ffpmsg(
                "keyword or column for histogram weights doesn't exist: ");
                ffpmsg(wtcol);
-               return(*status);
+	       goto cleanup;
             }
 
+	    /* get the datatype of the column */
+	    fits_get_eqcoltype(*fptr, wtcolnum, &wtdatatype,
+			       &wtrepeat, NULL, status);
+
             weight = DOUBLENULLVALUE;
-        }
+        } 
+    }
+    else if (wtexpr && wtexpr[0])  /* A weighting expression - always TDOUBLE */
+    {     
+      /* Initialize the parser so that we can determine the datatype
+	 of the returned type as well as the vector dimensions.  The
+	 parsers is kept allocated so we can assemble an iterator that
+	 uses it below.
+      */
+      int naxis1;
+      long int nelem, naxes[MAXDIMS];
+      ParseData lParse;
+
+      ffiprs( *fptr, 0, wtexpr, MAXDIMS, &wtdatatype, &nelem, &naxis1,
+	      naxes, &lParse, status );
+      ffcprs( &lParse );
+      if (nelem < 0) nelem = 1; /* If it's a constant expression */
+
+      weight = DOUBLENULLVALUE;
+      wtrepeat = nelem;
+      wtdatatype = wtdatatype;
+
     }
     else
+    {
         weight = (double) weightin;
+	wtrepeat = vectorRepeat;
+	wtdatatype = TDOUBLE;
+    }
+
+    /* Make sure weighting column is not an un-binnable data type */
+    if (wtdatatype < 0 || wtdatatype == TSTRING || wtdatatype == TBIT || 
+	wtdatatype == TLOGICAL) {
+      ffpmsg("Invalid datatype for bin weighting factor");
+      *status = BAD_DATATYPE;
+      goto cleanup;
+    }
+
+    /* And dimensions of weighting must agree with input column data */
+    if (wtrepeat != vectorRepeat) {
+      ffpmsg("Vector dimensions of weighting do not agree with binning columns");
+      *status = BAD_DIMEN;
+      goto cleanup;
+    }      
 
     if (weight <= 0. && weight != DOUBLENULLVALUE)
     {
         ffpmsg("Illegal histogramming weighting factor <= 0.");
-        return(*status = URL_PARSE_ERROR);
+        *status = URL_PARSE_ERROR;
+	goto cleanup;
     }
 
-    if (recip && weight != DOUBLENULLVALUE)
+    if (recip && weight != DOUBLENULLVALUE) {
        /* take reciprocal of weight */
        weight = (double) (1.0 / weight);
+    }
+
 
     /* size of histogram is now known, so create temp output file */
     if (fits_create_file(&histptr, outfile, status) > 0)
     {
         ffpmsg("failed to create temp output file for histogram");
-        return(*status);
+	goto cleanup;
     }
 
     /* create output FITS image HDU */
     if (ffcrim(histptr, bitpix, naxis, haxes, status) > 0)
     {
         ffpmsg("failed to create output histogram FITS image");
-        return(*status);
+	goto cleanup;
     }
 
     /* copy header keywords, converting pixel list WCS keywords to image WCS form */
     if (fits_copy_pixlist2image(*fptr, histptr, 9, naxis, colnum, status) > 0)
     {
         ffpmsg("failed to copy pixel list keywords to new histogram header");
-        return(*status);
+	goto cleanup;
     }
 
     /* if the table columns have no WCS keywords, then write default keywords */
-    fits_write_keys_histo(*fptr, histptr, naxis, colnum, status);
+    fits_write_keys_histoe(*fptr, histptr, naxis, colnum, colname, colexpr, status);
     
     /* update the WCS keywords for the ref. pixel location, and pixel size */
     fits_rebin_wcsd(histptr, naxis, amin, binsize,  status);      
     
     /* now compute the output image by binning the column values */
-    if (fits_make_histd(*fptr, histptr, bitpix, naxis, haxes, colnum, amin, amax,
-        binsize, weight, wtcolnum, recip, selectrow, status) > 0)
+    if (fits_make_histde(*fptr, histptr, datatypes, bitpix, naxis, haxes, 
+			 colnum, colexpr, amin, amax, binsize,
+			 weight, wtcolnum, wtexpr, recip, 
+			 selectrow, status) > 0)
     {
         ffpmsg("failed to calculate new histogram values");
-        return(*status);
+	goto cleanup;
     }
               
     /* finally, close the original file and return ptr to the new image */
     ffclos(*fptr, status);
     *fptr = histptr;
 
+ cleanup:
     return(*status);
 }
+
+/*--------------------------------------------------------------------------*/
+int ffhist2(fitsfile **fptr,  /* IO - pointer to table with X and Y cols;    */
+                             /*     on output, points to histogram image    */
+           char *outfile,    /* I - name for the output histogram file      */
+           int imagetype,    /* I - datatype for image: TINT, TSHORT, etc   */
+           int naxis,        /* I - number of axes in the histogram image   */
+           char colname[4][FLEN_VALUE],   /* I - column names               */
+           double *minin,     /* I - minimum histogram value, for each axis */
+           double *maxin,     /* I - maximum histogram value, for each axis */
+           double *binsizein, /* I - bin size along each axis               */
+           char minname[4][FLEN_VALUE], /* I - optional keywords for min    */
+           char maxname[4][FLEN_VALUE], /* I - optional keywords for max    */
+           char binname[4][FLEN_VALUE], /* I - optional keywords for binsize */
+           double weightin,        /* I - binning weighting factor          */
+           char wtcol[FLEN_VALUE], /* I - optional keyword or col for weight*/
+           int recip,              /* I - use reciprocal of the weight?     */
+           char *selectrow,        /* I - optional array (length = no. of   */
+                             /* rows in the table).  If the element is true */
+                             /* then the corresponding row of the table will*/
+                             /* be included in the histogram, otherwise the */
+                             /* row will be skipped.  Ingnored if *selectrow*/
+                             /* is equal to NULL.                           */
+           int *status)
+{
+  /* Non-extended-syntax version of ffhist2e() */
+
+  return ffhist2e(fptr, outfile, imagetype, naxis, colname, 0,
+		  minin, maxin, binsizein, 
+		  minname, maxname, binname,
+		  weightin, wtcol, 0, recip, selectrow, status);
+}
+
+
 /*--------------------------------------------------------------------------*/
 
 /* ffhist3: same as ffhist2, but does not close the original file */
 /*  and/or replace the original file pointer */
 fitsfile *ffhist3(fitsfile *fptr, /* I - ptr to table with X and Y cols*/
            char *outfile,    /* I - name for the output histogram file      */
            int imagetype,    /* I - datatype for image: TINT, TSHORT, etc   */
@@ -1501,51 +1758,61 @@
       binsize[i] = (float) binsized[i];
     }
   }
 
   return (*status);
 }
 
-/* Double precision version */  
-int fits_calc_binningd(
+/* Double precision version, with extended syntax */  
+int fits_calc_binningde(
       fitsfile *fptr,  /* IO - pointer to table to be binned      ;       */
       int naxis,       /* I - number of axes/columns in the binned image  */
       char colname[4][FLEN_VALUE],   /* I - optional column names         */
+      char *colexpr[4],  /* I - optional column expression instead of name*/
       double *minin,     /* I - optional lower bound value for each axis  */
       double *maxin,     /* I - optional upper bound value, for each axis */
       double *binsizein, /* I - optional bin size along each axis         */
       char minname[4][FLEN_VALUE], /* I - optional keywords for min       */
       char maxname[4][FLEN_VALUE], /* I - optional keywords for max       */
       char binname[4][FLEN_VALUE], /* I - optional keywords for binsize   */
 
     /* The returned parameters for each axis of the n-dimensional histogram are */
 
       int *colnum,     /* O - column numbers, to be binned */
+      int *datatypes,  /* O - datatypes of each output column */
       long *haxes,     /* O - number of bins in each histogram axis */
       double *amin,     /* O - lower bound of the histogram axes */
       double *amax,     /* O - upper bound of the histogram axes */
       double *binsize,  /* O - width of histogram bins/pixels on each axis */
+      long *repeat,     /* O - vector repeat of input columns */
       int *status)
 /*_
     Calculate the actual binning parameters, based on various user input
     options.
+
+    Note: caller is responsible to free parsers[*] upon return using ffcprs()
 */
 {
     tcolumn *colptr;
     char *cptr, cpref[4][FLEN_VALUE];
     char errmsg[FLEN_ERRMSG], keyname[FLEN_KEYWORD];
     int tstatus, ii;
-    int datatype, repeat, imin, imax, ibin,  use_datamax = 0;
+    int datatype, imin, imax, ibin,  use_datamax = 0;
+    long repeat1;
     double datamin, datamax;
+    int ncols;
 
     /* check inputs */
     
     if (*status > 0)
         return(*status);
 
+    /* Initialize the number of iterator columns required */
+    if (repeat)    (*repeat) = 0;
+
     if (naxis > 4)
     {
         ffpmsg("histograms with more than 4 dimensions are not supported");
         return(*status = BAD_DIMEN);
     }
 
     /* reset position to the correct HDU if necessary */
@@ -1623,16 +1890,17 @@
 
       /* =========================================================== */
       /* Determine column Number, based on, in order of priority,
          1  input column name, or
 	 2  name given by CPREF keyword, or
 	 3  assume X, Y, Z and T for the name
       */
-	  
-      if (*colname[ii] == '\0')
+
+      if (*colname[ii] == '\0' && 
+	  (colexpr == 0 || colexpr[ii] == 0 || colexpr[ii][0] == '\0'))
       {
          strcpy(colname[ii], cpref[ii]); /* try using the preferred column */
          if (*colname[ii] == '\0')
          {
            if (ii == 0)
               strcpy(colname[ii], "X");
            else if (ii == 1)
@@ -1641,50 +1909,86 @@
               strcpy(colname[ii], "Z");
            else if (ii == 3)
               strcpy(colname[ii], "T");
          }
       }
 
       /* get the column number in the table */
-      if (ffgcno(fptr, CASEINSEN, colname[ii], colnum+ii, status)
-              > 0)
+      colnum[ii] = 0;
+      if (colexpr == 0 || colexpr[ii] == 0 || colexpr[ii][0] == '\0')
       {
-          strcpy(errmsg, "column for histogram axis doesn't exist: ");
-          strncat(errmsg, colname[ii],FLEN_ERRMSG-strlen(errmsg)-1);
-          ffpmsg(errmsg);
-          return(*status);
-      }
-
-      /* ================================================================ */
-      /* check tha column is not a vector or a string                     */
+	if (ffgcno(fptr, CASEINSEN, colname[ii], colnum+ii, status) > 0)
+	  {
+	    strcpy(errmsg, "column for histogram axis doesn't exist: ");
+	    strncat(errmsg, colname[ii],FLEN_ERRMSG-strlen(errmsg)-1);
+	    ffpmsg(errmsg);
+	    return(*status);
+	  }
+	
+	/* ================================================================ */
+	/* check tha column is not a vector or a string                     */
+	
+	/* get the datatype of the column */
+	fits_get_eqcoltype(fptr, colnum[ii], &datatype,
+			   &repeat1, NULL, status);
+	
+	ncols = 1; /* Require only one iterator column, the actual column */
+
+      } else { /* column expression: use parse to determine datatype and dimensions */
+
+	long nelem, naxes[MAXDIMS];
+	int naxis;
+	ParseData lParse;
+
+	/* Initialize the parser so that we can determine the datatype
+	   of the returned type as well as the vector dimensions */
+	if ( ffiprs( fptr, 0, colexpr[ii], MAXDIMS, &datatype, &nelem, &naxis,
+		     naxes, &lParse, status ) ) {
+	  snprintf(errmsg, FLEN_ERRMSG, 
+		   "Parser error of binning expression: %s", 
+		   colexpr[ii]);
+	  ffpmsg(errmsg);
+	  return *status;
+	}
+	if (nelem < 0) nelem = 1; /* If it's a constant expression */
 
-      colptr = ((fptr)->Fptr)->tableptr;
-      colptr += (colnum[ii] - 1);
+	repeat1 = nelem;
 
-      repeat = (int) colptr->trepeat;  /* vector repeat factor of the column */
-      if (repeat > 1)
-      {
-        strcpy(errmsg, "Can't bin a vector column: ");
-        strncat(errmsg, colname[ii],FLEN_ERRMSG-strlen(errmsg)-1);
-        ffpmsg(errmsg);
-        return(*status = BAD_DATATYPE);
+	/* We require lParse.nCols columns to be read from input,
+	   plus one for the Temporary calculator result */
+	ncols = lParse.nCols + 1;
+	ffcprs( &lParse );
       }
 
-      /* get the datatype of the column */
-      fits_get_eqcoltype(fptr, colnum[ii], &datatype,
-         NULL, NULL, status);
-
+      /* Not sure why this repeat limitation is here -- CM
+	 The iterator system can handle vector columns just fine
+`       */
       if (datatype < 0 || datatype == TSTRING)
       {
-        strcpy(errmsg, "Inappropriate datatype; can't bin this column: ");
-        strncat(errmsg, colname[ii],FLEN_ERRMSG-strlen(errmsg)-1);
-        ffpmsg(errmsg);
-        return(*status = BAD_DATATYPE);
+	strcpy(errmsg, "Inappropriate datatype; can't bin this column: ");
+	strncat(errmsg, colname[ii],FLEN_ERRMSG-strlen(errmsg)-1);
+	ffpmsg(errmsg);
+	return(*status = BAD_DATATYPE);
+      }
+
+      /* Store repeat value for future use */
+      if (repeat) {
+	if (ii == 0) {
+	  *repeat = repeat1; /* First time around save the repeat value */
+
+	} else if (*repeat != repeat1) { /* later dimensions, keep same dims */
+
+	  strcpy(errmsg, "Vector repeat of input columns do not agree");
+	  ffpmsg(errmsg);
+	  return (*status = BAD_DIMEN);
+	}
       }
 
+      if (datatypes) datatypes[ii] = datatype;
+
       /* ================================================================ */
       /* get the minimum value */
 
       datamin = DOUBLENULLVALUE;
       datamax = DOUBLENULLVALUE;
       
       if (*minname[ii])
@@ -1697,29 +2001,39 @@
          }
       }
 
       if (minin[ii] != DOUBLENULLVALUE)
       {
         amin[ii] = (double) minin[ii];
       }
-      else
+      else if (colexpr == 0 || colexpr[ii] == 0 || colexpr[ii][0] == '\0')
       {
         ffkeyn("TLMIN", colnum[ii], keyname, status);
         if (ffgky(fptr, TDOUBLE, keyname, amin+ii, NULL, status) > 0)
         {
             /* use actual data minimum value for the histogram minimum */
             *status = 0;
             if (fits_get_col_minmax(fptr, colnum[ii], amin+ii, &datamax, status) > 0)
             {
                 strcpy(errmsg, "Error calculating datamin and datamax for column: ");
                 strncat(errmsg, colname[ii],FLEN_ERRMSG-strlen(errmsg)-1);
                 ffpmsg(errmsg);
                 return(*status);
             }
          }
+      } else { /* it's an expression */
+	if (fits_get_expr_minmax(fptr, colexpr[ii], amin+ii, &datamax, 0, status) > 0)
+            {
+                strcpy(errmsg, "Error calculating datamin and datamax for expression: ");
+                ffpmsg(errmsg);
+		ffpmsg(colexpr[ii]);
+                return(*status);
+            }
+	if (amin[ii] == DOUBLENULLVALUE) amin[ii] = 0.0;
+	
       }
 
       /* ================================================================ */
       /* get the maximum value */
 
       if (*maxname[ii])
       {
@@ -1731,15 +2045,15 @@
          }
       }
 
       if (maxin[ii] != DOUBLENULLVALUE)
       {
         amax[ii] = (double) maxin[ii];
       }
-      else
+      else if (colexpr == 0 || colexpr[ii] == 0 || colexpr[ii][0] == '\0')
       {
         ffkeyn("TLMAX", colnum[ii], keyname, status);
         if (ffgky(fptr, TDOUBLE, keyname, &amax[ii], NULL, status) > 0)
         {
           *status = 0;
           if(datamax != DOUBLENULLVALUE)  /* already computed max value */
           {
@@ -1755,14 +2069,26 @@
                  ffpmsg(errmsg);
                  return(*status);
              }
           }
         }
         use_datamax = 1;  /* flag that the max was determined by the data values */
                           /* and not specifically set by the calling program */
+
+      } else { /* it's an expression */
+
+	if (fits_get_expr_minmax(fptr, colexpr[ii], &datamin, &amax[ii], 0, status) > 0)
+	{
+	  strcpy(errmsg, "Error calculating datamin and datamax for expression: ");
+	  ffpmsg(errmsg);
+	  ffpmsg(colexpr[ii]);
+	  return(*status);
+	}
+	if (amax[ii] == DOUBLENULLVALUE) amin[ii] = 1.0;
+        use_datamax = 1;  
       }
 
 
       /* ================================================================ */
       /* determine binning size and range                                 */
 
       if (*binname[ii])
@@ -1785,18 +2111,23 @@
       if (binsizein[ii] != DOUBLENULLVALUE)
       { 
          binsize[ii] = (double) binsizein[ii];
       }
       else
       {
          tstatus = 0;
-         ffkeyn("TDBIN", colnum[ii], keyname, &tstatus);
 
-         if (ffgky(fptr, TDOUBLE, keyname, binsizein + ii, NULL, &tstatus) > 0)
-         {
+	 if (colexpr == 0 || colexpr[ii] == 0 || colexpr[ii][0] == '\0')
+	 {
+	   ffkeyn("TDBIN", colnum[ii], keyname, &tstatus);
+	   ffgky(fptr, TDOUBLE, keyname, binsizein + ii, NULL, &tstatus);
+	 }
+
+         if (tstatus || 
+	     colexpr && colexpr[ii] && colexpr[ii][0]) {
 	    /* make at least 10 bins */
             binsize[ii] = (amax[ii] - amin[ii]) / 10.F ;
             if (binsize[ii] > 1.)
                 binsize[ii] = 1.;  /* use default bin size */
          }
       }
 
@@ -1864,61 +2195,108 @@
             haxes[ii]++;   /* need to include another partial bin */
         }
       }
     }
 
     return(*status);
 }
+
+/* Double precision version, with non-extended syntax */
+int fits_calc_binningd(
+      fitsfile *fptr,  /* IO - pointer to table to be binned      ;       */
+      int naxis,       /* I - number of axes/columns in the binned image  */
+      char colname[4][FLEN_VALUE],   /* I - optional column names         */
+      double *minin,     /* I - optional lower bound value for each axis  */
+      double *maxin,     /* I - optional upper bound value, for each axis */
+      double *binsizein, /* I - optional bin size along each axis         */
+      char minname[4][FLEN_VALUE], /* I - optional keywords for min       */
+      char maxname[4][FLEN_VALUE], /* I - optional keywords for max       */
+      char binname[4][FLEN_VALUE], /* I - optional keywords for binsize   */
+
+    /* The returned parameters for each axis of the n-dimensional histogram are */
+
+      int *colnum,     /* O - column numbers, to be binned */
+      long *haxes,     /* O - number of bins in each histogram axis */
+      double *amin,     /* O - lower bound of the histogram axes */
+      double *amax,     /* O - upper bound of the histogram axes */
+      double *binsize,  /* O - width of histogram bins/pixels on each axis */
+      int *status)
+/*
+  Calculate the actual binning parameters, non-extended-syntax version
+*/
+{
+  return fits_calc_binningde(fptr, naxis, colname, 0, 
+			     minin, maxin, binsizein, 
+			     minname, maxname, binname, 
+			     colnum, 0, haxes, amin, amax, binsize, 0, 
+			     status);
+}
+
+
 /*--------------------------------------------------------------------------*/
-int fits_write_keys_histo(
+int fits_write_keys_histoe(
       fitsfile *fptr,   /* I - pointer to table to be binned              */
       fitsfile *histptr,  /* I - pointer to output histogram image HDU      */
       int naxis,        /* I - number of axes in the histogram image      */
       int *colnum,      /* I - column numbers (array length = naxis)      */
+      char colname[4][FLEN_VALUE], /* I - if expression, then column name to use */
+      char *colexpr[4], /* I - if expression, then column name to use */
       int *status)     
 {      
    /*  Write default WCS keywords in the output histogram image header */
    /*  if the keywords do not already exist.   */
 
     int ii, tstatus;
     char keyname[FLEN_KEYWORD], svalue[FLEN_VALUE];
     double dvalue;
     
     if (*status > 0)
         return(*status);
 
     for (ii = 0; ii < naxis; ii++)
     {
-     /*  CTYPEn  */
-       tstatus = 0;
-       ffkeyn("CTYPE", ii+1, keyname, &tstatus);
-       ffgky(histptr, TSTRING, keyname, svalue, NULL, &tstatus);
-       
-       if (!tstatus) continue;  /* keyword already exists, so skip to next axis */
-       
-       /* use column name as the axis name */
+       /*  CTYPEn  */
        tstatus = 0;
-       ffkeyn("TTYPE", colnum[ii], keyname, &tstatus);
-       ffgky(fptr, TSTRING, keyname, svalue, NULL, &tstatus);
 
-       if (!tstatus)
+       if (colexpr && colexpr[ii] && colexpr[ii][0] && colname[ii]) 
        {
+	 /* Column expression: we need to put the column name from the binning expression */
          ffkeyn("CTYPE", ii + 1, keyname, &tstatus);
-         ffpky(histptr, TSTRING, keyname, svalue, "Coordinate Type", &tstatus);
+         ffpky(histptr, TSTRING, keyname, colname[ii], "Coordinate Type", &tstatus);
        }
-
-       /*  CUNITn,  use the column units */
-       tstatus = 0;
-       ffkeyn("TUNIT", colnum[ii], keyname, &tstatus);
-       ffgky(fptr, TSTRING, keyname, svalue, NULL, &tstatus);
-
-       if (!tstatus)
+       else
        {
-         ffkeyn("CUNIT", ii + 1, keyname, &tstatus);
-         ffpky(histptr, TSTRING, keyname, svalue, "Coordinate Units", &tstatus);
+	 /* Column name */
+	 tstatus = 0;
+	 ffkeyn("CTYPE", ii+1, keyname, &tstatus);
+	 ffgky(histptr, TSTRING, keyname, svalue, NULL, &tstatus);
+	 
+	 if (!tstatus) continue;  /* keyword already exists, so skip to next axis */
+
+	 /* use column name as the axis name */
+	 tstatus = 0;
+	 ffkeyn("TTYPE", colnum[ii], keyname, &tstatus);
+	 ffgky(fptr, TSTRING, keyname, svalue, NULL, &tstatus);
+	 
+	 if (!tstatus)
+	   {
+	     ffkeyn("CTYPE", ii + 1, keyname, &tstatus);
+	     ffpky(histptr, TSTRING, keyname, svalue, "Coordinate Type", &tstatus);
+	   }
+	 
+	 /*  CUNITn,  use the column units */
+	 tstatus = 0;
+	 ffkeyn("TUNIT", colnum[ii], keyname, &tstatus);
+	 ffgky(fptr, TSTRING, keyname, svalue, NULL, &tstatus);
+	 
+	 if (!tstatus)
+	   {
+	     ffkeyn("CUNIT", ii + 1, keyname, &tstatus);
+	     ffpky(histptr, TSTRING, keyname, svalue, "Coordinate Units", &tstatus);
+	   }
        }
 
        /*  CRPIXn  - Reference Pixel choose first pixel in new image as ref. pix. */
        dvalue = 1.0;
        tstatus = 0;
        ffkeyn("CRPIX", ii + 1, keyname, &tstatus);
        ffpky(histptr, TDOUBLE, keyname, &dvalue, "Reference Pixel", &tstatus);
@@ -1936,14 +2314,25 @@
        ffkeyn("CDELT", ii + 1, keyname, &tstatus);
        ffpky(histptr, TDOUBLE, keyname, &dvalue, "Pixel size", &tstatus);
 
     }
     return(*status);
 }
 /*--------------------------------------------------------------------------*/
+int fits_write_keys_histo(
+      fitsfile *fptr,   /* I - pointer to table to be binned              */
+      fitsfile *histptr,  /* I - pointer to output histogram image HDU      */
+      int naxis,        /* I - number of axes in the histogram image      */
+      int *colnum,      /* I - column numbers (array length = naxis)      */
+      int *status)     
+{      
+  return fits_write_keys_histoe(fptr, histptr, naxis, colnum, 0, 0, status);
+}
+
+/*--------------------------------------------------------------------------*/
 int fits_rebin_wcs(
       fitsfile *fptr,   /* I - pointer to table to be binned           */
       int naxis,        /* I - number of axes in the histogram image   */
       float *amin,     /* I - first pixel include in each axis        */
       float *binsize,  /* I - binning factor for each axis            */
       int *status)      
 {
@@ -1986,16 +2375,17 @@
     for (ii = 0; ii < naxis; ii++)
     {
        reset = 0;  /* flag to reset the reference pixel */
        tstatus = 0;
        ffkeyn("CRVAL", ii + 1, keyname, &tstatus);
        /* get previous (pre-binning) value */
        ffgky(fptr, TDOUBLE, keyname, &dvalue, NULL, &tstatus); 
-       if (!tstatus && dvalue == 1.0)
+       if (!tstatus && dvalue == 1.0) {
            reset = 1;
+       }
 
        tstatus = 0;
        /*  CRPIXn - update location of the ref. pix. in the binned image */
        ffkeyn("CRPIX", ii + 1, keyname, &tstatus);
 
        /* get previous (pre-binning) value */
        ffgky(fptr, TDOUBLE, keyname, &dvalue, NULL, &tstatus); 
@@ -2112,48 +2502,67 @@
 		    selectrow, status);
   }
 
   return (*status);
 }
 
 /* Double-precision version */
-int fits_make_histd(fitsfile *fptr, /* IO - pointer to table with X and Y cols; */
+int fits_make_histde(fitsfile *fptr, /* IO - pointer to table with X and Y cols; */
     fitsfile *histptr, /* I - pointer to output FITS image      */
+    int *datatypes,   /*  I - datatype of input (or 0 for auto) */
     int bitpix,       /* I - datatype for image: 16, 32, -32, etc    */
     int naxis,        /* I - number of axes in the histogram image   */
     long *naxes,      /* I - size of axes in the histogram image   */
-    int *colnum,    /* I - column numbers (array length = naxis)   */
+    int *colnum,      /* I - column numbers (array length = naxis)   */
+    char *colexpr[4], /* I - optional expression instead of column */
     double *amin,     /* I - minimum histogram value, for each axis */
     double *amax,     /* I - maximum histogram value, for each axis */
-    double *binsize, /* I - bin size along each axis               */
-    double weight,        /* I - binning weighting factor          */
-    int wtcolnum, /* I - optional keyword or col for weight*/
+    double *binsize,  /* I - bin size along each axis               */
+    double weight,    /* I - binning weighting factor (0 or DOUBLENULLVALUE means null) */
+    int wtcolnum,     /* I - optional keyword or col for weight*/
+    char *wtexpr,     /* I - optional weighting expression */
+		      /*  disambiguation of weight values */
+		      /*    non-null weight: use that value */
+		      /*    null weight: use wtexpr if non-null, else wtcolnum */
     int recip,              /* I - use reciprocal of the weight?     */
     char *selectrow,        /* I - optional array (length = no. of   */
                              /* rows in the table).  If the element is true */
                              /* then the corresponding row of the table will*/
                              /* be included in the histogram, otherwise the */
                              /* row will be skipped.  Ingnored if *selectrow*/
                              /* is equal to NULL.                           */
     int *status)
 {		  
-    int ii, imagetype, datatype;
+    int ii, imagetype;
     int n_cols = 1;
     long imin, imax, ibin;
     long  offset = 0;
     long n_per_loop = -1;  /* force whole array to be passed at one time */
     double taxes[4], tmin[4], tmax[4], tbin[4], maxbin[4];
     histType histData;    /* Structure holding histogram info for iterator */
     iteratorCol imagepars[1];
+    long nrows = -1;
+    ParseData parsers[5];
+    parseInfo infos[5];
+    int numAllocCols = 0, startCol = -1, numIterCols = 0;
+    iteratorCol *iterCols = 0;
+    double double_nulval = DOUBLENULLVALUE;
+    long repeat = 0, wtrepeat = 0;
 
     /* check inputs */
     
     if (*status > 0)
         return(*status);
 
+    /* Make sure the parser information is initialized because we will
+       use this to determine what needs to be deallocated at the end */
+    memset(infos, 0, sizeof(infos));
+    memset(parsers, 0, sizeof(parsers));
+    memset(&histData, 0, sizeof(histData));
+
     if (naxis > 4)
     {
         ffpmsg("histogram has more than 4 dimensions");
         return(*status = BAD_DIMEN);
     }
 
     if   (bitpix == BYTE_IMG)
@@ -2169,39 +2578,68 @@
     else
         return(*status = BAD_DATATYPE);
 
     /* reset position to the correct HDU if necessary */
     if ((fptr)->HDUposition != ((fptr)->Fptr)->curhdu)
         ffmahd(fptr, ((fptr)->HDUposition) + 1, NULL, status);
 
+    /* Resolve the conflict between wtexpr, wtcolnum, and weight */
+    if ( ((wtcolnum > 0) || (wtexpr && wtexpr[0])) && weight == 0 ) weight = DOUBLENULLVALUE;
     histData.weight     = weight;
     histData.wtcolnum   = wtcolnum;
+    histData.wtexpr     = wtexpr;
     histData.wtrecip    = recip;
     histData.tblptr     = fptr;
     histData.himagetype = imagetype;
     histData.haxis      = naxis;
     histData.rowselector = selectrow;
 
+    /* Now make iterator columns for input, as well as any calculated values */
+    numAllocCols = 5;
+    iterCols = fits_recalloc(0, 0, numAllocCols, sizeof(iteratorCol));
+    if (!iterCols) {
+      ffpmsg("memory allocation failure (fits_make_histde)");
+      *status = MEMORY_ALLOCATION;
+      goto cleanup;
+    }
+
+    /* We fill the iterCols in order, starting from column 1 through 4, and 
+       then moving on to the weighting column */
+    for (ii = 0; ii < 5; ii++)  histData.startCols[ii] = -1;
+    startCol = 0;
+
+    /* Loop through each axis and recheck the binning parameters */
     for (ii = 0; ii < naxis; ii++)
     {
+      long colrepeat = 0;
+      int datatype;
+      histData.startCols[ii] = startCol;
+
       taxes[ii] = (double) naxes[ii];
       tmin[ii] = amin[ii];
       tmax[ii] = amax[ii];
       if ( (amin[ii] > amax[ii] && binsize[ii] > 0. ) ||
            (amin[ii] < amax[ii] && binsize[ii] < 0. ) )
           tbin[ii] =  -binsize[ii];  /* reverse the sign of binsize */
       else
           tbin[ii] =   binsize[ii];  /* binsize has the correct sign */
           
       imin = (long) tmin[ii];
       imax = (long) tmax[ii];
       ibin = (long) tbin[ii];
     
-      /* get the datatype of the column */
-      fits_get_eqcoltype(fptr, colnum[ii], &datatype, NULL, NULL, status);
+      /* get the datatype of the column and repeat */
+      if (! (colexpr && colexpr[ii] && colexpr[ii][0]) ) {
+	fits_get_eqcoltype(fptr, colnum[ii], &datatype, &colrepeat, NULL, status);
+      }
+
+      /* If caller specified datatype, use that */
+      if (datatypes && datatypes[ii]) {
+	datatype = datatypes[ii];
+      }
 
       if (datatype <= TLONG && (double) imin == tmin[ii] &&
                                (double) imax == tmax[ii] &&
                                (double) ibin == tbin[ii] )
       {
         /* This is an integer column and integer limits were entered. */
         /* Shift the lower and upper histogramming limits by 0.5, so that */
@@ -2218,64 +2656,215 @@
         {
           tmin[ii] = tmin[ii] + 0.5F;
           tmax[ii] = tmax[ii] - 0.5F;
         }
       } else {  /* not an integer column with integer limits */
           maxbin[ii] = (tmax[ii] - tmin[ii]) / tbin[ii]; 
       }
-    }
+
+      /* This is a column expression.  Here is where we allocate the 
+	 parser for it during the actual evaluation. */
+      if (colexpr && colexpr[ii] && colexpr[ii][0]) {
+	int datatype, naxis1;
+	long nelem, naxes[MAXDIMS];
+	int jj;
+
+	/* Initialize the parser for this binning expression */
+	ffiprs( fptr, 0, colexpr[ii], MAXDIMS, &datatype, &nelem, &naxis1,
+		naxes, &(parsers[ii]), status );
+	if (*status) goto cleanup;
+	if (nelem < 0) nelem = 1; /* If it's a constant expression */
+
+	colrepeat = nelem;
+
+	/* Set up the parser data for evaluation to a TemporaryCol */
+	fits_get_num_rows(fptr, &nrows, status);
+	if (fits_parser_set_temporary_col(&(parsers[ii]), &(infos[ii]), nrows,
+					  (void *) &(double_nulval), status)) goto cleanup;
+
+	/* Copy iterator columns from the parser to the master iterator columns */
+	iterCols = fits_recalloc(iterCols, numAllocCols, numAllocCols+parsers[ii].nCols,
+			    sizeof(iteratorCol));
+	if (!iterCols) {
+	  *status = MEMORY_ALLOCATION;
+	  goto cleanup;
+	}
+	numAllocCols += parsers[ii].nCols;
+	for (jj = 0; jj < parsers[ii].nCols; jj++) iterCols[startCol++] = parsers[ii].colData[jj];
+
+      } else {
+
+	/* Just a "regular" column name, we already have enough allocated for these */
+	fits_iter_set_by_num(&(iterCols[startCol]), fptr, colnum[ii], TDOUBLE, InputCol);
+	startCol ++;
+      }
+
+      /* Check that all the vector dimensions agree */
+      if (repeat == 0) {
+	repeat = colrepeat;
+      } else {
+	if (repeat != colrepeat) {
+	  ffpmsg("vector dimensions of binning values do not agree");
+	  *status = BAD_DIMEN;
+	  goto cleanup;
+	}
+      }
+
+    } /* End of loop over columns */
+
+    /* Now initialize the iterator column data for the weighting */
+    if (wtexpr && wtexpr[0] && weight == DOUBLENULLVALUE) {
+      int wtdatatype, wtnaxis;
+      long wtnaxes[MAXDIMS];
+      int jj;
+
+      histData.startCols[4] = startCol;
+      ffiprs( fptr, 0, wtexpr, MAXDIMS, &wtdatatype, &wtrepeat, &wtnaxis,
+	      wtnaxes, &(parsers[4]), status );
+      if (*status) goto cleanup;
+      if (wtrepeat < 0) wtrepeat = 1; /* If it's a constant expression */
+
+      /* Set up the parser data for evaluation to a TemporaryCol */
+      /* It's a weighting expression, set that up and ... */
+      fits_get_num_rows(fptr, &nrows, status);
+      if (fits_parser_set_temporary_col(&(parsers[4]), &(infos[4]), nrows,
+					(void *) &(double_nulval), status)) goto cleanup;
+
+      /* Copy iterator columns from the parser to the master iterator columns */
+      iterCols = fits_recalloc(iterCols, numAllocCols, numAllocCols+parsers[4].nCols,
+			  sizeof(iteratorCol));
+      if (!iterCols) {
+	*status = MEMORY_ALLOCATION;
+	goto cleanup;
+      }
+      numAllocCols += parsers[ii].nCols;
+      for (jj = 0; jj < parsers[4].nCols; jj++) iterCols[startCol++] = parsers[4].colData[jj];
+
+    } else if (weight == DOUBLENULLVALUE) {
+      int wtdatatype;
+
+      /* It's a "regular" weighting column */
+      fits_get_eqcoltype(fptr, wtcolnum, &wtdatatype, &wtrepeat, NULL, status);
+
+      histData.startCols[4] = startCol;
+      fits_iter_set_by_num(&(iterCols[startCol]), fptr, wtcolnum, TDOUBLE, InputCol);
+      startCol ++;
+    } else {
+
+      /* In case of explicit numerical value, we can just use that number
+	 in the vector expression, so the vector repeat of the weighting can
+	 be set to that of the input */
+      wtrepeat = repeat;
+    }
+
+    /* Vector dimension of weighting must agree with binning */
+    if (wtrepeat != 0 && repeat != 0 && wtrepeat != repeat) {
+      ffpmsg("vector dimensions of weights do not agree with bins");
+      *status = BAD_DIMEN;
+      goto cleanup;
+    }
+
+    /* We now know he number of iterator columns */
+    numIterCols = startCol;
+
+    /* Fill in iterator information for the parser*/
+    histData.numIterCols = numIterCols;
+    histData.iterCols = iterCols;
+    histData.parsers = parsers;
+    histData.infos = infos;
+    histData.repeat = repeat;
 
     /* Set global variables with histogram parameter values.    */
     /* Use separate scalar variables rather than arrays because */
     /* it is more efficient when computing the histogram.       */
 
     histData.hcolnum[0]  = colnum[0];
     histData.amin1 = tmin[0];
     histData.maxbin1 = maxbin[0];
     histData.binsize1 = tbin[0];
     histData.haxis1 = (long) taxes[0];
+    histData.incr[0] = 1;
 
     if (histData.haxis > 1)
     {
       histData.hcolnum[1]  = colnum[1];
       histData.amin2 = tmin[1];
       histData.maxbin2 = maxbin[1];
       histData.binsize2 = tbin[1];
       histData.haxis2 = (long) taxes[1];
+      histData.incr[1] = histData.incr[0] * histData.haxis1;
 
       if (histData.haxis > 2)
       {
         histData.hcolnum[2]  = colnum[2];
         histData.amin3 = tmin[2];
         histData.maxbin3 = maxbin[2];
         histData.binsize3 = tbin[2];
         histData.haxis3 = (long) taxes[2];
+	histData.incr[2] = histData.incr[1] * histData.haxis2;
 
         if (histData.haxis > 3)
         {
           histData.hcolnum[3]  = colnum[3];
           histData.amin4 = tmin[3];
           histData.maxbin4 = maxbin[3];
           histData.binsize4 = tbin[3];
           histData.haxis4 = (long) taxes[3];
+	  histData.incr[3] = histData.incr[2] * histData.haxis3;
         }
       }
     }
 
     /* define parameters of image for the iterator function */
     fits_iter_set_file(imagepars, histptr);        /* pointer to image */
     fits_iter_set_datatype(imagepars, imagetype);  /* image datatype   */
     fits_iter_set_iotype(imagepars, OutputCol);    /* image is output  */
 
     /* call the iterator function to write out the histogram image */
     fits_iterate_data(n_cols, imagepars, offset, n_per_loop,
                           ffwritehisto, (void*)&histData, status);
        
+ cleanup:
+    /* Free any allocated memory ... */
+    if (iterCols) free(iterCols);
+    /* ... and parsers */
+    for (ii = 0; ii <= 4; ii ++) {
+      if (parsers[ii].nCols > 0) ffcprs(&(parsers[ii]));
+    }
     return(*status);
 }
+
+/* Double-precision version, non-extended syntax */
+int fits_make_histd(fitsfile *fptr, /* IO - pointer to table with X and Y cols; */
+    fitsfile *histptr, /* I - pointer to output FITS image      */
+    int bitpix,       /* I - datatype for image: 16, 32, -32, etc    */
+    int naxis,        /* I - number of axes in the histogram image   */
+    long *naxes,      /* I - size of axes in the histogram image   */
+    int *colnum,    /* I - column numbers (array length = naxis)   */
+    double *amin,     /* I - minimum histogram value, for each axis */
+    double *amax,     /* I - maximum histogram value, for each axis */
+    double *binsize, /* I - bin size along each axis               */
+    double weight,        /* I - binning weighting factor          */
+    int wtcolnum, /* I - optional keyword or col for weight*/
+    int recip,              /* I - use reciprocal of the weight?     */
+    char *selectrow,        /* I - optional array (length = no. of   */
+                             /* rows in the table).  If the element is true */
+                             /* then the corresponding row of the table will*/
+                             /* be included in the histogram, otherwise the */
+                             /* row will be skipped.  Ingnored if *selectrow*/
+                             /* is equal to NULL.                           */
+    int *status)
+{		  
+  return fits_make_histde(histptr, 0, 0, bitpix, naxis, naxes,
+			  colnum, 0, 
+			  amin, amax, binsize, 
+			  weight, wtcolnum, 0, recip,
+			  selectrow, status);
+}
+
 /*--------------------------------------------------------------------------*/
 int fits_get_col_minmax(fitsfile *fptr, int colnum, double *datamin, 
 			double *datamax, int *status)
 /* 
    Simple utility routine to compute the min and max value in a column
 */
 {
@@ -2306,24 +2895,145 @@
         }
 
         nrows -= ntodo;
         firstrow += ntodo;
     }
     return(*status);
 }
+
+struct histo_minmax_workfn_struct {
+  parseInfo *Info;
+  double datamin, datamax;
+  long ntotal, ngood;
+};
+
+/*---------------------------------------------------------------------------*/
+static int histo_minmax_expr_workfn( long    totalrows,     /* I - Total rows to be processed     */
+                long    offset,        /* I - Number of rows skipped at start*/
+                long    firstrow,      /* I - First row of this iteration    */
+                long    nrows,         /* I - Number of rows in this iter    */
+                int      nCols,        /* I - Number of columns in use       */
+                iteratorCol *colData,  /* IO- Column information/data        */
+                void    *userPtr )     /* I - Data handling instructions     */
+/*                                                                           */
+/* Iterator work function which evaluates a parser result and computes       */
+/* min max value */
+/*---------------------------------------------------------------------------*/
+{
+  int status = 0;
+  long i;
+  double *data;
+  double nulval;
+  struct histo_minmax_workfn_struct *wf = ((struct histo_minmax_workfn_struct *)userPtr);
+  struct ParseStatusVariables *pv = &(wf->Info->parseVariables);
+  iteratorCol *outcol = &(colData[nCols-1]);
+
+  /* Call calculator work function.  Result is put in final column of colData as a TemporaryCol */
+  status = fits_parser_workfn(totalrows, offset, firstrow, nrows, 
+			      nCols, colData, (void *) wf->Info);
+
+  /* The result of the calculation is in pv->Data, and null value in pv->Null */
+  data = (double *)(outcol->array);
+  nulval = *((double *)(wf->Info->nullPtr));
+
+  for (i = 1; i<=(nrows*pv->repeat); i++ ) {
+    /* Note that data[0] == 0 indicates no null values at all!!! */
+    if (data[0] == 0 || data[i] != nulval) {
+      if (data[i] < wf->datamin || wf->datamin == DOUBLENULLVALUE) wf->datamin = data[i];
+      if (data[i] > wf->datamax || wf->datamax == DOUBLENULLVALUE) wf->datamax = data[i];
+      wf->ngood ++;
+    }
+     wf->ntotal ++;
+  }
+
+  return status;
+}
+
+
+/*--------------------------------------------------------------------------*/
+int fits_get_expr_minmax(fitsfile *fptr, char *expr, double *datamin, 
+			 double *datamax, int *datatype, int *status)
+/* 
+   Simple utility routine to compute the min and max value in an expression
+*/
+{
+   parseInfo Info;
+   ParseData lParse;
+   struct histo_minmax_workfn_struct minmaxWorkFn;
+   int naxis, constant, typecode, newNullKwd=0;
+   long nelem, naxes[MAXDIMS], repeat, width, nrows;
+   int col_cnt, colNo;
+   Node *result;
+   char card[81], tform[16], nullKwd[9], tdimKwd[9];
+   double double_nulval = DOUBLENULLVALUE;
+
+   if( *status ) return( *status );
+
+   memset(&minmaxWorkFn, 0, sizeof(minmaxWorkFn));
+   memset(&Info, 0, sizeof(Info));
+   memset(&lParse, 0, sizeof(lParse));
+   if (datatype) *datatype = 0;
+
+   ffgky(fptr, TLONG, "NAXIS2", &nrows, NULL, status); /* no. of rows */
+
+   if( ffiprs( fptr, 0, expr, MAXDIMS, &Info.datatype, &nelem, &naxis,
+               naxes, &lParse, status ) ) {
+
+      ffcprs(&lParse);
+      return( *status );
+   }
+
+   if (datatype) *datatype = Info.datatype;
+
+   if( nelem<0 ) { /* Constant already computed */
+      result  = lParse.Nodes + lParse.resultNode;
+      switch( Info.datatype ) {
+      case TDOUBLE: *datamin = *datamax = result->value.data.dbl; break;
+      case TLONG:   *datamin = *datamax = (double) result->value.data.lng; break;
+      case TLOGICAL:*datamin = *datamax = (double) ((result->value.data.log == 1)?1:0); break;
+      case TBIT:    *datamin = *datamax = (double) ((result->value.data.str[0])?1:0); break;
+      }
+      ffcprs(&lParse);
+      return( *status );
+   }
+
+   Info.parseData = &lParse;
+
+   /* Add a temporary column which contains the expression value */
+   if ( fits_parser_set_temporary_col( &lParse, &Info, nrows, &double_nulval, status) ) {
+     ffcprs(&lParse);
+     return( *status );
+   }
+
+   /* Initialize the work function computing min/max */
+   minmaxWorkFn.Info = &Info;
+   minmaxWorkFn.datamin = minmaxWorkFn.datamax = DOUBLENULLVALUE;
+   minmaxWorkFn.ntotal = minmaxWorkFn.ngood = 0;
+   
+   if( ffiter( lParse.nCols, lParse.colData, 0, 0,
+	       histo_minmax_expr_workfn, (void*)&minmaxWorkFn, status ) == -1 )
+     *status = 0;  /* -1 indicates exitted without error before end... OK */
+
+   if (datamin) *datamin = minmaxWorkFn.datamin;
+   if (datamax) *datamax = minmaxWorkFn.datamax;
+
+   ffcprs(&lParse);
+   return(*status);
+
+}
 /*--------------------------------------------------------------------------*/
 int ffwritehisto(long totaln, long pixoffset, long firstn, long nvalues,
-             int narrays, iteratorCol *imagepars, void *userPointer)
+		 int narrays, iteratorCol *imagepars, void *userPointer)
 /*
    Interator work function that writes out the histogram.
    The histogram values are calculated by another work function, ffcalchisto.
    This work function only gets called once, and totaln = nvalues.
 */
 {
-    iteratorCol colpars[5];
+    iteratorCol *colpars;
     int ii, status = 0, ncols;
     long rows_per_loop = 0, offset = 0;
     histType *histData;
 
     histData = (histType *)userPointer;
 
     /* store pointer to the histogram array, and initialize to zero */
@@ -2342,198 +3052,201 @@
        histData->hist.r = (float * ) fits_iter_get_array(imagepars);
        break;
     case TDOUBLE:
        histData->hist.d = (double *) fits_iter_get_array(imagepars);
        break;
     }
 
-    /* set the column parameters for the iterator function */
-    for (ii = 0; ii < histData->haxis; ii++)
-    {
-      fits_iter_set_by_num(&colpars[ii], histData->tblptr,
-			   histData->hcolnum[ii], TDOUBLE, InputCol);
-    }
-    ncols = histData->haxis;
-
-    if (histData->weight == DOUBLENULLVALUE)
-    {
-      fits_iter_set_by_num(&colpars[histData->haxis], histData->tblptr,
-			   histData->wtcolnum, TDOUBLE, InputCol);
-      ncols = histData->haxis + 1;
-    }
-
     /* call iterator function to calc the histogram pixel values */
 
     /* must lock this call in multithreaded environoments because */
     /* the ffcalchist work routine uses static vaiables that would */
     /* get clobbered if multiple threads were running at the same time */
-    FFLOCK;
-    fits_iterate_data(ncols, colpars, offset, rows_per_loop,
-                          ffcalchist, (void*)histData, &status);
-    FFUNLOCK;
+    fits_iterate_data(histData->numIterCols, histData->iterCols,
+		      offset, rows_per_loop,
+		      ffcalchist, (void*)histData, &status);
 
     return(status);
 }
 /*--------------------------------------------------------------------------*/
 int ffcalchist(long totalrows, long offset, long firstrow, long nrows,
              int ncols, iteratorCol *colpars, void *userPointer)
 /*
    Interator work function that calculates values for the 2D histogram.
 */
 {
     long ii, ipix, iaxisbin;
     double pix, axisbin;
-    static double *col1, *col2, *col3, *col4; /* static to preserve values */
-    static double *wtcol;
-    static long incr2, incr3, incr4;
-    static histType histData;
-    static char *rowselect;
+    char *rowselect;
+    histType *histData = (histType*)userPointer;
+    double *colptr[MAXDIMS] = {0};
+    int status = 0;
+    long irow;
 
-    /*  Initialization procedures: execute on the first call  */
-    if (firstrow == 1)
-    {
+    if (firstrow == 1) {
+      histData->rowselector_cur = histData->rowselector;
+    }
+    rowselect = histData->rowselector_cur;
 
-      /*  Copy input histogram data to static local variable so we */
-      /*  don't have to constantly dereference it.                 */
+    for (ii=0; ii<=4; ii++) {
+      int startCol = histData->startCols[ii];
+      iteratorCol *outcol = 0;
+      /* Call calculator work function.  Result is put in final column of colData as a TemporaryCol */
+      colptr[ii] = 0;
 
-      histData = *(histType*)userPointer;
-      rowselect = histData.rowselector;
+      /* Do not process unspecified axes (but do process weight column) */
+      if ( (ii >= histData->haxis && ii != 4) || histData->startCols[ii] < 0) continue;
 
-      /* assign the input array pointers to local pointers */
-      col1 = (double *) fits_iter_get_array(&colpars[0]);
-      if (histData.haxis > 1)
-      {
-        col2 = (double *) fits_iter_get_array(&colpars[1]);
-        incr2 = histData.haxis1;
+      /* We have a parser for this, evaluate it */
+      if (histData->parsers[ii].nCols > 0) {
+	struct ParseStatusVariables *pv = &(histData->infos[ii].parseVariables);
+	iteratorCol *colData = &(histData->iterCols[startCol]);
+	int nCols = histData->parsers[ii].nCols;
 
-        if (histData.haxis > 2)
-        {
-          col3 = (double *) fits_iter_get_array(&colpars[2]);
-          incr3 = incr2 * histData.haxis2;
+	status = fits_parser_workfn(totalrows, offset, firstrow, nrows, 
+				    nCols, colData, (void *) &(histData->infos[ii]));
+	if (status) return status;
+	/* Output column is last iterator column, which better be a TemporaryCol */
+	outcol = &(colData[nCols-1]);
 
-          if (histData.haxis > 3)
-          {
-            col4 = (double *) fits_iter_get_array(&colpars[3]);
-            incr4 = incr3 * histData.haxis3;
-          }
-        }
+      } else {
+	outcol = &(histData->iterCols[startCol]);
       }
 
-      if (ncols > histData.haxis)  /* then weights are give in a column */
-      {
-        wtcol = (double *) fits_iter_get_array(&colpars[histData.haxis]);
+      if (outcol) {
+	/* Note that the 0th array element returned by the iterator is
+	   actually the null value!  This is actually rather a big
+	   undocumented "feature" of the iterator. However, "ii" below
+	   starts at a value of 1 which skips over the null value */
+	colptr[ii] = ((double *) fits_iter_get_array(outcol));
       }
-    }   /* end of Initialization procedures */
+    }
+
+    /*  Main loop over rows */
+    /* irow = row counter (1 .. nrows) */
+    /* elem = counter of element (1 .. histData->repeat) for each row */
+    /* ii = counts up from 1 (see note below) used to index colptr[]'s */
 
-    /*  Main loop: increment the histogram at position of each event */
-    for (ii = 1; ii <= nrows; ii++) 
+    /* Note that ii starts at 1 because position [0] in the 
+       column data arrays is for the "null" value! */
+    for (ii = 1, irow = 1; irow <= nrows; irow++) 
     {
-        if (rowselect)     /* if a row selector array is supplied... */
-        {
-           if (*rowselect)
-           {
+        long elem;
+        if (rowselect) {    /* if a row selector array is supplied... */
+
+	  if (*rowselect) {
                rowselect++;   /* this row is included in the histogram */
-           }
-           else
-           {
+
+	  } else {
                rowselect++;   /* this row is excluded from the histogram */
+
+	       ii += histData->repeat; /* skip this portion of data */
                continue;
            }
         }
 
-        if (col1[ii] == DOUBLENULLVALUE)  /* test for null value */
-            continue;
 
-        pix = (col1[ii] - histData.amin1) / histData.binsize1;
-        ipix = (long) (pix + 1.); /* add 1 because the 1st pixel is the null value */
+	/* Loop over elements in each row, increment ii after each element */
 
-	/* test if bin is within range */
-        if (ipix < 1 || ipix > histData.haxis1 || pix > histData.maxbin1)
+        for (elem = 1; elem <= histData->repeat; elem++, ii++) {
+	  if (colptr[0][ii] == DOUBLENULLVALUE)  /* test for null value */
             continue;
+	  if (colptr[4] && colptr[4][ii] == DOUBLENULLVALUE) /* and null weight */
+	    continue;
+	  
+	  pix = (colptr[0][ii] - histData->amin1) / histData->binsize1;
+	  ipix = (long) (pix + 1.); /* add 1 because the 1st pixel is the null value */
+	  
+	  /* test if bin is within range */
+	  if (ipix < 1 || ipix > histData->haxis1 || pix > histData->maxbin1)
+            continue;
+	  
+	  if (histData->haxis > 1)
+	    {
+	      if (colptr[1][ii] == DOUBLENULLVALUE)
+		continue;
+	      
+	      axisbin = (colptr[1][ii] - histData->amin2) / histData->binsize2;
+	      iaxisbin = (long) axisbin;
+	      
+	      if (axisbin < 0. || iaxisbin >= histData->haxis2 || axisbin > histData->maxbin2)
+		continue;
+	      
+	      ipix += (iaxisbin * histData->incr[1]);
+	      
+	      if (histData->haxis > 2)
+		{
+		  if (colptr[2][ii] == DOUBLENULLVALUE)
+		    continue;
+		  
+		  axisbin = (colptr[2][ii] - histData->amin3) / histData->binsize3;
+		  iaxisbin = (long) axisbin;
+		  if (axisbin < 0. || iaxisbin >= histData->haxis3 || axisbin > histData->maxbin3)
+		    continue;
+		  
+		  ipix += (iaxisbin * histData->incr[2]);
+		  
+		  if (histData->haxis > 3)
+		    {
+		      if (colptr[3][ii] == DOUBLENULLVALUE)
+			continue;
+		      
+		      axisbin = (colptr[3][ii] - histData->amin4) / histData->binsize4;
+		      iaxisbin = (long) axisbin;
+		      if (axisbin < 0. || iaxisbin >= histData->haxis4 || axisbin > histData->maxbin4)
+			continue;
+		      
+		      ipix += (iaxisbin * histData->incr[3]);
+		      
+		    }  /* end of haxis > 3 case */
+		}    /* end of haxis > 2 case */
+	    }      /* end of haxis > 1 case */
+
+	  /* increment the histogram pixel */
+	  if (histData->weight != DOUBLENULLVALUE) /* constant weight factor */
+	    {   /* Note that if wtrecip == 1, the reciprocal was precomputed above */
+	      if (histData->himagetype == TINT)
+		histData->hist.j[ipix] += (int) histData->weight;
+	      else if (histData->himagetype == TSHORT)
+		histData->hist.i[ipix] += (short) histData->weight;
+	      else if (histData->himagetype == TFLOAT)
+		histData->hist.r[ipix] += histData->weight;
+	      else if (histData->himagetype == TDOUBLE)
+		histData->hist.d[ipix] += histData->weight;
+	      else if (histData->himagetype == TBYTE)
+		histData->hist.b[ipix] += (char) histData->weight;
+	    }
+	  else if (histData->wtrecip) /* use reciprocal of the weight */
+	    {
+	      if (histData->himagetype == TINT)
+		histData->hist.j[ipix] += (int) (1./colptr[4][ii]);
+	      else if (histData->himagetype == TSHORT)
+		histData->hist.i[ipix] += (short) (1./colptr[4][ii]);
+	      else if (histData->himagetype == TFLOAT)
+		histData->hist.r[ipix] += (float) (1./colptr[4][ii]);
+	      else if (histData->himagetype == TDOUBLE)
+		histData->hist.d[ipix] += 1./colptr[4][ii];
+	      else if (histData->himagetype == TBYTE)
+		histData->hist.b[ipix] += (char) (1./colptr[4][ii]);
+	    }
+	  else   /* no weights */
+	    {
+	      if (histData->himagetype == TINT)
+		histData->hist.j[ipix] += (int) colptr[4][ii];
+	      else if (histData->himagetype == TSHORT)
+		histData->hist.i[ipix] += (short) colptr[4][ii];
+	      else if (histData->himagetype == TFLOAT)
+		histData->hist.r[ipix] += colptr[4][ii];
+	      else if (histData->himagetype == TDOUBLE)
+		histData->hist.d[ipix] += colptr[4][ii];
+	      else if (histData->himagetype == TBYTE)
+		histData->hist.b[ipix] += (char) colptr[4][ii];
+	    }
 
-        if (histData.haxis > 1)
-        {
-          if (col2[ii] == DOUBLENULLVALUE)
-              continue;
-
-          axisbin = (col2[ii] - histData.amin2) / histData.binsize2;
-          iaxisbin = (long) axisbin;
-
-          if (axisbin < 0. || iaxisbin >= histData.haxis2 || axisbin > histData.maxbin2)
-              continue;
-
-          ipix += (iaxisbin * incr2);
-
-          if (histData.haxis > 2)
-          {
-            if (col3[ii] == DOUBLENULLVALUE)
-                continue;
-
-            axisbin = (col3[ii] - histData.amin3) / histData.binsize3;
-            iaxisbin = (long) axisbin;
-            if (axisbin < 0. || iaxisbin >= histData.haxis3 || axisbin > histData.maxbin3)
-                continue;
-
-            ipix += (iaxisbin * incr3);
- 
-            if (histData.haxis > 3)
-            {
-              if (col4[ii] == DOUBLENULLVALUE)
-                  continue;
-
-              axisbin = (col4[ii] - histData.amin4) / histData.binsize4;
-              iaxisbin = (long) axisbin;
-              if (axisbin < 0. || iaxisbin >= histData.haxis4 || axisbin > histData.maxbin4)
-                  continue;
-
-              ipix += (iaxisbin * incr4);
-
-            }  /* end of haxis > 3 case */
-          }    /* end of haxis > 2 case */
-        }      /* end of haxis > 1 case */
-
-        /* increment the histogram pixel */
-        if (histData.weight != DOUBLENULLVALUE) /* constant weight factor */
-        {
-            if (histData.himagetype == TINT)
-              histData.hist.j[ipix] += (int) histData.weight;
-            else if (histData.himagetype == TSHORT)
-              histData.hist.i[ipix] += (short) histData.weight;
-            else if (histData.himagetype == TFLOAT)
-              histData.hist.r[ipix] += histData.weight;
-            else if (histData.himagetype == TDOUBLE)
-              histData.hist.d[ipix] += histData.weight;
-            else if (histData.himagetype == TBYTE)
-              histData.hist.b[ipix] += (char) histData.weight;
-        }
-        else if (histData.wtrecip) /* use reciprocal of the weight */
-        {
-            if (histData.himagetype == TINT)
-              histData.hist.j[ipix] += (int) (1./wtcol[ii]);
-            else if (histData.himagetype == TSHORT)
-              histData.hist.i[ipix] += (short) (1./wtcol[ii]);
-            else if (histData.himagetype == TFLOAT)
-              histData.hist.r[ipix] += (float) (1./wtcol[ii]);
-            else if (histData.himagetype == TDOUBLE)
-              histData.hist.d[ipix] += 1./wtcol[ii];
-            else if (histData.himagetype == TBYTE)
-              histData.hist.b[ipix] += (char) (1./wtcol[ii]);
-        }
-        else   /* no weights */
-        {
-            if (histData.himagetype == TINT)
-              histData.hist.j[ipix] += (int) wtcol[ii];
-            else if (histData.himagetype == TSHORT)
-              histData.hist.i[ipix] += (short) wtcol[ii];
-            else if (histData.himagetype == TFLOAT)
-              histData.hist.r[ipix] += wtcol[ii];
-            else if (histData.himagetype == TDOUBLE)
-              histData.hist.d[ipix] += wtcol[ii];
-            else if (histData.himagetype == TBYTE)
-              histData.hist.b[ipix] += (char) wtcol[ii];
-        }
+	} /* end of loop over elements per row */
 
     }  /* end of main loop over all rows */
 
-    return(0);
+    histData->rowselector_cur = rowselect; /* Save row pointer for next go-round */
+    return(status);
 }
```

### Comparing `fitsio-1.1.9/cfitsio3490/imcompress.c` & `fitsio-1.2.0/cfitsio-4.2.0/imcompress.c`

 * *Files 0% similar despite different names*

```diff
@@ -1318,15 +1318,23 @@
 	    
 	    /* Unless dithering has been specifically turned off by setting */
 	    /* request_quantize_method = -1, use dithering by default */
 	    /* when quantizing floating point images. */
 	
 	    if ( (outfptr->Fptr)->request_quantize_method == 0) 
               (outfptr->Fptr)->request_quantize_method = SUBTRACTIVE_DITHER_1;
-       
+            
+            /* HCompress must not use SUBTRACTIVE_DITHER_2. If user is requesting
+               this, assign SUBTRACTIVE_DITHER_1 instead. */
+            if ((outfptr->Fptr)->request_quantize_method == SUBTRACTIVE_DITHER_2
+              && !(strcmp(zcmptype,"HCOMPRESS_1"))) {
+                 (outfptr->Fptr)->request_quantize_method = SUBTRACTIVE_DITHER_1;
+               fprintf(stderr,"Warning: CFITSIO does not allow subtractive_dither_2 when using Hcompress algorithm.\nWill use subtractive_dither_1 instead.\n");
+            }
+                 
 	    if ((outfptr->Fptr)->request_quantize_method == SUBTRACTIVE_DITHER_1) {
 	      ffpkys(outfptr, "ZQUANTIZ", "SUBTRACTIVE_DITHER_1", 
 	        "Pixel Quantization Algorithm", status);
 
 	      /* also write the associated ZDITHER0 keyword with a default value */
 	      /* which may get updated later. */
               ffpky(outfptr, TINT, "ZDITHER0", &((outfptr->Fptr)->request_dither_seed),
```

### Comparing `fitsio-1.1.9/cfitsio3490/imcopy.c` & `fitsio-1.2.0/cfitsio-4.2.0/imcopy.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/install-sh` & `fitsio-1.2.0/cfitsio-4.2.0/install-sh`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iraffits.c` & `fitsio-1.2.0/cfitsio-4.2.0/iraffits.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_a.c` & `fitsio-1.2.0/cfitsio-4.2.0/iter_a.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_a.f` & `fitsio-1.2.0/cfitsio-4.2.0/iter_a.f`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_a.fit` & `fitsio-1.2.0/cfitsio-4.2.0/iter_a.fit`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_b.c` & `fitsio-1.2.0/cfitsio-4.2.0/iter_b.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_b.f` & `fitsio-1.2.0/cfitsio-4.2.0/iter_b.f`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_b.fit` & `fitsio-1.2.0/cfitsio-4.2.0/iter_b.fit`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_c.c` & `fitsio-1.2.0/cfitsio-4.2.0/iter_c.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_c.f` & `fitsio-1.2.0/cfitsio-4.2.0/iter_c.f`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_c.fit` & `fitsio-1.2.0/cfitsio-4.2.0/iter_c.fit`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_image.c` & `fitsio-1.2.0/cfitsio-4.2.0/iter_image.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/iter_var.c` & `fitsio-1.2.0/cfitsio-4.2.0/iter_var.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/longnam.h` & `fitsio-1.2.0/cfitsio-4.2.0/longnam.h`

 * *Files 0% similar despite different names*

```diff
@@ -383,14 +383,15 @@
 #define fits_read_subsetnull_dbl ffgsfd
 
 #define ffcpimg fits_copy_image_section
 #define fits_compress_img fits_comp_img
 #define fits_decompress_img fits_decomp_img
 
 #define fits_read_col        ffgcv
+#define fits_read_cols       ffgcvn
 #define fits_read_colnull    ffgcf
 #define fits_read_col_str    ffgcvs
 #define fits_read_col_log    ffgcvl
 #define fits_read_col_byt    ffgcvb
 #define fits_read_col_sbyt    ffgcvsb
 #define fits_read_col_usht    ffgcvui
 #define fits_read_col_ulng    ffgcvuj
@@ -516,14 +517,15 @@
 #define fits_write_subset_lnglng  ffpssjj
 #define fits_write_subset_uint  ffpssuk
 #define fits_write_subset_int  ffpssk
 #define fits_write_subset_flt  ffpsse
 #define fits_write_subset_dbl  ffpssd
 
 #define fits_write_col         ffpcl
+#define fits_write_cols        ffpcln
 #define fits_write_col_str     ffpcls
 #define fits_write_col_log     ffpcll
 #define fits_write_col_byt     ffpclb
 #define fits_write_col_sbyt     ffpclsb
 #define fits_write_col_usht     ffpclui
 #define fits_write_col_ulng     ffpcluj
 #define fits_write_col_sht     ffpcli
@@ -572,14 +574,15 @@
 #define fits_delete_rowlistll ffdrwsll
 #define fits_insert_col   fficol
 #define fits_insert_cols  fficls
 #define fits_delete_col   ffdcol
 #define fits_copy_col     ffcpcl
 #define fits_copy_cols    ffccls
 #define fits_copy_rows    ffcprw
+#define fits_copy_selrows    ffcpsr
 #define fits_modify_vector_len  ffmvec
 
 #define fits_read_img_coord ffgics
 #define fits_read_img_coord_version ffgicsa
 #define fits_read_tbl_coord ffgtcs
 #define fits_pix_to_world ffwldp
 #define fits_world_to_pix ffxypx
```

### Comparing `fitsio-1.1.9/cfitsio3490/makefile.bc` & `fitsio-1.2.0/cfitsio-4.2.0/makefile.bc`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/makefile.vcc` & `fitsio-1.2.0/cfitsio-4.2.0/makefile.vcc`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/makepc.bat` & `fitsio-1.2.0/cfitsio-4.2.0/makepc.bat`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/modkey.c` & `fitsio-1.2.0/cfitsio-4.2.0/modkey.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/pliocomp.c` & `fitsio-1.2.0/cfitsio-4.2.0/pliocomp.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcol.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcol.c`

 * *Files 2% similar despite different names*

```diff
@@ -883,14 +883,129 @@
              (char *) nulval, status);
     }
     else
       *status = BAD_DATATYPE;
 
     return(*status);
 }
+
+/*--------------------------------------------------------------------------*/
+int ffpcln( fitsfile *fptr,   /* I - FITS file pointer                       */
+	    int ncols,        /* I - number of columns to write              */
+            int  *datatype,   /* I - datatypes of the values                 */
+            int  *colnum,     /* I - columns numbers to write (1 = 1st col)  */
+            LONGLONG  firstrow,   /* I - first row to write (1 = 1st row)    */
+            LONGLONG nrows,       /* I - number of rows to write             */
+            void **array,     /* I - array of pointers to values to write    */
+            void **nulval,    /* I - array of pointers to values for undefined pixels */
+            int  *status)     /* IO - error status                           */
+/*
+  Write arrays of values to NCOLS table columns. This is an optimization
+  to write all columns in one pass through the table.  The datatypes of the
+  input arrays are defined by the 3rd argument.  Data conversion
+  and scaling will be performed if necessary (e.g, if the datatype of
+  the FITS array is not the same as the array being written).
+  Undefined elements for column i that are equal to *(nulval[i]) are set to
+  the defined null value, unless nulval[i]=0,
+  in which case no checking for undefined values will be performed.
+*/
+{
+    LONGLONG ntotrows, ndone, nwrite, currow;
+    long nrowbuf;
+    LONGLONG *repeats = 0;
+    size_t sizes[255] = {0};
+    int icol;
+
+    sizes[TBYTE] = sizes[TSBYTE] = sizes[TLOGICAL] = sizeof(char);
+    sizes[TUSHORT] = sizes[TSHORT] = sizeof(short int);
+    sizes[TINT] = sizes[TUINT] = sizeof(int);
+    sizes[TLONG] = sizes[TULONG] = sizeof(long int);
+    sizes[TLONGLONG] = sizes[TULONGLONG] = sizeof(LONGLONG);
+    sizes[TFLOAT] = sizeof(float);
+    sizes[TDOUBLE] = sizeof(double);
+    sizes[TDBLCOMPLEX] = 2*sizeof(double);
+
+    if (*status > 0)
+        return(*status);
+
+    if (ncols <= 0) return (*status=0);
+
+    repeats = malloc(sizeof(LONGLONG)*ncols);
+    if (repeats == 0) return (*status=MEMORY_ALLOCATION);
+
+    fits_get_num_rowsll(fptr, &ntotrows, status);
+    fits_get_rowsize(fptr, &nrowbuf, status);
+
+    /* Retrieve column repeats */
+    for (icol = 0; (icol < ncols) && (icol < 1000); icol++) {
+      int typecode;
+      LONGLONG repeat, width;
+      fits_get_coltypell(fptr, colnum[icol], &typecode, 
+			 &repeat, &width, status);
+      repeats[icol] = repeat;
+
+      if (datatype[icol] == TBIT || datatype[icol] == TSTRING ||
+	  sizes[datatype[icol]] == 0) {
+	ffpmsg("Cannot write to TBIT or TSTRING datatypes (ffpcln)");
+	*status = BAD_DATATYPE;
+      }
+      if (typecode < 0) {
+	ffpmsg("Cannot write to variable-length data (ffpcln)");
+	*status = BAD_DIMEN;
+      }
+
+      if (*status) break;
+    }
+    if (*status) {
+      free(repeats);
+      return *status;
+    }
+
+    /* Optimize for 1 column */
+    if (ncols == 1) {
+      fits_write_colnull(fptr, datatype[0], colnum[0], firstrow, 1,
+			 nrows*repeats[0], 
+			 array[0], nulval[0], status);
+      free(repeats);
+      return *status;
+    }
+
+    /* Scan through file, in chunks of nrowbuf */
+    currow = firstrow;
+    ndone = 0;
+    while (ndone < nrows) {
+      int icol;
+      nwrite = (nrows-ndone);
+      if (nwrite > nrowbuf) nwrite = nrowbuf;
+
+      for (icol=0; icol<ncols; icol++) {
+	LONGLONG nelem1 = (nwrite*repeats[icol]);
+	char *array1 = (char *) array[icol] + repeats[icol]*ndone*sizes[datatype[icol]];
+
+	fits_write_colnull(fptr, datatype[icol], colnum[icol], ndone+1, 1, 
+			   nelem1, array1, nulval[icol], status);
+	if (*status) {
+	  char errmsg[100];
+	  sprintf(errmsg,
+		  "Failed to write column %d data rows %lld-%lld (ffpcln)",
+		  colnum[icol], currow, currow+nwrite-1);
+	  ffpmsg(errmsg);
+	  break;
+	}
+      }
+
+      if (*status) break;
+      currow += nwrite;
+      ndone += nwrite;
+    }
+
+    free(repeats);
+    return *status;
+}
+
 /*--------------------------------------------------------------------------*/
 int fits_iter_set_by_name(iteratorCol *col, /* I - iterator col structure */
            fitsfile *fptr,  /* I - FITS file pointer                      */
            char *colname,   /* I - column name                            */
            int datatype,    /* I - column datatype                        */
            int iotype)      /* I - InputCol, InputOutputCol, or OutputCol */
 /*
@@ -1102,15 +1217,15 @@
 	    LONGLONG longlongnull;
         } null;
     } colNulls;
 
     void *dataptr, *defaultnull;
     colNulls *col;
     int ii, jj, tstatus, naxis, bitpix;
-    int typecode, hdutype, jtype, type, anynul, nfiles, nbytes;
+    int typecode, hdutype, jtype, type, anynul=0, nfiles, nbytes;
     long totaln, nleft, frow, felement, n_optimum, i_optimum, ntodo;
     long rept, rowrept, width, tnull, naxes[9] = {1,1,1,1,1,1,1,1,1}, groups;
     double zeros = 0.;
     char message[FLEN_ERRMSG], keyname[FLEN_KEYWORD], nullstr[FLEN_VALUE];
     char **stringptr, *nullptr, *cptr;
 
     if (*status > 0)
@@ -1131,22 +1246,36 @@
     ffghdt(cols[0].fptr, &hdutype, status);  /* type of first HDU */
 
     for (jj = 0; jj < n_cols; jj++)
     {
         /* check that output datatype code value is legal */
         type = cols[jj].datatype;  
 
-        /* Allow variable length arrays for InputCol and InputOutputCol columns,
-	   but not for OutputCol columns.  Variable length arrays have a
-	   negative type code value. */
+        /* Allow variable length arrays for InputCol and
+	   InputOutputCol columns, but not for OutputCol/TemporaryCol
+	   columns.  Variable length arrays have a negative type code
+	   value. */
 
-        if ((cols[jj].iotype != OutputCol) && (type<0)) {
+        if ( !((cols[jj].iotype == OutputCol) || (cols[jj].iotype == TemporaryCol))
+	     && (type<0)) {
             type*=-1;
         }
 
+	/* TemporaryCol must have defined datatype and repeat */
+	if (cols[jj].iotype == TemporaryCol &&
+	    (type <= 0 || cols[jj].repeat <= 0)) {
+	  
+	  snprintf(message,FLEN_ERRMSG,
+		   "TemporaryCol column must have defined datatype and repeat for column %d (ffiter)",
+		   jj + 1);
+	  ffpmsg(message);
+	  return(*status = BAD_DATATYPE);
+	}
+
+	/* Check for variable length or illegal data types */
         if (type != 0      && type != TBYTE  &&
             type != TSBYTE && type != TLOGICAL && type != TSTRING &&
             type != TSHORT && type != TINT     && type != TLONG && 
             type != TFLOAT && type != TDOUBLE  && type != TCOMPLEX &&
             type != TULONG && type != TUSHORT  && type != TDBLCOMPLEX &&
 	    type != TLONGLONG )
         {
@@ -1166,15 +1295,20 @@
 
         /* initialize TLMINn, TLMAXn, column name, and display format */
         cols[jj].tlmin = 0;
         cols[jj].tlmax = 0;
         cols[jj].tunit[0] = '\0';
         cols[jj].tdisp[0] = '\0';
 
-        ffghdt(cols[jj].fptr, &jtype, status);  /* get HDU type */
+	/* Determine HDU type of this table (or BINARY_TBL for TemporaryCol) */
+	if (cols[jj].iotype != TemporaryCol) {
+	  ffghdt(cols[jj].fptr, &jtype, status);  /* get HDU type */
+	} else {
+	  hdutype = BINARY_TBL;
+	}
 
         if (hdutype == IMAGE_HDU) /* operating on FITS images */
         {
             if (jtype != IMAGE_HDU)
             {
                 snprintf(message,FLEN_ERRMSG,
                 "File %d not positioned to an image extension (ffiter)",
@@ -1184,81 +1318,92 @@
 
             /* since this is an image, set a dummy column number = 0 */
             cols[jj].colnum = 0;
             strcpy(cols[jj].colname, "IMAGE");  /* dummy name for images */
 
             tstatus = 0;
             ffgkys(cols[jj].fptr, "BUNIT", cols[jj].tunit, 0, &tstatus);
+
+	    if (cols[jj].iotype == TemporaryCol) {
+                snprintf(message,FLEN_ERRMSG,
+			 "Column type TemporaryCol not permitted for IMAGE HDUs (ffiter)");
+                return(*status = BAD_DATATYPE);
+            }
+	      
         }
         else  /* operating on FITS tables */
         {
             if (jtype == IMAGE_HDU)
             {
                 snprintf(message,FLEN_ERRMSG,
                 "File %d not positioned to a table extension (ffiter)",
                     jj + 1);
                 return(*status = NOT_TABLE);
             }
 
-            if (cols[jj].colnum < 1)
-            {
-                /* find the column number for the named column */
-                if (ffgcno(cols[jj].fptr, CASEINSEN, cols[jj].colname,
-                           &cols[jj].colnum, status) )
-                {
-                    snprintf(message,FLEN_ERRMSG,
-                      "Column '%s' not found for column number %d  (ffiter)",
-                       cols[jj].colname, jj + 1);
-                    ffpmsg(message);
-                    return(*status);
-                }
-            }
-
-            /* check that the column number is valid */
-            if (cols[jj].colnum < 1 || 
-                cols[jj].colnum > ((cols[jj].fptr)->Fptr)->tfield)
-            {
-                snprintf(message,FLEN_ERRMSG,
-                  "Column %d has illegal table position number: %d  (ffiter)",
-                    jj + 1, cols[jj].colnum);
-                ffpmsg(message);
-                return(*status = BAD_COL_NUM);
-            }
-
-            /* look for column description keywords and update structure */
-            tstatus = 0;
-            ffkeyn("TLMIN", cols[jj].colnum, keyname, &tstatus);
-            ffgkyj(cols[jj].fptr, keyname, &cols[jj].tlmin, 0, &tstatus);
-
-            tstatus = 0;
-            ffkeyn("TLMAX", cols[jj].colnum, keyname, &tstatus);
-            ffgkyj(cols[jj].fptr, keyname, &cols[jj].tlmax, 0, &tstatus);
-
-            tstatus = 0;
-            ffkeyn("TTYPE", cols[jj].colnum, keyname, &tstatus);
-            ffgkys(cols[jj].fptr, keyname, cols[jj].colname, 0, &tstatus);
-            if (tstatus)
+	    if (cols[jj].iotype != TemporaryCol)
+	    {
+	      if (cols[jj].colnum < 1)
+		{
+		  /* find the column number for the named column */
+		  if (ffgcno(cols[jj].fptr, CASEINSEN, cols[jj].colname,
+			     &cols[jj].colnum, status) )
+		    {
+		      snprintf(message,FLEN_ERRMSG,
+			       "Column '%s' not found for column number %d  (ffiter)",
+			       cols[jj].colname, jj + 1);
+		      ffpmsg(message);
+		      return(*status);
+		    }
+		}
+	      
+	      /* check that the column number is valid */
+	      if (cols[jj].colnum < 1 || 
+		  cols[jj].colnum > ((cols[jj].fptr)->Fptr)->tfield)
+		{
+		  snprintf(message,FLEN_ERRMSG,
+			   "Column %d has illegal table position number: %d  (ffiter)",
+			   jj + 1, cols[jj].colnum);
+		  ffpmsg(message);
+		  return(*status = BAD_COL_NUM);
+		}
+	      
+	      /* look for column description keywords and update structure */
+	      tstatus = 0;
+	      ffkeyn("TLMIN", cols[jj].colnum, keyname, &tstatus);
+	      ffgkyj(cols[jj].fptr, keyname, &cols[jj].tlmin, 0, &tstatus);
+	      
+	      tstatus = 0;
+	      ffkeyn("TLMAX", cols[jj].colnum, keyname, &tstatus);
+	      ffgkyj(cols[jj].fptr, keyname, &cols[jj].tlmax, 0, &tstatus);
+	      
+	      tstatus = 0;
+	      ffkeyn("TTYPE", cols[jj].colnum, keyname, &tstatus);
+	      ffgkys(cols[jj].fptr, keyname, cols[jj].colname, 0, &tstatus);
+	      if (tstatus)
                 cols[jj].colname[0] = '\0';
-
-            tstatus = 0;
-            ffkeyn("TUNIT", cols[jj].colnum, keyname, &tstatus);
-            ffgkys(cols[jj].fptr, keyname, cols[jj].tunit, 0, &tstatus);
-
-            tstatus = 0;
-            ffkeyn("TDISP", cols[jj].colnum, keyname, &tstatus);
-            ffgkys(cols[jj].fptr, keyname, cols[jj].tdisp, 0, &tstatus);
+	      
+	      tstatus = 0;
+	      ffkeyn("TUNIT", cols[jj].colnum, keyname, &tstatus);
+	      ffgkys(cols[jj].fptr, keyname, cols[jj].tunit, 0, &tstatus);
+	      
+	      tstatus = 0;
+	      ffkeyn("TDISP", cols[jj].colnum, keyname, &tstatus);
+	      ffgkys(cols[jj].fptr, keyname, cols[jj].tdisp, 0, &tstatus);
+	    }
         }
     }  /* end of loop over all columns */
 
     /*-----------------------------------------------------------------*/
     /* use the first file to set the total number of values to process */
     /*-----------------------------------------------------------------*/
 
     offset = maxvalue(offset, 0L);  /* make sure offset is legal */
 
+    felement = 0;
     if (hdutype == IMAGE_HDU)   /* get total number of pixels in the image */
     {
       fits_get_img_dim(cols[0].fptr, &naxis, status);
       fits_get_img_size(cols[0].fptr, 9, naxes, status);
 
       tstatus = 0;
       ffgkyj(cols[0].fptr, "GROUPS", &groups, NULL, &tstatus);
@@ -1277,17 +1422,40 @@
           totaln *= naxes[ii];
 
       frow = 1;
       felement = 1 + offset;
     }
     else   /* get total number or rows in the table */
     {
-      ffgkyj(cols[0].fptr, "NAXIS2", &totaln, 0, status);
-      frow = 1 + offset;
-      felement = 1;
+      /* Note the maxvalue here is a special case to deal with
+	 how the calculator treats expressions that have NO 
+	 referenced columns, just constants and other derivable
+	 values like #ROW.  In that case, the calculator creates
+	 a cols[0].fptr even though there is no column for it,
+	 and the iterator is not meant to allocate any space,
+	 etc for the column.  So the maxvalue() here assures
+	 that cols[0] is always checked, even if ncols==0, which
+	 is how the original logic worked.  This is a bit 
+	 dangerous in the sense that, what happens if the user
+	 passes a non-calculator input to this iterator, and
+	 has NOT set fptr to a legitimate FITS handle.  Boom! */
+      for (jj=0; jj < maxvalue(n_cols,1); jj++) {
+	if (cols[jj].iotype != TemporaryCol && cols[jj].fptr) {
+	  ffgkyj(cols[jj].fptr, "NAXIS2", &totaln, 0, status);
+	  frow = 1 + offset;
+	  felement = 1;
+	  break;
+	}
+      }
+      if (felement != 1) {
+	snprintf(message,FLEN_ERRMSG,
+		 "There must be at least one input or output column in iterator (ffiter)");
+	ffpmsg(message);
+	return(*status = BAD_COL_NUM);
+      }
     }
 
     /*  adjust total by the input starting offset value */
     totaln -= offset;
     totaln = maxvalue(totaln, 0L);   /* don't allow negative number */
 
     /*------------------------------------------------------------------*/
@@ -1297,29 +1465,35 @@
     if (n_per_loop == 0)
     {
         /* Determine optimum number of values for each iteration.    */
         /* Look at all the fitsfile pointers to determine the number */
         /* of unique files.                                          */
 
         nfiles = 1;
-        ffgrsz(cols[0].fptr, &n_optimum, status);
+	n_optimum = 0;
+        if (cols[0].iotype != TemporaryCol) ffgrsz(cols[0].fptr, &n_optimum, status);
 
         for (jj = 1; jj < n_cols; jj++)
         {
+	    if (cols[jj].iotype == TemporaryCol) continue;
             for (ii = 0; ii < jj; ii++)
             {
                 if (cols[ii].fptr == cols[jj].fptr)
                    break;
             }
 
             if (ii == jj)  /* this is a new file */
             {
                 nfiles++;
                 ffgrsz(cols[jj].fptr, &i_optimum, status);
-                n_optimum = minvalue(n_optimum, i_optimum);
+		if (n_optimum == 0) { /* If first column is TemporaryCol */
+		  n_optimum = i_optimum;
+		} else {
+		  n_optimum = minvalue(n_optimum, i_optimum);
+		}
             }
         }
 
         /* divid n_optimum by the number of files that will be processed */
         n_optimum = n_optimum / nfiles;
         n_optimum = maxvalue(n_optimum, 1);
     }
@@ -1368,15 +1542,15 @@
                  typecode = TDOUBLE;
                  break;
              case LONGLONG_IMG:
                  typecode = TLONGLONG;
                  break;
             }
         }
-        else
+        else if (cols[jj].iotype != TemporaryCol)
         {
             if (ffgtcl(cols[jj].fptr, cols[jj].colnum, &typecode, &rept,
                   &width, status) > 0)
                 goto cleanup;
 		
 	    if (typecode < 0) {  /* if any variable length arrays, then the */ 
 	        n_optimum = 1;   /* must process the table 1 row at a time */
@@ -1390,14 +1564,36 @@
                 "Variable length array not allowed for output column number %d (ffiter)",
                     jj + 1);
                 ffpmsg(message);
                 return(*status = BAD_DATATYPE);
               }
 	   }
         }
+	else 
+	{
+	    /* TemporaryCol - datatype etc must be defined */
+	    typecode = cols[jj].datatype;
+	    if (typecode <= 0 || typecode == TBIT || typecode == TSTRING) {
+	      snprintf(message,FLEN_ERRMSG,
+		       "Invalid typecode for temporary output column number %d (ffiter)",
+		       jj+1);
+	      ffpmsg(message);
+                return(*status = BAD_DATATYPE);
+	    }
+
+	    rept = cols[jj].repeat;
+	    if (rept <= 0) {
+	      snprintf(message,FLEN_ERRMSG,
+		       "Invalid repeat (%ld) for temporary output column number %d (ffiter)",
+		       rept, jj+1);
+	      ffpmsg(message);
+	      return(*status = BAD_DIMEN);
+	    }
+
+	}
 
         /* special case where sizeof(long) = 8: use TINT instead of TLONG */
         if (abs(typecode) == TLONG && sizeof(long) == 8 && sizeof(int) == 4) {
 		if(typecode<0) {
 			typecode = -TINT;
 		} else {
 			typecode = TINT;
@@ -1419,16 +1615,19 @@
             else
                 cols[jj].datatype = abs(typecode);
         }
 
         /* calc total number of elements to do on each iteration */
         if (hdutype == IMAGE_HDU || cols[jj].datatype == TSTRING)
         {
-            ntodo = n_optimum; 
+            ntodo = n_optimum;
             cols[jj].repeat = 1;
+            /* handle special case of a 0-width string column */
+            if (hdutype == BINARY_TBL && rept == 0)
+               cols[jj].repeat = 0;
 
             /* get the BLANK keyword value, if it exists */
             if (abs(typecode) == TBYTE || abs(typecode) == TSHORT || abs(typecode) == TLONG
                 || abs(typecode) == TINT || abs(typecode) == TLONGLONG)
             {
                 tstatus = 0;
                 ffgkyj(cols[jj].fptr, "BLANK", &tnull, 0, &tstatus);
@@ -1447,15 +1646,15 @@
 	      rept = 1;
 	      for (ii = 0; ii < totaln; ii++) {
 		ffgdes(cols[jj].fptr, cols[jj].colnum, frow + ii, &rowrept, NULL, status);
 		
 		rept = maxvalue(rept, rowrept);
 	      }
             }
-	    
+
             ntodo = n_optimum * rept;   /* vector columns */
             cols[jj].repeat = rept;
 
             /* get the TNULL keyword value, if it exists */
             if (abs(typecode) == TBYTE || abs(typecode) == TSHORT || abs(typecode) == TLONG
                 || abs(typecode) == TINT || abs(typecode) == TLONGLONG)
             {
@@ -1697,15 +1896,16 @@
           cols[jj].array = stringptr;
           col[jj].nullsize  = rept + 1;  /* number of bytes per value */
 
           if (stringptr)
           {
             /* allocate string to store the null string value */
             col[jj].null.stringnull = calloc(rept + 1, sizeof(char) );
-            col[jj].null.stringnull[1] = 1; /* to make sure string != 0 */
+            if (rept > 0)
+               col[jj].null.stringnull[1] = 1; /* to make sure string != 0 */
 
             /* allocate big block for the array of table column strings */
             stringptr[0] = calloc((ntodo + 1) * (rept + 1), sizeof(char) );
 
             if (stringptr[0])
             {
               for (ii = 1; ii <= ntodo; ii++)
@@ -1781,15 +1981,15 @@
     while (nleft)
     {
       ntodo = minvalue(nleft, n_optimum); /* no. of values for this loop */
 
       /*  read input columns from FITS file(s)  */
       for (jj = 0; jj < n_cols; jj++)
       {
-        if (cols[jj].iotype != OutputCol)
+        if (cols[jj].iotype != OutputCol && cols[jj].iotype != TemporaryCol)
         {
           if (cols[jj].datatype == TSTRING)
           {
             stringptr = cols[jj].array;
             dataptr = stringptr + 1;
             defaultnull = col[jj].null.stringnull; /* ptr to the null value */
           }
@@ -1871,15 +2071,15 @@
       if (*status > 0 || *status < -1 ) 
          break;   /* looks like an error occurred; quit immediately */
 
       /*  write output columns  before quiting if status = -1 */
       tstatus = 0;
       for (jj = 0; jj < n_cols; jj++)
       {
-        if (cols[jj].iotype != InputCol)
+        if (cols[jj].iotype != InputCol && cols[jj].iotype != TemporaryCol)
         {
           if (cols[jj].datatype == TSTRING)
           {
             stringptr = cols[jj].array;
             dataptr = stringptr + 1;
             nullptr = *stringptr;
             nbytes = 2;
```

### Comparing `fitsio-1.1.9/cfitsio3490/putcolb.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcolb.c`

 * *Files 1% similar despite different names*

```diff
@@ -352,14 +352,15 @@
   Each row of the table represents a group in the case of multigroup FITS
   images.
 
   The input array of values will be converted to the datatype of the column 
   and will be inverse-scaled by the FITS TSCALn and TZEROn values if necessary.
 */
 {
+    int writemode;
     int tcode, maxelem2, hdutype, writeraw;
     long twidth, incre;
     long  ntodo;
     LONGLONG repeat, startpos, elemnum, wrtptr, rowlen, rownum, remain, next, tnull, maxelem;
     double scale, zero;
     char tform[20], cform[20];
     char message[FLEN_ERRMSG];
@@ -373,15 +374,23 @@
         return(*status);
 
     buffer = cbuff;
 
     /*---------------------------------------------------*/
     /*  Check input and get parameters about the column: */
     /*---------------------------------------------------*/
-    if (ffgcprll( fptr, colnum, firstrow, firstelem, nelem, 1, &scale, &zero,
+
+    /* IMPORTANT NOTE: that the special case of using this subroutine
+       to write bytes to a character column are handled internally
+       by the call to ffgcprll() below.  It will adjust the effective
+       *tcode, repeats, etc, to appear as a TBYTE column. */
+
+    writemode = 17; /* Equivalent to writemode = 1 but allow TSTRING -> TBYTE */
+
+    if (ffgcprll( fptr, colnum, firstrow, firstelem, nelem, writemode, &scale, &zero,
         tform, &twidth, &tcode, &maxelem2, &startpos,  &elemnum, &incre,
         &repeat, &rowlen, &hdutype, &tnull, snull, status) > 0)
         return(*status);
     maxelem = maxelem2;
 
     if (tcode == TSTRING)   
          ffcfmt(tform, cform);     /* derive C format for writing strings */
@@ -477,26 +486,27 @@
                 ffi1fr8(&array[next], ntodo, scale, zero,
                         (double *) buffer, status);
                 ffpr8b(fptr, ntodo, incre, (double *) buffer, status);
                 break;
 
             case (TSTRING):  /* numerical column in an ASCII table */
 
-                if (strchr(tform,'A'))
+	        if (strchr(tform,'A')) 
                 {
                     /* write raw input bytes without conversion        */
                     /* This case is a hack to let users write a stream */
                     /* of bytes directly to the 'A' format column      */
 
-                    if (incre == twidth)
+		  if (incre == twidth) {
                         ffpbyt(fptr, ntodo, &array[next], status);
-                    else
+		  } else {
                         ffpbytoff(fptr, twidth, ntodo/twidth, incre - twidth, 
                                 &array[next], status);
-                    break;
+		  }
+		  break;
                 }
                 else if (cform[1] != 's')  /*  "%s" format is a string */
                 {
                   ffi1fstr(&array[next], ntodo, scale, zero, cform,
                           twidth, (char *) buffer, status);
 
                   if (incre == twidth)    /* contiguous bytes */
```

### Comparing `fitsio-1.1.9/cfitsio3490/putcold.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcold.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcole.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcole.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcoli.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcoli.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcolj.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcolj.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcolk.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcolk.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcoll.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcoll.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcols.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcols.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcolsb.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcolsb.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcolu.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcolu.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcolui.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcolui.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcoluj.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcoluj.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putcoluk.c` & `fitsio-1.2.0/cfitsio-4.2.0/putcoluk.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/putkey.c` & `fitsio-1.2.0/cfitsio-4.2.0/putkey.c`

 * *Files 0% similar despite different names*

```diff
@@ -453,15 +453,19 @@
     contin = 0;
     next = 0;                  /* pointer to next character to write */
 
     while (remain > 0)
     {
         tstring[0] = '\0';
         strncat(tstring, &value[next], nchar); /* copy string to temp buff */
-        ffs2c(tstring, valstring, status);  /* expand quotes, and put quotes around the string */
+        /* expand quotes, and put quotes around the string */
+        if (contin)
+           ffs2c_nopad(tstring,valstring,status);
+        else
+           ffs2c(tstring, valstring, status);  
 
         if (remain > nchar)   /* if string is continued, put & as last char */
         {
             vlen = strlen(valstring);
             nchar -= 1;        /* outputting one less character now */
 
             if (valstring[vlen-2] != '\'')
@@ -1397,20 +1401,21 @@
         else if (slen < 19) 
         {
             ffpmsg("input date string has illegal format:");
             ffpmsg(datestr);
             return(*status = BAD_DATE);
         }
 
-        else if (datestr[10] == 'T' && datestr[13] == ':' && datestr[16] == ':')
+        else if (datestr[10] == 'T')
         {
-          if (isdigit((int) datestr[11]) && isdigit((int) datestr[12])
-           && isdigit((int) datestr[14]) && isdigit((int) datestr[15])
-           && isdigit((int) datestr[17]) && isdigit((int) datestr[18]) )
-            {
+          if (datestr[13] == ':' && datestr[16] == ':') {
+            if (isdigit((int) datestr[11]) && isdigit((int) datestr[12])
+             && isdigit((int) datestr[14]) && isdigit((int) datestr[15])
+             && isdigit((int) datestr[17]) && isdigit((int) datestr[18]) )
+             {
                 if (slen > 19 && datestr[19] != '.')
                 {
                   ffpmsg("input date string has illegal format:");
                   ffpmsg(datestr);
                   return(*status = BAD_DATE);
                 }
 
@@ -1419,22 +1424,29 @@
                     *hour   = atoi(&datestr[11]);
 
                 if (minute)
                     *minute = atoi(&datestr[14]);
 
                 if (second)
                     *second = atof(&datestr[17]);
-            }
-            else
-            {
+             }
+             else
+             {
                   ffpmsg("input date string has illegal format:");
                   ffpmsg(datestr);
                   return(*status = BAD_DATE);
-            }
+             }
 
+          }
+          else
+          {
+               ffpmsg("input date string has illegal format:");
+               ffpmsg(datestr);
+               return(*status = BAD_DATE);
+          }
         }
     }
     else   /* no date fields */
     {
         if (datestr[2] == ':' && datestr[5] == ':')   /* time string */
         {
             if (isdigit((int) datestr[0]) && isdigit((int) datestr[1])
@@ -1560,15 +1572,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -1619,15 +1631,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -1679,15 +1691,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -1737,15 +1749,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -1796,15 +1808,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -1855,15 +1867,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -1914,15 +1926,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -1973,15 +1985,15 @@
     if (comm)
     {
       len = strlen(comm[0]);
 
       while (len > 0  && comm[0][len - 1] == ' ')
         len--;                               /* ignore trailing blanks */
 
-      if (comm[0][len - 1] == '&')
+      if (len > 0 && comm[0][len - 1] == '&')
       {
         len = minvalue(len, FLEN_COMMENT);
         tcomment[0] = '\0';
         strncat(tcomment, comm[0], len-1); /* don't copy the final '&' char */
         repeat = 1;
       }
     }
@@ -3002,14 +3014,16 @@
 int ffs2c(const char *instr, /* I - null terminated input string  */
           char *outstr,      /* O - null terminated quoted output string */
           int *status)       /* IO - error status */
 /*
   convert an input string to a quoted string. Leading spaces 
   are significant.  FITS string keyword values must be at least 
   8 chars long so pad out string with spaces if necessary.
+  (*** This 8 char requirement is now obsolete.  See ffs2c_nopad
+  for an alternative ***)
       Example:   km/s ==> 'km/s    '
   Single quote characters in the input string will be replace by
   two single quote characters. e.g., o'brian ==> 'o''brian'
 */
 {
     size_t len, ii, jj;
 
@@ -3043,14 +3057,65 @@
 
     if (jj == 70)   /* only occurs if the last char of string was a quote */
         outstr[69] = '\0';
     else
     {
         outstr[jj] = '\'';         /* append closing quote character */
         outstr[jj+1] = '\0';          /* terminate the string */
+    }
+
+    return(*status);
+}
+/*--------------------------------------------------------------------------*/
+int ffs2c_nopad(const char *instr, /* I - null terminated input string  */
+          char *outstr,      /* O - null terminated quoted output string */
+          int *status)       /* IO - error status */
+/*
+   This performs identically to ffs2c except that it won't pad output
+   strings to make them a minimum of 8 chars long.  The requirement
+   that FITS keyword string values be 8 characters is now obsolete
+   (except for "XTENSION" keyword), but for backwards compatibility we'll
+   keep ffs2c the way it is.  A better solution would be to add another
+   argument to ffs2c for 'pad' or 'nopad', but it is called from many other
+   places in Heasoft outside of CFITSIO.  
+*/
+{
+    size_t len, ii, jj;
+
+    if (*status > 0)           /* inherit input status value if > 0 */
+        return(*status);
+
+    if (!instr)            /* a null input pointer?? */
+    {
+       strcpy(outstr, "''");   /* a null FITS string */
+       return(*status);
+    }
+
+    outstr[0] = '\'';      /* start output string with a quote */
+
+    len = strlen(instr);
+    if (len > 68)
+        len = 68;    /* limit input string to 68 chars */
+
+    for (ii=0, jj=1; ii < len && jj < 69; ii++, jj++)
+    {
+        outstr[jj] = instr[ii];  /* copy each char from input to output */
+        if (instr[ii] == '\'')
+        {
+            jj++;
+            outstr[jj]='\'';   /* duplicate any apostrophies in the input */
+        }
+    }
+
+    if (jj == 70)   /* only occurs if the last char of string was a quote */
+        outstr[69] = '\0';
+    else
+    {
+        outstr[jj] = '\'';         /* append closing quote character */
+        outstr[jj+1] = '\0';          /* terminate the string */
     }
 
     return(*status);
 }
 /*--------------------------------------------------------------------------*/
 int ffr2f(float fval,   /* I - value to be converted to a string */
           int  decim,   /* I - number of decimal places to display */
```

### Comparing `fitsio-1.1.9/cfitsio3490/quantize.c` & `fitsio-1.2.0/cfitsio-4.2.0/quantize.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/region.c` & `fitsio-1.2.0/cfitsio-4.2.0/region.c`

 * *Files 2% similar despite different names*

```diff
@@ -976,25 +976,66 @@
    result = result || comp_result;
    
    return( result );
 }
 
 /*---------------------------------------------------------------------------*/
 void fits_free_region( SAORegion *Rgn )
-/*   Free up memory allocated to hold the region data.                       */
+/*   Free up memory allocated to hold the region data.                       
+   This is more complicated for the case of polygons, which may be sharing
+   points arrays due to shallow copying (in fits_set_region_components) of
+   'exluded' regions.  We must ensure that these arrays are only freed once.       
+
 /*---------------------------------------------------------------------------*/
 {
-   int i;
+   int i,j;
+   
+   int nFreedPoly=0;
+   int nPolyArraySize=10;
+   double **freedPolyPtrs=0;
+   double *ptsToFree=0;
+   int isAlreadyFreed=0;
+   
+   freedPolyPtrs = (double**)malloc(nPolyArraySize*sizeof(double*));
 
    for( i=0; i<Rgn->nShapes; i++ )
       if( Rgn->Shapes[i].shape == poly_rgn )
-         free( Rgn->Shapes[i].param.poly.Pts );
+      {
+         /* No shared arrays for 'include' polygons */
+         if (Rgn->Shapes[i].sign)
+            free(Rgn->Shapes[i].param.poly.Pts);
+         else
+         {
+            ptsToFree = Rgn->Shapes[i].param.poly.Pts;
+            isAlreadyFreed = 0;
+            for (j=0; j<nFreedPoly && !isAlreadyFreed; j++)
+            {
+               if (freedPolyPtrs[j] == ptsToFree)
+                  isAlreadyFreed = 1;
+            }
+            if (!isAlreadyFreed)
+            {
+               free(ptsToFree);
+               /* Now add pointer to array of freed points */
+               if (nFreedPoly == nPolyArraySize)
+               {
+                  nPolyArraySize *= 2;
+                  freedPolyPtrs = (double **)realloc(freedPolyPtrs, 
+                          nPolyArraySize*sizeof(double*));
+               }
+               freedPolyPtrs[nFreedPoly] = ptsToFree;
+               ++nFreedPoly;
+            }
+         }
+      }
    if( Rgn->Shapes )
       free( Rgn->Shapes );
    free( Rgn );
+   
+   free(freedPolyPtrs);
 }
 
 /*---------------------------------------------------------------------------*/
 static int Pt_in_Poly( double x,
                        double y,
                        int nPts,
                        double *Pts )
@@ -1101,14 +1142,18 @@
 
       /* and loop back through the regions */
 
       while ( j >= 0 ) {
 
 	/* if this is an include region then insert a copy of the exclude
 	   region immediately after it */
+           
+        /* Note that this makes shallow copies of a polygon's dynamically
+        allocated Pts array -- the memory is shared.  This must be checked
+        when freeing in fits_free_region. */
 
 	if ( aRgn->Shapes[j].sign ) {
 
 	  aRgn->Shapes = (RgnShape *) realloc (aRgn->Shapes,(1+aRgn->nShapes)*sizeof(RgnShape));
 	  aRgn->nShapes++;
 	  for (k=aRgn->nShapes-1; k>j+1; k--) aRgn->Shapes[k] = aRgn->Shapes[k-1];
```

### Comparing `fitsio-1.1.9/cfitsio3490/region.h` & `fitsio-1.2.0/cfitsio-4.2.0/region.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/ricecomp.c` & `fitsio-1.2.0/cfitsio-4.2.0/ricecomp.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/sample.tpl` & `fitsio-1.2.0/cfitsio-4.2.0/sample.tpl`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/scalnull.c` & `fitsio-1.2.0/cfitsio-4.2.0/scalnull.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/simplerng.c` & `fitsio-1.2.0/cfitsio-4.2.0/simplerng.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/simplerng.h` & `fitsio-1.2.0/cfitsio-4.2.0/simplerng.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/smem.c` & `fitsio-1.2.0/cfitsio-4.2.0/smem.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/speed.c` & `fitsio-1.2.0/cfitsio-4.2.0/speed.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/swapproc.c` & `fitsio-1.2.0/cfitsio-4.2.0/swapproc.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/testf77.f` & `fitsio-1.2.0/cfitsio-4.2.0/testf77.f`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/testf77.out` & `fitsio-1.2.0/cfitsio-4.2.0/testf77.out`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/testf77.std` & `fitsio-1.2.0/cfitsio-4.2.0/testf77.std`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/testprog.c` & `fitsio-1.2.0/cfitsio-4.2.0/testprog.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/testprog.out` & `fitsio-1.2.0/cfitsio-4.2.0/testprog.out`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/testprog.std` & `fitsio-1.2.0/cfitsio-4.2.0/testprog.std`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/vmsieee.c` & `fitsio-1.2.0/cfitsio-4.2.0/vmsieee.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/wcssub.c` & `fitsio-1.2.0/cfitsio-4.2.0/wcssub.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/wcsutil.c` & `fitsio-1.2.0/cfitsio-4.2.0/wcsutil.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/winDumpExts.mak` & `fitsio-1.2.0/cfitsio-4.2.0/winDumpExts.mak`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/windumpexts.c` & `fitsio-1.2.0/cfitsio-4.2.0/windumpexts.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/adler32.c` & `fitsio-1.2.0/zlib/adler32.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/crc32.c` & `fitsio-1.2.0/zlib/crc32.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/crc32.h` & `fitsio-1.2.0/zlib/crc32.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/deflate.c` & `fitsio-1.2.0/zlib/deflate.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/deflate.h` & `fitsio-1.2.0/zlib/deflate.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/infback.c` & `fitsio-1.2.0/zlib/infback.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/inffast.c` & `fitsio-1.2.0/zlib/inffast.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/inffixed.h` & `fitsio-1.2.0/zlib/inffixed.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/inflate.c` & `fitsio-1.2.0/zlib/inflate.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/inflate.h` & `fitsio-1.2.0/zlib/inflate.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/inftrees.c` & `fitsio-1.2.0/zlib/inftrees.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/inftrees.h` & `fitsio-1.2.0/zlib/inftrees.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/trees.c` & `fitsio-1.2.0/zlib/trees.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/trees.h` & `fitsio-1.2.0/zlib/trees.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/uncompr.c` & `fitsio-1.2.0/zlib/uncompr.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/zcompress.c` & `fitsio-1.2.0/cfitsio-4.2.0/zcompress.c`

 * *Files 4% similar despite different names*

```diff
@@ -114,16 +114,16 @@
 
         for (;;) {
             /* uncompress as much of the input as will fit in the output */
             err = inflate(&d_stream, Z_NO_FLUSH);
 
             if (err == Z_STREAM_END ) { /* We reached the end of the input */
 	        break; 
-            } else if (err == Z_OK ) { 
-
+            } else if (err == Z_OK || err == Z_BUF_ERROR) { 
+	        /* Z_BUF_ERROR means need more input data to make progress */
                 if (!d_stream.avail_in) break; /* need more input */
 		
                 /* need more space in output buffer */
                 /* First check if more memory is available above the
                     4Gb limit in the originally input buffptr array */
                 if (iPage < nPages)
                 {
@@ -217,15 +217,16 @@
 
     for (;;) {
         /* uncompress as much of the input as will fit in the output */
         err = inflate(&d_stream, Z_NO_FLUSH);
 
         if (err == Z_STREAM_END) { /* We reached the end of the input */
 	    break; 
-        } else if (err == Z_OK ) { /* need more space in output buffer */
+        } else if (err == Z_OK || err == Z_BUF_ERROR) { /* need more space in output buffer */
+	    /* Z_BUF_ERROR means need more input data to make progress */
 
             if (mem_realloc) {   
                 *buffptr = mem_realloc(*buffptr,*buffsize + BUFFINCR);
                 if (*buffptr == NULL){
                     inflateEnd(&d_stream);
                     return(*status = 414);  /* memory allocation failed */
                 }
@@ -309,15 +310,16 @@
 
         for (;;) {
             /* uncompress as much of the input as will fit in the output */
             err = inflate(&d_stream, Z_NO_FLUSH);
 
             if (err == Z_STREAM_END ) { /* We reached the end of the input */
 	        break; 
-            } else if (err == Z_OK ) { 
+            } else if (err == Z_OK || err == Z_BUF_ERROR) { 
+	        /* Z_BUF_ERROR means need more input data to make progress */
 
                 if (!d_stream.avail_in) break; /* need more input */
 		
                 /* flush out the full output buffer */
                 if ((int)fwrite(outfilebuff, 1, GZBUFSIZE, outdiskfile) != GZBUFSIZE) {
                     inflateEnd(&d_stream);
                     free(infilebuff);
```

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/zconf.h` & `fitsio-1.2.0/zlib/zconf.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/zlib.h` & `fitsio-1.2.0/zlib/zlib.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/zuncompress.c` & `fitsio-1.2.0/cfitsio-4.2.0/zuncompress.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/zutil.c` & `fitsio-1.2.0/zlib/zutil.c`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/cfitsio3490/zlib/zutil.h` & `fitsio-1.2.0/zlib/zutil.h`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/__init__.py` & `fitsio-1.2.0/fitsio/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # flake8: noqa
 """
 A python library to read and write data to FITS files using cfitsio.
 See the docs at https://github.com/esheldon/fitsio for example
 usage.
 """
 
-__version__ = '1.1.9'
+__version__ = '1.2.0'
 
 from . import fitslib
 
 from .fitslib import (
     FITS,
     read,
     read_header,
```

### Comparing `fitsio-1.1.9/fitsio/fitsio_pywrap.c` & `fitsio-1.2.0/fitsio/fitsio_pywrap.c`

 * *Files 0% similar despite different names*

```diff
@@ -23,15 +23,14 @@
 #include <string.h>
 #include <Python.h>
 #include "fitsio.h"
 #include "fitsio2.h"
 //#include "fitsio_pywrap_lists.h"
 #include <numpy/arrayobject.h>
 
-
 // this is not defined anywhere in cfitsio except in
 // the fits file structure
 #define CFITSIO_MAX_ARRAY_DIMS 99
 
 // not sure where this is defined in numpy...
 #define NUMPY_MAX_DIMS 32
 
@@ -41,18 +40,23 @@
 };
 
 #ifdef FITSIO_PYWRAP_ALWAYS_NONSTANDARD_STRINGS
 static int fits_use_standard_strings(void)
 {
     return 0;
 }
+#else
+#ifndef _FITSIO_H_FITS_USE_STANDARD_STRINGS
+#define _FITSIO_H_FITS_USE_STANDARD_STRINGS
+int CFITS_API fits_use_standard_strings(void);
+#endif
 #endif
-
 
 // check unicode for python3, string for python2
+static
 int is_python_string(const PyObject* obj)
 {
 #if PY_MAJOR_VERSION >= 3
     return PyUnicode_Check(obj) || PyBytes_Check(obj);
 #else
     return PyUnicode_Check(obj) || PyString_Check(obj);
 #endif
@@ -388,14 +392,15 @@
     Py_XINCREF(Py_None);
 }
 static
 void add_true_to_dict(PyObject* dict, const char* key) {
     PyDict_SetItemString(dict, key, Py_True);
     Py_XINCREF(Py_True);
 }
+static
 void add_false_to_dict(PyObject* dict, const char* key) {
     PyDict_SetItemString(dict, key, Py_False);
     Py_XINCREF(Py_False);
 }
 
 
 /*
@@ -2739,14 +2744,15 @@
         return NULL;
     }
 
     Py_RETURN_NONE;
 }
 
 //   ADW: Adapted from ffpcom and ffphis in putkey.c
+static
 int fits_write_continue( fitsfile *fptr,      /* I - FITS file pointer  */
                          const char *cont,    /* I - continue string    */
                          int   *status)       /* IO - error status      */
 /*
   Write 1 or more CONTINUE keywords.  If the history string is too
   long to fit on a single keyword (72 chars) then it will automatically
   be continued on multiple CONTINUE keywords.
@@ -3201,33 +3207,29 @@
     tcolumn* colptr=NULL;
     LONGLONG file_pos=0, irow=0;
     npy_int64 row=0, si=0;
 
     LONGLONG repeat=0;
     LONGLONG width=0;
 
-    int rows_sent=0;
-
     // use char for pointer arith.  It's actually ok to use void as char but
     // this is just in case.
     char *data=NULL, *ptr=NULL;
 
     data = (char *) vdata;
 
     // using struct defs here, could cause problems
     hdu = fits->Fptr;
     colptr = hdu->tableptr + (colnum-1);
 
     repeat = colptr->trepeat;
     width = colptr->tdatatype == TSTRING ? 1 : colptr->twidth;
 
-    rows_sent = nrows == hdu->numrows ? 0 : 1;
-
     for (irow=0; irow<nrows; irow++) {
-        if (rows_sent) {
+        if (rows != NULL) {
             si = sortind[irow];
             row = rows[si];
         } else {
             row = irow;
         }
 
         ptr = data + si * stride;
@@ -3535,29 +3537,26 @@
     FITSfile* hdu=NULL;
     tcolumn* colptr=NULL;
     LONGLONG file_pos=0;
     npy_intp col=0;
     npy_int64 colnum=0;
     char* ptr=NULL;
 
-    int rows_sent=0;
     npy_intp irow=0;
     npy_int64 row=0, si=0;
 
     LONGLONG gsize=0; // number of bytes in column
     LONGLONG repeat=0;
     LONGLONG width=0;
 
     // using struct defs here, could cause problems
     hdu = fits->Fptr;
 
-    rows_sent = (nrows == hdu->numrows) ? 0 : 1;
-
     for (irow=0; irow < nrows; irow++) {
-        if (rows_sent) {
+        if (rows != NULL) {
             si = sortind[irow];
             row = rows[si];
         } else {
             si = irow;
             row = irow;
         }
 
@@ -3640,15 +3639,21 @@
 
     hdu = self->fits->Fptr;
 
     if (rowsObj == Py_None) {
         nrows = hdu->numrows;
     } else {
         rows = get_int64_from_array(rowsObj, &nrows);
+        if (rows == NULL) {
+            return NULL;
+        }
         sortind = get_int64_from_array(sortindObj, &nsortind);
+        if (sortind == NULL) {
+            return NULL;
+        }
     }
     if (read_binary_rec_columns(
             self->fits, ncols, colnums,
             nrows, rows, sortind, array, &status)) {
         goto recread_columns_cleanup;
     }
```

### Comparing `fitsio-1.1.9/fitsio/fitslib.py` & `fitsio-1.2.0/fitsio/fitslib.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/hdu/base.py` & `fitsio-1.2.0/fitsio/hdu/base.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/hdu/image.py` & `fitsio-1.2.0/fitsio/hdu/image.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/hdu/table.py` & `fitsio-1.2.0/fitsio/hdu/table.py`

 * *Files 0% similar despite different names*

```diff
@@ -1095,15 +1095,15 @@
         w, = np.where(isvar == True)  # noqa
         if w.size > 0:
             if vstorage is None:
                 _vstorage = self._vstorage
             else:
                 _vstorage = vstorage
             rows = np.arange(firstrow, lastrow, step, dtype='i8')
-            sortind = np.arange(rows.size)
+            sortind = np.arange(rows.size, dtype='i8')
             colnums = self._extract_colnums()
             array = self._read_rec_with_var(
                 colnums, rows, sortind, dtype, offsets, isvar, _vstorage)
         else:
             if step != 1:
                 rows = np.arange(firstrow, lastrow, step, dtype='i8')
                 array = self.read(rows=rows)
@@ -1421,16 +1421,16 @@
         """
         if rows is not None:
             rows = np.array(rows, ndmin=1, copy=False, dtype='i8')
             if sort:
                 rows = np.unique(rows)
                 return rows, None
 
-            # returns unique, sorted
-            sortind = rows.argsort()
+            # returns unique, sorted.  Force i8 for 32-bit systems
+            sortind = np.array(rows.argsort(), dtype='i8', copy=False)
 
             maxrow = self._info['nrows']-1
             if rows.size > 0:
                 firstrow = rows[sortind[0]]
                 lastrow = rows[sortind[-1]]
 
                 if len(rows) > 0 and (firstrow < 0 or lastrow > maxrow):
```

### Comparing `fitsio-1.1.9/fitsio/header.py` & `fitsio-1.2.0/fitsio/header.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/test_images/test_gzip_compressed_image.fits.fz` & `fitsio-1.2.0/fitsio/test_images/test_gzip_compressed_image.fits.fz`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/checks.py` & `fitsio-1.2.0/fitsio/tests/checks.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/makedata.py` & `fitsio-1.2.0/fitsio/tests/makedata.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 lorem_ipsum = (
     'Lorem ipsum dolor sit amet, consectetur adipiscing '
     'elit, sed do eiusmod tempor incididunt ut labore '
     'et dolore magna aliqua'
 )
 
 
-@lru_cache
+@lru_cache(maxsize=1)
 def make_data():
 
     nvec = 2
     ashape = (21, 21)
     Sdtype = 'S6'
     Udtype = 'U6'
```

### Comparing `fitsio-1.1.9/fitsio/tests/test_header.py` & `fitsio-1.2.0/fitsio/tests/test_header.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/test_header_junk.py` & `fitsio-1.2.0/fitsio/tests/test_header_junk.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/test_image.py` & `fitsio-1.2.0/fitsio/tests/test_image.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/test_image_compression.py` & `fitsio-1.2.0/fitsio/tests/test_image_compression.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/test_lib.py` & `fitsio-1.2.0/fitsio/tests/test_lib.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/test_table.py` & `fitsio-1.2.0/fitsio/tests/test_table.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/tests/test_warnings.py` & `fitsio-1.2.0/fitsio/tests/test_warnings.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio/util.py` & `fitsio-1.2.0/fitsio/util.py`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/fitsio.egg-info/PKG-INFO` & `fitsio-1.2.0/fitsio.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: fitsio
-Version: 1.1.9
+Version: 1.2.0
 Summary: A full featured python library to read from and write to FITS files.
 Home-page: https://github.com/esheldon/fitsio
 Author: Erin Scott Sheldon
 Author-email: erin.sheldon@gmail.com
 License: GPL
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: License :: OSI Approved :: GNU General Public License (GPL)
```

### Comparing `fitsio-1.1.9/patches/README.md` & `fitsio-1.2.0/patches/README.md`

 * *Files identical despite different names*

### Comparing `fitsio-1.1.9/patches/build_cfitsio_patches.py` & `fitsio-1.2.0/patches/build_cfitsio_patches.py~`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,10 @@
 import os
+import sys
+import subprocess
 
 VERSION = '3.47'
 SRC_URL = (
     "https://heasarc.gsfc.nasa.gov/FTP/software/"
     "fitsio/c/cfitsio-%s.tar.gz" % VERSION)
 SRC_TARBALL = os.path.basename(SRC_URL)
 SRC_DIR = os.path.basename(SRC_URL).replace('.tar.gz', '')
```

### Comparing `fitsio-1.1.9/patches/fitscore.c.patch` & `fitsio-1.2.0/patches/fitscore.c.patch`

 * *Files 11% similar despite different names*

```diff
@@ -1,22 +1,24 @@
---- cfitsio3470/fitscore.c	2018-03-01 10:28:51.000000000 -0600
-+++ cfitsio3470/fitscore.c	2018-12-14 08:39:20.000000000 -0600
-@@ -182,6 +182,19 @@
-
+--- cfitsio-4.2.0/fitscore.c	2022-10-31 14:40:23.000000000 -0400
++++ cfitsio-4.2.0/fitscore.c	2023-07-14 11:47:54.870417064 -0400
+@@ -194,6 +194,21 @@
+ 
      return(*version);
  }
 +
++
 +/*
 +   Return 1 if we are to treat strings per the FITS standard (not
 +   replacing nulls with spaces, and not padding with spaces)
 +*/
 +int fits_use_standard_strings(void) {
 +#ifdef FITS_USE_STANDARD_STRINGS
 +    return 1;
 +#else
 +    return 0;
 +#endif
 +}
 +
++
  /*--------------------------------------------------------------------------*/
  int ffflnm(fitsfile *fptr,    /* I - FITS file pointer  */
             char *filename,    /* O - name of the file   */
```

### Comparing `fitsio-1.1.9/patches/putcols.c.patch` & `fitsio-1.2.0/patches/putcols.c.patch`

 * *Files 14% similar despite different names*

```diff
@@ -1,19 +1,20 @@
---- cfitsio3470/putcols.c	2018-03-01 10:28:51.000000000 -0600
-+++ cfitsio3470/putcols.c	2018-12-14 08:39:20.000000000 -0600
-@@ -158,7 +158,16 @@
-
+--- cfitsio-4.2.0/putcols.c	2022-10-31 14:40:24.000000000 -0400
++++ cfitsio-4.2.0/putcols.c	2023-07-14 11:49:03.954820768 -0400
+@@ -157,7 +157,16 @@
+ 
           for (;jj < twidth; jj++)    /* fill field with blanks, if needed */
           {
 -           *buffer = ' ';
-+             if ( fits_use_standard_strings() ) {
-+                 if (snull[0] == ASCII_NULL_UNDEFINED) {
-+                     *buffer = ' ';
-+                 } else {
-+                     *buffer = '\0';
-+                 }
-+             } else {
-+                 *buffer = ' ';
-+             }
++           if ( fits_use_standard_strings() ) {
++               if (snull[0] == ASCII_NULL_UNDEFINED) {
++                   *buffer = ' ';
++               } else {
++                   *buffer = '\0';
++               }
++           } else {
++               *buffer = ' ';
++           }
 +
             buffer++;
           }
+
```

### Comparing `fitsio-1.1.9/setup.py` & `fitsio-1.2.0/setup.py`

 * *Files 25% similar despite different names*

```diff
@@ -4,58 +4,92 @@
 # c.f.
 # https://packaging.python.org/guides/distributing-packages-using-setuptools/
 
 from __future__ import print_function
 from setuptools import setup, Extension, find_packages
 from setuptools.command.build_ext import build_ext
 
+import sys
 import os
 import subprocess
 from subprocess import Popen, PIPE
 import glob
 import shutil
 
 
-class build_ext_subclass(build_ext):
-    boolean_options = build_ext.boolean_options + ['use-system-fitsio']
+if "--use-system-fitsio" in sys.argv:
+    del sys.argv[sys.argv.index("--use-system-fitsio")]
+    USE_SYSTEM_FITSIO = True
+else:
+    USE_SYSTEM_FITSIO = False or "FITSIO_USE_SYSTEM_FITSIO" in os.environ
+
+if (
+    "--system-fitsio-includedir" in sys.argv
+    or any(a.startswith("--system-fitsio-includedir=") for a in sys.argv)
+):
+    if "--system-fitsio-includedir" in sys.argv:
+        ind = sys.argv.index("--system-fitsio-includedir")
+        SYSTEM_FITSIO_INCLUDEDIR = sys.argv[ind+1]
+        del sys.argv[ind+1]
+        del sys.argv[ind]
+    else:
+        for ind in range(len(sys.argv)):
+            if sys.argv[ind].startswith("--system-fitsio-includedir="):
+                break
+        SYSTEM_FITSIO_INCLUDEDIR = sys.argv[ind].split("=", 1)[1]
+        del sys.argv[ind]
+else:
+    SYSTEM_FITSIO_INCLUDEDIR = os.environ.get(
+        "FITSIO_SYSTEM_FITSIO_INCLUDEDIR",
+        None,
+    )
+
+
+if (
+    "--system-fitsio-libdir" in sys.argv
+    or any(a.startswith("--system-fitsio-libdir=") for a in sys.argv)
+):
+    if "--system-fitsio-libdir" in sys.argv:
+        ind = sys.argv.index("--system-fitsio-libdir")
+        SYSTEM_FITSIO_LIBDIR = sys.argv[ind+1]
+        del sys.argv[ind+1]
+        del sys.argv[ind]
+    else:
+        for ind in range(len(sys.argv)):
+            if sys.argv[ind].startswith("--system-fitsio-libdir="):
+                break
+        SYSTEM_FITSIO_LIBDIR = sys.argv[ind].split("=", 1)[1]
+        del sys.argv[ind]
+else:
+    SYSTEM_FITSIO_LIBDIR = os.environ.get(
+        "FITSIO_SYSTEM_FITSIO_LIBDIR",
+        None,
+    )
+
 
-    user_options = build_ext.user_options + [
-        ('use-system-fitsio', None, "Use the cfitsio installed in the system"),
-        ('system-fitsio-includedir=', None,
-         "Path to look for cfitsio header; default is "
-         "the system search path."),
-        ('system-fitsio-libdir=', None,
-         "Path to look for cfitsio library; default is "
-         "the system search path."),
-    ]
-    cfitsio_version = '3490'
-    cfitsio_dir = 'cfitsio%s' % cfitsio_version
-
-    def initialize_options(self):
-        self.use_system_fitsio = False
-        self.system_fitsio_includedir = None
-        self.system_fitsio_libdir = None
-        build_ext.initialize_options(self)
+class build_ext_subclass(build_ext):
+    cfitsio_version = '4.2.0'
+    cfitsio_dir = 'cfitsio-%s' % cfitsio_version
 
     def finalize_options(self):
 
         build_ext.finalize_options(self)
 
         self.cfitsio_build_dir = os.path.join(
             self.build_temp, self.cfitsio_dir)
         self.cfitsio_zlib_dir = os.path.join(
             self.cfitsio_build_dir, 'zlib')
         self.cfitsio_patch_dir = os.path.join(
             self.build_temp, 'patches')
 
-        if self.use_system_fitsio:
-            if self.system_fitsio_includedir:
-                self.include_dirs.insert(0, self.system_fitsio_includedir)
-            if self.system_fitsio_libdir:
-                self.library_dirs.insert(0, self.system_fitsio_libdir)
+        if USE_SYSTEM_FITSIO:
+            if SYSTEM_FITSIO_INCLUDEDIR is not None:
+                self.include_dirs.insert(0, SYSTEM_FITSIO_INCLUDEDIR)
+            if SYSTEM_FITSIO_LIBDIR is not None:
+                self.library_dirs.insert(0, SYSTEM_FITSIO_LIBDIR)
         else:
             # We defer configuration of the bundled cfitsio to build_extensions
             # because we will know the compiler there.
             self.include_dirs.insert(0, self.cfitsio_build_dir)
 
     def run(self):
         # For extensions that require 'numpy' in their include dirs,
@@ -68,19 +102,23 @@
                 idx = extension.include_dirs.index('numpy')
                 extension.include_dirs.insert(idx, np_include)
                 extension.include_dirs.remove('numpy')
 
         build_ext.run(self)
 
     def build_extensions(self):
-        if not self.use_system_fitsio:
+        if not USE_SYSTEM_FITSIO:
 
             # Use the compiler for building python to build cfitsio
             # for maximized compatibility.
 
+            # turns out we need to set the include dirs here too
+            # directly for the compiler
+            self.compiler.include_dirs.insert(0, self.cfitsio_build_dir)
+
             CCold = self.compiler.compiler
             if 'ccache' in CCold:
                 CC = []
                 for val in CCold:
                     if val == 'ccache':
                         print("removing ccache from the compiler options")
                         continue
@@ -106,15 +144,15 @@
             self.compile_cfitsio()
 
             # link against the .a library in cfitsio;
             # It should have been a 'static' library of relocatable objects
             # (-fPIC), since we use the python compiler flags
 
             link_objects = glob.glob(
-                os.path.join(self.cfitsio_build_dir, '*.a'))
+                os.path.join(self.cfitsio_build_dir, '*.o'))
 
             self.compiler.set_link_objects(link_objects)
 
             # Ultimate hack: append the .a files to the dependency list
             # so they will be properly rebuild if cfitsio source is updated.
             for ext in self.extensions:
                 ext.depends += link_objects
@@ -131,14 +169,16 @@
             # function. If not, then define a macro to tell the wrapper
             # to always return False.
             if not self.check_system_cfitsio_objects(
                     '_fits_use_standard_strings'):
                 self.compiler.define_macro(
                     'FITSIO_PYWRAP_ALWAYS_NONSTANDARD_STRINGS')
 
+            self.compiler.add_library('z')
+
         # fitsio requires libm as well.
         self.compiler.add_library('m')
 
         # call the original build_extensions
 
         build_ext.build_extensions(self)
 
@@ -187,29 +227,33 @@
         if not os.path.exists(self.cfitsio_build_dir):
             os.makedirs(self.cfitsio_build_dir)
 
         if not os.path.exists(self.cfitsio_patch_dir):
             os.makedirs(self.cfitsio_patch_dir)
 
         copy_update(self.cfitsio_dir, self.cfitsio_build_dir)
+        copy_update('zlib', self.cfitsio_build_dir)
         copy_update('patches', self.cfitsio_patch_dir)
 
         # we patch the source in the buil dir to avoid mucking with the repo
         self.patch_cfitsio()
 
         makefile = os.path.join(self.cfitsio_build_dir, 'Makefile')
 
         if os.path.exists(makefile):
             # Makefile already there
+            print("found Makefile so not running configure!", flush=True)
             return
 
         args = ''
         if CC is not None:
             args += ' CC="%s"' % ' '.join(CC[:1])
-            args += ' CFLAGS="%s"' % ' '.join(CC[1:])
+            args += ' CFLAGS="%s -fvisibility=hidden"' % ' '.join(CC[1:])
+        else:
+            args += ' CFLAGS="${CFLAGS} -fvisibility=hidden"'
 
         if ARCHIVE:
             args += ' ARCHIVE="%s"' % ' '.join(ARCHIVE)
         if RANLIB:
             args += ' RANLIB="%s"' % ' '.join(RANLIB)
 
         p = Popen(
@@ -242,14 +286,15 @@
                     stdout=PIPE,
                     stderr=PIPE,
                 )
                 if len(p.stdout.read()) > 0:
                     return True
                 else:
                     return False
+        return False
 
 
 sources = ["fitsio/fitsio_pywrap.c"]
 
 ext = Extension("fitsio._fitsio_wrap", sources, include_dirs=['numpy'])
 
 description = ("A full featured python library to read from and "
@@ -263,15 +308,15 @@
     "License :: OSI Approved :: GNU General Public License (GPL)",
     "Topic :: Scientific/Engineering :: Astronomy",
     "Intended Audience :: Science/Research",
 ]
 
 setup(
     name="fitsio",
-    version="1.1.9",
+    version="1.2.0",
     description=description,
     long_description=long_description,
     long_description_content_type='text/markdown; charset=UTF-8; variant=GFM',
     license="GPL",
     classifiers=classifiers,
     url="https://github.com/esheldon/fitsio",
     author="Erin Scott Sheldon",
```

