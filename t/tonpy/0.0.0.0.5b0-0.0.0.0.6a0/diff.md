# Comparing `tmp/tonpy-0.0.0.0.5b0-cp39-cp39-win_amd64.whl.zip` & `tmp/tonpy-0.0.0.0.6a0-cp39-cp39-macosx_12_0_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,46 @@
-Zip file size: 17219 bytes, number of entries: 17
--rw-rw-rw-  2.0 fat       27 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/__init__.py
--rw-rw-rw-  2.0 fat       49 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/tlb_gen/__init__.py
--rw-rw-rw-  2.0 fat     1140 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/tlb_gen/py.py
--rw-rw-rw-  2.0 fat      213 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/__init__.py
--rw-rw-rw-  2.0 fat     1418 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/cell.py
--rw-rw-rw-  2.0 fat    10309 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/cellbuilder.py
--rw-rw-rw-  2.0 fat    11943 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/cellslice.py
--rw-rw-rw-  2.0 fat      112 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/tlb.py
--rw-rw-rw-  2.0 fat    10169 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/vmdict.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/utils/__init__.py
--rw-rw-rw-  2.0 fat      802 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/utils/bit_converter.py
--rw-rw-rw-  2.0 fat      176 b- defN 23-Jul-11 06:28 tonpy-0.0.0.0.5b0.data/purelib/tonpy/utils/bit_int.py
--rw-rw-rw-  2.0 fat     9870 b- defN 23-Jul-11 06:29 tonpy-0.0.0.0.5b0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     3318 b- defN 23-Jul-11 06:29 tonpy-0.0.0.0.5b0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Jul-11 06:29 tonpy-0.0.0.0.5b0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 23-Jul-11 06:29 tonpy-0.0.0.0.5b0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1719 b- defN 23-Jul-11 06:29 tonpy-0.0.0.0.5b0.dist-info/RECORD
-17 files, 51371 bytes uncompressed, 14273 bytes compressed:  72.2%
+Zip file size: 7164262 bytes, number of entries: 44
+-rw-r--r--  2.0 unx       54 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/autogen/__init__.py
+-rw-r--r--  2.0 unx  1025817 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/autogen/block.py
+-rw-r--r--  2.0 unx    53434 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/autogen/hashmap.py
+-rw-r--r--  2.0 unx       76 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/__init__.py
+-rw-r--r--  2.0 unx      620 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/disasm.py
+-rw-r--r--  2.0 unx      977 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/fift.py
+-rw-r--r--  2.0 unx    44320 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Asm.fif
+-rw-r--r--  2.0 unx      498 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Color.fif
+-rw-r--r--  2.0 unx     5796 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Disasm.fif
+-rw-r--r--  2.0 unx     4654 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Fift.fif
+-rw-r--r--  2.0 unx     3692 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/FiftExt.fif
+-rw-r--r--  2.0 unx     5527 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/GetOpt.fif
+-rw-r--r--  2.0 unx    14977 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Lisp.fif
+-rw-r--r--  2.0 unx     7708 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Lists.fif
+-rw-r--r--  2.0 unx     9525 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Stack.fif
+-rw-r--r--  2.0 unx    13280 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/TonUtil.fif
+-rw-r--r--  2.0 unx 16460472 b- defN 23-Aug-02 17:04 tonpy-0.0.0.0.6a0.data/purelib/tonpy/libs/python_ton.cpython-39-darwin.so
+-rw-r--r--  2.0 unx       62 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/tlb_gen/__init__.py
+-rw-r--r--  2.0 unx     1844 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/tlb_gen/py.py
+-rw-r--r--  2.0 unx       70 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/tvm/__init__.py
+-rw-r--r--  2.0 unx       25 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/tvm/emulator.py
+-rw-r--r--  2.0 unx     1715 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/tvm/tvm.py
+-rw-r--r--  2.0 unx      351 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/__init__.py
+-rw-r--r--  2.0 unx     1515 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/cell.py
+-rw-r--r--  2.0 unx    10475 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/cellbuilder.py
+-rw-r--r--  2.0 unx    14706 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/cellslice.py
+-rw-r--r--  2.0 unx     2351 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/stack.py
+-rw-r--r--  2.0 unx     9134 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb.py
+-rw-r--r--  2.0 unx     9988 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/vmdict.py
+-rw-r--r--  2.0 unx      236 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/__init__.py
+-rw-r--r--  2.0 unx      729 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/builtins.py
+-rw-r--r--  2.0 unx      382 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/complex.py
+-rw-r--r--  2.0 unx      762 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/nat.py
+-rw-r--r--  2.0 unx     1338 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/reft.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/__init__.py
+-rw-r--r--  2.0 unx      771 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/bit_converter.py
+-rw-r--r--  2.0 unx      172 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/bit_int.py
+-rw-r--r--  2.0 unx      180 b- defN 23-Aug-02 17:03 tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/token.py
+-rw-r--r--  2.0 unx     9789 b- defN 23-Aug-02 17:05 tonpy-0.0.0.0.6a0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3241 b- defN 23-Aug-02 17:05 tonpy-0.0.0.0.6a0.dist-info/METADATA
+-rw-r--r--  2.0 unx      109 b- defN 23-Aug-02 17:05 tonpy-0.0.0.0.6a0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        6 b- defN 23-Aug-02 17:05 tonpy-0.0.0.0.6a0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4767 b- defN 23-Aug-02 17:05 tonpy-0.0.0.0.6a0.dist-info/RECORD
+44 files, 17726145 bytes uncompressed, 7156234 bytes compressed:  59.6%
```

## zipnote {}

```diff
@@ -1,52 +1,133 @@
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/__init__.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/__init__.py
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/tlb_gen/__init__.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/autogen/__init__.py
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/tlb_gen/py.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/autogen/block.py
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/__init__.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/autogen/hashmap.py
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/cell.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/__init__.py
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/cellbuilder.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/disasm.py
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/cellslice.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/fift.py
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/tlb.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Asm.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/vmdict.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Color.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/utils/__init__.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Disasm.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/utils/bit_converter.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Fift.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.data/purelib/tonpy/utils/bit_int.py
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/FiftExt.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.dist-info/LICENSE
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/GetOpt.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.dist-info/METADATA
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Lisp.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.dist-info/WHEEL
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Lists.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.dist-info/top_level.txt
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/Stack.fif
 Comment: 
 
-Filename: tonpy-0.0.0.0.5b0.dist-info/RECORD
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/fift/libs/TonUtil.fif
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/libs/python_ton.cpython-39-darwin.so
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/tlb_gen/__init__.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/tlb_gen/py.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/tvm/__init__.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/tvm/emulator.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/tvm/tvm.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/__init__.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/cell.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/cellbuilder.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/cellslice.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/stack.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/vmdict.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/__init__.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/builtins.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/complex.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/nat.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/tlb_types/reft.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/__init__.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/bit_converter.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/bit_int.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/token.py
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.dist-info/LICENSE
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.dist-info/METADATA
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.dist-info/WHEEL
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.dist-info/top_level.txt
+Comment: 
+
+Filename: tonpy-0.0.0.0.6a0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## Comparing `tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/cellbuilder.py` & `tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/cellbuilder.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,336 +1,348 @@
-from tonpy.libs.python_ton import PyCellBuilder
-from tonpy.types.cell import Cell
-from tonpy.types.cellslice import CellSlice
-from bitstring import BitArray
-
-from tonpy.utils.bit_int import test_value_len
-
-
-class CellBuilder:
-    def __init__(self):
-        """
-        CellBuilder class allow you to create cells
-        """
-        self.builder: PyCellBuilder = PyCellBuilder()
-
-    @property
-    def bits(self) -> int:
-        """Bits num that been used in cell"""
-
-        return self.builder.bits
-
-    @property
-    def refs(self) -> int:
-        """Refs num that been used in cell"""
-
-        return self.builder.refs
-
-    @property
-    def remaining_bits(self) -> int:
-        """Remaining bits in cell"""
-
-        return self.builder.remaining_bits
-
-    @property
-    def remaining_refs(self) -> int:
-        """Refs num that been used in cell"""
-
-        return self.builder.remaining_refs
-
-    def store_ref(self, cell: Cell) -> "CellBuilder":
-        """
-        Take cell and store it to next reference in current builder
-
-        :param cell: Cell to be stored as reference to current builder
-        :return: Updated (self) builder with new reference to cell
-        """
-        self.builder.store_ref(cell.cell)
-        return self
-
-    def store_builder(self, b: "CellBuilder") -> "CellBuilder":
-        """
-        Append CellBuilder (bits & refs) ``b`` to current builder
-
-        :param b: CellBuilder that will be appended to this builder
-        :return: Current CellBuilder
-        """
-        self.builder.store_builder(b.builder)
-        return self
-
-    def store_uint(self, uint_: int, uint_bits: int) -> "CellBuilder":
-        """
-        Stores ``uint_`` unsigned integer with ``uint_bits`` size (up to 256) to current cell
-
-        :param uint_: Unsigned integer to be stored into cell
-        :param uint_bits: Bits num that will be used to store integer to cell
-        :return: Current CellBuilder
-        """
-
-        if uint_ < 0:
-            raise ValueError("Only unsigned integers supported")
-
-        if uint_bits > 256:
-            raise ValueError("Max value for int_bits is 256")
-
-        test_value_len(uint_, uint_bits)
-
-        # Large ints need to be converted to string to be parsed in C++
-        self.builder.store_uint_str(str(uint_), uint_bits)
-        return self
-
-    def store_uint_big(self, a, b):
-        self.builder.store_256uint_str(str(a), b)
-        return self
-
-    def begin_parse(self) -> CellSlice:
-        """Convert CellBuilder to CellSlice"""
-
-        return self.end_cell().begin_parse()
-
-    def store_int(self, int_: int, int_bits: int) -> "CellBuilder":
-        """
-        Stores ``int_`` integer with ``int_bits`` size (up to 257) to current cell
-
-        :param int_: Integer to be stored into cell
-        :param int_bits: Bits num that will be used to store integer to cell
-        :return: Current CellBuilder
-        """
-
-        if int_bits > 257:
-            raise ValueError("Max value for int_bits is 257")
-
-        test_value_len(int_, int_bits)
-
-        self.builder.store_int_str(str(int_), int_bits)
-        return self
-
-    def store_slice(self, cs: CellSlice) -> "CellBuilder":
-        """
-        Append CellSlice ``b`` (bits & refs) to current CellBuilder
-
-        :param cs: CellSlice that will be appended to this builder
-        :return: Current CellBuilder
-        """
-
-        assert isinstance(cs, CellSlice), "Only CellSlice supported"
-
-        self.builder.store_slice(cs.cell_slice)
-        return self
-
-    def store_zeroes(self, n: int) -> "CellBuilder":
-        """
-        Store ``n`` 0 bits to current CellBuilder
-
-        :param n: Num of 0 bits to be stored
-        :return: Current CellBuilder
-        """
-
-        if n < 0:
-            raise ValueError("Only unsigned integer supported")
-
-        self.builder.store_zeroes(n)
-
-        return self
-
-    def store_ones(self, n: int) -> "CellBuilder":
-        """
-        Store ``n`` 1 bits to current CellBuilder
-
-        :param n: Num of 1 bits to be stored
-        :return: Current CellBuilder
-        """
-
-        if n < 0:
-            raise ValueError("Only unsigned integer supported")
-
-        self.builder.store_ones(n)
-
-        return self
-
-    def store_var_uint(self, uint_: int, bits: int) -> "CellBuilder":
-        """
-        Store ``VarUInteger bits`` to CellSlice
-
-        The main idea that we store size of our integer in first up to ``bits`` in Cell
-        So we can use less space when storing large integers
-
-        TLB scheme:
-
-        .. code-block::
-
-            var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
-              = VarUInteger n;
-
-
-        :param uint_: Unsigned integer to be stored
-        :param bits: Num of bits for VarUInteger
-        :return: Current CellBuilder
-        """
-
-        if uint_ < 0:
-            raise ValueError("Only unsigned integers supported")
-
-        self.builder.store_var_integer(str(uint_), bits, False)
-        return self
-
-    def store_var_int(self, int_: int, bits: int) -> "CellBuilder":
-        """
-        Same as ``store_var_uint`` but work with integers
-
-        TLB Scheme:
-
-        .. code-block::
-
-            var_int$_ {n:#} len:(#< n) value:(int (len * 8))
-              = VarInteger n;
-
-
-        :param int_: Signed integer to be stored
-        :param bits: Num of bits for VarInteger
-        :return: Current CellBuilder
-        """
-
-        self.builder.store_var_integer(str(int_), bits, True)
-        return self
-
-    def store_uint_less(self, upper_bound: int, value: int) -> "CellBuilder":
-        """
-        Store ``value`` less than ``upper_bound`` unsigned integer stored as ``bitCount(upper_bound - 1)`` bits
-
-        :param upper_bound: Max unsigned integer that can be stored
-        :param value: Value to store
-        :return: Current CellBuilder
-        """
-
-        if value > upper_bound - 1:
-            raise ValueError("Value can't be upper than upper_bound - 1")
-
-        if upper_bound < 0:
-            raise ValueError("Upper bound can't be less then zero in unsigned int")
-
-        if value < 0:
-            raise ValueError("Only unsigned integer supported")
-
-        self.builder.store_uint_less(upper_bound, str(value))
-        return self
-
-    def store_uint_leq(self, upper_bound: int, value: int) -> "CellBuilder":
-        """
-        Store ``value`` less or equal than ``upper_bound`` unsigned integer stored as ``bitCount(upper_bound - 1)`` bits
-
-        :param upper_bound: Max unsigned integer that can be stored
-        :param value: Value to store
-        :return: Current CellBuilder
-        """
-
-        if value > upper_bound:
-            raise ValueError("Value can't be upper than upper_bound")
-
-        if upper_bound < 0:
-            raise ValueError("Upper bound can't be less then zero in unsigned int")
-
-        if value < 0:
-            raise ValueError("Only unsigned integer supported")
-
-        self.builder.store_uint_leq(upper_bound, str(value))
-        return self
-
-    def store_bitstring(self, bitstring: str) -> "CellBuilder":
-        """
-        Store bits from ``bitstring`` string
-
-        :param bitstring: Bits to store to cell (ex. '11001')
-        :return: Current CellBuilder
-        """
-
-        self.builder.store_bitstring(bitstring)
-        return self
-
-    def end_cell(self) -> Cell:
-        """Convert CellBuilder to Cell"""
-
-        return Cell(self.builder.get_cell())
-
-    def to_boc(self) -> str:
-        """Convert CellBuilder to BOC string"""
-
-        return self.builder.to_boc()
-
-    def dump(self) -> str:
-        """Recursively dump all cells as hex"""
-
-        return self.builder.dump()
-
-    def dump_as_tlb(self, tlb: str) -> str:
-        """Dump as C++ PrettyPrint parsed by TLB type"""
-
-        return self.builder.dump_as_tlb(tlb)
-
-    def get_hash(self) -> str:
-        """Get hash of cell"""
-
-        return self.builder.get_hash()
-
-    def store_grams(self, grams: int) -> "CellBuilder":
-        """
-        Same as store ``.store_var_uint(grams, 16)``, grams is nanoTON value
-
-        :param grams: nano TON value to store
-        :return: Current CellBuilder
-        """
-
-        self.builder.store_grams_str(str(grams))
-        return self
-
-    def store_address(self, address: str) -> "CellBuilder":
-        """
-        Parse smart-contract address from string and store as ``MsgAddress`` TLB structure
-
-        :param address: Smart-contract address in any format
-        :return: Current CellBuilder
-        """
-
-        self.builder.store_address(address)
-        return self
-
-    def _store_string_rec(self, binstrint_to_store: str) -> Cell:
-        """Store bitsring as chain of cells"""
-
-        bits_in_bitstring = len(binstrint_to_store)
-        cb = CellBuilder()
-        reamining = cb.remaining_bits
-
-        if reamining > bits_in_bitstring:
-            cb.store_bitstring(binstrint_to_store)
-            return cb.end_cell()
-        else:
-            body = binstrint_to_store[:reamining]
-            tail = binstrint_to_store[reamining:]
-            cb.store_bitstring(body)
-            return cb.store_ref(self._store_string_rec(tail)).end_cell()
-
-    def store_string(self, string_to_store: str) -> "CellBuilder":
-        """
-        Convert string ``string_to_store`` to bitstring and store it in chain of cells
-
-        :param string_to_store: string to be stored
-        :return: current CellBuilder
-        """
-        string_as_bitstring = ''.join(format(byte, '08b') for byte in string_to_store.encode('utf-8'))
-
-        reamining = self.builder.remaining_bits
-
-        if reamining > len(string_as_bitstring):
-            self.builder.store_bitstring(string_as_bitstring)
-        else:
-            body = string_as_bitstring[:reamining]
-            tail = string_as_bitstring[reamining:]
-
-            self.builder.store_bitstring(body)
-            tail_cell = self._store_string_rec(tail)
-            self.store_ref(tail_cell)
-
-        return self
-
-    def __repr__(self):
-        return self.builder.__repr__()
+from typing import Union
+
+from tonpy.libs.python_ton import PyCellBuilder
+from tonpy.types.cell import Cell
+from tonpy.types.cellslice import CellSlice
+from bitstring import BitArray
+
+from tonpy.utils.bit_int import test_value_len
+
+
+class CellBuilder:
+    def __init__(self):
+        """CellBuilder class allow you to create cells"""
+        self.builder: PyCellBuilder = PyCellBuilder()
+
+    @property
+    def bits(self) -> int:
+        """Bits num that been used in cell"""
+
+        return self.builder.bits
+
+    @property
+    def refs(self) -> int:
+        """Refs num that been used in cell"""
+
+        return self.builder.refs
+
+    @property
+    def remaining_bits(self) -> int:
+        """Remaining bits in cell"""
+
+        return self.builder.remaining_bits
+
+    @property
+    def remaining_refs(self) -> int:
+        """Refs num that been used in cell"""
+
+        return self.builder.remaining_refs
+
+    def store_ref(self, cell: Cell) -> "CellBuilder":
+        """
+        Take cell and store it to next reference in current builder  |br|
+
+        :param cell: Cell to be stored as reference to current builder
+        :return: Updated (self) builder with new reference to cell
+        """
+        self.builder.store_ref(cell.cell)
+        return self
+
+    def store_builder(self, b: "CellBuilder") -> "CellBuilder":
+        """
+        Append CellBuilder (bits & refs) ``b`` to current builder  |br|
+
+        :param b: CellBuilder that will be appended to this builder
+        :return: Current CellBuilder
+        """
+        self.builder.store_builder(b.builder)
+        return self
+
+    def store_uint(self, uint_: int, uint_bits: int) -> "CellBuilder":
+        """
+        Stores ``uint_`` unsigned integer with ``uint_bits`` size (up to 256) to current cell  |br|
+
+        :param uint_: Unsigned integer to be stored into cell
+        :param uint_bits: Bits num that will be used to store integer to cell
+        :return: Current CellBuilder
+        """
+
+        if uint_ < 0:
+            raise ValueError("Only unsigned integers supported")
+
+        if uint_bits > 256:
+            raise ValueError("Max value for int_bits is 256")
+
+        test_value_len(uint_, uint_bits)
+
+        # Large ints need to be converted to string to be parsed in C++
+        self.builder.store_uint_str(str(uint_), uint_bits)
+        return self
+
+    def store_uint_big(self, a, b):
+        self.builder.store_256uint_str(str(a), b)
+        return self
+
+    def begin_parse(self) -> CellSlice:
+        """Convert CellBuilder to CellSlice"""
+
+        return self.end_cell().begin_parse()
+
+    def store_int(self, int_: int, int_bits: int) -> "CellBuilder":
+        """
+        Stores ``int_`` integer with ``int_bits`` size (up to 257) to current cell  |br|
+
+        :param int_: Integer to be stored into cell
+        :param int_bits: Bits num that will be used to store integer to cell
+        :return: Current CellBuilder
+        """
+
+        if int_bits > 257:
+            raise ValueError("Max value for int_bits is 257")
+
+        test_value_len(int_, int_bits)
+
+        self.builder.store_int_str(str(int_), int_bits)
+        return self
+
+    def store_slice(self, cs: CellSlice) -> "CellBuilder":
+        """
+        Append CellSlice ``b`` (bits & refs) to current CellBuilder  |br|
+
+        :param cs: CellSlice that will be appended to this builder
+        :return: Current CellBuilder
+        """
+
+        assert isinstance(cs, CellSlice), "Only CellSlice supported"
+
+        self.builder.store_slice(cs.cell_slice)
+        return self
+
+    def store_zeroes(self, n: int) -> "CellBuilder":
+        """
+        Store ``n`` 0 bits to current CellBuilder  |br|
+
+        :param n: Num of 0 bits to be stored
+        :return: Current CellBuilder
+        """
+
+        if n < 0:
+            raise ValueError("Only unsigned integer supported")
+
+        self.builder.store_zeroes(n)
+
+        return self
+
+    def store_ones(self, n: int) -> "CellBuilder":
+        """
+        Store ``n`` 1 bits to current CellBuilder  |br|
+
+        :param n: Num of 1 bits to be stored
+        :return: Current CellBuilder
+        """
+
+        if n < 0:
+            raise ValueError("Only unsigned integer supported")
+
+        self.builder.store_ones(n)
+
+        return self
+
+    def store_var_uint(self, uint_: int, bits: int) -> "CellBuilder":
+        """
+        Store ``VarUInteger bits`` to CellSlice  |br|
+
+        The main idea that we store size of our integer in first up to ``bits`` in Cell  |br|
+        So we can use less space when storing large integers  |br|
+
+        TLB scheme:  |br|
+
+        .. code-block::
+
+            var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
+              = VarUInteger n;
+
+
+        :param uint_: Unsigned integer to be stored
+        :param bits: Num of bits for VarUInteger
+        :return: Current CellBuilder
+        """
+
+        if uint_ < 0:
+            raise ValueError("Only unsigned integers supported")
+
+        self.builder.store_var_integer(str(uint_), bits, False)
+        return self
+
+    def store_var_int(self, int_: int, bits: int) -> "CellBuilder":
+        """
+        Same as ``store_var_uint`` but work with integers  |br|
+
+        TLB Scheme:  |br|
+
+        .. code-block::
+
+            var_int$_ {n:#} len:(#< n) value:(int (len * 8))
+              = VarInteger n;
+
+
+        :param int_: Signed integer to be stored
+        :param bits: Num of bits for VarInteger
+        :return: Current CellBuilder
+        """
+
+        self.builder.store_var_integer(str(int_), bits, True)
+        return self
+
+    def store_uint_less(self, upper_bound: int, value: int) -> "CellBuilder":
+        """
+        Store ``value`` less than ``upper_bound`` unsigned integer stored as ``bitCount(upper_bound - 1)`` bits  |br|
+
+        :param upper_bound: Max unsigned integer that can be stored
+        :param value: Value to store
+        :return: Current CellBuilder
+        """
+
+        if value > upper_bound - 1:
+            raise ValueError("Value can't be upper than upper_bound - 1")
+
+        if upper_bound < 0:
+            raise ValueError("Upper bound can't be less then zero in unsigned int")
+
+        if value < 0:
+            raise ValueError("Only unsigned integer supported")
+
+        self.builder.store_uint_less(upper_bound, str(value))
+        return self
+
+    def store_uint_leq(self, upper_bound: int, value: int) -> "CellBuilder":
+        """
+        Store ``value`` less or equal than ``upper_bound`` unsigned integer stored as ``bitCount(upper_bound)`` bits  |br|
+
+        :param upper_bound: Max unsigned integer that can be stored
+        :param value: Value to store
+        :return: Current CellBuilder
+        """
+
+        if value > upper_bound:
+            raise ValueError("Value can't be upper than upper_bound")
+
+        if upper_bound < 0:
+            raise ValueError("Upper bound can't be less then zero in unsigned int")
+
+        if value < 0:
+            raise ValueError("Only unsigned integer supported")
+
+        self.builder.store_uint_leq(upper_bound, str(value))
+        return self
+
+    def store_bitstring(self, bitstring: Union[str, BitArray]) -> "CellBuilder":
+        """
+        Store bits from ``bitstring`` string  |br|
+
+        :param bitstring: Bits to store to cell (ex. '11001')
+        :return: Current CellBuilder
+        """
+
+        if isinstance(bitstring, BitArray):
+            bitstring = bitstring.bin
+
+        self.builder.store_bitstring(bitstring)
+        return self
+
+    def end_cell(self) -> Cell:
+        """Convert CellBuilder to Cell"""
+
+        return Cell(self.builder.get_cell())
+
+    def to_boc(self) -> str:
+        """Convert CellBuilder to BOC string"""
+
+        return self.builder.to_boc()
+
+    def dump(self) -> str:
+        """Recursively dump all cells as hex"""
+
+        return self.builder.dump()
+
+    def dump_as_tlb(self, tlb: str) -> str:
+        """Dump as C++ PrettyPrint parsed by TLB type"""
+
+        return self.builder.dump_as_tlb(tlb)
+
+    def get_hash(self) -> str:
+        """Get hash of cell"""
+
+        return self.builder.get_hash()
+
+    def store_grams(self, grams: int) -> "CellBuilder":
+        """
+        Same as store ``.store_var_uint(grams, 16)``, grams is nanoTON value  |br|
+
+        :param grams: nano TON value to store
+        :return: Current CellBuilder
+        """
+
+        self.builder.store_grams_str(str(grams))
+        return self
+
+    def store_address(self, address: str) -> "CellBuilder":
+        """
+        Parse smart-contract address from string and store as ``MsgAddress`` TLB structure  |br|
+
+        :param address: Smart-contract address in any format
+        :return: Current CellBuilder
+        """
+
+        self.builder.store_address(address)
+        return self
+
+    def _store_string_rec(self, binstrint_to_store: str) -> Cell:
+        """Store bitsring as chain of cells"""
+
+        bits_in_bitstring = len(binstrint_to_store)
+        cb = CellBuilder()
+        reamining = cb.remaining_bits
+
+        if reamining > bits_in_bitstring:
+            cb.store_bitstring(binstrint_to_store)
+            return cb.end_cell()
+        else:
+            body = binstrint_to_store[:reamining]
+            tail = binstrint_to_store[reamining:]
+            cb.store_bitstring(body)
+            return cb.store_ref(self._store_string_rec(tail)).end_cell()
+
+    def store_string(self, string_to_store: str) -> "CellBuilder":
+        """
+        Convert string ``string_to_store`` to bitstring and store it in chain of cells  |br|
+
+        :param string_to_store: string to be stored
+        :return: current CellBuilder
+        """
+        string_as_bitstring = ''.join(format(byte, '08b') for byte in string_to_store.encode('utf-8'))
+
+        reamining = self.builder.remaining_bits
+
+        if reamining > len(string_as_bitstring):
+            self.builder.store_bitstring(string_as_bitstring)
+        else:
+            body = string_as_bitstring[:reamining]
+            tail = string_as_bitstring[reamining:]
+
+            self.builder.store_bitstring(body)
+            tail_cell = self._store_string_rec(tail)
+            self.store_ref(tail_cell)
+
+        return self
+
+    def store_bool(self, bool_: bool) -> "CellBuilder":
+        """Store bool ``bool_`` as 1 bit to current CellBuilder and return modified self"""
+        if bool(bool_) is True:
+            self.store_uint(1, 1)
+        else:
+            self.store_uint(0, 1)
+
+        return self
+
+    def __repr__(self):
+        return self.builder.__repr__()
```

## Comparing `tonpy-0.0.0.0.5b0.data/purelib/tonpy/types/vmdict.py` & `tonpy-0.0.0.0.6a0.data/purelib/tonpy/types/vmdict.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,270 +1,271 @@
-from typing import Union, Iterable
-
-from tonpy.libs.python_ton import PyDict
-
-from tonpy.types.cell import Cell
-from tonpy.types.cellslice import CellSlice
-from tonpy.types.cellbuilder import CellBuilder
-from tonpy.utils.bit_converter import convert_str_to_int
-from tonpy.utils.bit_int import test_value_len
-
-
-class VmDict:
-    def __init__(self, key_len: int, signed: bool = False, cell_root: Union[Union[str, Cell], CellSlice] = None):
-        """
-        Wrapper of HashmapE (dictionary type of TON)
-
-        Key are represented as ``key_len`` bits. They can be loaded as ``signed`` or not.
-
-        :param key_len: Size of keys in bits (up to 257 with ``signed`` or 256)
-        :param signed: Load keys as signed integers or not
-        :param cell_root: Root of HashmapE, can be BOC string, CellSlice or Cell
-        """
-
-        if key_len > 256:
-            if not (key_len == 257 and signed):
-                raise ValueError("Key len must not be larger than 256 for unsigned / 257 for signed")
-
-        self.key_len = key_len
-        self.signed = signed
-
-        if cell_root is not None:
-            cs = cell_root
-
-            if isinstance(cs, str):
-                cs = CellSlice(cs)
-            elif isinstance(cs, Cell):
-                cs = cs.begin_parse()
-
-            cell_root = cs.cell_slice
-
-        self.dict = PyDict(key_len, signed, cell_root)
-
-    def _process_sgnd(self, key: int = None, signed: bool = None) -> bool:
-        """Check ``key`` to be ``signed`` or if ``signed`` is None will use current dict ``self.signed``"""
-        if signed is None:
-            signed = self.signed
-
-        if key is not None:
-            if key < 0 and (signed is False):
-                raise ValueError(f"Signed is false, but key < 0")
-        return signed
-
-    def set(self, key: int, value: CellSlice, mode: str = "set", signed: bool = None) -> "VmDict":
-        """
-        Add / Set / Replace ``key`` as ``key_len`` and ``signed`` bits to value ``value``
-
-        - Set: sets the value associated with ``key_len``-bit key ``key`` in VmDict to value ``value``
-
-        - Add: sets the value associated with key ``key`` to ``value``, but only if ``key`` is not already present in VmDict
-
-        - Replace: sets the value of ``key`` to ``value`` only if the key ``key`` was already present in VmDict
-
-        :param key: Integer to be stored as key
-        :param value: CellSlice to be stored
-        :param mode: "set" / "replace" / "add"
-        :param signed: Signed
-        :return: Updated self
-        """
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        if not isinstance(value, CellSlice):
-            raise ValueError(f"CellSlice needed")
-
-        self.dict.set_str(str(key), value.cell_slice, mode, 0, signed)
-        return self
-
-    def is_empty(self) -> bool:
-        """If dict contains no keys - it's empty"""
-        return self.dict.is_empty()
-
-    def get_cell(self) -> Cell:
-        """Get root cell of dictionary"""
-        return Cell(self.dict.get_pycell())
-
-    def lookup_nearest_key(self, key: int, fetch_next: bool = True, allow_eq: bool = False,
-                           invert_first: bool = True, signed: bool = None) -> tuple[int, CellSlice]:
-        """
-        Compute the nearest key to ``key``
-
-        :param key: ``self.key_len``-bit integer key
-        :param fetch_next: If ``True`` will fetch next else will return prev
-        :param allow_eq: If ``True`` will return value with ``key`` if exist
-        :param invert_first: If ``True`` will respect ``signed`` in operations
-        :param signed: Fetch keys as signed or not
-        :return: Founded key and value
-        """
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        key, value = self.dict.lookup_nearest_key(str(key), fetch_next, allow_eq, invert_first, 0, signed)
-        return int(key), CellSlice(value)
-
-    def get_minmax_key(self, fetch_max: bool = True, invert_first: bool = True, signed: bool = None) -> tuple[
-        int, CellSlice]:
-        """
-        Fetch max / min ``key, value``
-
-        :param fetch_max: If ``True`` will fetch max key, else will fetch min key in dict
-        :param invert_first: If ``True`` will respect ``signed`` in operations
-        :param signed: Fetch keys as signed or not
-        :return: Key and CellSlice that stored in key
-        """
-        signed = self._process_sgnd(signed=signed)
-
-        key, value = self.dict.get_minmax_key(fetch_max, invert_first, 0, signed)
-        return int(key), CellSlice(value)
-
-    def get_minmax_key_ref(self, fetch_max: bool = True, inver_first: bool = False, signed: bool = None) -> tuple[
-        int, Cell]:
-        """
-        Same as get_minmax, but fetch Cell by key (stored in ref)
-
-        :param fetch_max: If ``True`` will fetch max key, else will fetch min key in dict
-        :param invert_first: If ``True`` will respect ``signed`` in operations
-        :param signed: Fetch keys as signed or not
-        :return: Key and Cell that stored in key
-        """
-
-        key, value = self.dict.get_minmax_key_ref(fetch_max, inver_first, 0, signed)
-        return int(key), Cell(value)
-
-    def set_ref(self, key: int, value: Cell, mode: str = "set", signed: bool = None) -> "VmDict":
-        """
-        Same as set, but store Cell to ref (by key)
-
-        :param key: Integer to be stored as key
-        :param value: CellSlice to be stored
-        :param mode: "set" / "replace" / "add"
-        :param signed: Signed
-        :return: Updated self
-        """
-
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        if not isinstance(value, Cell):
-            raise ValueError(f"Only Cell accepted as value")
-
-        self.dict.set_ref_str(str(key), value.cell, mode, 0, signed)
-        return self
-
-    def set_builder(self, key: int, value: CellBuilder, mode: str = "set", signed: bool = None) -> "VmDict":
-        """
-        Set cell builder stored to ``key``, you can load it by ``lookup`` method
-
-        :param key: Integer to be stored as key
-        :param value: CellSlice to be stored
-        :param mode: "set" / "replace" / "add"
-        :param signed: Signed
-        :return: Updated self
-        """
-
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        if not isinstance(value, CellBuilder):
-            raise ValueError(f"CellBuilder needed")
-
-        self.dict.set_builder_str(str(key), value.builder, mode, 0, signed)
-        return self
-
-    def lookup(self, key: int, signed: bool = None) -> CellSlice:
-        """
-        Fetch CellSlice stored in ``key``
-
-        :param key: Integer to be loaded as ``self.key_len`` bit and used as key to search
-        :param signed: Signed
-        :return: CellSlice that stored by key
-        """
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        return CellSlice(self.dict.lookup_str(str(key), 0, signed))
-
-    def lookup_delete(self, key: int, signed: bool = None) -> CellSlice:
-        """
-        Same as lookup, but delete ``(key, value)`` from VmDict
-
-        :param key: Integer to be loaded as ``self.key_len`` bit and used as key to search
-        :param signed: Signed
-        :return: CellSlice that stored by key
-        """
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        return CellSlice(self.dict.lookup_delete_str(str(key), 0, signed))
-
-    def lookup_ref(self, key, signed: bool = None) -> Cell:
-        """
-        Same as lookup, but fetch ref stored by ``set_ref``
-
-        :param key:  Integer to be loaded as ``self.key_len`` bit and used as key to search
-        :param signed: Signed
-        :return: Cell that stored by key
-        """
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        return Cell(self.dict.lookup_ref_str(str(key), 0, signed))
-
-    def lookup_delete_ref(self, key: int, signed: bool = None) -> Cell:
-        """
-        Same as ```lookup_delete`` but delete the ref stored by ``set_ref``
-
-        :param key:  Integer to be loaded as ``self.key_len`` bit and used as key to search
-        :param signed: Signed
-        :return: Cell that stored by key
-        """
-        test_value_len(key, self.key_len)
-        signed = self._process_sgnd(key, signed)
-
-        return Cell(self.dict.lookup_delete_ref_str(str(key), 0, signed))
-
-    def get_iter(self, direction=False) -> Iterable[tuple[int, CellSlice]]:
-        """Simple dict iterator"""
-
-        key, value = self.get_minmax_key(direction)
-        yield key, value
-
-        while True:
-            try:
-                key, value = self.lookup_nearest_key(key, not direction)
-                yield key, value
-            except RuntimeError:
-                return
-
-    def __setitem__(self, key: Union[int, str], value: Union[Union[Union[str, CellSlice], Cell], CellBuilder]):
-        if isinstance(key, str):
-            key = convert_str_to_int(key)
-
-        test_value_len(key, self.key_len)
-        self._process_sgnd(key, None)
-
-        if isinstance(value, str):
-            self.set(key, CellSlice(value))
-        elif isinstance(value, CellSlice):
-            self.set(key, value)
-        elif isinstance(value, Cell):
-            self.set_ref(key, value)
-        elif isinstance(value, CellBuilder):
-            self.set_builder(key, value)
-
-    def __getitem__(self, key: Union[int, str]):
-        if isinstance(key, str):
-            key = convert_str_to_int(key)
-
-        test_value_len(key, self.key_len)
-        self._process_sgnd(key, None)
-
-        return self.lookup(key)
-
-    def __repr__(self):
-        return self.dict.__repr__()
-
-    def __iter__(self):
-        return self.get_iter(False)
-
-    def __reversed__(self):
-        return self.get_iter(True)
+from typing import Union, Iterable
+
+from tonpy.libs.python_ton import PyDict
+
+from tonpy.types.cell import Cell
+from tonpy.types.cellslice import CellSlice
+from tonpy.types.cellbuilder import CellBuilder
+from tonpy.utils.bit_converter import convert_str_to_int
+from tonpy.utils.bit_int import test_value_len
+
+
+class VmDict:
+    def __init__(self, key_len: int, signed: bool = False, cell_root: Union[Union[str, Cell], CellSlice] = None):
+        """
+        Wrapper of HashmapE (dictionary type of TON)  |br|
+
+        Key are represented as ``key_len`` bits. They can be loaded as ``signed`` or not.  |br|
+
+        :param key_len: Size of keys in bits (up to 257 with ``signed`` or 256)
+        :param signed: Load keys as signed integers or not
+        :param cell_root: Root of HashmapE, can be BOC string, CellSlice or Cell
+        :return:
+        """
+
+        if key_len > 256:
+            if not (key_len == 257 and signed):
+                raise ValueError("Key len must not be larger than 256 for unsigned / 257 for signed")
+
+        self.key_len = key_len
+        self.signed = signed
+
+        if cell_root is not None:
+            cs = cell_root
+
+            if isinstance(cs, str):
+                cs = CellSlice(cs)
+            elif isinstance(cs, Cell):
+                cs = cs.begin_parse()
+
+            cell_root = cs.cell_slice
+
+        self.dict = PyDict(key_len, signed, cell_root)
+
+    def _process_sgnd(self, key: int = None, signed: bool = None) -> bool:
+        """Check ``key`` to be ``signed`` or if ``signed`` is None will use current dict ``self.signed``"""
+        if signed is None:
+            signed = self.signed
+
+        if key is not None:
+            if key < 0 and (signed is False):
+                raise ValueError(f"Signed is false, but key < 0")
+        return signed
+
+    def set(self, key: int, value: CellSlice, mode: str = "set", signed: bool = None) -> "VmDict":
+        """
+        Add / Set / Replace ``key`` as ``key_len`` and ``signed`` bits to value ``value``  |br|
+
+        - Set: sets the value associated with ``key_len``-bit key ``key`` in VmDict to value ``value``
+
+        - Add: sets the value associated with key ``key`` to ``value``, but only if ``key`` is not already present in VmDict
+
+        - Replace: sets the value of ``key`` to ``value`` only if the key ``key`` was already present in VmDict
+
+        :param key: Integer to be stored as key
+        :param value: CellSlice to be stored
+        :param mode: "set" / "replace" / "add"
+        :param signed: Signed
+        :return: Updated self
+        """
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        if not isinstance(value, CellSlice):
+            raise ValueError(f"CellSlice needed")
+
+        self.dict.set_str(str(key), value.cell_slice, mode, 0, signed)
+        return self
+
+    def is_empty(self) -> bool:
+        """If dict contains no keys - it's empty"""
+        return self.dict.is_empty()
+
+    def get_cell(self) -> Cell:
+        """Get root cell of dictionary"""
+        return Cell(self.dict.get_pycell())
+
+    def lookup_nearest_key(self, key: int, fetch_next: bool = True, allow_eq: bool = False,
+                           invert_first: bool = True, signed: bool = None) -> tuple[int, CellSlice]:
+        """
+        Compute the nearest key to ``key``  |br|
+
+        :param key: ``self.key_len``-bit integer key
+        :param fetch_next: If ``True`` will fetch next else will return prev
+        :param allow_eq: If ``True`` will return value with ``key`` if exist
+        :param invert_first: If ``True`` will respect ``signed`` in operations
+        :param signed: Fetch keys as signed or not
+        :return: Founded key and value
+        """
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        key, value = self.dict.lookup_nearest_key(str(key), fetch_next, allow_eq, invert_first, 0, signed)
+        return int(key), CellSlice(value)
+
+    def get_minmax_key(self, fetch_max: bool = True, invert_first: bool = True, signed: bool = None) -> tuple[
+        int, CellSlice]:
+        """
+        Fetch max / min ``key, value``  |br|
+
+        :param fetch_max: If ``True`` will fetch max key, else will fetch min key in dict
+        :param invert_first: If ``True`` will respect ``signed`` in operations
+        :param signed: Fetch keys as signed or not
+        :return: Key and CellSlice that stored in key
+        """
+        signed = self._process_sgnd(signed=signed)
+
+        key, value = self.dict.get_minmax_key(fetch_max, invert_first, 0, signed)
+        return int(key), CellSlice(value)
+
+    def get_minmax_key_ref(self, fetch_max: bool = True, inver_first: bool = False, signed: bool = None) -> tuple[
+        int, Cell]:
+        """
+        Same as get_minmax, but fetch Cell by key (stored in ref)  |br|
+
+        :param fetch_max: If ``True`` will fetch max key, else will fetch min key in dict
+        :param invert_first: If ``True`` will respect ``signed`` in operations
+        :param signed: Fetch keys as signed or not
+        :return: Key and Cell that stored in key
+        """
+
+        key, value = self.dict.get_minmax_key_ref(fetch_max, inver_first, 0, signed)
+        return int(key), Cell(value)
+
+    def set_ref(self, key: int, value: Cell, mode: str = "set", signed: bool = None) -> "VmDict":
+        """
+        Same as set, but store Cell to ref (by key)  |br|
+
+        :param key: Integer to be stored as key
+        :param value: CellSlice to be stored
+        :param mode: "set" / "replace" / "add"
+        :param signed: Signed
+        :return: Updated self
+        """
+
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        if not isinstance(value, Cell):
+            raise ValueError(f"Only Cell accepted as value")
+
+        self.dict.set_ref_str(str(key), value.cell, mode, 0, signed)
+        return self
+
+    def set_builder(self, key: int, value: CellBuilder, mode: str = "set", signed: bool = None) -> "VmDict":
+        """
+        Set cell builder stored to ``key``, you can load it by ``lookup`` method  |br|
+
+        :param key: Integer to be stored as key
+        :param value: CellSlice to be stored
+        :param mode: "set" / "replace" / "add"
+        :param signed: Signed
+        :return: Updated self
+        """
+
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        if not isinstance(value, CellBuilder):
+            raise ValueError(f"CellBuilder needed")
+
+        self.dict.set_builder_str(str(key), value.builder, mode, 0, signed)
+        return self
+
+    def lookup(self, key: int, signed: bool = None) -> CellSlice:
+        """
+        Fetch CellSlice stored in ``key``  |br|
+
+        :param key: Integer to be loaded as ``self.key_len`` bit and used as key to search
+        :param signed: Signed
+        :return: CellSlice that stored by key
+        """
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        return CellSlice(self.dict.lookup_str(str(key), 0, signed))
+
+    def lookup_delete(self, key: int, signed: bool = None) -> CellSlice:
+        """
+        Same as lookup, but delete ``(key, value)`` from VmDict  |br|
+
+        :param key: Integer to be loaded as ``self.key_len`` bit and used as key to search
+        :param signed: Signed
+        :return: CellSlice that stored by key
+        """
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        return CellSlice(self.dict.lookup_delete_str(str(key), 0, signed))
+
+    def lookup_ref(self, key, signed: bool = None) -> Cell:
+        """
+        Same as lookup, but fetch ref stored by ``set_ref``  |br|
+
+        :param key:  Integer to be loaded as ``self.key_len`` bit and used as key to search
+        :param signed: Signed
+        :return: Cell that stored by key
+        """
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        return Cell(self.dict.lookup_ref_str(str(key), 0, signed))
+
+    def lookup_delete_ref(self, key: int, signed: bool = None) -> Cell:
+        """
+        Same as ```lookup_delete`` but delete the ref stored by ``set_ref``  |br|
+
+        :param key:  Integer to be loaded as ``self.key_len`` bit and used as key to search
+        :param signed: Signed
+        :return: Cell that stored by key
+        """
+        test_value_len(key, self.key_len)
+        signed = self._process_sgnd(key, signed)
+
+        return Cell(self.dict.lookup_delete_ref_str(str(key), 0, signed))
+
+    def get_iter(self, direction=False) -> Iterable[tuple[int, CellSlice]]:
+        """Simple dict iterator"""
+
+        key, value = self.get_minmax_key(direction)
+        yield key, value
+
+        while True:
+            try:
+                key, value = self.lookup_nearest_key(key, not direction)
+                yield key, value
+            except RuntimeError:
+                return
+
+    def __setitem__(self, key: Union[int, str], value: Union[Union[Union[str, CellSlice], Cell], CellBuilder]):
+        if isinstance(key, str):
+            key = convert_str_to_int(key)
+
+        test_value_len(key, self.key_len)
+        self._process_sgnd(key, None)
+
+        if isinstance(value, str):
+            self.set(key, CellSlice(value))
+        elif isinstance(value, CellSlice):
+            self.set(key, value)
+        elif isinstance(value, Cell):
+            self.set_ref(key, value)
+        elif isinstance(value, CellBuilder):
+            self.set_builder(key, value)
+
+    def __getitem__(self, key: Union[int, str]):
+        if isinstance(key, str):
+            key = convert_str_to_int(key)
+
+        test_value_len(key, self.key_len)
+        self._process_sgnd(key, None)
+
+        return self.lookup(key)
+
+    def __repr__(self):
+        return self.dict.__repr__()
+
+    def __iter__(self):
+        return self.get_iter(False)
+
+    def __reversed__(self):
+        return self.get_iter(True)
```

## Comparing `tonpy-0.0.0.0.5b0.data/purelib/tonpy/utils/bit_converter.py` & `tonpy-0.0.0.0.6a0.data/purelib/tonpy/utils/bit_converter.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-from bitstring import BitArray
-
-
-def bitstring_to_utf8(bitstring_: str, strict: bool = True) -> str:
-    tmp = len(bitstring_) % 8
-
-    if tmp != 0 and strict:
-        raise ValueError(f"Final bitstring has {len(bitstring_)} bits, (% 8) check fail")
-
-    if tmp == 0:
-        bits = BitArray(bin=bitstring_)
-    else:
-        bits = BitArray(bin=bitstring_[:-1 * tmp])
-
-    bytes_data = bits.tobytes()
-
-    # Decode bytes to UTF-8 text
-    utf8_text = bytes_data.decode("utf-8")
-
-    return utf8_text
-
-
-def convert_str_to_bitsring(string: str) -> str:
-    encoded_bitstring = string.encode('utf-8')
-    return ''.join(bin(byte)[2:].zfill(8) for byte in encoded_bitstring)
-
-
-def convert_str_to_int(string: str) -> int:
-    return int(convert_str_to_bitsring(string), 2)
-
-
+from bitstring import BitArray
+
+
+def bitstring_to_utf8(bitstring_: str, strict: bool = True) -> str:
+    tmp = len(bitstring_) % 8
+
+    if tmp != 0 and strict:
+        raise ValueError(f"Final bitstring has {len(bitstring_)} bits, (% 8) check fail")
+
+    if tmp == 0:
+        bits = BitArray(bin=bitstring_)
+    else:
+        bits = BitArray(bin=bitstring_[:-1 * tmp])
+
+    bytes_data = bits.tobytes()
+
+    # Decode bytes to UTF-8 text
+    utf8_text = bytes_data.decode("utf-8")
+
+    return utf8_text
+
+
+def convert_str_to_bitsring(string: str) -> str:
+    encoded_bitstring = string.encode('utf-8')
+    return ''.join(bin(byte)[2:].zfill(8) for byte in encoded_bitstring)
+
+
+def convert_str_to_int(string: str) -> int:
+    return int(convert_str_to_bitsring(string), 2)
+
+
```

## Comparing `tonpy-0.0.0.0.5b0.dist-info/LICENSE` & `tonpy-0.0.0.0.6a0.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 3% similar despite different names*

```diff
@@ -1,82 +1,82 @@
-Apache License
-Version 2.0, January 2004
-http://www.apache.org/licenses/
-
-TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-1. Definitions.
-
-"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
-
-"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.
-
-"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.
-
-"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
-
-"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.
-
-"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.
-
-"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).
-
-"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.
-
-"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."
-
-"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.
-
-2. Grant of Copyright License.
-
-Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.
-
-3. Grant of Patent License.
-
-Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.
-
-4. Redistribution.
-
-You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:
-
-    You must give any other recipients of the Work or Derivative Works a copy of this License; and
-    You must cause any modified files to carry prominent notices stating that You changed the files; and
-    You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and
-    If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.
-
-You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.
-
-5. Submission of Contributions.
-
-Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.
-
-6. Trademarks.
-
-This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.
-
-7. Disclaimer of Warranty.
-
-Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.
-
-8. Limitation of Liability.
-
-In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.
-
-9. Accepting Warranty or Additional Liability.
-
-While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.
-
-END OF TERMS AND CONDITIONS
-
-Copyright (c) 2022 Disintar LLP Licensed under the Apache License Version 2.0
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
+Apache License
+Version 2.0, January 2004
+http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
+
+"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.
+
+"Legal Entity" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, "control" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.
+
+"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.
+
+"Source" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.
+
+"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.
+
+"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).
+
+"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.
+
+"Contribution" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as "Not a Contribution."
+
+"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.
+
+2. Grant of Copyright License.
+
+Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License.
+
+Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.
+
+4. Redistribution.
+
+You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:
+
+    You must give any other recipients of the Work or Derivative Works a copy of this License; and
+    You must cause any modified files to carry prominent notices stating that You changed the files; and
+    You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and
+    If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.
+
+You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.
+
+5. Submission of Contributions.
+
+Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.
+
+6. Trademarks.
+
+This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty.
+
+Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability.
+
+In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability.
+
+While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+Copyright (c) 2022 Disintar LLP Licensed under the Apache License Version 2.0
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
    limitations under the License.
```

## Comparing `tonpy-0.0.0.0.5b0.dist-info/METADATA` & `tonpy-0.0.0.0.6a0.dist-info/METADATA`

 * *Files 19% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-Metadata-Version: 2.1
-Name: tonpy
-Version: 0.0.0.0.5b0
-Summary: Types / API for TON blockchain
-Home-page: https://github.com/disintar/tonpy
-Author: Disintar LLP
-Author-email: andrey@head-labs.com
-Project-URL: Bug Tracker, https://github.com/disintar/tonpy/issues
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Operating System :: OS Independent
-Classifier: Intended Audience :: Developers
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >3.8,<3.12
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: loguru
-Requires-Dist: pytest
-Requires-Dist: bitstring
-Provides-Extra: built
-Requires-Dist: setuptools ; extra == 'built'
-Requires-Dist: build ; extra == 'built'
-Requires-Dist: twine ; extra == 'built'
-Requires-Dist: pytest ; extra == 'built'
-Provides-Extra: docs
-Requires-Dist: Sphinx (>=3.0.0) ; extra == 'docs'
-Requires-Dist: docutils ; extra == 'docs'
-Requires-Dist: pylons-sphinx-themes (>=1.0.8) ; extra == 'docs'
-Requires-Dist: pylons-sphinx-latesturl ; extra == 'docs'
-Requires-Dist: repoze.sphinx.autointerface ; extra == 'docs'
-Requires-Dist: sphinxcontrib-autoprogram ; extra == 'docs'
-Requires-Dist: sphinx-rtd-theme ; extra == 'docs'
-
-[telegram-tondev-url]: https://t.me/tondev_eng
-[ton-svg]: https://img.shields.io/badge/Based%20on-TON-blue
-[telegram-tondev-badge]: https://img.shields.io/badge/chat-TONDev-2CA5E0?logo=telegram&logoColor=white&style=flat
-[ton]: https://ton.org
-
-[![Based on TON][ton-svg]][ton]
-![Python version](https://img.shields.io/badge/python-3.9%20%7C%203.10%20%7C%203.11-blue)
-![Supported OS](https://img.shields.io/badge/os-Linux%20%7C%20MacOS%20%7C%20Windows-green)
-![Supported arch](https://img.shields.io/badge/arch-arm64%20%7C%20x86_64-purple)
-[![Telegram Community Chat][telegram-tondev-badge]][telegram-tondev-url]
-[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
-[![PyPI version](https://badge.fury.io/py/tonpy.svg)](https://pypi.org/project/tonpy/)
-
-# tonpy: powerful Python TON toolkit
-
-## What is it?
-
-**tonpy** is a Python package that provides data structures and API to interact
-with [TON blockchain](https://github.com/ton-blockchain/ton). Tonpy is separate for two
-packages: [C++ bindings](https://github.com/disintar/ton/tree/master/tvm-python)
-and [main package](https://github.com/disintar/tonpy)
-that [takes](https://github.com/disintar/tonpy/tree/main/.github/workflows) pre-built binaries compiled
-by [workflow](https://github.com/disintar/ton/tree/master/.github/workflows) and creates complete python package with
-some python code on top of C++ bindings.
-
-## Installation
-
-One command: `pip install tonpy`
-
-Complex installation for not supported systems and python versions are described in [documentation](https://tonpy.dton.io/installation.html#development-setup-compile-from-sources)
-
-## Documentation
-
-Documentation can be found on [tonpy.dton.io](https://tonpy.dton.io)
-
-## Donation
-
-If you want to support our work, send any coins to:
-
-`EQDfmsDtWQP5D_YkXX-XlULvs4HivRaKY38ftT2hS5yAANRf`
-
-## License 
-
-Copyright (c) 2023 Disintar LLP Licensed under the Apache License
+Metadata-Version: 2.1
+Name: tonpy
+Version: 0.0.0.0.6a0
+Summary: Types / API for TON blockchain
+Home-page: https://github.com/disintar/tonpy
+Author: Disintar LLP
+Author-email: andrey@head-labs.com
+Project-URL: Bug Tracker, https://github.com/disintar/tonpy/issues
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Operating System :: OS Independent
+Classifier: Intended Audience :: Developers
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Requires-Python: >3.8,<3.12
+Description-Content-Type: text/markdown
+License-File: LICENSE
+Requires-Dist: loguru
+Requires-Dist: pytest
+Requires-Dist: bitstring
+Provides-Extra: built
+Requires-Dist: setuptools ; extra == 'built'
+Requires-Dist: build ; extra == 'built'
+Requires-Dist: twine ; extra == 'built'
+Requires-Dist: pytest ; extra == 'built'
+Provides-Extra: docs
+Requires-Dist: Sphinx (>=3.0.0) ; extra == 'docs'
+Requires-Dist: docutils ; extra == 'docs'
+Requires-Dist: pylons-sphinx-themes (>=1.0.8) ; extra == 'docs'
+Requires-Dist: pylons-sphinx-latesturl ; extra == 'docs'
+Requires-Dist: repoze.sphinx.autointerface ; extra == 'docs'
+Requires-Dist: sphinxcontrib-autoprogram ; extra == 'docs'
+Requires-Dist: sphinx-rtd-theme ; extra == 'docs'
+
+[telegram-tondev-url]: https://t.me/tondev_eng
+[ton-svg]: https://img.shields.io/badge/Based%20on-TON-blue
+[telegram-tondev-badge]: https://img.shields.io/badge/chat-TONDev-2CA5E0?logo=telegram&logoColor=white&style=flat
+[ton]: https://ton.org
+
+[![Based on TON][ton-svg]][ton]
+![Python version](https://img.shields.io/badge/python-3.9%20%7C%203.10%20%7C%203.11-blue)
+![Supported OS](https://img.shields.io/badge/os-Linux%20%7C%20MacOS%20%7C%20Windows-green)
+![Supported arch](https://img.shields.io/badge/arch-arm64%20%7C%20x86_64-purple)
+[![Telegram Community Chat][telegram-tondev-badge]][telegram-tondev-url]
+[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)
+[![PyPI version](https://badge.fury.io/py/tonpy.svg)](https://pypi.org/project/tonpy/)
+
+# tonpy: powerful Python TON toolkit
+
+## What is it?
+
+**tonpy** is a Python package that provides data structures and API to interact
+with [TON blockchain](https://github.com/ton-blockchain/ton). Tonpy is separate for two
+packages: [C++ bindings](https://github.com/disintar/ton/tree/master/tvm-python)
+and [main package](https://github.com/disintar/tonpy)
+that [takes](https://github.com/disintar/tonpy/tree/main/.github/workflows) pre-built binaries compiled
+by [workflow](https://github.com/disintar/ton/tree/master/.github/workflows) and creates complete python package with
+some python code on top of C++ bindings.
+
+## Installation
+
+One command: `pip install tonpy`
+
+Complex installation for not supported systems and python versions are described in [documentation](https://tonpy.dton.io/installation.html#development-setup-compile-from-sources)
+
+## Documentation
+
+Documentation can be found on [tonpy.dton.io](https://tonpy.dton.io)
+
+## Donation
+
+If you want to support our work, send any coins to:
+
+`EQDfmsDtWQP5D_YkXX-XlULvs4HivRaKY38ftT2hS5yAANRf`
+
+## License 
+
+Copyright (c) 2023 Disintar LLP Licensed under the Apache License
```

