# Comparing `tmp/mwxlib-0.86.5-py3-none-any.whl.zip` & `tmp/mwxlib-0.87.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 164496 bytes, number of entries: 22
+Zip file size: 164364 bytes, number of entries: 22
 -rw-rw-rw-  2.0 fat     2514 b- defN 23-Jun-23 06:26 mwx/__init__.py
--rw-rw-rw-  2.0 fat    46456 b- defN 23-Jul-12 13:47 mwx/controls.py
--rw-rw-rw-  2.0 fat    73415 b- defN 23-Jul-20 01:51 mwx/framework.py
--rw-rw-rw-  2.0 fat    69295 b- defN 23-Jul-12 13:47 mwx/graphman.py
+-rw-rw-rw-  2.0 fat    46456 b- defN 23-Jul-12 13:46 mwx/controls.py
+-rw-rw-rw-  2.0 fat    73403 b- defN 23-Aug-02 13:07 mwx/framework.py
+-rw-rw-rw-  2.0 fat    69312 b- defN 23-Aug-02 02:00 mwx/graphman.py
 -rw-rw-rw-  2.0 fat    49957 b- defN 23-Jul-11 09:28 mwx/images.py
 -rw-rw-rw-  2.0 fat    36006 b- defN 23-Jul-13 01:15 mwx/matplot2.py
--rw-rw-rw-  2.0 fat    66388 b- defN 23-Jul-20 02:03 mwx/matplot2g.py
+-rw-rw-rw-  2.0 fat    66355 b- defN 23-Jul-31 01:16 mwx/matplot2g.py
 -rw-rw-rw-  2.0 fat    28267 b- defN 23-Jul-13 01:15 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     6878 b- defN 23-Feb-21 08:50 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   138953 b- defN 23-Jul-20 01:54 mwx/nutshell.py
--rw-rw-rw-  2.0 fat    37863 b- defN 23-Jul-11 17:15 mwx/utilus.py
--rw-rw-rw-  2.0 fat    11175 b- defN 23-Jun-20 08:11 mwx/wxmon.py
+-rw-rw-rw-  2.0 fat   138504 b- defN 23-Aug-02 03:38 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat    37560 b- defN 23-Aug-02 03:37 mwx/utilus.py
+-rw-rw-rw-  2.0 fat    11238 b- defN 23-Aug-01 15:56 mwx/wxmon.py
 -rw-rw-rw-  2.0 fat    19529 b- defN 23-Jul-13 01:23 mwx/wxpdb.py
--rw-rw-rw-  2.0 fat     5372 b- defN 23-Jun-20 08:11 mwx/wxwil.py
--rw-rw-rw-  2.0 fat     8314 b- defN 23-Jun-20 08:11 mwx/wxwit.py
+-rw-rw-rw-  2.0 fat     5552 b- defN 23-Aug-01 15:56 mwx/wxwil.py
+-rw-rw-rw-  2.0 fat     8314 b- defN 23-Aug-01 15:51 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-23 14:06 mwx/py/__init__.py
 -rw-rw-rw-  2.0 fat    16794 b- defN 23-Jun-19 10:27 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-Jul-20 02:23 mwxlib-0.86.5.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1893 b- defN 23-Jul-20 02:23 mwxlib-0.86.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-20 02:23 mwxlib-0.86.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-Jul-20 02:23 mwxlib-0.86.5.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1609 b- defN 23-Jul-20 02:23 mwxlib-0.86.5.dist-info/RECORD
-22 files, 621865 bytes uncompressed, 161994 bytes compressed:  74.0%
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-Aug-02 13:20 mwxlib-0.87.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1893 b- defN 23-Aug-02 13:20 mwxlib-0.87.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Aug-02 13:20 mwxlib-0.87.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-Aug-02 13:20 mwxlib-0.87.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1609 b- defN 23-Aug-02 13:20 mwxlib-0.87.0.dist-info/RECORD
+22 files, 621328 bytes uncompressed, 161862 bytes compressed:  73.9%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.86.5.dist-info/LICENSE
+Filename: mwxlib-0.87.0.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.86.5.dist-info/METADATA
+Filename: mwxlib-0.87.0.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.86.5.dist-info/WHEEL
+Filename: mwxlib-0.87.0.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.86.5.dist-info/top_level.txt
+Filename: mwxlib-0.87.0.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.86.5.dist-info/RECORD
+Filename: mwxlib-0.87.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/framework.py

```diff
@@ -1,14 +1,14 @@
 #! python3
 # -*- coding: utf-8 -*-
 """mwxlib framework
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
-__version__ = "0.86.5"
+__version__ = "0.87.0"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 import traceback
 import builtins
 import datetime
@@ -33,14 +33,21 @@
     """
     @wraps(f)
     def _f(*args, **kwargs):
         wx.CallAfter(f, *args, **kwargs)
     return _f
 
 
+def deprecated(item=None, msg='', useName=False):
+    """A decorator of wx.deprecated."""
+    if item is None:
+        return lambda f: deprecated(f, msg, useName)
+    return wx.deprecated(item, msg, useName)
+
+
 def skip(v):
     v.Skip()
 
 
 _speckeys = {
     wx.WXK_ALT                  : 'alt',
     wx.WXK_BACK                 : 'backspace',
@@ -668,16 +675,14 @@
             """Close the window."""
             self.Close()
         
         self.__handler = FSM({ # DNA<Frame>
                 None : {
                 },
                 0 : {
-                    '* pressed' : (0, skip),
-                   '* released' : (0, skip),
                   'M-q pressed' : (0, close),
                 },
             },
             default = 0
         )
         self.make_keymap('C-x')
     
@@ -738,16 +743,14 @@
             """Close the window."""
             self.Close()
         
         self.__handler = FSM({ # DNA<MiniFrame>
                 None : {
                 },
                 0 : {
-                    '* pressed' : (0, skip),
-                   '* released' : (0, skip),
                   'M-q pressed' : (0, close),
                 },
             },
             default = 0
         )
         self.make_keymap('C-x')
     
@@ -1206,14 +1209,18 @@
         self.SESSION_FILE = os.path.abspath(f)
         try:
             with open(self.SESSION_FILE, encoding='utf-8', newline='') as i:
                 exec(i.read())
         except Exception:
             ## pass
             traceback.print_exc()
+        
+        ## Reposition the window if it is off the desktop.
+        if wx.Display.GetFromWindow(self) == -1:
+            self.Position = (0, 0)
     
     def save_session_as(self):
         """Save session as a new file."""
         with wx.FileDialog(self, "Save session as",
                 defaultFile=self.SESSION_FILE or '',
                 wildcard="Session file (*.debrc)|*.debrc",
                 style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT) as dlg:
@@ -1293,19 +1300,20 @@
                 if buf.need_buffer_save:
                     self.popup_window(book)
                     buf.SetFocus()
                     if wx.MessageBox( # Confirm close.
                             "You are closing unsaved content.\n\n"
                             "Changes to the content will be discarded.\n"
                             "Continue closing?",
-                            "Close {!r}".format(buf.name),
+                            "Close {!r}".format(book.Name),
                             style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                         self.message("The close has been canceled.")
                         evt.Veto()
                         return
+                    break # Don't ask any more.
         if self.__standalone:
             evt.Skip() # Close the window
         else:
             self.Show(0) # Don't destroy the window
     
     def OnActivate(self, evt):
         if not evt.Active:
@@ -1322,16 +1330,15 @@
                                 "The contents of the buffer will be overwritten.\n"
                                 "Continue loading {}/{}?".format(book.Name, buf.name),
                                 "Load {!r}".format(buf.name),
                                 style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                             self.__autoload = False # Don't ask any more.
                             return
                         book.load_file(buf)
-        else:
-            evt.Skip()
+        evt.Skip()
     
     def OnShow(self, evt):
         pane = self._mgr.GetPane(self.watcher)
         if evt.IsShown():
             if pane.IsShown():
                 self.inspector.watch() # restart
                 self.monitor.watch()
@@ -1422,31 +1429,35 @@
         """Show the notebook page and move the focus.
         
         Args:
             win  : window to popup
             show : True, False, otherwise None:toggle
                    The pane window will be hidden if no show.
         """
-        wnd = win if focus else wx.Window.FindFocus() # original focus
+        wnd = wx.Window.FindFocus() # original focus
+        
         for pane in self._mgr.GetAllPanes():
             nb = pane.window
             if nb is win:
                 break
             j = nb.GetPageIndex(win) # find and select page
             if j != -1:
                 if j != nb.Selection:
                     nb.Selection = j # the focus is moved
                 break
         else:
-            return
+            return # no such pane.windows
+        
         if show is None:
             show = not pane.IsShown() # toggle show
         
-        if wnd and win.IsShown(): # restore focus
-            wnd.SetFocus()
+        if focus and win.IsShown():
+            win.SetFocus() # move focus
+        elif wnd:
+            wnd.SetFocus() # restore focus
         
         ## Modify the floating position of the pane when displayed.
         ## Note: This is a known bug in wxWidgets 3.17 -- 3.20,
         ##       and will be fixed in wxPython 4.2.1.
         if wx.Display.GetFromWindow(pane.window) == -1:
             pane.floating_pos = wx.GetMousePosition()
         
@@ -1475,74 +1486,63 @@
         """Load file in the session (internal use only)."""
         try:
             if isinstance(book, str):
                 book = getattr(self, book)
         except AttributeError:
             return False
         
-        if re.match(r"https?://[\w/:%#\$&\?()~.=+-]+", filename): # url_re
+        if re.match(r"https?://[\w/:%#$&?()~.=+-]+", filename): # url_re
             return book.load_url(filename, lineno, verbose)
         else:
-            return book.load_file(filename, lineno)
+            return book.load_file(filename, lineno, verbose)
     
-    def load(self, filename, lineno=0, book=None, show=True, focus=False):
+    def load(self, filename, lineno=0):
         """Load file @where the object is defined.
         
         Args:
             filename : target filename:str or object.
                        It also supports <'filename:lineno'> format.
             lineno   : Set mark to lineno on load.
-            book     : book of the buffer to load.
-            show     : Show the book.
-            focus    : Set the focus if the window is displayed.
         """
         if not isinstance(filename, str):
             filename = where(filename)
             if filename is None:
                 return False
         if not lineno:
             m = re.match("(.*?):([0-9]+)", filename)
             if m:
                 filename, ln = m.groups()
                 lineno = int(ln)
-        if not book:
-            book = next((x for x in self.all_books
-                            if x.find_buffer(filename)), self.Log)
-        if show:
-            self.popup_window(book, focus=focus)
-        self._load(filename, lineno, book, verbose=1)
+        book = next((x for x in self.all_books
+                        if x.find_buffer(filename)), self.Log)
+        if self._load(filename, lineno, book, verbose=1):
+            self.popup_window(book, focus=0)
     
     def info(self, obj):
         self.rootshell.info(obj)
     
     def help(self, obj):
         self.rootshell.help(obj)
     
     def watch(self, obj):
         self.monitor.watch(obj)
         if obj:
-            self.popup_window(self.monitor, focus=0)
+            self.popup_window(self.monitor, focus=1)
             self.linfo.watch(obj.__dict__)
             self.ginfo.watch({})
     
     def highlight(self, obj, *args, **kwargs):
         self.inspector.highlight(obj, *args, **kwargs)
     
     ## Note: history 変数に余計な文字列が入らないようにする
     @postcall
     def debug(self, obj, *args, **kwargs):
-        if isinstance(obj, wx.Object) or obj is None:
-            if args or kwargs:
-                self.message("- Args:{} and kwargs:{} were given,"
-                             " but ignored for object monitoring.")
-            self.monitor.watch(obj)
-            if obj:
-                self.popup_window(self.monitor, focus=0)
-                self.linfo.watch(obj.__dict__)
-                self.ginfo.watch({})
+        if isinstance(obj, wx.Object):
+            self.watch(obj)
+        
         elif isinstance(obj, type(print)):
             wx.MessageBox("Builtin method or function.\n\n"
                           "Unable to debug {!r}".format(obj))
         elif callable(obj):
             try:
                 shell = self.debugger.interactive_shell
                 self.debugger.interactive_shell = self.current_shell
@@ -1669,18 +1669,18 @@
     def on_title_window(self, obj):
         """Set title to the frame."""
         title = obj if isinstance(obj, str) else repr(obj)
         self.SetTitle("Nautilus - {}".format(title))
     
     def on_buffer_caption(self, buf):
         """Called when the buffer caption is updated."""
-        if buf.caption.startswith('!'):
+        if buf.caption_prefix.startswith('!'):
             v = wx.ActivateEvent(wx.wxEVT_ACTIVATE, True,
                                  buf.Id, ActivationReason=0)
-            self.EventHandler.ProcessEvent(v)
+            self.EventHandler.ProcessEvent(v) # => self.OnActivate
     
     def add_log(self, text):
         """Add text to the logging buffer."""
         buf = self.Log.default_buffer or self.Log.new_buffer()
         with buf.off_readonly():
             buf.write(text)
         ## Logging text every step in case of crash.
@@ -1893,19 +1893,26 @@
     frame.filling.text.Zoom = -1 # zoom level of size of fonts
     frame.Show()
     return frame
 
 
 def timeit(f, *args, **kwargs):
     from timeit import timeit
-    try:
-        dt = timeit(lambda: f(*args, **kwargs), number=1)
-        print("duration time: {:g} s".format(dt))
-    except TypeError as e:
-        print(e)
+    if callable(f):
+        try:
+            dt = timeit(lambda: f(*args, **kwargs), number=1)
+            print("duration time: {:g} s".format(dt))
+        except TypeError as e:
+            print(e)
+    elif isinstance(f, str):
+        try:
+            dt = timeit(f, number=1)
+            print("duration time: {:g} s".format(dt))
+        except Exception as e:
+            print(e)
 
 
 def profile(obj, *args, **kwargs):
     from profile import Profile
     pr = Profile()
     pr.runcall(obj, *args, **kwargs)
     pr.print_stats()
```

## mwx/graphman.py

```diff
@@ -506,15 +506,15 @@
         del self.Region
     
     def hide_layers(self):
         for name in self.parent.plugins:
             plug = self.parent.get_plug(name)
             for art in plug.Arts:
                 art.set_visible(0)
-        self.set_markups_visible(0)
+        self.remove_markups()
         self.draw()
 
 
 class MyFileDropLoader(wx.FileDropTarget):
     """File Drop interface
     
     Args:
@@ -823,14 +823,15 @@
                         "You are closing unsaved frame.\n\n"
                         "Continue closing?",
                         "Close {!r}".format(frame.name),
                         style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
                     self.message("The close has been canceled.")
                     evt.Veto()
                     return
+                break
         evt.Skip()
     
     def Destroy(self):
         self._mgr.UnInit()
         return mwx.Frame.Destroy(self)
     
     ## --------------------------------
@@ -1609,15 +1610,15 @@
         """
         if not frame:
             frame = self.selected_view.frame
             if not frame:
                 return
         
         if not path:
-            name = re.sub('[\\/:*?"<>|]', '_', frame.name)
+            name = re.sub(r'[\/:*?"<>|]', '_', frame.name)
             with wx.FileDialog(self, "Save buffer as",
                     defaultFile=name,
                     wildcard='|'.join(self.wildcards),
                     style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT) as dlg:
                 if dlg.ShowModal() != wx.ID_OK:
                     return
                 path = dlg.Path
```

## mwx/matplot2g.py

```diff
@@ -343,28 +343,28 @@
         if not isinstance(x, np.ndarray): x = np.array([x])
         if not isinstance(y, np.ndarray): y = np.array([y])
         l,r,b,t = self.__art.get_extent()
         ux, uy = self.xy_unit
         nx = (x - l) / ux
         ny = (t - y) / uy # Y ピクセルインデクスは座標と逆
         if cast:
-            return np.vstack((pixel_cast(nx), pixel_cast(ny)))
-        return np.vstack((nx-0.5, ny-0.5))
+            return (pixel_cast(nx), pixel_cast(ny))
+        return (nx-0.5, ny-0.5)
     
     def xyfrompixel(self, nx, ny=None):
         """Convert pixel [nx,ny] -> (x,y) xydata (float number)."""
         if ny is None:
             nx, ny = nx
         if not isinstance(nx, np.ndarray): nx = np.array([nx])
         if not isinstance(ny, np.ndarray): ny = np.array([ny])
         l,r,b,t = self.__art.get_extent()
         ux, uy = self.xy_unit
         x = l + (nx + 0.5) * ux
         y = t - (ny + 0.5) * uy # Y ピクセルインデクスは座標と逆
-        return np.vstack((x, y))
+        return (x, y)
 
 
 class GraphPlot(MatplotPanel):
     """Graph panel for 2D graph
     """
     def __init__(self, *args, **kwargs):
         MatplotPanel.__init__(self, *args, **kwargs)
```

## mwx/nutshell.py

```diff
@@ -25,21 +25,20 @@
 from wx.py import dispatcher
 from wx.py import introspect
 from wx.py import interpreter
 from wx.py.shell import Shell
 from wx.py.editwindow import EditWindow
 
 from .utilus import funcall as _F
-from .utilus import split_words, split_paren
-from .utilus import find_modules, deprecated
+from .utilus import split_words, split_paren, find_modules
 from .framework import CtrlInterface, AuiNotebook, Menu
 
 
 ## URL pattern (flag = re.M | re.A)
-url_re = r"https?://[\w/:%#\$&\?()~.=+-]+"
+url_re = r"https?://[\w/:%#$&?()~.=+-]+"
 
 ## Python syntax pattern
 py_indent_re  = r"if|else|elif|for|while|with|def|class|try|except|finally"
 py_outdent_re = r"else:|elif\s+.*:|except(\s+.*)?:|finally:"
 py_closing_re = r"break|pass|return|raise|continue"
 
 ## Python interp traceback pattern
@@ -89,16 +88,14 @@
             None : {
                      'mark_set' : [ None, dispatch ],
                    'mark_unset' : [ None, dispatch ],
                   'pointer_set' : [ None, dispatch ],
                 'pointer_unset' : [ None, dispatch ],
             },
             0 : {
-                    '* pressed' : (0, skip),
-                   '* released' : (0, skip),
                'insert pressed' : (0, _F(self.over, None, doc="toggle-over")),
                'C-left pressed' : (0, _F(self.WordLeft)),
               'C-right pressed' : (0, _F(self.WordRightEnd)),
              'C-S-left pressed' : (0, _F(self.selection_backward_word_or_paren)),
             'C-S-right pressed' : (0, _F(self.selection_forward_word_or_paren)),
                'C-S-up pressed' : (0, _F(self.LineUpExtend)),
              'C-S-down pressed' : (0, _F(self.LineDownExtend)),
@@ -447,22 +444,14 @@
     
     def set_pointer(self):
         if self.pointer == self.cline:
             self.pointer = -1 # toggle marker
         else:
             self.pointer = self.cline
     
-    @deprecated
-    def goto_mark(self):
-        self.goto_marker(0b001)
-    
-    @deprecated
-    def goto_pointer(self):
-        self.goto_marker(0b11000)
-    
     def exchange_point_and_mark(self):
         p = self.cpos
         q = self.mark
         if q != -1:
             self.goto_char(q)
             self.recenter()
             self.mark = p
@@ -1457,27 +1446,31 @@
         f = self.filename
         if f and os.path.isfile(f):
             return os.path.getmtime(f) - self.__mtime
         elif f and re.match(url_re, f):
             return -1
     
     @property
-    def caption(self):
+    def caption_prefix(self):
         prefix = ''
         dt = self.mtdelta
         if dt is not None:
             if self.IsModified():
                 prefix += '*'
             if dt > 0:
                 prefix += '!'
             elif dt < 0:
                 prefix += '%'
         if prefix:
             prefix += ' '
-        return prefix + self.name
+        return prefix
+    
+    @property
+    def caption(self):
+        return self.caption_prefix + self.name
     
     def update_caption(self):
         try:
             if self.mtdelta is not None:
                 if self.parent.set_caption(self, self.caption):
                     self.parent.handler('buffer_caption_reset', self)
         except AttributeError:
@@ -1549,16 +1542,16 @@
                     '* pressed' : (0, skip, self.on_exit_escmap),
                  '*alt pressed' : (-1, ),
                 '*ctrl pressed' : (-1, ),
                '*shift pressed' : (-1, ),
              '*[LR]win pressed' : (-1, ),
             },
             0 : { # Normal mode
-                    '* pressed' : (0, dispatch), # => skip
-                   '* released' : (0, dispatch), # => skip
+                    '* pressed' : (0, skip, dispatch),
+                   '* released' : (0, skip, dispatch),
                'escape pressed' : (-1, self.on_enter_escmap),
             },
         })
         
         self.show_folder()
         self.set_style(self.STYLE)
     
@@ -1811,16 +1804,14 @@
            'buffer_inactivated' : [ None, dispatch, self.on_inactivated ],
          'buffer_caption_reset' : [ None, dispatch ],
         'buffer_filename_reset' : [ None, dispatch ],
              '*button* pressed' : [ None, dispatch, skip ],
             '*button* released' : [ None, dispatch, skip ],
             },
             0 : { # Normal mode
-                    '* pressed' : (0, skip),
-                   '* released' : (0, skip),
                  'M-up pressed' : (0, _F(self.previous_buffer)),
                'M-down pressed' : (0, _F(self.next_buffer)),
             },
         })
     
     def OnPageClose(self, evt): #<wx._aui.AuiNotebookEvent>
         nb = evt.EventObject
@@ -2087,15 +2078,15 @@
             return None
         else:
             return self.save_file(buf.filename, buf)
     
     def save_buffer_as(self, buf=None):
         """Confirm the saveas with the dialog."""
         buf = buf or self.buffer
-        name = re.sub('[\\/:*?"<>|]', '', buf.name)
+        name = re.sub(r'[\/:*?"<>|]', '_', buf.name)
         with wx.FileDialog(self, "Save buffer as",
                 defaultFile=name,
                 wildcard='|'.join(self.wildcards),
                 style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT) as dlg:
             if dlg.ShowModal() == wx.ID_OK:
                 return self.save_file(dlg.Path, buf)
     
@@ -2857,20 +2848,18 @@
             
             elif c == '@':
                 lhs = lhs.strip() or '_'
                 rhs = _eats(rest, sep2).strip()
                 
                 ## func(a,b,c) @debug --> func,a,b,c @debug
                 if rhs in ("debug", "profile", "timeit"):
-                    if lhs[-1] in ')]':
+                    if lhs[-1] in ')':
                         L, R = split_paren(lhs, reverse=1)
-                        if R.startswith('('):
+                        if R:
                             lhs = "{}, {}".format(L, R[1:-1])
-                        elif R.startswith('['):
-                            lhs = "{}.__getitem__, ({})".format(L, R[1:-1])
                 
                 ## @(y1,,,yn) --> @partial(y1,,,yn)
                 elif rhs.startswith('('):
                     rhs = re.sub(r"^\((.*)\)", r"partial(\1)", rhs, flags=re.S)
                 
                 return self.magic_interpret([f"{rhs}({lhs})"] + rest)
```

## mwx/utilus.py

```diff
@@ -4,19 +4,20 @@
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
 from functools import wraps
 from bdb import BdbQuit
 import traceback
 import warnings
-import shlex
 import time
 import sys
 import os
 import re
+import io
+import tokenize
 import fnmatch
 import pkgutil
 import pydoc
 import inspect
 from inspect import (isclass, ismodule, ismethod, isbuiltin,
                      isfunction, isgenerator, isframe, iscode, istraceback)
 from pprint import pprint
@@ -262,57 +263,64 @@
     if sys.version_info >= (3,6):
         pp.compact = False
     if sys.version_info >= (3,8):
         pp.sort_dicts = True
 
 
 def split_paren(text, reverse=False):
-    tokens = _split_tokens(text)
+    """Split text into a head parenthesis and the rest, including the tail.
+    If reverse is True, search from tail to head.
+    """
+    tokens = list(split_tokens(text))
     if reverse:
         tokens = tokens[::-1]
     words = _extract_paren_from_tokens(tokens, reverse)
     paren = ''.join(reversed(words) if reverse else words)
     rest = ''.join(reversed(tokens) if reverse else tokens)
     if reverse:
         return rest, paren
     else:
         return paren, rest
 
 
 def split_words(text, reverse=False):
-    tokens = _split_tokens(text)
+    """Generates words extracted from text.
+    If reverse is True, process from tail to head.
+    """
+    tokens = list(split_tokens(text))
     if reverse:
         tokens = tokens[::-1]
     while tokens:
         words = _extract_words_from_tokens(tokens, reverse)
         if words:
             yield ''.join(reversed(words) if reverse else words)
         else:
             yield tokens.pop(0)
 
 
-def _split_tokens(text):
-    lexer = shlex.shlex(text)
-    lexer.wordchars += '.'
-    lexer.whitespace = '' # nothing is white (for multiline analysis)
-    lexer.commenters = '' # don't ignore comment lines
-    ls = []
-    n = 0
-    p = re.compile(r"([a-zA-Z])[\"\']") # check [bfru]-string
+def split_tokens(text):
+    """Generates tokens extracted from text.
+    If reverse is True, process from tail to head.
+    """
     try:
-        for token in lexer:
-            m = p.match(token)
-            if m:
-                ls.append(m.group(1))
-                return ls + _split_tokens(text[n+1:])
-            ls.append(token)
-            n += len(token)
-    except ValueError:
+        f = io.StringIO(text)
+        tokens = tokenize.generate_tokens(f.readline)
+        j, k = 1, 0
+        for type, string, start, end, line in tokens:
+            if type in (0,5,6) or not string:
+                continue
+            l, m = start
+            if l > j and m > 0:
+                yield ' ' * m  # indent spaces
+            elif m > k:
+                yield ' ' * (m-k) # white spaces
+            j, k = end
+            yield string
+    except tokenize.TokenError:
         pass
-    return ls
 
 
 def _extract_words_from_tokens(tokens, reverse=False):
     """Extracts pythonic expressions from tokens
     until sep is found after the parenthesis is closed.
     
     The default sep includes `@, ops, delims, and whitespaces, etc.
@@ -435,29 +443,14 @@
     """
     home = os.path.normpath(os.path.expanduser("~/.mwxlib"))
     if not os.path.exists(home):
         os.mkdir(home)
     return os.path.join(home, f)
 
 
-def deprecated(f=None, count=1):
-    if f is None:
-        return lambda f: deprecated(f, count)
-    @wraps(f)
-    def _f(*v, **kw):
-        nonlocal count
-        if count:
-            warnings.warn(
-                f"{f.__name__!r} is deprecated and will be removed in the future version",
-                DeprecationWarning, stacklevel=2)
-            count -= 1
-        return f(*v, **kw)
-    return _f
-
-
 ## --------------------------------
 ## Finite State Machine
 ## --------------------------------
 
 class SSM(dict):
     """Single State Machine/Context of FSM
     """
@@ -532,15 +525,14 @@
         A default=None is given as an argument of the init.
         If there is only one state, that state will be the default.
     
     Note:
         There is no enter/exit event handler.
     """
     debug = 0
-    debugger = None
     
     default_state = None
     current_state = property(lambda self: self.__state)
     previous_state = property(lambda self: self.__prev_state)
     
     current_event = property(lambda self: self.__event)
     previous_event = property(lambda self: self.__prev_event)
@@ -668,18 +660,14 @@
                               "   event : {}".format(event),
                               "    from : {}".format(self.__prev_state),
                               "      to : {}".format(self.__state),
                               "  action : {}".format(typename(act)),
                               "    args : {}".format(args),
                               "  kwargs : {}".format(kwargs))
                     traceback.print_exc()
-                    if self.debugger:
-                        self.debugger(act, *args, **kwargs)
-                        self.clear(self.default_state)
-                        break
             self.__matched_pattern = None
             return retvals
         
         if isinstance(event, str): # matching test using fnmatch
             for pat in context:
                 if fnmatch.fnmatchcase(event, pat):
                     self.__matched_pattern = pat
```

## mwx/wxmon.py

```diff
@@ -41,20 +41,14 @@
 class EventMonitor(CheckList, ListCtrlAutoWidthMixin, CtrlInterface):
     """Event monitor
     
     Attributes:
         parent : shellframe
         target : widget to monitor
     """
-    _alist = (
-        ("typeId",    62),
-        ("typeName", 200),
-        ("stamp",     40),
-        ("source",     0),
-    )
     def __init__(self, parent, **kwargs):
         CheckList.__init__(self, parent,
                            style=wx.LC_REPORT|wx.LC_HRULES, **kwargs)
         ListCtrlAutoWidthMixin.__init__(self)
         CtrlInterface.__init__(self)
         
         self.parent = parent
@@ -62,33 +56,43 @@
         
         self.Font = wx.Font(9, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
         
         self.__prev = None
         self.__dir = True # sort direction
         self.__items = []
         
-        for k, (header, w) in enumerate(self._alist):
+        _alist = (
+            ("typeId",    62),
+            ("typeName", 200),
+            ("stamp",     40),
+            ("source",     0),
+        )
+        for k, (header, w) in enumerate(_alist):
             self.InsertColumn(k, header, width=w)
         
         self.Bind(wx.EVT_LIST_COL_CLICK, self.OnSortItems)
-        self.Bind(wx.EVT_LEFT_DCLICK, self.OnItemDClick)
         self.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)
+        self.Bind(wx.EVT_LEFT_DCLICK, self.OnItemDClick)
         self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
         self.Bind(wx.EVT_WINDOW_DESTROY, self.OnDestroy)
         
         from wx import adv, aui, stc, media
         for module in (adv, aui, stc, media):
             ew.addModuleEvents(module)
         
         @self.handler.bind('*button* pressed')
         @self.handler.bind('*button* released')
         def dispatch(v):
             """Fork mouse events to the parent."""
             self.parent.handler(self.handler.current_event, v)
             v.Skip()
+        
+        @self.handler.bind('C-c pressed')
+        def copy(v):
+            self.copy()
     
     def OnDestroy(self, evt):
         if evt.EventObject is self:
             try:
                 self.unwatch()
             except Exception as e:
                 print(e)
@@ -244,14 +248,24 @@
         if self.GetItemBackgroundColour(i) != wx.Colour('yellow'):
             self.SetItemBackgroundColour(i, "yellow")
             def reset_color():
                 if self and i < self.ItemCount:
                     self.SetItemBackgroundColour(i, 'white')
             wx.CallAfter(wx.CallLater, 1000, reset_color)
     
+    def copy(self):
+        if not self.SelectedItemCount:
+            return
+        text = ''
+        for i in range(self.ItemCount):
+            if self.IsSelected(i):
+                event, name, *_, attribs = self.__items[i]
+                text += "{}\t{}\n{}\n\n".format(event, name, attribs)
+        Clipboard.write(text.strip('\n'))
+    
     def OnSortItems(self, evt): #<wx._controls.ListEvent>
         n = self.ItemCount
         if n < 2:
             return
         
         data = self.__items
         f = data[self.FocusedItem]
@@ -278,30 +292,20 @@
         i, flag = self.HitTest(evt.Position)
         if i >= 0:
             item = self.__items[i]
             wx.CallAfter(wx.TipWindow, self, item[-1], 512) # attribs
         evt.Skip()
     
     def OnContextMenu(self, evt):
-        i = self.FocusedItem
-        item = self.__items[i] if i != -1 else []
         obj = self.target
         wnd = self.__prev
         menu = [
-            ('No Item selected', item) if not item
-        else
-            (item[1], Icon('copy'), (
-                (1, "Copy typeName",
-                    lambda v: Clipboard.write(item[1]),
-                    lambda v: v.Enable(item is not None)),
-                    
-                (2, "Copy typeInfo",
-                    lambda v: Clipboard.write('\n'.join(str(x) for x in item)),
-                    lambda v: v.Enable(item is not None)),
-            )),
+            (1, "Copy data", Icon('copy'),
+                lambda v: self.copy(),
+                lambda v: v.Enable(self.SelectedItemCount)),
             (),
             (11, "Restart watching {}".format(wnd.__class__.__name__), Icon('ghost'),
                  lambda v: self.watch(wnd),
                  lambda v: v.Enable(wnd is not None)),
              
             (12, "Stop watching {}".format(obj.__class__.__name__), Icon('exit'),
                  lambda v: self.unwatch(),
```

## mwx/wxwil.py

```diff
@@ -15,45 +15,49 @@
 class LocalsWatcher(wx.ListCtrl, ListCtrlAutoWidthMixin, CtrlInterface):
     """Locals info watcher
     
     Attributes:
         parent : shellframe
         target : locals:dict to watch
     """
-    _alist = (
-        ("key", 140),
-        ("value", 0),
-    )
     def __init__(self, parent, **kwargs):
         wx.ListCtrl.__init__(self, parent,
                           style=wx.LC_REPORT|wx.LC_HRULES, **kwargs)
         ListCtrlAutoWidthMixin.__init__(self)
         CtrlInterface.__init__(self)
         
         self.parent = parent
         self.target = None
         
         self.Font = wx.Font(9, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
         
         self.__dir = True # sort direction
         self.__items = [] # list of data:str
         
-        for k, (header, w) in enumerate(self._alist):
+        _alist = (
+            ("key", 140),
+            ("value", 0),
+        )
+        for k, (header, w) in enumerate(_alist):
             self.InsertColumn(k, header, width=w)
         
         self.Bind(wx.EVT_LIST_COL_CLICK, self.OnSortItems)
         self.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)
         
         @self.handler.bind('*button* pressed')
         @self.handler.bind('*button* released')
         def dispatch(v):
             """Fork mouse events to the parent."""
             self.parent.handler(self.handler.current_event, v)
             v.Skip()
         
+        @self.handler.bind('C-c pressed')
+        def copy(v):
+            self.copy()
+        
         dispatcher.connect(receiver=self._update, signal='Interpreter.push')
     
     def _update(self, *args, **kwargs):
         if not self:
             dispatcher.disconnect(receiver=self._update, signal='Interpreter.push')
             return
         self.update()
@@ -125,14 +129,24 @@
         if self.GetItemBackgroundColour(i) != wx.Colour('yellow'):
             self.SetItemBackgroundColour(i, "yellow")
             def reset_color():
                 if self and i < self.ItemCount:
                     self.SetItemBackgroundColour(i, 'white')
             wx.CallAfter(wx.CallLater, 1000, reset_color)
     
+    def copy(self):
+        if not self.SelectedItemCount:
+            return
+        text = ''
+        for i in range(self.ItemCount):
+            if self.IsSelected(i):
+                key, vstr = self.__items[i]
+                text += "{} = {}\n".format(key, vstr)
+        Clipboard.write(text.strip('\n'))
+    
     def OnSortItems(self, evt): #<wx._controls.ListEvent>
         n = self.ItemCount
         if n < 2:
             return
         
         data = self.__items
         f = data[self.FocusedItem]
@@ -146,19 +160,13 @@
             for j, v in enumerate(item):
                 self.SetItem(i, j, v)
             self.Select(i, item in ls)
             if item == f:
                 self.Focus(i)
     
     def OnContextMenu(self, evt):
-        def copy():
-            def _T(i):
-                return "{} = {}".format(*self.__items[i])
-            Clipboard.write('\n'.join(_T(i) for i in selected_items))
-        
-        selected_items = list(filter(self.IsSelected, range(self.ItemCount)))
         menu = [
             (1, "Copy data", Icon('copy'),
-                lambda v: copy(),
-                lambda v: v.Enable(selected_items != [])),
+                lambda v: self.copy(),
+                lambda v: v.Enable(self.SelectedItemCount)),
         ]
         Menu.Popup(self, menu)
```

## Comparing `mwxlib-0.86.5.dist-info/LICENSE` & `mwxlib-0.87.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.86.5.dist-info/METADATA` & `mwxlib-0.87.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.86.5
+Version: 0.87.0
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `mwxlib-0.86.5.dist-info/RECORD` & `mwxlib-0.87.0.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 mwx/__init__.py,sha256=6vaRq60B9cLrnsiaoytM9JAIheZvDs2R1Kqv3I9rf3g,2514
 mwx/controls.py,sha256=YZwCw-LgEvtBL58SahDn1vI7KLgsGiPBQZTbfRSw_L4,46456
-mwx/framework.py,sha256=Usc_a20jYbPWLXnRB814tFkD-RWO7YDhDkcCO7sHOK4,73415
-mwx/graphman.py,sha256=79sToLWv7BgalAsIsgUzFwOgSn1i9bPfPbsm1DZwy7M,69295
+mwx/framework.py,sha256=o4M47czsN1lEpNQxD9R-80o1McuR2pOcRPi2Fp0xOhs,73403
+mwx/graphman.py,sha256=iJb1kHM_vCuoz7KE4uZl5EH1_yKDeO9ynf8pncAbAek,69312
 mwx/images.py,sha256=mrnUYH12I3XLVSZcEXlpVltX0XMxufbl2yRvDIQJZqc,49957
 mwx/matplot2.py,sha256=7fe9yJqyK57dOX4oFsR-_1eLejOfG4hy0sH042iaPvE,36006
-mwx/matplot2g.py,sha256=4gznNNOAKzXhC8XfBE_YtXhTiV9zXsj4nqoE-JjOA54,66388
+mwx/matplot2g.py,sha256=JY1VUl2jpnkQ69WT2VRga1eLj6Bgf0gXb1myPE_ey_M,66355
 mwx/matplot2lg.py,sha256=sBLGYxUn-7bVoZ-x9Fik3VSPHcoTZxboO3j-Cjgo89o,28267
 mwx/mgplt.py,sha256=49_wpFZUEKErQmtobqrlNKDjWlAsdLft-izlqSyGPD0,6878
-mwx/nutshell.py,sha256=tBN4Afe82zaHggIdSugNqQA6SCIurztcjmjZaqZ7erI,138953
-mwx/utilus.py,sha256=pJoCX8g-amCsIWSXJ1qg8rl98bswh4OuzLivAlrnAwA,37863
-mwx/wxmon.py,sha256=JQ4sv-QDvMyqIXDektJZvvWD5ED0T30duAXLLcnO4cg,11175
+mwx/nutshell.py,sha256=01y0pKhjkAMPheZNe5M0s_iwcH0lsiJXtzNO19jlBBs,138504
+mwx/utilus.py,sha256=jx2sNwtVfJCm_HM_ZWhJwEvxPc2goiAAEEmj1Y02RJ4,37560
+mwx/wxmon.py,sha256=Y1ClT4c1kNl-59JyCHtxGa5LIX_c6v7ozehGxXMq3k4,11238
 mwx/wxpdb.py,sha256=Qtrd87IS_HQQFcpL-VHYNG21OiTORoglzq3vKNJHVjk,19529
-mwx/wxwil.py,sha256=_kyqGfKd6zRDKriHQehSkhQhv09dXizGqW3MkKA5MZ0,5372
+mwx/wxwil.py,sha256=_DPLd_6bEgQf4CGBUJqYyM31-KAczUj6heQOWUg8Dgc,5552
 mwx/wxwit.py,sha256=G_86UM-99fPq7s8aiYoTXS1TiEWiFV9PbtgUfbrEmT4,8314
 mwx/py/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 mwx/py/filling.py,sha256=f6KMBcBv7gwrl6qmJYLTL-O0Z47bWNAdTCZtUZIo8vM,16794
-mwxlib-0.86.5.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
-mwxlib-0.86.5.dist-info/METADATA,sha256=_K4vzgjsTA2ZbDJY_ZzkgnN5vqG-Ka4ltRKaKJgYwFY,1893
-mwxlib-0.86.5.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-mwxlib-0.86.5.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
-mwxlib-0.86.5.dist-info/RECORD,,
+mwxlib-0.87.0.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
+mwxlib-0.87.0.dist-info/METADATA,sha256=YITiwBHn7A53QHCrYw2709TCuxknKH5E8-61Nnp0Y8k,1893
+mwxlib-0.87.0.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+mwxlib-0.87.0.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
+mwxlib-0.87.0.dist-info/RECORD,,
```

