# Comparing `tmp/dvtTestKit-0.1.5-py3-none-any.whl.zip` & `tmp/dvtTestKit-0.1.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 19976 bytes, number of entries: 17
+Zip file size: 21588 bytes, number of entries: 17
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-10 16:52 docs/source/__init__.py
--rw-rw-rw-  2.0 fat     3397 b- defN 23-Mar-10 16:54 docs/source/conf.py
--rw-rw-rw-  2.0 fat      414 b- defN 23-Mar-02 16:12 dvtTestKit-0.1.5.data/scripts/dvtTestKit.cmd
--rw-rw-rw-  2.0 fat       40 b- defN 23-Feb-21 14:47 dvtTestKit-0.1.5.data/scripts/post.cmd
+-rw-rw-rw-  2.0 fat     3123 b- defN 23-Apr-11 15:53 docs/source/conf.py
+-rw-rw-rw-  2.0 fat      414 b- defN 23-Mar-02 16:12 dvtTestKit-0.1.8.data/scripts/dvtTestKit.cmd
+-rw-rw-rw-  2.0 fat       40 b- defN 23-Feb-21 14:47 dvtTestKit-0.1.8.data/scripts/post.cmd
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-19 21:43 dvttestkit/__init__.py
--rw-rw-rw-  2.0 fat    12885 b- defN 23-Mar-10 16:54 dvttestkit/confluence_handler.py
+-rw-rw-rw-  2.0 fat    14169 b- defN 23-Apr-11 15:53 dvttestkit/confluence_handler.py
 -rw-rw-rw-  2.0 fat     8179 b- defN 23-Mar-04 02:12 dvttestkit/data_handler.py
 -rw-rw-rw-  2.0 fat    11429 b- defN 23-Mar-04 02:12 dvttestkit/jenkins_handler.py
--rw-rw-rw-  2.0 fat    11345 b- defN 23-Mar-10 16:52 dvttestkit/jira_handler.py
--rw-rw-rw-  2.0 fat      787 b- defN 23-Mar-10 16:54 dvttestkit/post.py
--rw-rw-rw-  2.0 fat     2552 b- defN 23-Mar-04 02:12 dvttestkit/slack_handler.py
--rw-rw-rw-  2.0 fat    12127 b- defN 23-Mar-10 16:54 dvttestkit/testKitUtils.py
--rw-rw-rw-  2.0 fat      482 b- defN 23-Mar-10 16:56 dvtTestKit-0.1.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Mar-10 16:56 dvtTestKit-0.1.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       60 b- defN 23-Mar-10 16:56 dvtTestKit-0.1.5.dist-info/entry_points.txt
--rw-rw-rw-  2.0 fat       16 b- defN 23-Mar-10 16:56 dvtTestKit-0.1.5.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1415 b- defN 23-Mar-10 16:56 dvtTestKit-0.1.5.dist-info/RECORD
-17 files, 65220 bytes uncompressed, 17636 bytes compressed:  73.0%
+-rw-rw-rw-  2.0 fat    11451 b- defN 23-May-09 17:17 dvttestkit/jira_handler.py
+-rw-rw-rw-  2.0 fat     1144 b- defN 23-Apr-11 15:53 dvttestkit/post.py
+-rw-rw-rw-  2.0 fat     2552 b- defN 23-Apr-11 15:53 dvttestkit/slack_handler.py
+-rw-rw-rw-  2.0 fat    16781 b- defN 23-Apr-11 15:53 dvttestkit/testKitUtils.py
+-rw-rw-rw-  2.0 fat      482 b- defN 23-May-09 17:20 dvtTestKit-0.1.8.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-09 17:20 dvtTestKit-0.1.8.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       60 b- defN 23-May-09 17:20 dvtTestKit-0.1.8.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat       16 b- defN 23-May-09 17:20 dvtTestKit-0.1.8.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     1416 b- defN 23-May-09 17:20 dvtTestKit-0.1.8.dist-info/RECORD
+17 files, 71348 bytes uncompressed, 19248 bytes compressed:  73.0%
```

## zipnote {}

```diff
@@ -1,17 +1,17 @@
 Filename: docs/source/__init__.py
 Comment: 
 
 Filename: docs/source/conf.py
 Comment: 
 
-Filename: dvtTestKit-0.1.5.data/scripts/dvtTestKit.cmd
+Filename: dvtTestKit-0.1.8.data/scripts/dvtTestKit.cmd
 Comment: 
 
-Filename: dvtTestKit-0.1.5.data/scripts/post.cmd
+Filename: dvtTestKit-0.1.8.data/scripts/post.cmd
 Comment: 
 
 Filename: dvttestkit/__init__.py
 Comment: 
 
 Filename: dvttestkit/confluence_handler.py
 Comment: 
@@ -30,23 +30,23 @@
 
 Filename: dvttestkit/slack_handler.py
 Comment: 
 
 Filename: dvttestkit/testKitUtils.py
 Comment: 
 
-Filename: dvtTestKit-0.1.5.dist-info/METADATA
+Filename: dvtTestKit-0.1.8.dist-info/METADATA
 Comment: 
 
-Filename: dvtTestKit-0.1.5.dist-info/WHEEL
+Filename: dvtTestKit-0.1.8.dist-info/WHEEL
 Comment: 
 
-Filename: dvtTestKit-0.1.5.dist-info/entry_points.txt
+Filename: dvtTestKit-0.1.8.dist-info/entry_points.txt
 Comment: 
 
-Filename: dvtTestKit-0.1.5.dist-info/top_level.txt
+Filename: dvtTestKit-0.1.8.dist-info/top_level.txt
 Comment: 
 
-Filename: dvtTestKit-0.1.5.dist-info/RECORD
+Filename: dvtTestKit-0.1.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## docs/source/conf.py

```diff
@@ -1,49 +1,47 @@
 # Configuration file for the Sphinx documentation builder.
 # Documentation: https://www.sphinx-doc.org/en/master/usage/configuration.html
 # -- Setup root --------------------------------------------------------------
 import os
+import sys
 import time
 
-from ...dvttestkit import confluence_handler
-
+from dvttestkit import confluence_handler
 
 def get_version():
     with open('version.txt', 'r') as f:
         current_version = f.read().strip()
     return current_version
 
 
 project = 'dvtTestKit'
 author = 'Dan Edens'
 release = get_version()
 
-master_doc = 'index'
+master_doc = 'DvtKit_index'
 todo_include_todos = False
 # pygments_style = 'classic'
 source_suffix = {'.rst': 'restructuredtext'}
 exclude_patterns = ['build/*']
 html_theme = "classic"
 extensions = [
-        'sphinx.ext.autodoc',
-        'sphinx.ext.coverage',
-        'sphinxcontrib.confluencebuilder',
-        'sphinx.ext.napoleon',
-        'sphinx.ext.viewcode',
-        ]
+    'sphinx.ext.autodoc',
+    'sphinx.ext.coverage',
+    'sphinxcontrib.confluencebuilder',
+    'sphinx.ext.napoleon',
+    'sphinx.ext.viewcode',
+]
 
 confluence_default_alignment = 'center'
 # confluence_header_file = 'assets/header.tpl'
 # confluence_footer_file = 'assets/footer.tpl'
 # confluence_disable_ssl_validation = False
 confluence_publish_debug = True
 
 confluence_publish_onlynew = True
-
-
 # confluence_publish_denylist = [
 #     'index',
 #     'foo/bar',
 # ]
 
 def generate_sphinx_config(theme='alabaster', pdf=False):
     """
@@ -54,54 +52,49 @@
             Defaults to 'alabaster'.
         pdf (bool): Whether to generate settings for PDF output. Defaults to False.
 
     Returns:
         A dictionary containing the Sphinx configuration.
     """
     config = {
-            'htmlhelp_basename':    'DVT Test Kit',
-            'html_theme':           theme,
-            'html_static_path':     [],
-            'html_show_sourcelink': False,
-            'html_show_sphinx':     False,
-            'html_show_copyright':  False
-            }
+        'htmlhelp_basename': 'DVT Test Kit',
+        'html_theme': theme,
+        'html_static_path': [],
+        'html_show_sourcelink': False,
+        'html_show_sphinx': False,
+        'html_show_copyright': False
+    }
 
     if pdf:
         config['latex_engine'] = 'xelatex'
         config['latex_elements'] = {
-                'papersize':    'letterpaper',
-                'pointsize':    '10pt',
-                'classoptions': ',oneside',
-                'babel':        '\\usepackage[english]{babel}',
-                'fontpkg':      '\\usepackage{fontspec}',
-                'fncychap':     '\\usepackage[Bjornstrup]{fncychap}',
-                'preamble':     '\\usepackage{unicode-math}\n\\setmathfont{XITS Math}\n\\setmainfont{XITS}\n'
-                }
+            'papersize': 'letterpaper',
+            'pointsize': '10pt',
+            'classoptions': ',oneside',
+            'babel': '\\usepackage[english]{babel}',
+            'fontpkg': '\\usepackage{fontspec}',
+            'fncychap': '\\usepackage[Bjornstrup]{fncychap}',
+            'preamble': '\\usepackage{unicode-math}\n\\setmathfont{XITS Math}\n\\setmainfont{XITS}\n'
+        }
 
     return config
 
 
 def publish_dvttestkit_to_confluence(pages):
     for file_name, page_id in pages:
         # print(file_name, page_id)
-        confluence_handler.update_confluence_page(
-                conf_file_path=file_name,
-                page_id=page_id
-                )
+        confluence_handler.update_confluence_page(conf_file_path=file_name, page_id=page_id)
 
 
 if __name__ == '__main__':
-    docs_dir = os.path.abspath('docs')
-    confluence_command = os.path.join(docs_dir, 'make confluence')
-
+    os.chdir('docs')
     # Run the "make confluence" command
-    os.system(confluence_command)
+    os.system('make confluence')
+    os.chdir('..')
 
     time.sleep(5)
     pages = []
     for each in (confluence_handler.get_child_page_ids("2751201315")):
         # print(confluence_handler.get_confluence_page_title(each))
-        pages.append(
-                (confluence_handler.get_confluence_page_title(each), each))
+        pages.append((confluence_handler.get_confluence_page_title(each), each))
     print(f"pre-publish_dvttestkit: {pages}")
     publish_dvttestkit_to_confluence(pages)
```

## dvttestkit/confluence_handler.py

```diff
@@ -1,18 +1,19 @@
 import json
 import os
 from collections import namedtuple
 
-import chardet
 import requests
 from requests.auth import HTTPBasicAuth
 from sphinx.application import Sphinx
 
 from dvttestkit import testKitUtils
 
+logger = testKitUtils.makeLogger(__name__, True)
+
 
 def generate_pdf(doc_path, doc_index):
     """
     Generate a PDF file from a Sphinx documentation project.
 
     Args:
         doc_path (str): The path to the root directory of the Sphinx documentation project.
@@ -26,18 +27,20 @@
     app.build()
 
     # Convert the LaTeX file to PDF
     os.chdir(os.path.join(doc_path, '_build', 'latex'))
     os.system('make')
 
     # Move the PDF file to the documentation directory
-    os.rename(os.path.join(doc_path, '_build', 'latex', f'{doc_index}.pdf'), os.path.join(doc_path, f'{doc_index}.pdf'))
+    os.rename(os.path.join(doc_path, '_build', 'latex', f'{doc_index}.pdf'),
+              os.path.join(doc_path, f'{doc_index}.pdf'))
 
 
-def get_confluence_page_title(page_id: str, confluence_domain: str = os.getenv("JiraDomain")) -> str:
+def get_confluence_page_title(page_id: str, confluence_domain: str = os.getenv(
+    "JiraDomain")) -> str:
     # Set the Confluence API endpoint and authentication credentials
     url = f"{confluence_domain}/wiki/rest/api/content/{page_id}"
     auth = HTTPBasicAuth(os.getenv("JiraEmail"), os.getenv("JiraToken"))
 
     # Set the headers for the API request
     headers = {
         'Content-Type': 'application/json'
@@ -52,32 +55,50 @@
         return response.json()['title']
     else:
         # Raise an exception with the error message
         raise Exception('Error getting Confluence page: ' + response.text)
 
 
 def get_confluence_page_version(page_id: str,
-                                confluence_domain: str = os.getenv("JiraDomain")):
+                                confluence_domain: str = os.getenv(
+                                    "JiraDomain")):
+    """
+        Retrieves the version number of a Confluence page. This is used for
+
+        Args:
+            page_id (str): The ID of the Confluence page to retrieve the version number for.
+            confluence_domain (str): The base URL of the Confluence site, including the protocol
+                                     (e.g., 'https://your-domain.atlassian.net'). Defaults to the
+                                     value of the 'JiraDomain' environment variable.
+
+        Returns:
+            The version number of the Confluence page as an integer.
+
+        Raises:
+            Exception: If an error occurs while retrieving the Confluence page version.
+    """
     # Set the Confluence API endpoint and authentication credentials
     url = f"{confluence_domain}/wiki/rest/api/content/{page_id}?expand=version"
     auth = HTTPBasicAuth(os.getenv("JiraEmail"), os.getenv("JiraToken"))
 
     # Send the API request to retrieve the Confluence page
     response = requests.get(url, auth=auth)
 
     # Check if the API request was successful
     if response.status_code == 200:
         # Return the version number of the page
         return response.json()['version']['number']
     else:
         # Raise an exception with the error message
-        raise Exception('Error retrieving Confluence page version: ' + response.text)
+        raise Exception(
+            'Error retrieving Confluence page version: ' + response.text)
 
 
-def get_page_data(confluence_domain: str = os.getenv("JiraDomain"), page_id: str = os.getenv("PageId")):
+def get_page_data(confluence_domain: str = os.getenv("JiraDomain"),
+                  page_id: str = os.getenv("PageId")):
     """
     Makes a GET request to the Confluence API to retrieve data for the specified page.
     Returns a named tuple with the following fields: id, title, body, version, space, ancestors,
     status, created_date, updated_date
 
     :param page_id: the ID of the Confluence page
     :return: Named Tuple
@@ -115,30 +136,39 @@
                            confluence_domain: str = os.getenv("JiraDomain"),
                            space_key: str = os.getenv("SPACE_KEY"),
                            parent_id: str = None) -> str:
     """
     Creates a new Confluence page with the specified title and content.
 
     Args:
-        title (str): The title of the new page. Defaults to 'dvttestKit'.
-        conf_file_path (str): The path to the .conf file containing the content of the new page.
-                              Defaults to 'dvtTestKit.conf'.
-        confluence_domain (str): The base URL of the Confluence site, including the protocol
-                                 (e.g., 'https://your-domain.atlassian.net'). Defaults to the
-                                 value of the 'JiraDomain' environment variable.
-        space_key (str): The key of the space in which to create the new page. Defaults to the
-                         value of the 'SPACE_KEY' environment variable.
-        parent_id (str): The ID of the parent page, if the new page should be a child of an
-                         existing page. Defaults to None, meaning the new page will be created
-                         at the top level of the space.
-
-    Returns:
-        str: The ID of the newly created page.
+    -------
+        title (str):
+            | The title of the new page. Defaults to 'dvttestKit'.
+        conf_file_path (str):
+            | The path to the .conf file containing the content of the new page.
+            | Defaults to 'dvtTestKit.conf'.
+        confluence_domain (str):
+            | The base URL of the Confluence site, including the protocol
+            | (e.g., 'https://your-domain.atlassian.net').
+            | Defaults to the value of the 'JiraDomain' environment variable.
+        space_key (str):
+            | The key of the space in which to create the new page. Defaults to the
+            value of the 'SPACE_KEY' environment variable.
+        parent_id (str):
+            | The ID of the parent page, if the new page should be a child of an
+              existing page. Defaults to None, meaning the new page will be created
+              at the top level of the space.
+
+    Returns
+    --------
+    str
+        The ID of the newly created page.
 
-    Raises:
+    Raises
+    -------
         Exception: If an error occurs while creating the Confluence page.
     """
     # Set the Confluence API endpoint and authentication credentials
     url = f"{confluence_domain}/wiki/rest/api/content/"
     auth = HTTPBasicAuth(os.getenv("JiraEmail"), os.getenv("JiraToken"))
     contents = testKitUtils.get_contents(conf_file_path)
 
@@ -166,61 +196,64 @@
 
     # Set the headers for the API request
     headers = {
         'Content-Type': 'application/json'
     }
 
     # Send the API request to create the Confluence page
-    response = requests.post(url, data=payload_json, auth=auth, headers=headers)
+    response = requests.post(url, data=payload_json, auth=auth,
+                             headers=headers)
 
     # Check if the API request was successful
     if response.status_code == 200:
         # Return the ID of the new page
         return response.json()['id']
     else:
         # Raise an exception with the error message
         raise Exception('Error creating Confluence page: ' + response.text)
 
 
 def update_confluence_page(page_id: str,
                            conf_file_path: str,
                            confluence_domain: str = os.getenv("JiraDomain"),
                            space_key: str = os.getenv("SPACE_KEY"),
-                           parent_id: str = None) -> None:
+                           parent_id: str = None) -> int:
     """
     Updates an existing Confluence page with new content.
 
     Args:
         page_id (str): The ID of the page to update.
         conf_file_path (str): The path to the .conf file containing the new content for the page.
-        confluence_domain (str): The base URL of the Confluence site, including the protocol
-                                 (e.g., 'https://your-domain.atlassian.net'). Defaults to the
-                                 value of the 'JiraDomain' environment variable.
-        parent_id (str): The ID of the new parent page, if the updated page should be moved to a
-                         different parent page. Defaults to None, meaning the parent page will not
-                         be changed.
+        confluence_domain (str): The base URL of the Confluence site, including the protocol.
+                                 Defaults to the value of the 'JiraDomain' environment variable.
+        space_key (str): The key of the space that contains the page to update.
+                         Defaults to the value of the 'SPACE_KEY' environment variable.
+        parent_id (str, optional): The ID of the new parent page, if the updated page should be moved to a
+                                   different parent page. Defaults to None, meaning the parent page will not be changed.
 
     Returns:
-        None.
+        str: The HTTP status code of the API response.
 
     Raises:
         Exception: If an error occurs while updating the Confluence page.
     """
+
     # Set the Confluence API endpoint and authentication credentials
     url = f"{confluence_domain}/wiki/rest/api/content/{page_id}"
     auth = HTTPBasicAuth(os.getenv("JiraEmail"), os.getenv("JiraToken"))
+    if conf_file_path.endswith(".py"):
+        conf_file_path = conf_file_path[:-3]
     filepath = f"docs/build/confluence/{conf_file_path}.conf"
-    # Detect the encoding of the .conf file
-    with open(filepath, 'rb') as file:
-        raw_data = file.read()
-        encoding = chardet.detect(raw_data)['encoding']
-
-    # Read the .conf file with the detected encoding
-    with open(filepath, 'r', encoding=encoding) as file:
-        conf_content = file.read()
+    logger.debug(f"pre file check {filepath}")
+    if os.path.isfile(filepath):
+        logger.debug(f"File found: {filepath}")
+        conf_content = testKitUtils.get_contents(filepath)
+    else:
+        logger.debug(f"not found {filepath}")
+        return 0
 
     # Set the JSON payload for updating the Confluence page
     payload = {
         "id": page_id,
         "type": "page",
         "title": get_confluence_page_title(page_id),
         "space": {
@@ -234,16 +267,15 @@
                 "value": conf_content,
                 "representation": "storage"
             }
         }
     }
 
     # If a parent page ID was provided, add it to the JSON payload
-    if parent_id:
-        payload['ancestors'] = [{'id': parent_id}]
+    if parent_id: payload['ancestors'] = [{'id': parent_id}]
 
     # Convert the payload to JSON
     payload_json = json.dumps(payload)
 
     # Set the headers for the API request
     headers = {
         'Content-Type': 'application/json'
@@ -251,18 +283,23 @@
 
     # Send the API request to update the Confluence page
     response = requests.put(url, data=payload_json, auth=auth, headers=headers)
 
     # Check if the API request was successful
     if response.status_code != 200:
         # Raise an exception with the error message
+        logger.debug(
+            f' Page: {page_id}. Error updating Confluence page: {response.text}')
         raise Exception('Error updating Confluence page: ' + response.text)
+    logger.debug(f"Update successful for {filepath}")
+    return response.status_code
 
 
-def delete_confluence_page(page_id: str, confluence_domain: str = os.getenv("JiraDomain")):
+def delete_confluence_page(page_id: str,
+                           confluence_domain: str = os.getenv("JiraDomain")):
     """
     Deletes a Confluence page with the given ID using the Confluence REST API.
 
     Args:
         page_id (str): The ID of the Confluence page to delete.
         confluence_domain (str): The domain of the Confluence instance. Defaults to the JiraDomain environment variable.
 
@@ -286,42 +323,46 @@
 
     # Check if the API request was successful
     if response.status_code != 204:
         # Raise an exception with the error message
         raise Exception('Error deleting Confluence page: ' + response.text)
 
 
-if __name__ == '__main__':
-    # results = create_confluence_page(title="DVTTestKit shared library", conf_file_path="docs/source/index.rst", parent_id="2750939137")
-    # results = update_confluence_page(page_id="2750939137",conf_file_path="docs/build/confluence/README.conf")
-        # conf_file_path="docs/build/html/README.html")
-    # results = get_confluence_page_version(page_id="2750939137")
-    README = update_confluence_page(page_id="2751201315", conf_file_path="README")
-    features = update_confluence_page(page_id="2750939170", conf_file_path="features")
-
-    index = update_confluence_page(page_id="2750971920", conf_file_path="index")
-    testKitUtils = update_confluence_page(page_id="2750971933", conf_file_path="testKitUtils")
-    confluence_handler = update_confluence_page(page_id="2751201295", conf_file_path="confluence_handler")
-    data_handler = update_confluence_page(page_id="2751168543", conf_file_path="data_handler")
-    jenkins_handler = update_confluence_page(page_id="2751102985", conf_file_path="jenkins_handler")
-    jira_handler = update_confluence_page(page_id="2751168548", conf_file_path="jira_handler")
-    post = update_confluence_page(page_id="2751037455", conf_file_path="post")
-    slack_handler = update_confluence_page(page_id="2751430657", conf_file_path="slack_handler")
-
-    # data_handler
-    # developer_docs
-    # dvtTestKit
-    # environment
-    # External_documentation
-    # features
-    # index
-    # jenkins_handler
-    # jira_handler
-    # post
-    # README
-    # scripting
-    # slack_handler
+def get_child_page_ids(parent_id, confluence_domain=os.getenv("JiraDomain")):
+    """
+    Retrieves the page IDs of all child pages under a given parent page.
 
+    Parameters:
+    parent_id (str): The ID of the parent page.
+    confluence_domain (str): The domain of the Confluence site. Default is retrieved from environment variable.
 
+    Returns:
+    list: A list of page IDs for all child pages under the given parent page.
+    """
+    # Set the Confluence API endpoint and authentication credentials
+    url = f"{confluence_domain}/wiki/rest/api/content/{parent_id}/child/page?limit=1000"
+    auth = HTTPBasicAuth(os.getenv("JiraEmail"), os.getenv("JiraToken"))
 
+    # Set the headers for the API request
+    headers = {
+        'Content-Type': 'application/json'
+    }
 
+    # Send the API request to retrieve the child pages of the parent page
+    response = requests.get(url, auth=auth, headers=headers)
 
+    # Check if the API request was successful
+    if response.status_code == 200:
+        # Extract the page IDs from the API response
+        child_page_ids = [page['id'] for page in response.json()['results']]
+        # Recursively retrieve the child pages of each child page
+        for child_id in child_page_ids:
+            child_page_ids.extend(get_child_page_ids(child_id))
+        return child_page_ids
+    else:
+        # Raise an exception with the error message
+        raise Exception('Error retrieving child pages: ' + response.text)
+
+
+if __name__ == '__main__':
+    for each in (get_child_page_ids("2751201315")):
+        logger.debug(get_confluence_page_title(each))
```

## dvttestkit/jira_handler.py

```diff
@@ -74,31 +74,35 @@
     :return: HTTP status code of the POST request.
     :rtype: int
     """
     # Get the current status of the ticket
     ticket_data = get_ticket_data(issue_key=issue_key)
     current_status = ticket_data.status
     # Check if the current status is already `transition_name`
-    if current_status == transition_name or "Done" or "In Review":
+    print(current_status)
+    if current_status == "In Review":
+        print(f"Ticket {issue_key} is already in {current_status}.")
+        return 200
+    if current_status == "Done":
         print(f"Ticket {issue_key} is already in {current_status}.")
         return 200
-    else:
-        transition_id = get_ticket_transitions(transition_name=transition_name, issue_key=issue_key)
 
-        # Sending POST request
-        logger.debug(f"{os.getenv('JiraEmail')}, {os.getenv('JiraToken')}")
-        response = requests.request(
-            "POST",
-            f"{jira_domain}/rest/api/2/issue/{issue_key}/transitions",
-            headers={"Accept": "application/json", "Content-Type": "application/json"},
-            auth=HTTPBasicAuth(os.getenv('JiraEmail'), os.getenv('JiraToken')),
-            json={"transition": {"id": transition_id}}
-        )
+    transition_id = get_ticket_transitions(transition_name=transition_name, issue_key=issue_key)
+
+    # Sending POST request
+    logger.debug(f"{os.getenv('JiraEmail')}, {os.getenv('JiraToken')}")
+    response = requests.request(
+        "POST",
+        f"{jira_domain}/rest/api/2/issue/{issue_key}/transitions",
+        headers={"Accept": "application/json", "Content-Type": "application/json"},
+        auth=HTTPBasicAuth(os.getenv('JiraEmail'), os.getenv('JiraToken')),
+        json={"transition": {"id": transition_id}}
+    )
 
-        return response.status_code
+    return response.status_code
 
 
 def get_ticket_data(jira_domain: str = os.getenv("JiraDomain"), issue_key: str = os.getenv('TicketKey')):
     """
     Makes a GET request to the Jira API to retrieve data for the specified ticket.
     Returns a named tuple with the following fields: key, summary, description, due_date, components,
     status, assignee, priority, change_date, view_date
@@ -293,8 +297,8 @@
 
 class TicketData:
     def __init__(self, issue_key: str = os.getenv('TicketKey')):
         self.data = get_ticket_data(issue_key)
 
 
 if __name__ == '__main__':
-    pass
+    set_status_testing(issue_key="AUTO-1072")
```

## dvttestkit/post.py

```diff
@@ -1,16 +1,31 @@
 import sys
 
 from dvttestkit.testKitUtils import post
 
 
 def post():
     """
-    The main function of my_script.py.
-    It takes three command line arguments and calls the post function with those arguments.
+    This Script serves as an easy access point for external tools to publish data.
+    Python will automatically add the associated command to your path, enabling:
+
+
+    ::
+        post dvt/jenkins/custom-test start-test
+
+    or
+
+    ::
+        python -m dvttestkit/post dvt/jenkins/custom-test start-test
+
+
+    .. note::  This is not the same function as dvttestkit.testKitUtils.post()
+              Which is called by this wrapper with standalone environment handling.
+
+
 
     Args:
         None (Uses command line arguments)
 
     Returns:
         None
     """
```

## dvttestkit/testKitUtils.py

```diff
@@ -18,19 +18,127 @@
 import paho.mqtt.client as mqtt
 import paho.mqtt.publish as publish
 
 # Create utils specific fallback logger for Debugging debug mode
 logger = logging.getLogger(__name__)
 project = __name__
 fileDate = datetime.now().strftime("%Y-%m-%d")
-os.environ['ROOT_DIR'] = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..')
+os.environ['ROOT_DIR'] = os.path.join(
+        os.path.dirname(os.path.abspath(__file__)), '..')
 
 
-class NoAvailablePortError(Exception):
-    pass
+class mqttHandler(logging.Handler):
+    """A custom logging handler that publishes messages to an MQTT broker.
+
+    This handler uses the paho-mqtt library to connect to an MQTT broker and publish log messages
+    as MQTT messages. The handler can be used to send log messages from a Python application to a
+    centralized log server, or to any other system that can subscribe to the MQTT topic.
+
+    Args:
+        _hostName (str): The hostname or IP address of the MQTT broker. Default is 'localhost' or
+            the value of the AWSIP environment variable.
+        topic (str): The MQTT topic to publish messages to. The default value is constructed from
+            the 'project' and 'project_device' environment variables, which are assumed to contain
+            the name of the current project and the name of the current device or instance, separated
+            by a forward slash. For example, if project='myapp' and project_device='dev1', the default
+            topic will be 'myapp/dev1/log'.
+        qos (int): The quality of service (QoS) level to use when publishing messages. The default
+            is QoS level 1.
+        retain (bool): If set to True, the MQTT broker will retain the last message sent to the topic.
+            The default is True.
+        _port (int): The port number to use when connecting to the MQTT broker. The default is 1884
+            or the value of the AWSPORT environment variable.
+        client_id (str): The client ID to use when connecting to the MQTT broker. If not specified,
+            a random client ID will be generated.
+        keepalive (int): The keepalive time, in seconds, for the MQTT connection. The default is 60.
+        will (str): A last will and testament message to send to the MQTT broker if the connection is
+            unexpectedly lost. The default is None.
+        auth (str): An optional username and password string to use when connecting to the MQTT broker.
+            The format of the string is 'username:password'. The default is None.
+        tls (str): An optional path to a file containing the TLS certificate for the MQTT broker. If
+            not specified, TLS encryption will not be used. The default is None.
+        protocol (int): The MQTT protocol version to use. The default is MQTTv3.1.1.
+        transport (str): The transport protocol to use. The default is 'tcp', which uses the standard
+            TCP/IP protocol. Other options include 'websockets', which uses the WebSocket protocol.
+
+    Attributes:
+        topic (str): The MQTT topic to publish messages to.
+        qos (int): The quality of service (QoS) level to use when publishing messages.
+        retain (bool): Whether the MQTT broker should retain the last message sent to the topic.
+        hostname (str): The hostname or IP address of the MQTT broker.
+        port (int): The port number to use when connecting to the MQTT broker.
+        client_id (str): The client ID to use when connecting to the MQTT broker.
+        keepalive (int): The keepalive time, in seconds, for the MQTT connection.
+        will (str): The last will and testament message to send to the MQTT broker if the connection
+            is unexpectedly lost.
+        auth (str): The username and password string to use when connecting to the MQTT broker.
+        tls (str): The path to the TLS certificate file for the MQTT broker.
+        protocol (int): The MQTT protocol version to use.
+        transport (str): The transport protocol to use.
+
+    """
+
+    def __init__(
+            self,
+            _hostName: str = os.environ.get('AWSIP', 'localhost'),
+            topic: str = f'{project}/{os.environ.get(f"{project}_device")}/log',
+            qos: int = 1, retain: bool = True,
+            _port: int = int(os.environ.get('AWSPORT', 1884)),
+            client_id: str = '',
+            keepalive: int = 60,
+            will: str = None,
+            auth: str = None,
+            tls: str = None,
+            protocol: int = 3,
+            transport: str = 'tcp',
+            ) -> object:
+        logging.Handler.__init__(self)
+        self.topic = topic
+        self.qos = qos
+        self.retain = retain
+        self.hostname = _hostName
+        self.port = _port
+        self.client_id = client_id
+        self.keepalive = keepalive
+        self.will = will
+        self.auth = auth
+        self.tls = tls
+        self.protocol = protocol
+        self.transport = transport
+
+    def emit(self, record):
+        """
+        The emit method in this code is responsible for publishing a single formatted logging record to a broker and then disconnecting cleanly.
+        The method takes a single parameter record, which represents the logging record to be published.
+
+        The purpose of this section of code is to allow for logging messages to be sent to a broker, where they can be consumed by other applications or services.
+        This can be useful in distributed systems where log messages need to be centralized for monitoring and debugging purposes.
+
+        The emit method formats the logging record using the format method and then publishes the resulting message using the publish.single method.
+        The various parameters passed to publish.single specify details such as the topic to publish to, the quality of service, and authentication details.
+        After the message is published, the connection to the broker is cleanly disconnected.
+
+        This code provides a convenient way to integrate logging functionality into a distributed system using a message broker.
+        """
+        msg = self.format(record)
+        publish.single(
+                self.topic,
+                msg,
+                self.qos,
+                self.retain,
+                hostname=self.hostname,
+                port=self.port,
+                client_id=self.client_id,
+                keepalive=self.keepalive,
+                will=self.will,
+                auth=self.auth,
+                tls=self.tls,
+                protocol=self.protocol,
+                transport=self.transport
+                )
 
 
 def establishBroker():
     """
     Connect to the MQTT broker for logger mqttHandler stream
     :return:
     """
@@ -55,149 +163,48 @@
     _format = '%(asctime)s - %(module)s - %(message)s' if log_level == 'DEBUG' else '%(asctime)s - %(message)s'
 
     log = logging.getLogger(name)
     log.setLevel(log_level)
 
     if log_to_file:
         filename = f"{datetime.now().strftime('%Y%m%d-%H%M%S')}-TestKit.log"
-        _log = ensure_exists(Path(os.environ['ROOT_DIR']).joinpath(f"data//{filename}"))
+        _log = ensure_exists(
+                Path(os.environ['ROOT_DIR']).joinpath(f"data//{filename}"))
         file_handler = logging.FileHandler(_log)
         file_handler.setFormatter(logging.Formatter(_format))
         log.addHandler(file_handler)
 
     stream_handler = logging.StreamHandler()
     stream_handler.setFormatter(logging.Formatter(_format))
     log.addHandler(stream_handler)
 
     my_handler = mqttHandler(topic=f'DVT/{name}')
     log.addHandler(my_handler)
     return log
 
 
-def remove_file(files: List[str]) -> bool:
-    """
-    Removes old copies of files if they exist.
-
-    :param files: The names of the files to remove.
-    :return: `True` if all files were removed successfully, `False` otherwise.
-    """
-    success = True
-    for f in files:
-        try:
-            os.remove(f)
-            logger.debug(f'Removing previous copy of {f}..')
-        except OSError:
-            success = False
-    return success
-
-
-def linePrepender(file, line, depth: int = 0, mode: int = 0):
-    """
-    Prepends given line to given file at depth.
-    :param file: Filepath to write too
-    :param line: str to write
-    :param depth: # of Lines to move away from mode
-    :param mode: 0=Top,1=current,2=Bottom
-    :return:
-    """
-    with open(file, 'r+') as _file:
-        _file.seek(depth, mode)
-        _file.write(line.rstrip('\r\n') + '\n' + _file.read())
-
-
-def ensure_exists(path):
-    """
-    Accepts path to file, then creates the directory path if it does not exist
-    :param path:
-    :return:
-    """
-    if not os.path.exists(os.path.dirname(path)):
-        try:
-            os.makedirs(os.path.dirname(path))
-        except OSError as exc:  # Guard against race condition
-            if exc.errno != errno.EEXIST:
-                raise
-    return path
-
-
-class mqttHandler(logging.Handler):
-    """
-    A handler class which writes logging records, appropriately formatted,
-    to a MQTT server to a topic.
-    """
-
-    def __init__(
-            self,
-            _hostName=os.environ.get('AWSIP', 'localhost'),
-            topic=f'{project}/{os.environ.get(f"{project}_device")}/log',
-            qos=1, retain=True,
-            _port=int(os.environ.get('AWSPORT', 1884)),
-            client_id='',
-            keepalive=60,
-            will=None,
-            auth=None,
-            tls=None,
-            protocol=3,
-            transport='tcp',
-    ):
-        logging.Handler.__init__(self)
-        self.topic = topic
-        self.qos = qos
-        self.retain = retain
-        self.hostname = _hostName
-        self.port = _port
-        self.client_id = client_id
-        self.keepalive = keepalive
-        self.will = will
-        self.auth = auth
-        self.tls = tls
-        self.protocol = protocol
-        self.transport = transport
-
-    def emit(self, record):
-        """
-        Publish a single formatted logging record to a broker,
-        then disconnect cleanly
-        """
-        msg = self.format(record)
-        publish.single(
-            self.topic,
-            msg,
-            self.qos,
-            self.retain,
-            hostname=self.hostname,
-            port=self.port,
-            client_id=self.client_id,
-            keepalive=self.keepalive,
-            will=self.will,
-            auth=self.auth,
-            tls=self.tls,
-            protocol=self.protocol,
-            transport=self.transport
-        )
-
-
 def post(topic: str, payload: str, retain: bool = False,
          _client=establishBroker()):
     """
     Post msg to MQTT broker
+
     :type _client: object
     :type retain: bool
     :param _client: Logging handler. By default, it is created by this module
     :param retain: Retain topic on broker
     :param topic: Project name
     :param payload: Sensor Data
     """
     topic = str(f'{project}/{topic}')
     payload = str(payload)
     try:
         _client.publish(topic=topic, payload=payload, qos=0, retain=retain)
     except ValueError:
         logger.warning(
-            f"pub Failed because of wildcard: {str(topic)}=:={str(payload)}")
+                f"pub Failed because of wildcard: {str(topic)}=:={str(payload)}")
         logger.warning(f"Attempting fix...")
         try:
             tame_t = topic.replace("+", "_")
             tame_topic = tame_t.replace("#", "_")
             tame_p = payload.replace("+", "_")
             tame_payload = tame_p.replace("#", "_")
             _client.publish(topic=str(tame_topic), payload=str(tame_payload),
@@ -218,46 +225,58 @@
     :rtype: str
     """
     process = subprocess.run(command, shell=True, capture_output=True,
                              text=True)
     return process.stdout
 
 
-def get_available_from_port_range(from_port: int, to_port: int) -> int:
-    """Returns available local port number.
-    Args:
-        from_port: The start port to search
-        to_port: The end port to search
-    Returns:
-        int: available local port number which are found first
+def ensure_exists(path):
+    """
+    Accepts path to file, then creates the directory path if it does not exist
+    :param path:
+    :return:
     """
+    if not os.path.exists(os.path.dirname(path)):
+        try:
+            os.makedirs(os.path.dirname(path))
+        except OSError as exc:  # Guard against race condition
+            if exc.errno != errno.EEXIST:
+                raise
+    return path
 
-    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
 
-    for port in range(from_port, to_port):
-        try:
-            if sock.connect_ex(('localhost', port)) != 0:
-                return port
-        finally:
-            sock.close()
+def remove_file(files: List[str]) -> bool:
+    """
+    Removes old copies of files if they exist.
 
-    raise NoAvailablePortError(f'No available port between {from_port} and {to_port}')
+    :param files: The names of the files to remove.
+    :return: `True` if all files were removed successfully, `False` otherwise.
+    """
+    success = True
+    for f in files:
+        try:
+            os.remove(f)
+            logger.debug(f'Removing previous copy of {f}..')
+        except OSError:
+            success = False
+    return success
 
 
 def get_contents(conf_file_path: str) -> str:
     """
     Reads the contents of a file and returns them as a string.
 
     Args:
         conf_file_path: The path to the file to be read.
 
     Returns:
         The contents of the file as a string.
     """
     import chardet
+
     # with open(file) as file:
     #     return file.read()
     # Detect the encoding of the .conf file
     # Detect the encoding of the .conf file
     with open(conf_file_path, 'rb') as file:
         raw_data = file.read()
         encoding = chardet.detect(raw_data)['encoding']
@@ -284,32 +303,33 @@
         if element['type'] == 'paragraph':
             xhtml_content += "<p>" + html.escape(element['content']) + "</p>"
         elif element['type'] == 'hardBreak':
             xhtml_content += "<br/>"
         elif element['type'] == 'text':
             xhtml_content += html.escape(element['text'])
         elif element['type'] == 'link':
-            link_text = element['title'] if 'title' in element else element['href']
+            link_text = element['title'] if 'title' in element else element[
+                'href']
             xhtml_content += f'<a href="{element["href"]}">{html.escape(link_text)}</a>'
 
     return xhtml_content
 
 
-def get_ip() -> str:
+def linePrepender(file, line, depth: int = 0, mode: int = 0):
     """
-    Retrieve the IP address of the current machine.
-
-    :return: A string containing the IP address of the current machine
+    Prepends given line to given file at depth.
+    :param file: Filepath to write too
+    :param line: str to write
+    :param depth: # of Lines to move away from mode
+    :param mode: 0=Top,1=current,2=Bottom
+    :return:
     """
-    return socket.gethostbyname(socket.gethostname())
-
-
-def print_device_info():
-    logger.info(f"Running on: {platform.system()}")
-    logger.info(f"Deivce IP:  {get_ip()}")
+    with open(file, 'r+') as _file:
+        _file.seek(depth, mode)
+        _file.write(line.rstrip('\r\n') + '\n' + _file.read())
 
 
 def ping_ip(ip_address="192.168.0.1") -> bool:
     """Pings the given IP address until it is successful.
 
    :param ip_address: The IP address to ping.
    :type ip_address: str
@@ -331,14 +351,34 @@
             # Ping was successful
             return True
         else:
             logger.debug(f"Waiting for DUT to power on: {result.returncode}")
             time.sleep(4)
 
 
+def get_ip() -> str:
+    """
+    Retrieve the IP address of the current machine.
+
+    :return: A string containing the IP address of the current machine
+    """
+    return socket.gethostbyname(socket.gethostname())
+
+
+def parse_status(string: str) -> any:
+    """Parse an integer from a string using the regular expression pattern 'INTEGER: (\d+)'.
+
+    :param string: The string to parse.
+    :type string: str
+    :return: The parsed integer.
+    :rtype: int | str
+    """
+    return parse_integer(string, r'INTEGER: (\d+)')
+
+
 def parse_string(string: str, pattern: str) -> str:
     """Parse a string using the given regular expression pattern.
 
     :param string: The string to parse.
     :type string: str
     :param pattern: The regular expression pattern to use for parsing.
     :type pattern: str
@@ -348,15 +388,15 @@
     match = re.search(pattern, string)
     if match:
         return match.group(1)
     else:
         return f"{pattern} Not Found in {string}"
 
 
-def parse_integer(string: str, pattern: str) -> int | str:
+def parse_integer(string: str, pattern: str) -> any:
     """Parse an integer from a string using the given regular expression pattern.
 
     :param string: The string to parse.
     :type string: str
     :param pattern: The regular expression pattern to use for parsing.
     :type pattern: str
     :return: The parsed integer.
@@ -365,26 +405,47 @@
     match = re.search(pattern, string)
     if match:
         return int(match.group(1))
     else:
         return f"{pattern} Not Found in {string}"
 
 
-def parse_status(string: str) -> int | str:
-    """Parse an integer from a string using the regular expression pattern 'INTEGER: (\d+)'.
+class NoAvailablePortError(Exception):
+    """Raised when there isn't a viable port in the given range."""
+    pass
 
-    :param string: The string to parse.
-    :type string: str
-    :return: The parsed integer.
-    :rtype: int | str
+
+def get_available_from_port_range(from_port: int, to_port: int) -> int:
+    """Returns available local port number.
+    Args:
+        from_port: The start port to search
+        to_port: The end port to search
+    Returns:
+        int: available local port number which are found first
     """
-    return parse_integer(string, r'INTEGER: (\d+)')
+
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+
+    for port in range(from_port, to_port):
+        try:
+            if sock.connect_ex(('localhost', port)) != 0:
+                return port
+        finally:
+            sock.close()
+
+    raise NoAvailablePortError(
+            f'No available port between {from_port} and {to_port}')
+
+
+def print_device_info():
+    logger.info(f"Running on: {platform.system()}")
+    logger.info(f"Deivce IP:  {get_ip()}")
 
 
 if __name__ == '__main__':
     # get_slack_messages()
     # print(post_slack_message())
     post(topic="test", payload="message", retain=True)
-    logger = makeLogger(__name__, True, 'DEBUG')
+    logger = makeLogger(__name__, True)
     logger.info("Info message")
     logger.debug("Debug  message")
     logger.warning("Warning message")
```

## Comparing `dvtTestKit-0.1.5.dist-info/RECORD` & `dvtTestKit-0.1.8.dist-info/RECORD`

 * *Files 18% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 docs/source/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-docs/source/conf.py,sha256=9QsDJqVWha00tPQqSuICm5y6Vx5k-Sh_tPFRffQrrNA,3397
-dvtTestKit-0.1.5.data/scripts/dvtTestKit.cmd,sha256=4OxV0ffeP9NSilWTgZUa41-zAtm6jA7JJ8ksC4pCqlM,414
-dvtTestKit-0.1.5.data/scripts/post.cmd,sha256=JPtJj-qbwJPgaN7ME3U2ZHqFVaUDxAdWTmmFz-muSJE,40
+docs/source/conf.py,sha256=RKqDKlG19L1RXu05x_KIVxyfM-hBDK-iBb5LJwXwdzU,3123
+dvtTestKit-0.1.8.data/scripts/dvtTestKit.cmd,sha256=4OxV0ffeP9NSilWTgZUa41-zAtm6jA7JJ8ksC4pCqlM,414
+dvtTestKit-0.1.8.data/scripts/post.cmd,sha256=JPtJj-qbwJPgaN7ME3U2ZHqFVaUDxAdWTmmFz-muSJE,40
 dvttestkit/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dvttestkit/confluence_handler.py,sha256=bTjchS_s0zxXRH9hfXh50dpI_OFn3TRSncuz1aIGRrw,12885
+dvttestkit/confluence_handler.py,sha256=kkaQOo1BlGEGopt7MPZRfV5BRx4zi1gusOkbBcICrb0,14169
 dvttestkit/data_handler.py,sha256=FIxP9Xbjt-Fq6abgh5zi6mMIHSuG5ueU9pCk1O6jMhg,8179
 dvttestkit/jenkins_handler.py,sha256=EUPa9PCkTz9s1QVZLjs1lkp2cqxtTvGzVm95NsqfEwI,11429
-dvttestkit/jira_handler.py,sha256=dw8HCZPTtp9r2xUTMgnZXov2Po_gtemEZINGcGshHi8,11345
-dvttestkit/post.py,sha256=cqV3cLtbIZQRlxJYOdfKM5sHF_Y80GXM1gPfrmmBd54,787
+dvttestkit/jira_handler.py,sha256=UxAtnfc3mzV4G5_vwnxbHCaVA8qaE09491DSNW3GPt8,11451
+dvttestkit/post.py,sha256=xI3wZGI34eezMMmEnSGSwVUP0sdby3ojsUjpREJHtWw,1144
 dvttestkit/slack_handler.py,sha256=LBrvpMcFrkNqZ7xsgZCQAEEy5Cl7axtCj8LOXOLN6q8,2552
-dvttestkit/testKitUtils.py,sha256=EaMvBTw2PoRxg5kGqLCHOB98avyQLyEKEQLhiaDCrQk,12127
-dvtTestKit-0.1.5.dist-info/METADATA,sha256=Q8v78uMN1sB2Da1ZBkvIT0ZbJ0UFx7xyf0trx9RE38o,482
-dvtTestKit-0.1.5.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-dvtTestKit-0.1.5.dist-info/entry_points.txt,sha256=BtgrUB1DJQRmiVI3GgoqtCljE7G5XRg0unqxZR_i5wQ,60
-dvtTestKit-0.1.5.dist-info/top_level.txt,sha256=urZ8c9bHu5SHBEolzzyzhR4Q3SfVREBRXa0tA9Xzjo0,16
-dvtTestKit-0.1.5.dist-info/RECORD,,
+dvttestkit/testKitUtils.py,sha256=8pVhN6qHC9_r8bQd6Qo6F87UpeaxDTJ4LJDBQcmWjSs,16781
+dvtTestKit-0.1.8.dist-info/METADATA,sha256=AiIDscalz0IydorUaG-nzQhnzq_PLGe59V5foubBw4E,482
+dvtTestKit-0.1.8.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+dvtTestKit-0.1.8.dist-info/entry_points.txt,sha256=BtgrUB1DJQRmiVI3GgoqtCljE7G5XRg0unqxZR_i5wQ,60
+dvtTestKit-0.1.8.dist-info/top_level.txt,sha256=urZ8c9bHu5SHBEolzzyzhR4Q3SfVREBRXa0tA9Xzjo0,16
+dvtTestKit-0.1.8.dist-info/RECORD,,
```

