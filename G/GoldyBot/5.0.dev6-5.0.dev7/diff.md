# Comparing `tmp/GoldyBot-5.0.dev6-py3-none-any.whl.zip` & `tmp/GoldyBot-5.0.dev7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,84 +1,88 @@
-Zip file size: 118982 bytes, number of entries: 82
--rw-r--r--  2.0 unx     1256 b- defN 23-Jul-08 23:42 GoldyBot/__init__.py
+Zip file size: 125964 bytes, number of entries: 86
+-rw-r--r--  2.0 unx     1279 b- defN 23-Aug-02 19:40 GoldyBot/__init__.py
 -rw-r--r--  2.0 unx      421 b- defN 23-Jun-18 11:58 GoldyBot/config.py
 -rw-r--r--  2.0 unx     1673 b- defN 23-Jul-08 23:42 GoldyBot/errors.py
 -rw-r--r--  2.0 unx     1043 b- defN 23-Jun-18 11:58 GoldyBot/file_templates.py
--rw-r--r--  2.0 unx      404 b- defN 23-Jul-09 12:13 GoldyBot/info.py
+-rw-r--r--  2.0 unx      463 b- defN 23-Aug-02 19:40 GoldyBot/info.py
 -rw-r--r--  2.0 unx      523 b- defN 23-Jun-18 11:58 GoldyBot/logging.py
 -rw-r--r--  2.0 unx      530 b- defN 23-Jun-18 11:58 GoldyBot/paths.py
 -rw-r--r--  2.0 unx    37153 b- defN 23-Jun-18 11:58 GoldyBot/assets/ding.mp3
--rw-r--r--  2.0 unx      397 b- defN 23-Jul-08 23:42 GoldyBot/assets/goldy.json
+-rw-r--r--  2.0 unx      391 b- defN 23-Aug-02 19:40 GoldyBot/assets/goldy.json
 -rw-r--r--  2.0 unx       98 b- defN 23-Jun-18 11:58 GoldyBot/assets/run.py
 -rw-r--r--  2.0 unx       76 b- defN 23-Jun-18 11:58 GoldyBot/assets/token.env
 -rw-r--r--  2.0 unx       50 b- defN 23-Jun-18 11:58 GoldyBot/cli/__init__.py
 -rw-r--r--  2.0 unx     1873 b- defN 23-Jun-18 11:58 GoldyBot/cli/__main__.py
 -rw-r--r--  2.0 unx     1419 b- defN 23-Jun-18 11:58 GoldyBot/cli/_setup.py
--rw-r--r--  2.0 unx    10935 b- defN 23-Jul-08 23:42 GoldyBot/goldy/__init__.py
+-rw-r--r--  2.0 unx    10966 b- defN 23-Aug-02 19:40 GoldyBot/goldy/__init__.py
 -rw-r--r--  2.0 unx     2854 b- defN 23-Jul-08 23:42 GoldyBot/goldy/goldy_config.py
--rw-r--r--  2.0 unx     3505 b- defN 23-Jul-08 23:42 GoldyBot/goldy/permission_system.py
--rw-r--r--  2.0 unx      193 b- defN 23-Jun-18 11:58 GoldyBot/goldy/perms.py
+-rw-r--r--  2.0 unx     3898 b- defN 23-Aug-02 19:40 GoldyBot/goldy/permission_system.py
+-rw-r--r--  2.0 unx      160 b- defN 23-Aug-02 19:40 GoldyBot/goldy/perms.py
 -rw-r--r--  2.0 unx     2833 b- defN 23-Jun-18 11:58 GoldyBot/goldy/presence.py
 -rw-r--r--  2.0 unx     1812 b- defN 23-Jul-08 23:42 GoldyBot/goldy/system.py
 -rw-r--r--  2.0 unx     3580 b- defN 23-Jun-18 11:58 GoldyBot/goldy/token.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jul-08 23:42 GoldyBot/goldy/commands/__init__.py
--rw-r--r--  2.0 unx     7958 b- defN 23-Jul-08 23:42 GoldyBot/goldy/commands/command.py
--rw-r--r--  2.0 unx     2687 b- defN 23-Jul-08 23:42 GoldyBot/goldy/commands/decorator.py
--rw-r--r--  2.0 unx     8115 b- defN 23-Jul-08 23:42 GoldyBot/goldy/commands/group_command.py
--rw-r--r--  2.0 unx     4751 b- defN 23-Jul-09 12:13 GoldyBot/goldy/commands/listener.py
--rw-r--r--  2.0 unx     3387 b- defN 23-Jul-09 12:13 GoldyBot/goldy/commands/loader.py
--rw-r--r--  2.0 unx     5695 b- defN 23-Jul-08 23:42 GoldyBot/goldy/commands/prefix_command.py
--rw-r--r--  2.0 unx     6075 b- defN 23-Jul-08 23:42 GoldyBot/goldy/commands/slash_command.py
+-rw-r--r--  2.0 unx     7975 b- defN 23-Aug-02 19:40 GoldyBot/goldy/commands/command.py
+-rw-r--r--  2.0 unx     2722 b- defN 23-Aug-02 19:40 GoldyBot/goldy/commands/decorator.py
+-rw-r--r--  2.0 unx     8234 b- defN 23-Aug-02 19:40 GoldyBot/goldy/commands/group_command.py
+-rw-r--r--  2.0 unx     5168 b- defN 23-Aug-02 19:40 GoldyBot/goldy/commands/listener.py
+-rw-r--r--  2.0 unx     5736 b- defN 23-Aug-02 19:40 GoldyBot/goldy/commands/loader.py
+-rw-r--r--  2.0 unx     5765 b- defN 23-Aug-02 19:40 GoldyBot/goldy/commands/prefix_command.py
+-rw-r--r--  2.0 unx     6181 b- defN 23-Aug-02 19:40 GoldyBot/goldy/commands/slash_command.py
 -rw-r--r--  2.0 unx     4701 b- defN 23-Jul-08 23:42 GoldyBot/goldy/database/__init__.py
--rw-r--r--  2.0 unx     3836 b- defN 23-Jul-08 23:42 GoldyBot/goldy/database/databases/__init__.py
--rw-r--r--  2.0 unx     1363 b- defN 23-Jul-08 23:42 GoldyBot/goldy/database/wrappers/__init__.py
--rw-r--r--  2.0 unx     2926 b- defN 23-Jul-08 23:42 GoldyBot/goldy/database/wrappers/member.py
--rw-r--r--  2.0 unx     3714 b- defN 23-Jul-08 23:42 GoldyBot/goldy/extensions/__init__.py
--rw-r--r--  2.0 unx     7441 b- defN 23-Jul-08 23:42 GoldyBot/goldy/extensions/extension_loader.py
--rw-r--r--  2.0 unx     4029 b- defN 23-Jul-08 23:42 GoldyBot/goldy/guilds/__init__.py
--rw-r--r--  2.0 unx     2591 b- defN 23-Jul-08 23:42 GoldyBot/goldy/guilds/guild.py
+-rw-r--r--  2.0 unx     4189 b- defN 23-Aug-02 19:40 GoldyBot/goldy/database/databases/__init__.py
+-rw-r--r--  2.0 unx     1403 b- defN 23-Aug-02 19:40 GoldyBot/goldy/database/wrappers/__init__.py
+-rw-r--r--  2.0 unx     3581 b- defN 23-Aug-02 19:40 GoldyBot/goldy/database/wrappers/guild.py
+-rw-r--r--  2.0 unx     3034 b- defN 23-Aug-02 19:40 GoldyBot/goldy/database/wrappers/member.py
+-rw-r--r--  2.0 unx     4063 b- defN 23-Aug-02 19:40 GoldyBot/goldy/extensions/__init__.py
+-rw-r--r--  2.0 unx    10358 b- defN 23-Aug-02 19:40 GoldyBot/goldy/extensions/extension_loader.py
+-rw-r--r--  2.0 unx      991 b- defN 23-Aug-02 19:40 GoldyBot/goldy/extensions/extension_metadata.py
+-rw-r--r--  2.0 unx     2956 b- defN 23-Aug-02 19:40 GoldyBot/goldy/guilds/__init__.py
+-rw-r--r--  2.0 unx     1958 b- defN 23-Aug-02 19:40 GoldyBot/goldy/guilds/guild.py
 -rw-r--r--  2.0 unx     1016 b- defN 23-Jun-18 11:58 GoldyBot/goldy/live_console/__init__.py
--rw-r--r--  2.0 unx     2177 b- defN 23-Jul-08 23:42 GoldyBot/goldy/live_console/app.py
--rw-r--r--  2.0 unx      609 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/__init__.py
--rw-r--r--  2.0 unx      508 b- defN 23-Jun-18 11:58 GoldyBot/goldy/nextcore_utils/colours.py
--rw-r--r--  2.0 unx     5798 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/front_end_errors.py
+-rw-r--r--  2.0 unx     2176 b- defN 23-Aug-02 19:40 GoldyBot/goldy/live_console/app.py
+-rw-r--r--  2.0 unx      948 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/__init__.py
+-rw-r--r--  2.0 unx     1164 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/colours.py
+-rw-r--r--  2.0 unx     1450 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/defer.py
+-rw-r--r--  2.0 unx      681 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/files.py
+-rw-r--r--  2.0 unx     6763 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/front_end_errors.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-18 11:58 GoldyBot/goldy/nextcore_utils/channels/__init__.py
 -rw-r--r--  2.0 unx     1222 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/channels/delete_channel.py
 -rw-r--r--  2.0 unx     1158 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/channels/get_channel.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-18 11:58 GoldyBot/goldy/nextcore_utils/embeds/__init__.py
--rw-r--r--  2.0 unx     4255 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/embeds/embed.py
+-rw-r--r--  2.0 unx     5217 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/embeds/embed.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-18 11:58 GoldyBot/goldy/nextcore_utils/guilds/__init__.py
 -rw-r--r--  2.0 unx     1237 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/guilds/get_channels.py
--rw-r--r--  2.0 unx     1074 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/guilds/get_guild_data.py
+-rw-r--r--  2.0 unx     1073 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/guilds/get_guild_data.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-18 11:58 GoldyBot/goldy/nextcore_utils/messages/__init__.py
 -rw-r--r--  2.0 unx     1317 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/messages/delete_msg.py
--rw-r--r--  2.0 unx     9357 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/messages/send_msg.py
+-rw-r--r--  2.0 unx    10828 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/messages/send_msg.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jun-18 11:58 GoldyBot/goldy/nextcore_utils/slash_options/__init__.py
--rw-r--r--  2.0 unx     2523 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/slash_options/auto_complete.py
--rw-r--r--  2.0 unx     4952 b- defN 23-Jul-08 23:42 GoldyBot/goldy/nextcore_utils/slash_options/slash_option.py
--rw-r--r--  2.0 unx      285 b- defN 23-Jul-08 23:42 GoldyBot/goldy/objects/__init__.py
+-rw-r--r--  2.0 unx     5378 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/slash_options/auto_complete.py
+-rw-r--r--  2.0 unx     4913 b- defN 23-Aug-02 19:40 GoldyBot/goldy/nextcore_utils/slash_options/slash_option.py
+-rw-r--r--  2.0 unx      235 b- defN 23-Aug-02 19:40 GoldyBot/goldy/objects/__init__.py
 -rw-r--r--  2.0 unx     2303 b- defN 23-Jul-08 23:42 GoldyBot/goldy/objects/channel.py
 -rw-r--r--  2.0 unx     2293 b- defN 23-Jul-09 12:13 GoldyBot/goldy/objects/invokable.py
--rw-r--r--  2.0 unx     1811 b- defN 23-Jul-08 23:42 GoldyBot/goldy/objects/member.py
+-rw-r--r--  2.0 unx     1894 b- defN 23-Aug-02 19:40 GoldyBot/goldy/objects/member.py
 -rw-r--r--  2.0 unx     1079 b- defN 23-Jul-08 23:42 GoldyBot/goldy/objects/message.py
--rw-r--r--  2.0 unx     2438 b- defN 23-Jul-08 23:42 GoldyBot/goldy/objects/platter/__init__.py
--rw-r--r--  2.0 unx     1522 b- defN 23-Jul-08 23:42 GoldyBot/goldy/objects/platter/golden_platter.py
--rw-r--r--  2.0 unx      965 b- defN 23-Jul-08 23:42 GoldyBot/goldy/objects/platter/silver_platter.py
--rw-r--r--  2.0 unx     2491 b- defN 23-Jul-08 23:42 GoldyBot/goldy/recipes/__init__.py
+-rw-r--r--  2.0 unx      841 b- defN 23-Aug-02 19:40 GoldyBot/goldy/objects/platter/__init__.py
+-rw-r--r--  2.0 unx     4039 b- defN 23-Aug-02 19:40 GoldyBot/goldy/objects/platter/golden_platter.py
+-rw-r--r--  2.0 unx     2488 b- defN 23-Aug-02 19:40 GoldyBot/goldy/recipes/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Jul-08 23:42 GoldyBot/goldy/recipes/buttons/__init__.py
--rw-r--r--  2.0 unx     3764 b- defN 23-Jul-08 23:42 GoldyBot/goldy/recipes/buttons/button.py
--rw-r--r--  2.0 unx     2809 b- defN 23-Jul-08 23:42 GoldyBot/internal_extensions/extensions.py
--rw-r--r--  2.0 unx     2645 b- defN 23-Jul-08 23:42 GoldyBot/internal_extensions/goldy.py
--rw-r--r--  2.0 unx     8378 b- defN 23-Jul-08 23:42 GoldyBot/internal_extensions/timestamps.py
--rw-r--r--  2.0 unx      181 b- defN 23-Jul-08 23:42 GoldyBot/utils/__init__.py
+-rw-r--r--  2.0 unx     3946 b- defN 23-Aug-02 19:40 GoldyBot/goldy/recipes/buttons/button.py
+-rw-r--r--  2.0 unx     2709 b- defN 23-Aug-02 19:40 GoldyBot/internal_extensions/goldy.py
+-rw-r--r--  2.0 unx     6090 b- defN 23-Aug-02 19:40 GoldyBot/internal_extensions/guild_admin.py
+-rw-r--r--  2.0 unx     7887 b- defN 23-Aug-02 19:40 GoldyBot/internal_extensions/timestamps.py
+-rw-r--r--  2.0 unx      212 b- defN 23-Aug-02 19:40 GoldyBot/utils/__init__.py
 -rw-r--r--  2.0 unx      375 b- defN 23-Jul-08 23:42 GoldyBot/utils/_async.py
+-rw-r--r--  2.0 unx      404 b- defN 23-Aug-02 19:40 GoldyBot/utils/_dict.py
 -rw-r--r--  2.0 unx      283 b- defN 23-Jul-08 23:42 GoldyBot/utils/_lambda.py
--rw-r--r--  2.0 unx     1196 b- defN 23-Jul-08 23:42 GoldyBot/utils/cache.py
+-rw-r--r--  2.0 unx     1209 b- defN 23-Aug-02 19:40 GoldyBot/utils/cache.py
 -rw-r--r--  2.0 unx     1771 b- defN 23-Jul-08 23:42 GoldyBot/utils/human_datetime.py
 -rw-r--r--  2.0 unx      251 b- defN 23-Jul-08 23:42 GoldyBot/utils/strings.py
--rw-r--r--  2.0 unx    35123 b- defN 23-Jul-09 12:16 GoldyBot-5.0.dev6.dist-info/LICENSE
--rw-r--r--  2.0 unx    48606 b- defN 23-Jul-09 12:16 GoldyBot-5.0.dev6.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-09 12:16 GoldyBot-5.0.dev6.dist-info/WHEEL
--rw-r--r--  2.0 unx      105 b- defN 23-Jul-09 12:16 GoldyBot-5.0.dev6.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        9 b- defN 23-Jul-09 12:16 GoldyBot-5.0.dev6.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     7525 b- defN 23-Jul-09 12:16 GoldyBot-5.0.dev6.dist-info/RECORD
-82 files, 307400 bytes uncompressed, 106832 bytes compressed:  65.2%
+-rw-r--r--  2.0 unx    35123 b- defN 23-Aug-02 19:42 GoldyBot-5.0.dev7.dist-info/LICENSE
+-rw-r--r--  2.0 unx    49123 b- defN 23-Aug-02 19:42 GoldyBot-5.0.dev7.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-02 19:42 GoldyBot-5.0.dev7.dist-info/WHEEL
+-rw-r--r--  2.0 unx      105 b- defN 23-Aug-02 19:42 GoldyBot-5.0.dev7.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        9 b- defN 23-Aug-02 19:42 GoldyBot-5.0.dev7.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     7893 b- defN 23-Aug-02 19:42 GoldyBot-5.0.dev7.dist-info/RECORD
+86 files, 331305 bytes uncompressed, 113230 bytes compressed:  65.8%
```

## zipnote {}

```diff
@@ -90,23 +90,29 @@
 
 Filename: GoldyBot/goldy/database/databases/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/database/wrappers/__init__.py
 Comment: 
 
+Filename: GoldyBot/goldy/database/wrappers/guild.py
+Comment: 
+
 Filename: GoldyBot/goldy/database/wrappers/member.py
 Comment: 
 
 Filename: GoldyBot/goldy/extensions/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/extensions/extension_loader.py
 Comment: 
 
+Filename: GoldyBot/goldy/extensions/extension_metadata.py
+Comment: 
+
 Filename: GoldyBot/goldy/guilds/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/guilds/guild.py
 Comment: 
 
 Filename: GoldyBot/goldy/live_console/__init__.py
@@ -117,14 +123,20 @@
 
 Filename: GoldyBot/goldy/nextcore_utils/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/nextcore_utils/colours.py
 Comment: 
 
+Filename: GoldyBot/goldy/nextcore_utils/defer.py
+Comment: 
+
+Filename: GoldyBot/goldy/nextcore_utils/files.py
+Comment: 
+
 Filename: GoldyBot/goldy/nextcore_utils/front_end_errors.py
 Comment: 
 
 Filename: GoldyBot/goldy/nextcore_utils/channels/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/nextcore_utils/channels/delete_channel.py
@@ -183,65 +195,65 @@
 
 Filename: GoldyBot/goldy/objects/platter/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/objects/platter/golden_platter.py
 Comment: 
 
-Filename: GoldyBot/goldy/objects/platter/silver_platter.py
-Comment: 
-
 Filename: GoldyBot/goldy/recipes/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/recipes/buttons/__init__.py
 Comment: 
 
 Filename: GoldyBot/goldy/recipes/buttons/button.py
 Comment: 
 
-Filename: GoldyBot/internal_extensions/extensions.py
+Filename: GoldyBot/internal_extensions/goldy.py
 Comment: 
 
-Filename: GoldyBot/internal_extensions/goldy.py
+Filename: GoldyBot/internal_extensions/guild_admin.py
 Comment: 
 
 Filename: GoldyBot/internal_extensions/timestamps.py
 Comment: 
 
 Filename: GoldyBot/utils/__init__.py
 Comment: 
 
 Filename: GoldyBot/utils/_async.py
 Comment: 
 
+Filename: GoldyBot/utils/_dict.py
+Comment: 
+
 Filename: GoldyBot/utils/_lambda.py
 Comment: 
 
 Filename: GoldyBot/utils/cache.py
 Comment: 
 
 Filename: GoldyBot/utils/human_datetime.py
 Comment: 
 
 Filename: GoldyBot/utils/strings.py
 Comment: 
 
-Filename: GoldyBot-5.0.dev6.dist-info/LICENSE
+Filename: GoldyBot-5.0.dev7.dist-info/LICENSE
 Comment: 
 
-Filename: GoldyBot-5.0.dev6.dist-info/METADATA
+Filename: GoldyBot-5.0.dev7.dist-info/METADATA
 Comment: 
 
-Filename: GoldyBot-5.0.dev6.dist-info/WHEEL
+Filename: GoldyBot-5.0.dev7.dist-info/WHEEL
 Comment: 
 
-Filename: GoldyBot-5.0.dev6.dist-info/entry_points.txt
+Filename: GoldyBot-5.0.dev7.dist-info/entry_points.txt
 Comment: 
 
-Filename: GoldyBot-5.0.dev6.dist-info/top_level.txt
+Filename: GoldyBot-5.0.dev7.dist-info/top_level.txt
 Comment: 
 
-Filename: GoldyBot-5.0.dev6.dist-info/RECORD
+Filename: GoldyBot-5.0.dev7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## GoldyBot/__init__.py

```diff
@@ -27,15 +27,16 @@
 from .goldy.database.wrappers import DatabaseWrapper
 
 # Nextcore utils and api wrappers.
 # ----------------------------------
 from .goldy import nextcore_utils
 from .goldy.nextcore_utils import (
     Colours,
-    Embed, EmbedField, EmbedImage,
+    File,
+    Embed, EmbedField, EmbedImage, EmbedFooter,
     SlashOption, SlashOptionChoice, SlashOptionTypes,
     SlashOptionAutoComplete,
     send_msg, delete_msg,
     get_channel, get_channels, delete_channel,
     front_end_errors
 )
```

## GoldyBot/info.py

```diff
@@ -1,15 +1,17 @@
 # Version info
 # --------------
 VER = 5.0
 """Just the version number as an integer. E.g ``5.0``."""
-STAGE = ("dev", 6)
+STAGE = ("dev", 7)
 
 VERSION = f"{VER}{STAGE[0]}{STAGE[1]}"
 """Goldy Bot version string. E.g ``5.0alpha8``."""
 
 DISPLAY_NAME = f"Goldy Bot (v{VERSION})"
 """Display name of goldy bot with it's version, like e.g ``Goldy Bot (v5.0alpha8)``."""
 
+GITHUB_REPO = "https://github.com/Goldy-Bot/Goldy-Bot-V5"
+
 COPYRIGHT = "Copyright (C) 2023 - Goldy"
 
 __version__ = VERSION
```

## GoldyBot/assets/goldy.json

### Pretty-printed

 * *Similarity: 0.984375%*

 * *Differences: {"'goldy'": "{'allowed_guilds': {'{guild_id_here}': 'test_server'}}"}*

```diff
@@ -1,11 +1,11 @@
 {
     "goldy": {
         "allowed_guilds": {
-            "{guild_id_here}": "uwu_hangout_guild"
+            "{guild_id_here}": "test_server"
         },
         "bot_dev": null,
         "ding_on_exit": false,
         "extensions": {
             "folder_location": "./extensions",
             "ignored_extensions": [],
             "late_load_extensions": [],
```

## GoldyBot/goldy/__init__.py

```diff
@@ -215,15 +215,18 @@
         await self.command_loader.load()
         await self.command_listener.start_listening()
 
     def stop(self, reason: str = "Unknown Reason"):
         """Shuts down goldy bot right away and safely incase anything sussy wussy is going on. 😳"""
         self.live_console.stop()
 
-        self.async_loop.create_task(self.shard_manager.dispatcher.dispatch("critical", "Goldy Exiting: " + reason)) # Raises critical error within nextcore and stops it.
+        # Raises critical error within nextcore and stops it.
+        self.async_loop.create_task(
+            self.shard_manager.dispatcher.dispatch("critical", "Goldy Exiting: " + reason)
+        ) 
 
     async def stop_async(self, reason:str = "Unknown Reason"):
         """Shuts down goldy bot asynchronously."""
         self.live_console.stop()
 
         await self.shard_manager.dispatcher.dispatch("critical", "Goldy Exiting: " + reason)
```

## GoldyBot/goldy/permission_system.py

```diff
@@ -1,14 +1,15 @@
 from __future__ import annotations
 from typing import TYPE_CHECKING
 from discord_typings import GuildMemberData
 
 from nextcore.http import Route
 from devgoldyutils import LoggerAdapter, Colours
 
+from .perms import Perms
 from .. import goldy_bot_logger
 
 if TYPE_CHECKING:
     from . import Goldy
     from .objects.platter.golden_platter import GoldPlatter
 
 class PermissionSystem():
@@ -17,24 +18,33 @@
         self.goldy = goldy
 
         self.logger = LoggerAdapter(goldy_bot_logger, prefix=Colours.PURPLE.apply("PermissionSystem"))
 
     async def got_perms(self, platter: GoldPlatter) -> bool: # TODO: I might rename this method.
         """Method that checks if the command author has the perms to run this command."""
         
-        if not platter.command.required_roles == []:
+        if not platter.invokable.required_perms == []:
             self.logger.debug("Checking if member has perms to run command...")
 
             # If the required roles contain 'bot_dev' and the bot dev is running the command allow the command to execute.
             # --------------------------------------------------------------------------------------------------------------
-            if "bot_dev" in platter.command.required_roles:
+            if Perms.BOT_DEV in platter.invokable.required_perms:
                 if platter.author.id == self.goldy.config.bot_dev:
                     self.logger.debug("Member is a bot developer :)")
                     return True
 
+            # TODO: Add bot admin.
+
+            # Server owner check.
+            # --------------------
+            if Perms.GUILD_OWNER in platter.invokable.required_perms:
+                if platter.author.id == platter.guild.get("owner_id"):
+                    self.logger.debug("Member is server owner ✅")
+                    return True
+
             # Check if member has any of the required roles.
             #----------------------------------------------------
 
             # Get the member's guild data.
             r = await self.goldy.http_client.request(
                 Route(
                     "GET",
@@ -44,23 +54,23 @@
                 ),
                 rate_limit_key = self.goldy.nc_authentication.rate_limit_key,
                 headers = self.goldy.nc_authentication.headers,
             )
 
             member_data: GuildMemberData = await r.json()
 
-            for role_code_name in platter.command.required_roles:
+            for role_code_name in platter.invokable.required_perms:
 
-                if role_code_name not in ["bot_dev"]:
+                if role_code_name not in Perms:
                     try:
-                        role_id_uwu = platter.guild.roles[role_code_name]
+                        role_id_uwu = platter.guild.config_wrapper.roles[role_code_name]
                     except KeyError:
                         # Maybe there is a better way of handling this but I'll leave this as temporary solution for now.
                         self.logger.error(
-                            f"This guild ({platter.guild.code_name}) hasn't been configured to include the required role '{role_code_name}' you entered for the command '{platter.command.name}'."
+                            f"This guild ({platter.guild.code_name}) hasn't been configured to include the required role '{role_code_name}' you entered for the command '{platter.invokable.name}'."
                         )
                         return False
 
                     # Loop through each role of the member and check if the role id is equal to that required.
                     for member_role_id in member_data["roles"]:
                         if str(member_role_id) == role_id_uwu:
                             self.logger.debug(f"The author has the required role '{role_code_name}' :)")
```

## GoldyBot/goldy/perms.py

```diff
@@ -1,9 +1,9 @@
 from enum import Enum
 
 class Perms(Enum):
-    """Goldy Bot's built-in perms."""
-    BOT_DEV = "bot_dev"
-    BOT_ADMIN = "bot_admin"
+    """Goldy Bot's built-in permissions."""
+    BOT_DEV = 0
+    BOT_ADMIN = 1
 
-    def __str__(self) -> str:
-        return str(self.value)
+    GUILD_OWNER = 2
+    GUILD_ADMIN = 3
```

## GoldyBot/goldy/commands/command.py

```diff
@@ -6,49 +6,50 @@
 import regex
 from devgoldyutils import LoggerAdapter, Colours
 
 from ..extensions import extensions_cache
 from ... import goldy_bot_logger, utils
 from ..objects import Invokable
 from ... import errors
+from ..perms import Perms
 from ..nextcore_utils import front_end_errors
 
 if TYPE_CHECKING:
     from ... import Goldy, Extension
     from .. import objects
 
 class Command(Invokable):
     """Class that all commands in goldy bot inherit from."""
     def __init__(
         self, 
         goldy: Goldy, 
         func: Callable[[Extension, objects.GoldPlatter], Any], 
         name: str = None, 
         description: str = None, 
-        required_roles: List[str] = None, 
+        required_perms: List[Perms | str] = None, 
         slash_options: Dict[str, ApplicationCommandOptionData] = None, 
         hidden: bool = False, 
         pre_register = True
     ):
         self.func = func
         """The command's callback function."""
 
         self.extension_name = str(self.func).split(" ")[1].split(".")[0]
         """Returns extension's code name."""
 
         if name is None:
             name = func.__name__
 
         if description is None:
-            description = "🪹 Oops daisy, looks like no description was set for this command."
+            description = "🪹 Oopsie daisy, looks like no description was set for this command."
 
-        if required_roles is None:
-            self.__required_roles = []
+        if required_perms is None:
+            self.__required_perms = []
         else:
-            self.__required_roles = [str(role) for role in required_roles]
+            self.__required_perms = required_perms
 
         if slash_options is None:
             self.__slash_options = {}
         else:
             self.__slash_options = slash_options
 
         self.__hidden = hidden
@@ -81,17 +82,17 @@
 
     @property
     def description(self) -> str:
         """The command's set description. None if there is no description set."""
         return self.get("description")
 
     @property
-    def required_roles(self):
+    def required_perms(self):
         """The code names for the roles needed to access this command."""
-        return self.__required_roles
+        return self.__required_perms
 
     @property
     def slash_options(self):
         """Allows you to customize slash command arguments and make them beautiful 🥰."""
         return self.__slash_options
 
     @property
@@ -157,29 +158,29 @@
         """
         ...
 
     @abstractmethod
     async def invoke(self, platter: objects.GoldPlatter, lambda_func: Callable) -> None:
         self.logger.debug("Attempting to invoke command...")
 
-        if platter.guild.is_extension_allowed(self.extension) is False:
+        if await platter.guild.is_extension_allowed(self.extension) is False:
             raise front_end_errors.ExtensionNotAllowedInGuild(platter, self.logger)
 
         if self.is_disabled:
             raise front_end_errors.CommandIsDisabled(platter, self.logger)
 
         # I'm using a lambda function here so all the parameter bullshit 
         # can be handled by the child class instead of this method.
         if await self.goldy.permission_system.got_perms(platter):
             self.logger.info(
                 Colours.BLUE.apply(
                     f"Command invoked by '{platter.author.username}#{platter.author.discriminator}'."
                 )
             )
-            return await lambda_func() 
+            return await lambda_func()
 
         # If member has no perms raise MissingPerms exception.
         raise front_end_errors.MissingPerms(platter, self.logger)
 
 
     def __get_function_parameters(self) -> List[str]:
         """Returns the function parameters of a command respectively."""
```

## GoldyBot/goldy/commands/decorator.py

```diff
@@ -4,43 +4,43 @@
 
 from .group_command import GroupCommand
 from .slash_command import SlashCommand
 from .prefix_command import PrefixCommand
 from ... import get_goldy_instance
 
 if TYPE_CHECKING:
-    from GoldyBot import SlashOption
+    from GoldyBot import SlashOption, Perms
 
 @overload
 def command(
     name: str = None, 
     description: str = None, 
-    required_roles: List[str] = None, 
+    required_perms: List[str | Perms] = None, 
     slash_options: Dict[str, SlashOption] = None,
     slash_cmd_only: bool = False, 
     hidden: bool = False,
     group: Literal[False] = False
-) -> Callable[..., None]:
+) -> Callable[..., Callable]:
     ...
 
 @overload
 def command(
     name: str = None, 
     description: str = None, 
-    required_roles: List[str] = None, 
+    required_perms: List[str | Perms] = None, 
     slash_cmd_only: bool = False, 
     hidden: bool = False,
     group: Literal[True] = False
 ) -> Callable[..., GroupCommand]:
     ...
 
 def command(
     name: str = None, 
     description: str = None, 
-    required_roles: List[str] = None, 
+    required_perms: List[str | Perms] = None, 
     slash_options: Dict[str, SlashOption] = None,
     slash_cmd_only: bool = False, 
     hidden: bool = False,
     group: bool = False
 ):
     """
     Add a command to Goldy Bot with this decorator.
@@ -68,26 +68,26 @@
 
             commands = (
                 SlashCommand(
                     goldy = goldy, 
                     func = func, 
                     name = name, 
                     description = description, 
-                    required_roles = required_roles, 
+                    required_perms = required_perms, 
                     slash_options = slash_options,
                     hidden = hidden
                 ),
                 PrefixCommand(
                     goldy = goldy,
                     func = func,
                     name = name,
                     description = description,
-                    required_roles = required_roles,
+                    required_perms = required_perms,
                     hidden = hidden
                 ) if slash_cmd_only is False else None
             )
 
-            return GroupCommand(base_commands = commands) if group else None
+            return GroupCommand(base_commands = commands) if group else func
 
         return inner(func)
 
     return decorate
```

## GoldyBot/goldy/commands/group_command.py

```diff
@@ -1,14 +1,15 @@
 from __future__ import annotations
-from typing import Dict, List, TYPE_CHECKING, Tuple, overload, Callable
+from typing import Dict, List, TYPE_CHECKING, Tuple, overload, Callable, Any
 
 from devgoldyutils import LoggerAdapter
 
 if TYPE_CHECKING:
     from ..nextcore_utils.slash_options.slash_option import SlashOption
+    from ..objects.platter.golden_platter import GoldPlatter
 
 from .slash_command import SlashCommand
 from .prefix_command import PrefixCommand
 from ... import get_goldy_instance, goldy_bot_logger
 
 class GroupCommand():
     """
@@ -48,15 +49,15 @@
 
     """
     @overload
     def __init__(
         self, 
         name: str, 
         description: str = None, 
-        required_roles: List[str] = None, 
+        required_perms: List[str] = None, 
         slash_cmd_only: bool = False, 
         hidden: bool = False,
     ):
         ...
         
     @overload
     def __init__(
@@ -65,15 +66,15 @@
     ):
         ...
 
     def __init__(
         self, 
         name: str = None, 
         description: str = None, 
-        required_roles: List[str] = None, 
+        required_perms: List[str] = None, 
         slash_cmd_only: bool = False, 
         hidden: bool = False,
         base_commands: Tuple[SlashCommand, PrefixCommand] = None
     ):
         self.goldy = get_goldy_instance()
         self.logger = LoggerAdapter(goldy_bot_logger, prefix="GroupCommand")
 
@@ -82,23 +83,23 @@
         if base_commands is None:
             self.commands = (
                 SlashCommand(
                     self.goldy, 
                     func = lambda x, y: self.__dummy__(),
                     name = name,
                     description = description,
-                    required_roles = required_roles,
+                    required_perms = required_perms,
                     hidden = hidden
                 ),
                 PrefixCommand(
                     self.goldy, 
                     func = lambda x, y: self.__dummy__(),
                     name = name,
                     description = description,
-                    required_roles = required_roles,
+                    required_perms = required_perms,
                     hidden = hidden
                 ) if slash_cmd_only is False else None
             )
         else:
             self.commands = base_commands
 
         self.logger.debug("Group command has been initialized!")
@@ -120,15 +121,15 @@
 
         return decorate
 
     def sub_command(
         self,
         name: str = None, 
         description: str = None, 
-        required_roles: List[str]=None, 
+        required_perms: List[str]=None, 
         slash_options: Dict[str, SlashOption] = None
     ):
         """
         Create a sub command in this group command with this decorator.
         
         ---------------
         
@@ -190,43 +191,45 @@
             async def start(self, platter: GoldyBot.GoldPlatter):
                 await platter.send_message("✅ Game has started!", reply=True)
 
         Although this now sort of defeats the purpose, so it's up to you to pick which one is best. 😉
 
         """
         def decorate(func):
-            def inner(func: Callable) -> None:
+            def inner(func: Callable) -> Callable[[GoldPlatter], Any]:
                 slash_cmd, prefix_cmd = self.commands
 
                 if slash_cmd is not None:
                     slash_cmd.extension_name = str(func).split(" ")[1].split(".")[0] # I do this incase the master command is not set.
                     slash_cmd.register_sub_command(
                         SlashCommand(
                             self.goldy,
                             func,
                             name,
                             description,
-                            required_roles,
+                            required_perms,
                             slash_options,
                             pre_register = False
                         )
                     )
 
                 if prefix_cmd is not None:
                     prefix_cmd.extension_name = str(func).split(" ")[1].split(".")[0]  # I do this incase the master command is not set.
                     prefix_cmd.register_sub_command(
                         PrefixCommand(
                             self.goldy,
                             func,
                             name,
                             description,
-                            required_roles,
+                            required_perms,
                             pre_register = False
                         )
                     )
 
+                return func
+
             return inner(func)
 
         return decorate
 
     async def __dummy__(self):
         ...
```

## GoldyBot/goldy/commands/listener.py

```diff
@@ -6,15 +6,14 @@
 
 from .slash_command import SlashCommand
 from .prefix_command import PrefixCommand
 from ..recipes.buttons.button import Button
 from .. import objects
 from ... import LoggerAdapter, goldy_bot_logger, utils
 from ..objects.platter.golden_platter import GoldPlatter
-from ..objects.platter.silver_platter import SilverPlatter
 
 if TYPE_CHECKING:
     from .. import Goldy
 
 class CommandListener():
     """Class that handles the invoking of commands."""
     def __init__(self, goldy: Goldy) -> None:
@@ -45,83 +44,94 @@
 
     async def on_interaction(self, interaction: InteractionCreateData) -> None:
         guild = self.goldy.guild_manager.get_guild(interaction["guild_id"])
 
         if guild is not None:
             author = objects.Member(interaction["member"]["user"], guild, self.goldy)
 
-            # Slash command.
-            # ---------------
-            if interaction["type"] == 2:
-                command: Tuple[str, SlashCommand] = utils.cache_lookup(f"{guild.id}:{interaction['data']['id']}", self.goldy.invokables)
+            # Slash commands and slash auto complete.
+            # ------------------------------------------
+            if interaction["type"] == 2 or interaction["type"] == 4:
+                command: Tuple[str, SlashCommand] = utils.cache_lookup(f"{interaction['data']['id']}", self.goldy.invokables)
+
+                # uhhhh, let's hope this doesn't cause the biggest catastrophe EVER!!
+
+                if command is None and guild.code_name == "test_server": 
+                    command: Tuple[str, SlashCommand] = utils.cache_lookup(
+                        f"{guild.id}:{interaction['data']['id']}", 
+                        self.goldy.invokables
+                    )
 
                 if command is not None:
-                    gold_platter = GoldPlatter(
-                        data = interaction, 
-                        author = author,
-                        command = command[1]
-                    )
 
-                    await command[1].invoke(
-                        gold_platter
-                    )
+                    if interaction["type"] == 2:
+                        gold_platter = GoldPlatter(
+                            data = interaction, 
+                            author = author,
+                            invokable = command[1]
+                        )
+
+                        await gold_platter.guild.config_wrapper.update()
+
+                        await command[1].invoke(
+                            gold_platter
+                        )
+
+                    elif interaction["type"] == 4:
+                        await command[1].invoke_auto_complete(interaction)
 
 
             # Message components.
             # --------------------
             elif interaction["type"] == 3:
                 interaction: ComponentInteractionData
                 message_component: Tuple[str, Button] = utils.cache_lookup(interaction["data"]["custom_id"], self.goldy.invokables)
 
                 if message_component is not None:
-                    silver_platter = SilverPlatter(
+                    gold_platter = GoldPlatter(
                         data = interaction, 
                         author = author,
-                        recipe = message_component[1]
+                        invokable = message_component[1]
                     )
 
+                    await gold_platter.guild.config_wrapper.update()
+
                     await message_component[1].invoke(
-                        silver_platter
+                        gold_platter
                     )
 
-
-            # Command auto complete
-            # -----------------------
-            elif interaction["type"] == 4:
-                command: Tuple[str, SlashCommand] = utils.cache_lookup(f"{guild.id}:{interaction['data']['id']}", self.goldy.invokables)
-
-                if command is not None:
-                    await command[1].invoke_auto_complete(interaction)
-
         return None
 
 
     async def on_prefix_cmd(self, message: MessageData) -> None:
         guild = self.goldy.guild_manager.get_guild(message["guild_id"])
 
         # If user is bot return right away.
         if message["author"].get("bot", False):
             return
 
         if guild is not None:
             #await guild.update() # Since v5.0dev5 the guild database data is no longer updated automatically via the on message event.
             # This means if you manually change the command prefix in the database you have to also manually run "reload_config" in live console.
-            
+
             # Check if prefix is correct.
-            if not guild.prefix == message["content"][0]:
+            guild_config = await guild.config
+            if len(message["content"]) < 1 or not guild_config.prefix == message["content"][0]:
                 return
 
             # i really hope this doesn't break
             command: Tuple[str, PrefixCommand] = utils.cache_lookup(message["content"].split(" ")[0][1:], self.goldy.invokables)
 
-            if command is not None: # TODO: move this to invoke method and add a front end exception.
+            if command is not None:
                 gold_platter = GoldPlatter(
                     data = message, 
                     author = objects.Member(message["author"], guild, self.goldy),
-                    command = command[1],
+                    invokable = command[1],
                 )
-                
+
+                await gold_platter.guild.config_wrapper.update()
+
                 await command[1].invoke(
                     gold_platter
                 )
-        
-        return None
+
+        return None
```

## GoldyBot/goldy/commands/loader.py

```diff
@@ -1,10 +1,10 @@
 from __future__ import annotations
-from typing import List, overload
-from discord_typings import ApplicationCommandPayload
+from typing import List, overload, Tuple
+from discord_typings import ApplicationCommandPayload, ApplicationCommandData
 
 from nextcore.http import Route
 
 from .. import Goldy
 from . import slash_command
 from .command import Command
 from ... import goldy_bot_logger, LoggerAdapter
@@ -52,39 +52,106 @@
 
             command._is_loaded = True
 
             command.logger.debug("Command loaded.")
 
         slash_commands_to_register = [x for x in self.goldy.pre_invokables if isinstance(x, slash_command.SlashCommand)]
 
-        # Create slash commands for each allowed guild.
-        # ----------------------------------------------
+
+        # Grab testing server.
+        testing_server = None
         for guild in self.goldy.guild_manager.allowed_guilds:
+            if not guild[1] == "test_server":
+                continue
+
+            testing_server = guild
+            break
+
+        await self.__batch_create_interactions(
+            slash_commands_to_register = slash_commands_to_register,
+            slash_command_payloads = slash_command_payloads,
+            testing_server = testing_server
+        )
+
+        self.logger.info("All commands loaded!")
+
+        return None
+    
+    async def __batch_create_interactions(
+        self, 
+        slash_commands_to_register: List[slash_command.SlashCommand], 
+        slash_command_payloads: List[ApplicationCommandPayload], 
+        testing_server: Tuple[str, str] | None
+    ) -> None:
+        created_interactions: List[ApplicationCommandData] = []
+
+        # Creating global commands.
+        # --------------------------
+        global_route = Route(
+            "PUT",
+            "/applications/{application_id}/commands",
+            application_id = self.goldy.application_data["id"]
+        )
+        
+        r = await self.goldy.http_client.request(
+            global_route,
+            rate_limit_key = self.goldy.nc_authentication.rate_limit_key,
+            headers = self.goldy.nc_authentication.headers,
+            json = slash_command_payloads
+        )
+
+        created_interactions += await r.json()
+        self.logger.debug("Created global commands.")
+
+
+        # Creating guild commands for testing server.
+        # --------------------------------------------
+        if testing_server is not None:
+            testing_guild_route = Route(
+                "PUT",
+                "/applications/{application_id}/guilds/{guild_id}/commands",
+                application_id = self.goldy.application_data["id"],
+                guild_id = testing_server[0],
+            )
+
+            # Adding test warning to all slash commands for the test server.
+            for payload in slash_command_payloads:
+                test_description = "⚒️ THIS IS A TEST COMMAND REGISTERED JUST FOR THIS GUILD"
+                
+                # Setting test description to all first layer sub commands.
+                for option in payload["options"]:
+                    if not option["type"] == 1:
+                        continue
+
+                    option["description"] = test_description
+
+                payload["description"] = test_description
 
+            # Creating guild commands for testing server.
             r = await self.goldy.http_client.request(
-                Route(
-                    "PUT",
-                    "/applications/{application_id}/guilds/{guild_id}/commands",
-                    application_id = self.goldy.application_data["id"],
-                    guild_id = guild[0],
-                ),
+                testing_guild_route,
                 rate_limit_key = self.goldy.nc_authentication.rate_limit_key,
                 headers = self.goldy.nc_authentication.headers,
                 json = slash_command_payloads
             )
 
-            registered_interactions = await r.json()
+            created_interactions += await r.json()
 
-            # Registering slash commands with the id given by discord.
-            for interaction in registered_interactions:
+            self.logger.debug("Created guild commands for test server.")
 
-                for command in slash_commands_to_register:
 
-                    if command.name == interaction["name"]:
-                        command.register(f"{guild[0]}:{interaction['id']}")
-                        break
+        # Registering slash commands with the id given by discord.
+        # ----------------------------------------------------------
+        for interaction in created_interactions:
 
-            self.logger.debug(f"Created slash cmds for guild '{guild[1]}'.")
+            for command in slash_commands_to_register:
 
-        self.logger.info("All commands loaded!")
+                if command.name == interaction["name"]:
+
+                    if interaction.get("guild_id") is not None:
+                        command.register(f"{interaction.get('guild_id')}:{interaction['id']}")
+                    else:
+                        command.register(f"{interaction['id']}")
+
+                    break
 
         return None
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## GoldyBot/goldy/commands/prefix_command.py

```diff
@@ -14,26 +14,26 @@
 class PrefixCommand(Command):
     def __init__(
         self, 
         goldy: Goldy, 
         func: Callable[[Extension, objects.GoldPlatter], Any], 
         name: str = None, 
         description: str = None, 
-        required_roles: List[str] = None, 
+        required_perms: List[str] = None, 
         hidden: bool = False,
         pre_register: bool = True
     ):
         self.__sub_commands: List[PrefixCommand] = []
 
         super().__init__(
             goldy = goldy, 
             func = func, 
             name = name, 
             description = description, 
-            required_roles = required_roles, 
+            required_perms = required_perms, 
             hidden = hidden,
             pre_register = pre_register
         )
 
         self.logger.debug("Prefix command has been initialized!")
 
     @property
@@ -63,15 +63,15 @@
         data: MessageData = platter.data
 
         params = self.__invoke_data_to_params(data)
         if not params == []: self.logger.debug(f"Got args --> {params}")
 
         try:
             return_value = await super().invoke(
-                platter, lambda: self.func(platter.command.extension, platter, *params)
+                platter, lambda: self.func(platter.invokable.extension, platter, *params)
             )
 
             # Handle sub commands.
             # ----------------------
             # Invoke sub command if there is one in invoke data.
             if return_value is not False:
                 await self.__invoke_sub_command(data, platter)
@@ -89,29 +89,31 @@
             # The or condition is here because of newer python versions.
             if f"{self.func.__name__}() takes" in e.args[0] or f"{self.extension_name}.{self.func.__name__}() takes" in e.args[0]:
                 raise front_end_errors.InvalidArguments(
                     platter = platter, 
                     logger = self.logger
                 )
 
-            # TODO: When exceptions raise in commands wrap them in a goldy bot command exception.
-            raise e
+            raise front_end_errors.UnknownError(platter, logger = self.logger)
+
+        except Exception as e:
+            raise front_end_errors.UnknownError(platter, e, self.logger)
 
     async def __invoke_sub_command(self, data: MessageData, platter: objects.GoldPlatter) -> None:
         for arg in data["content"].split(" ")[1:]:
             for command in self.__sub_commands:
                 if command.name == arg:
                     data["content"] = data["content"].replace(arg, "")
         
                     self.logger.debug("Calling sub command...")
 
                     platter = objects.GoldPlatter(
                         data = data, 
                         author = platter.author,
-                        command = command,
+                        invokable = command,
                     )
 
                     await command.invoke(platter)
                     break
 
 
     def __invoke_data_to_params(self, data: MessageData) -> List[str]:
```

## GoldyBot/goldy/commands/slash_command.py

```diff
@@ -1,11 +1,13 @@
 from __future__ import annotations
 from typing import Any, Callable, Dict, List, TYPE_CHECKING
 from discord_typings import ApplicationCommandOptionData, InteractionData, AutocompleteInteractionData
 
+from ..nextcore_utils import front_end_errors
+
 if TYPE_CHECKING:
     from .. import Goldy, objects
     from ... import Extension
     from ..nextcore_utils.slash_options.auto_complete import SlashOptionAutoComplete
 
 from .command import Command
 from ..objects import GoldPlatter
@@ -13,27 +15,27 @@
 class SlashCommand(Command):
     def __init__(
         self, 
         goldy: Goldy, 
         func: Callable[[Extension, objects.GoldPlatter], Any], 
         name: str = None, 
         description: str = None, 
-        required_roles: List[str] = None, 
+        required_perms: List[str] = None, 
         slash_options: Dict[str, ApplicationCommandOptionData] = None, 
         hidden: bool = False,
         pre_register: bool = True
     ):
         self.__sub_commands: List[SlashCommand] = []
 
         super().__init__(
             goldy = goldy, 
             func = func, 
             name = name, 
             description = description, 
-            required_roles = required_roles, 
+            required_perms = required_perms, 
             slash_options = slash_options, 
             hidden = hidden,
             pre_register = pre_register
         )
 
         self.logger.debug("Slash command has been initialized!")
 
@@ -67,29 +69,31 @@
     async def invoke(self, platter: objects.GoldPlatter) -> None:
         """Runs and triggers a slash command. This method is usually ran internally."""
         data: InteractionData = platter.data
 
         params = self.__invoke_data_to_params(data)
         if not params == {}: self.logger.debug(f"Got args --> {params}")
 
-        return_value = await super().invoke(
-            platter, lambda: self.func(platter.command.extension, platter, **params)
-        )
-
-        # Handle sub commands.
-        # ----------------------
-        # Invoke sub command if there is one in invoke data.
-        if return_value is not False:
-            await self.__invoke_sub_command(data, platter)
+        try:
+            return_value = await super().invoke(
+                platter, lambda: self.func(platter.invokable.extension, platter, **params)
+            )
+
+            # Handle sub commands.
+            # ----------------------
+            # Invoke sub command if there is one in invoke data.
+            if return_value is not False:
+                await self.__invoke_sub_command(data, platter)
 
-        # TODO: When exceptions raise in commands wrap them in a goldy bot command exception.
+        except Exception as e:
+            raise front_end_errors.UnknownError(platter, e, self.logger)
 
 
     async def invoke_auto_complete(self, data: AutocompleteInteractionData):
-        command: SlashCommand = None
+        command: SlashCommand = self
         current_typing_value: str = None
         auto_complete_option: SlashOptionAutoComplete = None
         options = data["data"]["options"]
 
         # We are just handling sub commands here, nothing too important.
         if self.is_parent:
             for option in options:
@@ -135,15 +139,15 @@
 
                     # Migrating some things from sub command.
                     data["data"]["options"] = option["options"]
 
                     platter = GoldPlatter(
                         data = data, 
                         author = platter.author,
-                        command = command,
+                        invokable = command,
                     )
                     platter._interaction_responded = interaction_responded
 
                     await command.invoke(platter)
                     break
```

## GoldyBot/goldy/database/databases/__init__.py

```diff
@@ -1,10 +1,11 @@
 from __future__ import annotations
 
 from ... import LoggerAdapter
+from .... import utils
 
 from typing import List
 from devgoldyutils import Colours
 
 class GoldyDB():
     """A class representing a singular goldy bot database in mongoDB."""
     def __init__(self, core_database, db_code_name: str) -> None:
@@ -17,18 +18,23 @@
         """
         Inserts the data provided into a collection in this database. 
         Creates a whole new document. If you want to edit an existing document use .edit()
         """
         await self.database[collection].insert_one(data)
         self.logger.debug(f"Inserted '{data}' into '{collection}.'")
 
-    async def edit(self, collection: str, query, data: dict) -> None:
+    async def edit(self, collection: str, query, data: dict, overwrite: bool = True) -> None:
         """Finds and edits a document in this database and collection with the data provided."""
-        await self.database[collection].update_one(query, {"$set": data})
-        self.logger.debug(f"Edited '{query}' into '{data}.'")
+        if overwrite:
+            await self.database[collection].update_one(query, {"$set": data})
+        else:
+            document_data = await self.find_one("guild_configs", query)
+            new_data = utils.update_dict(document_data, data) # Override the document's data with the new data.
+            await self.database[collection].update_one(query, {"$set": new_data})
+        self.logger.debug(f"Edited '{query}' with '{data}.'")
 
     async def remove(self, collection: str, data) -> None:
         """Finds and deletes a copy of this data from a collection in this database."""
         await self.database[collection].delete_one(data)
         self.logger.debug(f"Deleted '{data}' from '{collection}.'")
 
     async def find(self, collection:  str, query, key: str, max_to_find=50) -> List[dict]:
```

## GoldyBot/goldy/database/wrappers/__init__.py

```diff
@@ -1,41 +1,42 @@
 from __future__ import annotations
 
 from typing import TYPE_CHECKING
+
+import logging
 from devgoldyutils import DictClass, LoggerAdapter, Colours
 from abc import abstractmethod, ABC
 from .. import DatabaseEnums
-from ... import objects
 
 if TYPE_CHECKING:
+    from ... import Goldy
     from ...guilds import Guild
 
 class DatabaseWrapper(DictClass, ABC):
     """✨ A useful interface class to build a database wrapper for easy of access to database data like member data, guild data and more."""
-    def __init__(self, object: objects.Member | Guild) -> None:
-        self.goldy = object.goldy
-        self.guild = object.guild
+    def __init__(self, goldy: Goldy, logger: logging.Logger) -> None:
+        self.goldy = goldy
 
         self.data = {}
 
         super().__init__(
-            LoggerAdapter(object.logger, prefix=Colours.PINK_GREY.apply("Database Wrapper"))
+            LoggerAdapter(logger, prefix=Colours.PINK_GREY.apply("Database Wrapper"))
         )
 
     @abstractmethod
     async def push(self, type: DatabaseEnums | str, data: dict) -> None:
         """Push new data directly to the database."""
         ...
 
     @abstractmethod
     async def update(self) -> None:
         """Update the wrapper with the greatest and latest data from the database."""
         ...
 
-        """
+        """ # TODO: Remove this when guild database wrapper is implemented.
         if isinstance(self.goldy, Guild):
             database = self.goldy.database.get_goldy_database(DatabaseEnums.GOLDY_MAIN)
 
             #self.data = await database.find_one("guild_configs", query = {"_id": self.id})
 
             # TODO: Move guild database stuff to this wrapper.
         """
```

## GoldyBot/goldy/database/wrappers/member.py

```diff
@@ -1,34 +1,39 @@
 from __future__ import annotations
-from typing import Literal
+from typing import Literal, TYPE_CHECKING
 
 from . import DatabaseWrapper
 
 from .. import DatabaseEnums
-from ... import objects
+
+if TYPE_CHECKING:
+    from ... import objects
 
 class MemberDBWrapper(DatabaseWrapper):
     """A database wrapper for goldy bot members."""
     def __init__(self, member: objects.Member) -> None:
         self.member = member
-        super().__init__(member)
+
+        super().__init__(
+            member.goldy, member.logger
+        )
 
     async def push(self, type: Literal[DatabaseEnums.MEMBER_GUILD_DATA, DatabaseEnums.MEMBER_GLOBAL_DATA] | str, data: dict) -> None:
         self.logger.info("Pushing data to the database...")
         database = self.goldy.database.get_goldy_database(DatabaseEnums.GOLDY_MEMBER_DATA)
 
         if isinstance(type, str):
             type = DatabaseEnums(type)
 
         doc_id = "1" # Global document.
 
         if type == DatabaseEnums.MEMBER_GUILD_DATA:
-            doc_id = self.guild.id
+            doc_id = self.member.guild.id
 
-        await database.edit(self.member.id, {"_id": doc_id}, data)
+        await database.edit(self.member.id, {"_id": doc_id}, data, overwrite = False)
 
     async def update(self) -> None:
         self.logger.info("Pulling updated member data from database...")
 
         database = self.goldy.database.get_goldy_database(DatabaseEnums.GOLDY_MEMBER_DATA)
 
         # Let's hope you are not in more than 200 guilds or else this will break! 😫
```

## GoldyBot/goldy/extensions/__init__.py

```diff
@@ -6,14 +6,15 @@
 
 from ...goldy import get_goldy_instance
 from ... import goldy_bot_logger, LoggerAdapter
 
 if TYPE_CHECKING:
     from ... import Goldy
     from ..commands.command import Command
+    from .extension_metadata import ExtensionMetadata
 
 extensions_cache: List[Tuple[str, object]] = []
 """
 This cache contains all the extensions that have been loaded and it's memory location to the class.
 """
 
 class Extension():
@@ -53,14 +54,15 @@
 
         # Cached commands list.
         self.commands: List[Command] = [
 
         ]
 
         self.__loaded_path = os.path.realpath(self.__class__.__module__) + ".py"
+        self.__metadata = self.goldy.extension_loader.phrase_pyproject(self.__loaded_path)
 
         if self.name.lower() in [extension.lower() for extension in self.goldy.config.ignored_extensions]:
             self.logger.info(f"Not loading the extension '{self.name}' as it's ignored.")
             return False
 
         # Adding to cache and loading commands.
         # ---------------------------------------        
@@ -75,14 +77,19 @@
         """Name of extension."""
         return self.__class__.__name__
 
     @property
     def loaded_path(self) -> str:
         """The path where this extension was loaded."""
         return self.__loaded_path
+    
+    @property
+    def metadata(self) -> ExtensionMetadata | None:
+        """Returns some metadata if available about this extension. Returns None if not available."""
+        return self.__metadata
 
     @property
     def is_disabled(self) -> bool:
         """Returns true/false whether the extension is disabled. An extension is considered disabled when all of it's commands are also disabled."""
         if all([command.is_disabled for command in self.commands]):
             return True
```

## GoldyBot/goldy/extensions/extension_loader.py

```diff
@@ -1,97 +1,43 @@
 from __future__ import annotations
 
 import os
 import sys
+import toml
 import pathlib
-from typing import List, overload, TYPE_CHECKING
+import pkg_resources
+from typing import List, overload, TYPE_CHECKING, Dict, Tuple
 import importlib.util
 
 from .. import Goldy, GoldyBotError
 from ... import goldy_bot_logger, LoggerAdapter
 from ...paths import Paths
 from . import extensions_cache
+from .extension_metadata import ExtensionMetadata
 
 if TYPE_CHECKING:
     from . import Extension
 
 class ExtensionLoader():
     """Class that handles extension loading and reloading."""
     def __init__(self, goldy: Goldy, raise_on_load_error: bool | None = True) -> None:
         self.goldy = goldy
         self.raise_on_load_error = raise_on_load_error
 
         if self.raise_on_load_error is None:
             self.raise_on_load_error = self.goldy.config.raise_on_extension_loader_error
 
         self.path_to_extensions_folder:str|None = (lambda x: os.path.abspath(x) if isinstance(x, str) else x)(goldy.config.extension_folder_location)
-        
+
         self.ignored_extensions = goldy.config.ignored_extensions
-        self.late_load_extensions = goldy.config.late_load_extensions + ["extensions.py"]
+        self.late_load_extensions = goldy.config.late_load_extensions + ["guild_admin.py"]
 
         self.logger = LoggerAdapter(goldy_bot_logger, prefix="ExtensionLoader")
 
-    def __find_all_paths(self) -> List[str]:
-        """Searches for all extensions, internal and external then returns their paths."""
-        external_path = None
-        internal_path = Paths.INTERNAL_EXTENSIONS
-
-        paths = []
-        late_load_paths = []
-        
-        # Finding external extensions folder path if none.
-        # -------------------------------------------------
-        if self.path_to_extensions_folder is None:
-            # Go look in the root dir.
-            for file in os.listdir("."):
-                if file == "extensions":
-                    external_path = os.path.abspath(f"./{file}")
-                    break
-        else:
-            external_path = self.path_to_extensions_folder
-
-        # Getting all paths of each individual extension.
-        # -------------------------------------------------
-        for path in [external_path, internal_path]:
-            path_object = pathlib.Path(path)
-
-            if path_object.exists() is False:
-                self.logger.warn(f"Couldn't find extension folder path at '{path_object}'!")
-                continue
-
-            self.logger.info(f"Found extension folder at '{path}'.")
-
-            for file in path_object.iterdir():
-                if file.name == "__pycache__":
-                    continue
-
-                if file.is_file() or file.is_dir():
-
-                    if file.is_dir():
-
-                        if "__init__.py" not in [x.name for x in file.iterdir()]:
-                            self.logger.warn(f"Extension module '{file.name}' has no __init__.py so I'm ignoring it...")
-                            continue
-
-                        load_path = os.path.join(str(file), "__init__.py")
-
-                    else:
-                        load_path = str(file)
-
-                    if file.name in self.late_load_extensions:
-                        self.logger.info(f"The extension '{file.name}' will load late (after all other extensions).")
-                        late_load_paths.append(load_path)
-                    else:
-                        paths.append(load_path)
-                    
-                    self.logger.debug(f"Found the module '{file.name}' in extensions.")
-
-        paths.extend(late_load_paths)
-        return paths
-
+        self.__installed_dependencies = {pkg.key for pkg in pkg_resources.working_set}
 
     @overload
     def load(self) -> None:
         """Loads all extensions goldy bot can find. Basically lets goldy bot search for extensions herself because your a lazy brat."""
         ...
     
     @overload
@@ -100,20 +46,27 @@
         ...
 
     def load(self, extension_paths: List[str] = None) -> None:
         """Loads each extension in this list of paths. If extension_paths is kept none, goldy bot will search for extensions to load itself."""
         if extension_paths is None:
             extension_paths = self.__find_all_paths()
 
+        # self.check_dependencies() # TODO: Add method that checks dependencies from pyproject.toml and installs them if they are missing.
+
         for path in extension_paths:
             # Specify and get the module.
             self.logger.debug(f"Loading the extension at '{path}'...")
             spec_module = importlib.util.spec_from_file_location(path[:-3], path)
             module_py = importlib.util.module_from_spec(spec_module)
 
+            # Pip install extension missing dependencies.
+            for dependency in self.__check_dependencies(path):
+                self.logger.info(f"Installing '{dependency[0]}'...")
+                os.system(f'pip install "{dependency[1]}"')
+
             # Run module and load function.
             try:
                 # For some reason if I don't do this shit blows up. (extensions won't be able to import modules in it's own directories)
                 sys.modules[module_py.__name__] = module_py
 
                 # Run module.
                 self.logger.debug(f"Running extension at '{path}'...") # TODO: Change path to extension name for better logging maybe.
@@ -175,8 +128,120 @@
                 loaded_paths.append(extension.loaded_path)
 
         self.load(loaded_paths)
 
         # Load commands again.
         await self.goldy.command_loader.load()
 
-        return None
+        return None
+
+    def phrase_pyproject(self, extension_path: str) -> ExtensionMetadata | None:
+        """Phrases the pyproject.toml file in that extension path."""
+        if not extension_path.endswith("__init__.py"): 
+            return None
+
+        try:
+            pyproject_toml: Dict[str, str] = toml.load(
+                open(os.path.split(extension_path)[0] + "/pyproject.toml")
+            )
+
+            return ExtensionMetadata(pyproject_toml)
+
+        except FileNotFoundError:
+            self.logger.info(
+                f"Couldn't phrase pyproject.toml for the extension at '{extension_path}' as it's directory does not contain a pyproject.toml file."
+            )
+
+        return None
+
+    def __check_dependencies(self, extension_path: str) -> List[Tuple[str, str]]:
+        """Returns list of missing dependencies needed to execute the extension."""
+        missing_dependencies = []
+
+        # Dependency check only works with extensions that are packages and contain a pyproject.toml file in their directory.
+        if extension_path.endswith("__init__.py"): 
+            self.logger.debug(f"Checking missing dependencies for extension at '{extension_path}'...")
+
+            extension_metadata = self.phrase_pyproject(extension_path)
+
+            if extension_metadata is None:
+                return []
+
+            if extension_metadata.dependencies is None:
+                raise GoldyBotError(
+                    f"Umm, seems like we couldn't find 'dependencies' in the pyproject.toml file for the extension at '{extension_path}'.\n" \
+                    "Make sure you are following PEP 621! (https://peps.python.org/pep-0621/)"
+                )
+
+            for dependency in extension_metadata.dependencies:
+                dependency_with_install_operations = dependency
+
+                for character in [">", "=", "^", "<"]:
+                    dependency = dependency.split(character)[0]
+
+                if dependency.lower() not in self.__installed_dependencies:
+                    self.logger.warning(f"Missing dependency '{dependency}'.")
+                    missing_dependencies.append(
+                        (dependency, dependency_with_install_operations)
+                    )
+                else:
+                    self.logger.debug(f"'{dependency}' dependency found.")
+
+        return missing_dependencies
+
+    def __find_all_paths(self) -> List[str]:
+        """Searches for all extensions, internal and external then returns their paths."""
+        external_path = None
+        internal_path = Paths.INTERNAL_EXTENSIONS
+
+        paths = []
+        late_load_paths = []
+        
+        # Finding external extensions folder path if none.
+        # -------------------------------------------------
+        if self.path_to_extensions_folder is None:
+            # Go look in the root dir.
+            for file in os.listdir("."):
+                if file == "extensions":
+                    external_path = os.path.abspath(f"./{file}")
+                    break
+        else:
+            external_path = self.path_to_extensions_folder
+
+        # Getting all paths of each individual extension.
+        # -------------------------------------------------
+        for path in [external_path, internal_path]:
+            path_object = pathlib.Path(path)
+
+            if path_object.exists() is False:
+                self.logger.warn(f"Couldn't find extension folder path at '{path_object}'!")
+                continue
+
+            self.logger.info(f"Found extension folder at '{path}'.")
+
+            for file in path_object.iterdir():
+                if file.name == "__pycache__":
+                    continue
+
+                if file.is_file() or file.is_dir():
+
+                    if file.is_dir():
+
+                        if "__init__.py" not in [x.name for x in file.iterdir()]:
+                            self.logger.warn(f"Extension module '{file.name}' has no __init__.py so I'm ignoring it...")
+                            continue
+
+                        load_path = os.path.join(str(file), "__init__.py")
+
+                    else:
+                        load_path = str(file)
+
+                    if file.name in self.late_load_extensions:
+                        self.logger.info(f"The extension '{file.name}' will load late (after all other extensions).")
+                        late_load_paths.append(load_path)
+                    else:
+                        paths.append(load_path)
+                    
+                    self.logger.debug(f"Found the module '{file.name}' in extensions.")
+
+        paths.extend(late_load_paths)
+        return paths
```

## GoldyBot/goldy/guilds/__init__.py

```diff
@@ -1,13 +1,15 @@
 from __future__ import annotations
 
 from typing import List, Tuple
 
+from nextcore.http import Route, NotFoundError
 from devgoldyutils import Colours
 
+from .. import nextcore_utils
 from .. import Goldy, LoggerAdapter, goldy_bot_logger
 from ... import utils, errors
 from ..database import DatabaseEnums
 
 from .guild import Guild
 
 import logging
@@ -19,82 +21,47 @@
         self.logger = LoggerAdapter(goldy_bot_logger, prefix=Colours.ORANGE.apply("GuildManager"))
 
         if self.allowed_guilds == []:
             raise AllowedGuildsNotSpecified(self.logger)
         
         self.guilds: List[Tuple[str|int, Guild]] = []
 
-    # TODO: In the future we might have to add some sort of way to reload the guild config of a guild from the database. (or just run setup again on that particular guild if that works well)
-    # I can see this being needed if the v5 framework is going to be running public invite-able bots.
-    # Also maybe we should rerun the setup when we reload.
-
     async def setup(self):
         """Adds guilds specified in goldy.json to the database if not already added."""
-        # TODO: Find better way to organize this code, it's too long and complex for my liking.
-        # 08/04/2023: idk is it really that complex... i'll come back to it later...
         self.logger.info("Setting up guilds...")
 
-        database = self.goldy.database.get_goldy_database(DatabaseEnums.GOLDY_MAIN)
-
-        for guild in self.allowed_guilds:
-
-            guild_config_template = {
-                "_id": guild[0],
-                "code_name": guild[1],
-
-                "prefix": "!",
-
-                "roles": {
-
-                },
-
-                "channels": {
-
-                },
-
-                "extensions": {
-                    "allowed": [],
-                    "disallowed": [],
-                    "hidden": []
-                },
-
-            }
+        for guild_id, guild_code_name in self.allowed_guilds:
 
-            # Add guild to database.
-            # --------------------------------
-            guild_config = await database.find_one("guild_configs", query = {"_id": guild[0]})
-
-            if guild_config is None:
-                guild_config = guild_config_template
-                await database.insert("guild_configs", data = guild_config)
-
-            else:
-                # Check if any keys are missing in the guild config, if any are update the config with the new item.
-                # ---------------------------------------------------------------------------------------------------
-                if not guild_config_template.keys() == guild_config.keys():
-                    
-                    # If there is an item in the template that isn't in the database add it.
-                    for item in guild_config_template:
-
-                        if item not in guild_config:
-                            guild_config[item] = guild_config_template[item]
-                            self.logger.debug(
-                                f"Added key '{item}' to {guild[1]}'s database config because it was missing."
-                            )
-
-                    await database.edit("guild_configs", query = {"_id": guild[0]}, data = guild_config)
+            # Getting guild discord data
+            # ---------------------------
+            try:
+                guild_data = await nextcore_utils.get_guild_data(guild_id, self.goldy)
+            except NotFoundError:
+                raise GuildNotFound(
+                    guild_code_name, self.logger
+                )
+
+            guild = Guild(
+                id = guild_id, 
+                code_name = guild_code_name, 
+                data = guild_data, 
+                goldy = self.goldy
+            )
 
+            await guild.config_wrapper.update() # This should update the guild's config data which should also generate itself configuration in the database if it's missing.
 
             # Add guild to list.
             # --------------------
             self.guilds.append(
-                (guild[0], Guild(guild_config, self.goldy))
+                (guild_id, guild)
             )
 
-            self.logger.info("Done setting up guilds.")
+            self.logger.debug(f"Guild '{guild.code_name}' set up.")
+
+        self.logger.info("Done setting up guilds.")
 
 
     def get_guild(self, guild_id: str | int) -> Guild | None:
         """Finds and returns goldy bot guild by id."""
         cache_tuple = utils.cache_lookup(
             key=guild_id,
             cache=self.guilds
@@ -109,8 +76,16 @@
 # Exceptions
 # ------------
 class AllowedGuildsNotSpecified(errors.GoldyBotError):
     def __init__(self, logger: logging.Logger = None):
         super().__init__(
             "Please add your guild id to the allowed_guilds in goldy.json",
             logger = logger
+        )
+
+class GuildNotFound(errors.GoldyBotError):
+    def __init__(self, guild_code_name: str, logger: logging.Logger = None):
+        super().__init__(
+            f"We couldn't find the guild '{guild_code_name}' you entered in allowed_guilds! " \
+            "Are you sure you have entered the guild id correctly and that goldy bot is currently present in that guild.",
+            logger = logger
         )
```

## GoldyBot/goldy/guilds/guild.py

```diff
@@ -1,80 +1,58 @@
 from __future__ import annotations
 
-from typing import List, TYPE_CHECKING
+from typing import TYPE_CHECKING
 from discord_typings import GuildData
-from ..database import DatabaseEnums
-from .. import nextcore_utils
+
+from devgoldyutils import DictClass, LoggerAdapter, Colours
+
+from ... import goldy_bot_logger
+from ..database.wrappers.guild import GuildDBWrapper
 
 if TYPE_CHECKING:
     from .. import Goldy
     from ... import Extension
 
-class Guild():
-    """A goldy bot guild."""
-    def __init__(self, db_data: dict, goldy: Goldy) -> None:
+class Guild(DictClass):
+    """A goldy bot guild class."""
+    def __init__(self, id: str, code_name:str, data: GuildData, goldy: Goldy) -> None:
+        self.id = id
+        """The guild's discord id"""
+        self.code_name = code_name
+        """The goldy bot code name of the guild."""
+        self.data = data
         self.goldy = goldy
-        self.db_data = db_data
 
-    @property
-    def id(self) -> str:
-        """The guild's discord id"""
-        return self.db_data["_id"]
+        self.logger = LoggerAdapter(
+            LoggerAdapter(goldy_bot_logger, prefix = "Guild"), 
+            prefix = Colours.PINK_GREY.apply(data["name"])
+        )
 
-    @property
-    def code_name(self) -> str:
-        """The goldy bot code name of the guild."""
-        return self.db_data["code_name"]
+        self.config_wrapper = GuildDBWrapper(self)
+
+        super().__init__(self.logger)
 
     @property
-    def prefix(self) -> str:
-        """The prefix the guild uses."""
-        return self.db_data["prefix"]
-    
-    @property
-    def roles(self):
-        return self.db_data["roles"]
-    
-    @property
-    def channels(self):
-        return self.db_data["channels"]
-    
-    @property
-    def allowed_extensions(self) -> List[str]:
-        """Returns the allowed extensions from this guild."""
-        return self.db_data["extensions"]["allowed"]
-    
-    @property
-    def disallowed_extensions(self) -> List[str]:
-        """Returns the disallowed extensions from this guild."""
-        return self.db_data["extensions"]["disallowed"]
-    
-    @property
-    def hidden_extensions(self) -> List[str]:
-        """Returns the hidden extensions from this guild."""
-        return self.db_data["extensions"]["hidden"]
-    
-    def is_extension_allowed(self, extension: Extension) -> bool:
+    async def config(self) -> GuildDBWrapper:
+        """Returns the guild's database wrapper for it's configuration."""
+        if self.config_wrapper.data == {}:
+            await self.config_wrapper.update()
+
+        return self.config_wrapper
+
+    async def is_extension_allowed(self, extension: Extension) -> bool:
         """Returns True/False if this extension is allowed to function in this guild."""
-        disallowed_extensions = [ext.lower() for ext in self.disallowed_extensions]
+        guild_config = await self.config
+        disallowed_extensions = [ext.lower() for ext in guild_config.disallowed_extensions]
+
+        if extension.name.lower() in [x.lower() for x in ["Goldy", "GuildAdmin"]]: # These extensions are always allowed.
+            return True
 
         if extension.name.lower() in disallowed_extensions:
             return False
-        
-        if len(disallowed_extensions) >= 1:
 
-            if disallowed_extensions[0] == "." and extension.name.lower() not in [ext.lower() for ext in self.allowed_extensions]:
-                return False
-        
-        return True
-    
-    async def get_guild_data(self) -> GuildData:
-        """Returns discord's guild data; the same as :py:meth:`~GoldyBot.goldy.nextcord_utils.get_guild()`."""
-        return await nextcore_utils.get_guild_data(self)
-
-    async def update(self) -> None:
-        """Updates guild's data by fetching from database."""
-        database = self.goldy.database.get_goldy_database(DatabaseEnums.GOLDY_MAIN)
+        if len(disallowed_extensions) > 0:
 
-        self.db_data = await database.find_one("guild_configs", query = {"_id": self.id})
+            if disallowed_extensions[0] == "." and extension.name.lower() not in [ext.lower() for ext in guild_config.allowed_extensions]:
+                return False
 
-        return None
+        return True
```

## GoldyBot/goldy/live_console/app.py

```diff
@@ -26,15 +26,15 @@
         if not extension_name == "":
             extension: Tuple[str, Extension] | None = utils.cache_lookup(extension_name, extensions_cache, False)
 
             if extension is None:
                 self.logger.error(f"The extension '{extension_name}' was not found.")
                 return False
             else:
-                self.logger.info(f"Found '{extension_name}'.")
+                self.logger.info(f"Found '{extension[1].name}'.")
 
         self.logger.info("Reloading extension(s)...")
         self.logger.warning("This may take a minute to begin...")
         self.goldy.async_loop.create_task(
             self.goldy.extension_loader.reload(
                 (lambda x: [x[1]] if x is not None else None)(extension)
             )
@@ -49,15 +49,15 @@
         )
 
     def do_reload_configs(self, _: cmd2.Statement):
         self.goldy.config.__init__()
 
         self.goldy.guild_manager.guilds.clear()
 
-        self.logger.warning("Wait, we're reloading guilds... (This may halt the discord for a while!)")
+        self.logger.warning("Wait, we're reloading guilds... (This may halt the bot for a while!)")
         self.goldy.async_loop.create_task(
             self.goldy.guild_manager.setup()
         )
 
     def do_quit(self, _: cmd2.Statement):
         self.logger.info("Exiting...")
         self.goldy.stop("Console master commanded me to stop!")
```

## GoldyBot/goldy/nextcore_utils/__init__.py

```diff
@@ -1,16 +1,27 @@
+"""
+This module contains common things we send to discord, 
+like e.g embeds, slash options the list goes on.
+
+It also contains numerous http wrappers like ``send_msg()`` and ``get_channels()``.
+
+If there's something you would like to get added, feel free to open an issue.
+"""
+
 DISCORD_CDN = "https://cdn.discordapp.com/"
 
-from .embeds.embed import Embed, EmbedField, EmbedImage
+from .embeds.embed import Embed, EmbedField, EmbedImage, EmbedFooter
 
 from .slash_options.auto_complete import SlashOptionAutoComplete
 from .slash_options.slash_option import SlashOption, SlashOptionChoice, SlashOptionTypes
 
+from .defer import wait
 from .messages.send_msg import send_msg
 from .messages.delete_msg import delete_msg
 from .guilds.get_channels import get_channels
 from .guilds.get_guild_data import get_guild_data
 from .channels.get_channel import get_channel
 from .channels.delete_channel import delete_channel
 
+from .files import File
 from .colours import Colours
 from .front_end_errors import FrontEndErrors
```

## GoldyBot/goldy/nextcore_utils/colours.py

```diff
@@ -1,19 +1,42 @@
+from __future__ import annotations
+from typing import TYPE_CHECKING
+
+if TYPE_CHECKING:
+    from .files import File
+
+from colorthief import ColorThief
 from enum import Enum
 
 class Colours(Enum):
-    """Goldy bot v4 colours just ported over to v5."""
+    """Goldy bot v4 colours ported over to v5 with some added colours."""
     AKI_PINK = 0xFF1493
     AKI_ORANGE = 0xF4900C
     AKI_RED = 0xff0051
     AKI_BLUE = 0X75E6DA
     BLUE = 0x3061f2
     GREEN = 0x00FF00
     LIME_GREEN = 0x8AFF65
     YELLOW = 0xffff4d
     PURPLE = 0xFF00FF
     RED = 0xFF0000
+    BROWN = 0xFFBA6D
     GREY = 0x3B3B3B
     WHITE = 0xFFFFFF
+    BLACK = 0x000000
 
     INVISIBLE = 0x2B2D31
-    """Makes the embed colour the same as the background essentially giving the embed colour a transparent look."""
+    """Makes the embed colour the same as the background essentially giving the embed colour a transparent look."""
+
+    def __init__(self, colour: int):
+        ...
+
+    @classmethod
+    def from_rgb(cls, r: int, g:int, b:int) -> int:
+        """Converts rgb values into colour."""
+        return (r << 16) + (g << 8) + b
+
+    @classmethod
+    def from_image(cls, file: File, accuracy: int = 5) -> int:
+        """Returns the dominant colour in that image."""
+        r, g, b = ColorThief(file.file_io).get_color(accuracy)
+        return cls.from_rgb(r, g, b)
```

## GoldyBot/goldy/nextcore_utils/front_end_errors.py

```diff
@@ -15,28 +15,28 @@
     from .. import objects
 
 class FrontEndErrors(errors.GoldyBotError):
     def __init__(
             self, 
             embed: Embed,
             message: str,
-            platter: objects.Platter, 
+            platter: objects.GoldPlatter, 
             delete_after = 8,
             logger: log.Logger = None
         ):
         from  ..commands import slash_command
 
         platter.goldy.async_loop.create_task(
             platter.send_message(
                 embeds = [
                     embed
                 ],
                 reply = True, 
-                delete_after = None if isinstance(platter.invoker, slash_command.SlashCommand) else delete_after,
-                flags = 1 << 6 if isinstance(platter.invoker, slash_command.SlashCommand) else None
+                delete_after = None if isinstance(platter.invokable, slash_command.SlashCommand) else delete_after,
+                flags = 1 << 6 if isinstance(platter.invokable, slash_command.SlashCommand) else None
             )
         )
 
         super().__init__(message, logger)
 
 
 class MissingArgument(FrontEndErrors):
@@ -47,16 +47,18 @@
 
         super().__init__(
             embed = Embed(
                 title = "🧡 Oops, you're missing an argument.", 
                 description = f"""
                 *You missed the argument(s): ``{missing_args_string[:-2]}``*
 
-                **Command Usage -> ``{platter.guild.prefix}{platter.command.command_usage}``**
-                """, # TODO: Add command usage string to command class.
+                ```
+                Command Usage -> {platter.guild.config_wrapper.prefix}{platter.invokable.command_usage}
+                ```
+                """,
                 colour = Colours.AKI_ORANGE
             ),
             message = f"The command author missed the arguments -> '{missing_args_string[:-2]}'.",
             platter = platter, 
             delete_after = 10,
             logger = logger
         )
@@ -72,15 +74,15 @@
 
                 One of these could be the cause:
                 - This command takes a sub command and you mistyped it.
                 - This command doesn't take that many arguments.
                 - It doesn't take any arguments at all.
 
                 ```
-                Command Usage -> {platter.guild.prefix}{platter.command.command_usage}
+                Command Usage -> {platter.guild.config_wrapper.prefix}{platter.invokable.command_usage}
                 ```
                 """,
                 colour = Colours.YELLOW
             ),
             message = "The command author passed too many arguments.",
             platter = platter, 
             delete_after = 30,
@@ -93,15 +95,15 @@
         # Don't raise front end error if the command is hidden and is a prefix command.
         # This insures prefix commands are truly hidden.
         # The git issue: https://github.com/Goldy-Bot/Goldy-Bot-V5/issues/54
         from  ..commands import prefix_command
 
         message = f"The command author '{platter.author.username}#{platter.author.discriminator}' doesn't have the perms to run this command."
 
-        if platter.command.hidden and isinstance(platter.command, prefix_command.PrefixCommand):
+        if platter.invokable.hidden and isinstance(platter.invokable, prefix_command.PrefixCommand):
             raise errors.GoldyBotError(message)
 
         super().__init__(
             embed = Embed(
                 title = ":heart: No Perms!", 
                 description = "Sorry, you don't have the perms to run this command.",
                 colour = Colours.RED
@@ -144,11 +146,32 @@
     def __init__(self, platter: objects.GoldPlatter, logger: log.Logger = None):
         super().__init__(
             embed = Embed(
                 title = "🧡 Only Author Can Invoke", 
                 description = "Sorry, only the command author can invoke this.",
                 colour = Colours.AKI_ORANGE
             ),
-            message = f"'{platter.author.username}#{platter.author.discriminator}' tried to invoke an 'author only' recipe.",
+            message = f"'{platter.author}' tried to invoke an 'author only' recipe.",
+            platter = platter, 
+            logger = logger
+        )
+
+class UnknownError(FrontEndErrors):
+    def __init__(self, platter: objects.GoldPlatter, error: Exception = None, logger: log.Logger = None):
+        # If the exception caught is a goldy bot exception continue raising that exception otherwise raise this unknown exception.
+        if error is not None and isinstance(error, errors.GoldyBotError):
+            raise error
+
+        super().__init__(
+            embed = Embed(
+                title = "❤️ An Error Occurred!", 
+                description = "Oopsie daisy, an internal unknown error occurred. *Sorry I'm still new to this.* 🥺",
+                colour = Colours.RED,
+                footer = {
+                    "text": "Report button will be coming soon."
+                }
+            ),
+            message = f"Error occurred in the command '{platter.invokable.name}' executed by '{platter.author}'!",
             platter = platter, 
+            delete_after = 12,
             logger = logger
         )
```

## GoldyBot/goldy/nextcore_utils/embeds/embed.py

```diff
@@ -1,19 +1,40 @@
 from __future__ import annotations
-
 from typing import List
-from discord_typings import EmbedData, EmbedFieldData, EmbedImageData
+from discord_typings import EmbedData, EmbedFieldData, EmbedImageData, EmbedFooterData
+
+import copy
 from ..colours import Colours
 from .... import utils
 
+class EmbedFooter(dict):
+    """A class used to create an embed's footer."""
+    def __init__(self, text: str, icon_url: str = None, proxy_icon_url: str = None, **extra) -> EmbedFooterData:
+        """
+        Creates an embed footer.
+        """
+        data: EmbedFooterData = {}
+
+        data["text"] = text
+
+        if icon_url is not None:
+            data["icon_url"] = icon_url
+
+        if proxy_icon_url is not None:
+            data["proxy_icon_url"] = proxy_icon_url
+
+        data.update(extra)
+
+        super().__init__(data)
+
 class EmbedImage(dict):
     """A class used to add an image to a embed."""
     def __init__(self, url: str, proxy_url: str = None, height: int = None, width: int = None, **extra) -> EmbedImageData:
         """
-        Creates an embed image or thumbnail. 😋
+        Creates an embed image or thumbnail.
         """
         data: EmbedImageData = {}
 
         data["url"] = url
 
         if proxy_url is not None:
             data["proxy_url"] = proxy_url
@@ -28,31 +49,31 @@
 
         super().__init__(data)
 
 class EmbedField(dict):
     """A class used to create an embed field for an embed."""
     def __init__(self, name: str, value: str, inline: bool = None, **extra) -> EmbedFieldData:
         """
-        Creates an embed field. 😋
+        Creates an embed field.
         
-        ⭐ Documentation at https://discord.com/developers/docs/resources/channel#embed-object-embed-field-structure
+        https://discord.com/developers/docs/resources/channel#embed-object-embed-field-structure
         """
         data: EmbedFieldData = {}
 
         data["name"] = name
         # TODO: Make this a goldy bot util function instead.
         data["value"] = utils.line_fix(value)
 
         if inline is not None:
             data["inline"] = inline
 
         data.update(extra)
 
         super().__init__(data)
-        
+
 
 class Embed(dict):
     """
     A class used to create a discord embed.
     
     -------------
 
@@ -75,22 +96,23 @@
     def __init__(
         self, 
         title: str = None, 
         description: str = None, 
         fields: List[EmbedField] = None, 
         color: Colours | int = None, 
         colour: Colours | int = None, 
+        footer: EmbedFooter = None,
         image: EmbedImage = None,
         thumbnail: EmbedImage = None,
         **extra
     ) -> EmbedData:
         """
         Creates a discord embed. 😋
-        
-        ⭐ Documentation at https://discord.com/developers/docs/resources/channel#embed-object
+
+        https://discord.com/developers/docs/resources/channel#embed-object
         """
         data: EmbedData = {}
 
         if title is not None:
             data["title"] = title
 
         if description is not None:
@@ -110,41 +132,54 @@
 
         if colour is not None:
             if isinstance(colour, Colours):
                 colour = colour.value
             
             data["color"] = colour
 
+        if footer is not None:
+            data["footer"] = footer
+
         if image is not None:
             data["image"] = image
 
         if thumbnail is not None:
             data["thumbnail"] = thumbnail
 
         data.update(extra)
 
         super().__init__(data)
 
+    def format_title(self, **keys) -> None:
+        "Just like the str.format() method but it formats the embed's title for you " \
+        "so you can avoid the catastrophe at https://github.com/Goldy-Bot/Goldy-Bot-V5/issues/35."
+        data: EmbedData = dict(self)
+
+        data["title"] = data["title"].format(**keys)
+
+        self.update(data)
+
     def format_description(self, **keys) -> None:
         "Just like the str.format() method but it formats the embed's description for you " \
         "so you can avoid the catastrophe at https://github.com/Goldy-Bot/Goldy-Bot-V5/issues/35."
-        data: EmbedData = super().copy()
-        
-        data["description"] = data["description"].format(kwargs = keys)
-        
+        data: EmbedData = dict(self)
+
+        data["description"] = data["description"].format(**keys)
+
         self.update(data)
 
     def format_fields(self, **keys) -> None:
         """
         Just like the str.format() method but it formats each of the embed's fields value.
         
         This was added because of https://github.com/Goldy-Bot/Goldy-Bot-V5/issues/35.
         """
-        data: EmbedData = super().copy()
+        data: EmbedData = dict(self)
 
         for index, field in enumerate(data["fields"]):
             data["fields"][index]["value"] = field["value"].format(**keys)
-        
+
         self.update(data)
 
     def copy(self) -> Embed:
-        return Embed(**super().copy())
+        """Returns copy of embed."""
+        return Embed(**copy.deepcopy(dict(self)))
```

## GoldyBot/goldy/nextcore_utils/guilds/get_guild_data.py

```diff
@@ -3,46 +3,45 @@
 from discord_typings import GuildData
 
 from nextcore.http import Route
 
 from ... import LoggerAdapter, goldy_bot_logger
 
 if TYPE_CHECKING:
-    from ...guilds import Guild
+    from ... import Goldy
 
-logger = LoggerAdapter(goldy_bot_logger, prefix="get_channels")
+logger = LoggerAdapter(goldy_bot_logger, prefix="get_guild_data")
 
-async def get_guild_data(guild: Guild) -> GuildData:
+async def get_guild_data(guild_id: str, goldy: Goldy) -> GuildData:
     """
     Returns the guild's discord data.
 
     ------------------
 
     Parameters
     ----------
-    ``guild``
-        The guild object.
+    ``guild_id``
+        The id of the guild.
 
     Returns
     -------
     :py:meth:`~discord_typings.GuildData`
         A dictionary of guild data.
     """
-    goldy = guild.goldy
 
     headers = goldy.nc_authentication.headers
 
     r = await goldy.http_client.request(
         Route(
             "GET",
             "/guilds/{guild_id}",
-            guild_id = guild.id
+            guild_id = str(guild_id)
         ),
         rate_limit_key = goldy.nc_authentication.rate_limit_key,
         headers = headers,
     )
 
     guild_data: GuildData = await r.json()
 
-    logger.debug(f"Grabbed guild data for the guild '{guild.code_name}'.")
+    logger.debug(f"Grabbed guild data for the guild with id '{guild_id}'.")
 
     return guild_data
```

## GoldyBot/goldy/nextcore_utils/messages/send_msg.py

```diff
@@ -9,26 +9,27 @@
 
 from ... import objects
 from .... import utils
 from ...commands import slash_command
 from ...recipes import Recipe
 
 if TYPE_CHECKING:
+    from ..files import File
     from ..embeds.embed import Embed
 
-# TODO: Add more options to allow using channel instead of platter.
-
 @overload
 async def send_msg(
     platter: objects.GoldPlatter, 
     text: str = None, 
     embeds: List[Embed] = None, 
     recipes: List[Recipe] = None, 
+    files: List[File] = None, 
     reply: bool = False, 
     delete_after: float = None,
+    hide: bool = False,
     **extra: MessageData | InteractionCallbackData
 ) -> objects.Message: # Work in progress...
     """
     Allows you to create and send a message to the channel the command was invoked from as a form of reply.
     
     ------------------
 
@@ -38,18 +39,22 @@
         The gold platter from the command.
     ``text``
         The content of the message.
     ``embeds``
         Embeds to include in the message.
     ``recipes``
         Components to include in the message.
+    ``files``
+        Files you may upload with this message.
     ``reply``
         Whether goldy bot should liberally reply to the message the command was invoked.
     ``delete_after``
         Deletes the sent message after said amount of seconds.
+    ``hide``
+        Hides the message in interaction commands and deletes the message after 3 seconds on prefix commands.
     ``**extra``
         Allows you to pass the extra parameters that are missing.
 
     Returns
     -------
     ``GoldyBot.goldy.objects.message.Message``
         The message that was sent.
@@ -58,15 +63,17 @@
 
 @overload
 async def send_msg(
     channel: objects.Channel, 
     text: str = None,
     embeds: List[Embed] = None, 
     recipes: List[Recipe] = None, 
+    files: List[File] = None, 
     delete_after: float = None,
+    hide: bool = False,
     **extra: MessageData | InteractionCallbackData
 ) -> objects.Message:
     """
     Allows you to create and send a message to this specific channel.
     
     ------------------
 
@@ -76,16 +83,20 @@
         The channel the message should be sent to.
     ``text``
         The content of the message.
     ``embeds``
         Embeds to include in the message.
     ``recipes``
         Components to include in the message.
+    ``files``
+        Files you may upload with this message.
     ``delete_after``
         Deletes the sent message after said amount of seconds.
+    ``hide``
+        Hides the message in interaction commands and deletes the message after 3 seconds on prefix commands.
     ``**extra``
         Allows you to pass the extra parameters that are missing.
         
     Returns
     -------
     ``GoldyBot.goldy.objects.message.Message``
         The message that was sent.
@@ -94,15 +105,17 @@
 
 @overload
 async def send_msg(
     member: objects.Member, 
     text: str = None, 
     embeds: List[Embed] = None, 
     recipes: List[Recipe] = None, 
+    files: List[File] = None, 
     delete_after: float = None,
+    hide: bool = False,
     **extra: MessageData | InteractionCallbackData
 ) -> objects.Message:
     """
     Allows you to create and send a message to this member's dms.
     
     ------------------
 
@@ -112,16 +125,20 @@
         The member the message should be sent to.
     ``text``
         The content of the message.
     ``embeds``
         Embeds to include in the message.
     ``recipes``
         Components to include in the message.
+    ``files``
+        Files you may upload with this message.
     ``delete_after``
         Deletes the sent message after said amount of seconds.
+    ``hide``
+        Hides the message in interaction commands and deletes the message after 3 seconds on prefix commands.
     ``**extra``
         Allows you to pass the extra parameters that are missing.
 
     Returns
     -------
     ``GoldyBot.goldy.objects.message.Message``
         The message that was sent.
@@ -129,21 +146,24 @@
     ...
 
 async def send_msg(
     object: objects.Platter | objects.Member | objects.Channel, 
     text: str = None, 
     embeds: List[Embed] = None, 
     recipes: List[Recipe] = None, 
+    files: List[File] = None, 
     reply: bool = False, 
     delete_after: float = None,
+    hide: bool = False,
     **extra: MessageData | InteractionCallbackData
 ) -> objects.Message:
     
     goldy = object.goldy
-    
+
+    form_data = FormData()
     payload: MessageBase | InteractionMessageCallbackData = {}
 
     if text is not None:
         payload["content"] = str(text)
 
     if embeds is not None:
         payload["embeds"] = embeds
@@ -163,42 +183,56 @@
 
             components[component_count]["components"].append(recipe)
 
             count += 1
 
         payload["components"] = [components[component] for component in components]
 
-    payload.update(extra)
+    # Adding files to form data.
+    if files is not None:
+        for file in files:
+            form_data.add_field(
+                file.name.split(".")[-2], file.contents, filename = file.name
+            )
 
+    payload.update(extra)
 
     message_data: MessageData = None
 
-    if isinstance(object, objects.Platter):
-        platter: objects.Platter = object
+    if isinstance(object, objects.GoldPlatter):
+        platter: objects.GoldPlatter = object
 
         if isinstance(platter.invokable, (slash_command.SlashCommand, Recipe)):
             # Perform interaction response.
             # ------------------------------
+            if hide:
+                payload["flags"] = 1 << 6
 
             # Callback message.
             # ------------------
             if platter._interaction_responded is False:
 
+                form_data.add_field(
+                    "payload_json", json_dumps(
+                        {
+                            "type": 4, 
+                            "data": payload
+                        }
+                    )
+                )
+
                 await goldy.http_client.request(
                     Route(
                         "POST", 
                         "/interactions/{interaction_id}/{interaction_token}/callback", 
                         interaction_id = platter.data["id"], 
                         interaction_token = platter.data["token"]
                     ),
                     rate_limit_key = goldy.nc_authentication.rate_limit_key,
-                    json = {
-                        "type": 4, 
-                        "data": payload
-                    }
+                    data = form_data
                 )
 
                 platter._interaction_responded = True
 
                 # Get and return message data of original interaction response. 
                 r = await goldy.http_client.request(
                     Route(
@@ -216,42 +250,49 @@
 
 
             # Follow up message.
             # -------------------
             # Is sent when you want to respond again after sending the original response to an interaction command.
             else:
 
+                form_data.add_field(
+                    "payload_json", json_dumps(payload)
+                )
+
                 r = await goldy.http_client.request(
                     Route(
                         "POST", 
                         "/webhooks/{application_id}/{interaction_token}", 
                         application_id = goldy.application_data["id"], 
                         interaction_token = platter.data["token"]
                     ),
                     rate_limit_key = goldy.nc_authentication.rate_limit_key,
-                    json = payload
+                    data = form_data
                 )
 
                 message_data = await r.json()
 
                 platter.logger.debug("Interaction follow up message was sent.")
 
         else:
             # Perform normal message response.
             # ----------------------------------
+            if hide and delete_after is not None:
+                delete_after = 3
 
             if reply:
                 payload["message_reference"] = MessageReferenceData(
                     message_id = platter.data["id"],
                     channel_id = platter.data["channel_id"],
                     guild_id = platter.data["guild_id"]
                 )
 
-            form_data = FormData()
-            form_data.add_field("payload_json", json_dumps(payload))
+            form_data.add_field(
+                "payload_json", json_dumps(payload)
+            )
 
             r = await goldy.http_client.request(
                 Route(
                     "POST", 
                     "/channels/{channel_id}/messages", 
                     channel_id = platter.data['channel_id']
                 ),
@@ -265,16 +306,17 @@
             platter.logger.debug("Message was sent.")
 
 
     # If object is a channel object just send the message in the channel.
     if isinstance(object, objects.Channel):
         channel: objects.Channel = object
 
-        form_data = FormData()
-        form_data.add_field("payload_json", json_dumps(payload))
+        form_data.add_field(
+            "payload_json", json_dumps(payload)
+        )
 
         r = await goldy.http_client.request(
             Route(
                 "POST", 
                 "/channels/{channel_id}/messages", 
                 channel_id = channel.id
             ),
@@ -283,16 +325,18 @@
             headers = goldy.nc_authentication.headers,
         )
 
         message_data = await r.json()
 
         channel.logger.debug(f"Message was sent in channel '{channel.data['name']}'.")
 
+
     message = objects.Message(message_data, object.guild, goldy)
 
+    # TODO: Find a way to also delete the author's prefix command message.
     if delete_after is not None:
         utils.delay(
             coro = message.delete(f"delete_after was set to {delete_after} seconds"), 
             seconds = delete_after, 
             goldy = goldy
         )
```

## GoldyBot/goldy/nextcore_utils/slash_options/auto_complete.py

```diff
@@ -1,36 +1,101 @@
 from __future__ import annotations
-
-from typing import List, TYPE_CHECKING
-from discord_typings import ApplicationCommandOptionData, AutocompleteInteractionData
+from typing import List, TYPE_CHECKING, overload, Callable, Union
+from discord_typings import AutocompleteOptionData, AutocompleteInteractionData
 
 from nextcore.http import Route
 from devgoldyutils import LoggerAdapter, Colours
 
 from .... import goldy_bot_logger
 from .slash_option import SlashOption, SlashOptionChoice
 from ...objects.member import Member
 
 if TYPE_CHECKING:
     from .... import Goldy
     from ...commands.slash_command import SlashCommand
+    from ...extensions import Extension
+
+    AUTO_COMPLETE_CALLBACK = Callable[[Extension, str], List[Union[SlashOptionChoice, str]]]
 
 class SlashOptionAutoComplete(SlashOption):
+    r"""
+    Like :py:meth:`~GoldyBot.SlashOption` but it auto completes while the member is typing and it doesn't force them to pick those options.
+    You can also override the callback and implement your own auto complete mechanism like I did in mal_cord (https://github.com/THEGOLDENPRO/mal_cord/blob/main/__init__.py#L23).
+
+    ---------------
+
+    ⭐ Example:
+    -------------
+    This is how you use auto complete slash options::
+
+        @GoldyBot.command(
+            slash_options = {
+                "bear_name": SlashOptionAutoComplete( # Now when you type these choices will be recommended to you but not forced on you.
+                    description = "⭐ Pick a custom bear name.",
+                    recommendations = [
+                        "Simba",
+                        "Paddington",
+                        "Goldilocks",
+                        "Toto"
+                    ]
+                )
+            }
+        )
+        async def custom_bear(self, platter: GoldyBot.GoldPlatter, bear_name: str):
+            if bear_name.lower() == "goldilocks":
+                return await platter.send_message("*Goldilocks is not a bear you fool!*", reply=True)
+
+            text = \
+                "*> In the woods, there lived three bears in their cozy house. " \
+                "There was a small wee bear, a middle-sized bear, " \
+                f"and a great, huge bear known as* **{bear_name}**..." \
+
+            await platter.send_message(text, reply=True)
+
+    .. note::
+
+        More at https://goldybot.devgoldy.xyz/examples.slash_options.html
+
+    """
+    @overload
+    def __init__(
+        self, 
+        callback: AUTO_COMPLETE_CALLBACK, 
+        name: str = None, 
+        description: str = None, 
+        required: bool = True, 
+        **extra: AutocompleteOptionData
+    ) -> None:
+        ...
+
+    @overload
     def __init__(
         self, 
         recommendations: List[SlashOptionChoice | str], 
         name: str = None, 
         description: str = None, 
         required: bool = True, 
-        **extra: ApplicationCommandOptionData
+        **extra: AutocompleteOptionData
     ) -> None:
+        ...
 
-        if isinstance(recommendations[0], str):
-            recommendations = [SlashOptionChoice(x, x) for x in recommendations]
+    def __init__(
+        self, 
+        name: str = None, 
+        description: str = None, 
+        callback: AUTO_COMPLETE_CALLBACK = None, 
+        recommendations: List[SlashOptionChoice | str] = None, 
+        required: bool = True, 
+        **extra: AutocompleteOptionData
+    ) -> None:
 
+        if recommendations is None:
+            recommendations = []
+
+        self.callback = callback
         self.recommendations = recommendations
 
         self.logger = LoggerAdapter(goldy_bot_logger, prefix=Colours.PURPLE.apply("SlashOptionAutoComplete"))
 
         super().__init__(
             name = name, 
             description = description, 
@@ -47,21 +112,33 @@
         command: SlashCommand,
         goldy: Goldy, 
     ) -> None:
 
         payload = {}
         payload["choices"] = []
 
+        choices: List[SlashOptionChoice | str] = []
+
         member = Member(data["member"]["user"], goldy.guild_manager.get_guild(data["guild_id"]), goldy)
-        self.logger.debug(f"We got --> '{current_typing_value}' from {member.name}#{member.discriminator}")
 
-        # Implemented some fuzzy searching.
-        for choice in self.recommendations:
-            if current_typing_value.lower() in choice["name"].lower():
-                payload["choices"].append(choice)
+        self.logger.debug(f"We got --> '{current_typing_value}' from {member}")
+
+        if self.callback is not None:
+            choices = await self.callback(command.extension, current_typing_value) # Might add a platter for this in the future, idk yet.
+
+        else: # If no callback was given then default to recommendations list.
+            for choice in self.recommendations: # Some shit fuzzy searching. I'll improve it later :L
+                if isinstance(choice, str):
+                    choice = SlashOptionChoice(choice, choice)
+
+                if current_typing_value.lower() in choice["name"].lower():
+                    choices.append(choice)
+
+        choices = [SlashOptionChoice(x, x) if isinstance(x, str) else x for x in choices]
+        payload["choices"] = choices[:24] # Discord only allows max of 25 choices.
 
         self.logger.debug(
             f"Sending auto complete '{payload['choices']}' to --> slash command '{command.name}'."
         )
 
         await goldy.http_client.request(
             Route(
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## GoldyBot/goldy/nextcore_utils/slash_options/slash_option.py

```diff
@@ -19,15 +19,15 @@
 
 class SlashOptionChoice(dict):
     """A class used to create slash option choice."""
     def __init__(self, name: str, value: str | int, **extra):
         """
         Creates an slash option choice. 😋
         
-        ⭐ Documentation at https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-choice-structure
+        https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-choice-structure
         """
         data: StrCommandOptionChoiceData | IntCommandOptionChoiceData = {}
 
         data["name"] = name
         data["value"] = value
 
         data.update(extra)
@@ -85,24 +85,24 @@
         type: SlashOptionTypes | Literal[6, 7, 8, 11] = None,
         required: bool = True, 
         **extra: ApplicationCommandOptionData
     ) -> None:
         """
         Creates a slash command option. 😋
         
-        ⭐ Documentation at https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-structure
+        https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-option-structure
         """
         self.data: ApplicationCommandOptionData = {}
 
         if description is None:
             description = "This option has no description. Sorry about that."
 
         # Check if all choices are same type.
         if choices is not None:
-            if isinstance(choices, str):
+            if isinstance(choices[0], str):
                 choices = [SlashOptionChoice(x, x) for x in choices]
 
             allowed_type = type_(choices[0]["value"])
 
             if not all([type_(choice["value"]) == allowed_type for choice in choices]):
                 raise GoldyBotError("All choices got to have the same value type!")
```

## GoldyBot/goldy/objects/__init__.py

```diff
@@ -1,10 +1,9 @@
 from .message import Message
 from .member import Member
 from .channel import Channel
 from .invokable import Invokable
 from .platter import Platter
 from .platter.golden_platter import GoldPlatter
-from .platter.silver_platter import SilverPlatter
 
 Ctx = GoldPlatter
 Context = GoldPlatter
```

## GoldyBot/goldy/objects/member.py

```diff
@@ -19,14 +19,17 @@
         self.guild = guild
         self.goldy = goldy
 
         super().__init__(LoggerAdapter(logger, prefix=Colours.GREY.apply(data['username'])))
 
         self.db_wrapper = MemberDBWrapper(self)
 
+    def __repr__(self) -> str:
+        return f"{self.name}#{self.discriminator}"
+
     @property
     def id(self) -> str:
         """Member's id duhhhh."""
         return self.get("id")
     
     @property
     def name(self) -> str:
```

## GoldyBot/goldy/objects/platter/__init__.py

```diff
@@ -1,69 +1,24 @@
 from __future__ import annotations
 
 from abc import ABC
 from devgoldyutils import DictClass
-from typing import TYPE_CHECKING, List
+from typing import TYPE_CHECKING
 
 if TYPE_CHECKING:
     from ..member import Member
     from ..invokable import Invokable
-    from ..message import Message
-    from ...recipes import Recipe
-    from ...nextcore_utils.embeds.embed import Embed
 
 class Platter(ABC, DictClass):
     def __init__(self, data: dict, invoker: Member, invokable: Invokable) -> None:
         self.data = data
         """The raw data received right from discord that triggered this."""
         self.invoker = invoker
         """The member who triggered this platter."""
         self.invokable = invokable
         """The invokable object that was triggered. E.g. Command"""
         self.goldy = invokable.goldy
         """An instance of the goldy class."""
         self.logger = invokable.logger
         """A logger object you may use to log."""
 
-        super().__init__(logger = invokable.logger)
-
-        self._interaction_responded = False
-        """An internal property that is set by the :py:meth:`~GoldyBot.nextcore_utils.send_msg` method when a slash command is responded to."""
-
-    async def send_message(
-        self, 
-        text: str = None, 
-        embeds: List[Embed] = None, 
-        recipes: List[Recipe] = None, 
-        reply: bool = False, 
-        delete_after: float = None, 
-        **extra
-    ) -> Message:
-        """
-        Allows you to create and send a message to the channel the command was invoked from as a form of reply.
-        
-        ------------------
-
-        Parameters
-        ----------
-        ``text``
-            The content of the message.
-        ``embeds``
-            Embeds to include in the message.
-        ``recipes``
-            Components to include in the message, e.g buttons and dropdowns.
-        ``reply``
-            Whether goldy bot should liberally reply to the message the command was invoked.
-        ``delete_after``
-            Deletes the message after this amount of seconds. 
-        ``**extra``
-            Allows you to pass the extra parameters that are missing.
-
-        Returns
-        -------
-        ``GoldyBot.goldy.objects.message.Message``
-            The message that was sent.
-        
-        """
-        return await nextcore_utils.send_msg(self, text, embeds, recipes, reply, delete_after, **extra)
-
-from ... import nextcore_utils # This must be here to avoid circular import.
+        super().__init__(logger = invokable.logger)
```

## GoldyBot/goldy/objects/platter/golden_platter.py

```diff
@@ -1,40 +1,111 @@
 from __future__ import annotations
 
 from typing import TYPE_CHECKING
-from discord_typings import MessageData, InteractionData
-
-from . import Platter
 
 if TYPE_CHECKING:
+    from typing import List, Union
+    from discord_typings import MessageData, InteractionData
+
     from ..member import Member
     from ...guilds import Guild
-    from ...commands.command import Command
+    from ..message import Message
+    from ...recipes import Recipe
+    from ...nextcore_utils.embeds.embed import Embed
+    from ...nextcore_utils.files import File
+
+    from ...commands.slash_command import SlashCommand
+    from ...commands.prefix_command import PrefixCommand
+
+    GOLD_PLATTER_INVOKABLE_TYPES = Union[SlashCommand, PrefixCommand, Recipe]
+
+from . import Platter
 
 class GoldPlatter(Platter):
     """
     🟡 The gold platter is equivalent to the context/ctx/interaction name your used to. You can use the alias context/ctx if your not a fan of the FUNNY name. 
     It's actually returned on both interactions and normal message/prefix commands. You can use this object to grab the command author, reply to the command, send a message in the command's channel and a lot more.
 
     ⚡ With this class I'm able to handle both slash and prefix commands simultaneously.
 
     ✨ Behold the golden platter. ✨😁
     """
-    def __init__(self, data: MessageData | InteractionData, author: Member, command: Command) -> None:
+    def __init__(self, data: MessageData | InteractionData, author: Member, invokable: GOLD_PLATTER_INVOKABLE_TYPES) -> None:
         # TODO: We got to somehow test this stuff with pytest because this being error prone is sort of a catastrophe.
         super().__init__(
             data = data, 
             invoker = author, 
-            invokable = command
+            invokable = invokable
         )
 
+        self.invokable: GOLD_PLATTER_INVOKABLE_TYPES
+
         self.guild: Guild = self.goldy.guild_manager.get_guild(self.get("guild_id"))
 
+        self._interaction_responded = False
+        """
+        An internal property that is set by the :py:meth:`~GoldyBot.nextcore_utils.send_msg` method when a slash command is responded to.
+        Basically don't mess around with it please.
+        """
+
     @property
     def author(self) -> Member:
-        """The member who triggered this command."""
+        """The author that invoked this invokable."""
         return self.invoker
 
-    @property
-    def command(self) -> Command:
-        """The command object that was invoked."""
-        return self.invokable
+
+    async def wait(self) -> None:
+        """
+        Use this to inform Discord and the member that this command will take longer than usual to respond or that a respond is being cooked up. 🍳🍲
+        
+        ------------------
+
+        Returns
+        -------
+        ``None``
+        """
+        return await nextcore_utils.wait(self)
+
+    async def send_message(
+        self, 
+        text: str = None, 
+        embeds: List[Embed] = None, 
+        recipes: List[Recipe] = None, 
+        files: List[File] = None,
+        reply: bool = False, 
+        delete_after: float = None, 
+        hide: bool = False,
+        **extra
+    ) -> Message:
+        """
+        Allows you to create and send a message to the channel the command was invoked from as a form of reply.
+        
+        ------------------
+
+        Parameters
+        ----------
+        ``text``
+            The content of the message.
+        ``embeds``
+            Embeds to include in the message.
+        ``recipes``
+            Components to include in the message, e.g buttons and dropdowns.
+        ``files``
+            Files you may upload with this message.
+        ``reply``
+            Whether goldy bot should liberally reply to the message the command was invoked.
+        ``delete_after``
+            Deletes the message after this amount of seconds.
+        ``hide``
+            Hides the message in interaction commands and deletes the message after a few seconds on prefix commands.
+        ``**extra``
+            Allows you to pass the extra parameters that are missing.
+
+        Returns
+        -------
+        ``GoldyBot.goldy.objects.message.Message``
+            The message that was sent.
+        
+        """
+        return await nextcore_utils.send_msg(self, text, embeds, recipes, files, reply, delete_after, hide, **extra)
+
+from ... import nextcore_utils # This must be here to avoid circular import. (shit will blow up if this is moved, trust me)
```

## GoldyBot/goldy/recipes/__init__.py

```diff
@@ -2,21 +2,21 @@
 
 from typing import Callable, Any, TYPE_CHECKING
 from discord_typings import ComponentData
 from devgoldyutils import LoggerAdapter, Colours
 
 from ... import goldy_bot_logger
 from ..objects.invokable import Invokable
-from ..objects.platter.silver_platter import SilverPlatter
+from ..objects.platter.golden_platter import GoldPlatter
 from ..nextcore_utils import front_end_errors
 
 if TYPE_CHECKING:
     from ... import objects
 
-RECIPE_CALLBACK = Callable[[SilverPlatter], Any]
+RECIPE_CALLBACK = Callable[[GoldPlatter], Any]
 
 class Recipe(Invokable):
     """A recipe is equivalent to an item or message component. This is inherited by all message components in Goldy Bot. This can be passed into a send_msg function."""
     def __init__(self, data: ComponentData, name: str, callback: RECIPE_CALLBACK, author_only: bool = True, **callback_args: dict) -> ComponentData:
         """
         Creates an component in discord to use in action rows. 😋
         """
@@ -40,20 +40,20 @@
             name = name,
             data = data,
             callback = callback,
             goldy = get_goldy_instance(),
             logger = self.logger 
         )
 
-    async def invoke(self, platter: objects.SilverPlatter) -> Any:
+    async def invoke(self, platter: objects.GoldPlatter) -> Any:
         """Runs/triggers this recipe. This method is usually used internally."""
         self.logger.debug(f"Attempting to invoke '{self.__class__.__name__}'...")
 
         if self.author_only:
-            if not platter.author.id == platter.recipe.command_platter.author.id:
+            if not platter.author.id == platter.invokable.command_platter.author.id:
                 raise front_end_errors.OnlyAuthorCanInvokeRecipe(platter, self.logger)
 
         try:
             value = await self.callback(
                 platter,
                 **self.callback_args
             )
```

## GoldyBot/goldy/recipes/buttons/button.py

```diff
@@ -90,17 +90,22 @@
         emoji: str = None, 
         author_only: bool = True, 
         callback: RECIPE_CALLBACK = None, 
         **callback_args: dict
     ) -> ButtonComponentData:
         """
         Creates a discord button to use in action rows. 😋
-        
-        ⭐ Documentation at https://discord.com/developers/docs/interactions/message-components#buttons
+
+        https://discord.com/developers/docs/interactions/message-components#buttons
         """
+        if url is None and callback is None:
+            raise TypeError(
+                "Button class cannot have both url and callback set to None. Take a closer look at the arguments please."
+            )
+
         data: ButtonComponentData = {}
 
         if isinstance(style, ButtonStyle):
             style = style.value
 
         if custom_id is None:
             custom_id = os.urandom(16).hex()
```

## GoldyBot/internal_extensions/goldy.py

```diff
@@ -46,15 +46,15 @@
             colour = Colours.YELLOW,
             thumbnail = GoldyBot.EmbedImage(self.goldy.bot_user.avatar_url)
         )
 
     @GoldyBot.command(
         name="goldy", 
         description = "💛 Shows you stats about the current Goldy Bot framework instance.", 
-        required_roles = [GoldyBot.Perms.BOT_DEV],
+        required_perms = [GoldyBot.Perms.BOT_DEV], # Umm, should we make this command available to bot admins too.
         hidden = True
     )
     async def goldy_cmd(self, platter: GoldyBot.GoldPlatter):
         embed = self.goldy_embed.copy()
 
         embed.format_fields(
             version = GoldyBot.info.VERSION,
```

## GoldyBot/internal_extensions/timestamps.py

```diff
@@ -92,16 +92,14 @@
             date = dt.datetime.now().strftime(datetime_formats[0][:8])
 
         if time == "now":
             time = dt.datetime.now().strftime(datetime_formats[0][9:])
 
         datetime = get_datetime(f"{date} {time}", option = HumanDatetimeOptions.BOTH, datetime_formats = datetime_formats)
 
-        # TODO: Phrase the timezone. (idk, maybe add some convenient aliases.)
-
         if timezone is None:
             timezone = (lambda x: x if x is not None else self.default_timezone)(member_data.get("timezone", optional=True))
 
         if datetime is None:
             raise front_end_errors.FrontEndErrors(
                 embed = self.failed_read_embed,
                 message = "Datetime failed to read the member's input.",
@@ -141,22 +139,14 @@
                 embed = self.failed_read_embed,
                 message = f"We got an unknown exception when we tried to process and send the timestamp. Error --> {e}",
                 platter = platter,
                 delete_after = 30,
                 logger = self.logger
             )
 
-    """
-    @create.auto_complete()
-    async def create_custom_auto_complete(self, platter: GoldyBot.GoldPlatter):
-        # TODO: This may be alright for custom auto completes but I REALLY don't want to do it this way.
-        # I want a similar implementation as what I did with callback in buttons. 
-        # So perhaps we should have another SlashOption class but for auto completion.
-        ...
-    """
 
     @timestamp.sub_command(description = "Allows you to sets default timezone and date format for /timestamp command.", slash_options = {
         "timezone" : GoldyBot.SlashOption(
             description = "The time zone. Must be like this --> Europe/London, America/New_York, Europe/Stockholm", 
             required = True
         ),
         "date_format": GoldyBot.SlashOption(
```

## GoldyBot/utils/__init__.py

```diff
@@ -1,5 +1,6 @@
 from .cache import cache_lookup
 from ._async import delay
 from ._lambda import is_lambda
+from ._dict import update_dict
 from .strings import line_fix
 from .human_datetime import get_datetime, HumanDatetimeOptions
```

## GoldyBot/utils/cache.py

```diff
@@ -1,22 +1,22 @@
 from __future__ import annotations
 
-from typing import Any, Tuple, overload
+from typing import Any, Tuple, overload, List
 
 @overload
 def cache_lookup(key: str|int, cache: dict) -> Any | None:
     ...
 
 @overload
 def cache_lookup(key: str, cache: dict, cap_sensitive = True) -> Tuple[str, ...] | None:
     ...
 
 
 @overload
-def cache_lookup(key: str|int, cache: list) -> Tuple[str, ...] | None:
+def cache_lookup(key: str|int, cache: List[tuple]) -> Tuple[str, ...] | None:
     ...
 
 @overload
 def cache_lookup(key: str, cache: list, cap_sensitive = True) -> Tuple[str, ...] | None:
     ...
```

## Comparing `GoldyBot-5.0.dev6.dist-info/LICENSE` & `GoldyBot-5.0.dev7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `GoldyBot-5.0.dev6.dist-info/METADATA` & `GoldyBot-5.0.dev7.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: GoldyBot
-Version: 5.0.dev6
+Version: 5.0.dev7
 Summary: Yet another another rewrite of Goldy Bot, a discord bot framework for my own bots.
 Author-email: Goldy <goldy@devgoldy.xyz>
 License: GNU GENERAL PUBLIC LICENSE
                                Version 3, 29 June 2007
         
          Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
          Everyone is permitted to copy and distribute verbatim copies
@@ -691,24 +691,26 @@
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: requests
 Requires-Dist: devgoldyutils (>=2.5)
-Requires-Dist: nextcore (>=2.0.0)
+Requires-Dist: nextcore[speed] (>=2.0.1)
 Requires-Dist: click (>=8.1.3)
 Requires-Dist: python-decouple (>=3.7)
 Requires-Dist: motor
 Requires-Dist: cmd2
 Requires-Dist: pygame (==2.3.0)
 Requires-Dist: regex
 Requires-Dist: psutil
 Requires-Dist: dateparser
 Requires-Dist: pytz
+Requires-Dist: toml
+Requires-Dist: colorthief
 Requires-Dist: importlib-metadata ; python_version < "3.8"
 Provides-Extra: dev
 Requires-Dist: Sphinx ; extra == 'dev'
 Requires-Dist: sphinxext-opengraph ; extra == 'dev'
 Requires-Dist: sphinx-inline-tabs ; extra == 'dev'
 Requires-Dist: furo ; extra == 'dev'
 Requires-Dist: myst-parser ; extra == 'dev'
@@ -717,15 +719,15 @@
 Requires-Dist: pytest-cov ; extra == 'dev'
 Requires-Dist: ruff ; extra == 'dev'
 
 <div align="center">
 
   # 💛 Goldy Bot V5
   
-  <sub>Yet another another rewrite of Goldy Bot, a discord bot framework for my own bots.</sub>
+  <sub>Yet **another** rewrite of Goldy Bot, a discord bot framework for my own bots.</sub>
 
   [![Pypi Badge](https://img.shields.io/pypi/v/GoldyBot?style=flat)](https://pypi.org/project/GoldyBot/ "We're on pypi!")
   [![Python Badge](https://img.shields.io/pypi/pyversions/GoldyBot?style=flat)](https://pypi.org/project/GoldyBot/ "Supported python versions.")
   [![Docs Badge](https://img.shields.io/static/v1?label=docs&message=Available&color=light-green)](https://goldybot.devgoldy.xyz/)
   [![Docker Badge](https://img.shields.io/docker/v/devgoldy/goldybot?label=docker)](https://hub.docker.com/r/devgoldy/goldybot "We're on docker!")
   
 </div>
@@ -746,78 +748,79 @@
 
 
   ## Why Version 5?
 
   
   <img align="left" src="./assets/goldy_art/1.png" width="180"/>
 
-  > I'm developing a new Discord bot framework to replace my [previous one](https://github.com/Goldy-Bot/Goldy-Bot-V4), which I found limiting and frustrating. The new framework will be more efficient and user-friendly and will utilize what I believe to be a better API wrapper than discord.py, which prompted the rewrite. Originally, I planned to update [V4](https://github.com/Goldy-Bot/Goldy-Bot-V4) for backwards compatibility, but it would be too difficult, and my extensions would need to be rewritten anyways. Therefore, I'm excited to announce the upcoming release of Goldy Bot Framework V5, which will be a brand-new framework starting fresh. 🍋
+  > I'm developing a new Discord bot framework to replace my [previous one](https://github.com/Goldy-Bot/Goldy-Bot-V4), which I found limiting and frustrating. The new framework will be more efficient and user-friendly and will utilize what I believe to be a better API wrapper than discord.py, which prompted the rewrite. Originally, I planned to update [V4](https://github.com/Goldy-Bot/Goldy-Bot-V4) for backward compatibility, but it would be too difficult, and my extensions would need to be rewritten anyways. Therefore, I'm excited to announce the upcoming release of Goldy Bot Framework V5, which will be a brand-new framework starting fresh. 🍋
 
 </p>
 
 ### 🏆 Goal
 My goal is to have a functional framework that's fast and lightweight and has the least code possible to maintain. 
 
 ### 💛 Is goldy bot for you?
-Do note that the whole point of this framework is to make it easier on myself to develop discord bots so you may dislike the way certain things are implemented; if so I highly recommend you not use the framework because more and more things will be implemented that way in the future so it's best to seek an API wrapper like [nextcord](https://github.com/nextcord/nextcord) for your discord bot development needs instead.
+Do note that the whole point of this framework is to make it easier for myself to develop discord bots so you may dislike the way certain things are implemented; if so I highly recommend you not use the framework because more and more things will be implemented that way in the future so it's best to seek an API wrapper like [nextcord](https://github.com/nextcord/nextcord) for your discord bot development needs instead.
 
-On a similar note goldy bot v5 is currently in a ALWAYS changing state, previous code WILL BREAK, non-stable versions especially so you'll find yourself always fixing your extensions after each release.
+On a similar note goldy bot v5 is currently in an ALWAYS changing state, previous code WILL BREAK, non-stable versions especially so you'll find yourself always fixing your extensions after each release.
 
 ### ⚡ Nextcore
-[Nextcore](https://github.com/nextsnake/nextcore) is the perfect api wrapper for v5, it's fast, low level and can be easily modified. Additionally, Nextcore provides a ton of control, this gives me the freedom to build my framework exactly the way I want it, without any unnecessary overhead like if I stayed with nextcord/discord.py.
+[Nextcore](https://github.com/nextsnake/nextcore) is the perfect API wrapper for v5, it's fast, low-level, and can be easily modified. Additionally, Nextcore provides a ton of control, this gives me the freedom to build my framework exactly the way I want it, without any unnecessary overhead like if I stayed with nextcord/discord.py.
 
 ## 🛠 *Install/Set Up* - ``Normal``
 
 These instructions assume you have a [MongoDB database](https://www.mongodb.com/), [Git](https://git-scm.com/) and [Python](https://www.python.org/) installed.
 
-> ℹ We recommend a clean mongo database, GoldyBot will connect to your mongoDB database and create stuff the first time you run.
+> ℹ We recommend a clean Mongo database, GoldyBot will connect to your MongoDB database and create stuff the first time you run.
 
-1. ~~**Install package from pypi.**~~ *not on there yet... here's a git install*
+1. **Install package from PyPI.**
 ```sh
 # Windows/Linux
 
-pip install GoldyBot@git+https://github.com/Goldy-Bot/Goldy-Bot-V5
+pip install GoldyBot
 ```
 
 2. **Generate a quick template.**
 Create a directory of your choice anywhere, then open a terminal in that directory and type the following below.
 ```sh
 # Windows/Linux
 
 goldybot setup normal
 ```
 
 3. **Run goldy!** ⚡
 
-Make sure to enter your Discord BOT token and mongoDB database url in the ``.env`` file generated in your folder.
+Make sure to enter your Discord BOT token and MongoDB database URL in the ``.env`` file generated in your folder.
 ```env
 DISCORD_TOKEN="DISCORD BOT TOKEN HERE"
 MONGODB_URL="MONGO DATABASE URL HERE"
 ```
 
 ### JSON Configuration
 
-Also make sure to add your discord guild to ``allowed_guilds`` in ``goldy.json``.
+Also, make sure to add your discord guild to ``allowed_guilds`` in ``goldy.json``.
 
-You may change ``"uwu_hangout_guild"`` to anything you like but just remember this will be the code_name of the guild within goldy bot and you'll use this code_name to reference it later.
+You may change ``"test_server"`` BUT **ONLY** if it's not a server you're going to be developing and testing on. The code name ``test_server`` is already reserved for you to use as a development environment to test your commands. Slash Commands will reload/update quicker in the ``test_server`` as they will be registered as guild commands instead of global commands. Check out [discord's explanation](https://discord.com/developers/docs/interactions/application-commands#registering-a-command) of global and guild commands for more clarification. 
 
-You may also want to add your discord member id to ``"bot_dev"``, like so: ``"bot_dev": "332592361307897856"``. If you don't you may not be able to run specific bot admin commands on discord.
+If your guild/server is not a testing server you may name it whatever you like but just remember this will be the code_name of the guild within goldy bot and you'll use this code_name to reference it later.
 
+You may also want to add your discord member id to ``"bot_dev"``, like so: ``"bot_dev": "332592361307897856"``. If you don't you may be unable to run specific bot administration commands within Discord.
 ```json
 {
     "goldy" : {
         "extensions": {
             "ignored_extensions" : [],
 
             "raise_on_load_error" : true,
             "folder_location" : "./extensions"
         },
 
         "allowed_guilds" : {
-            "{guild_id_here}" : "uwu_hangout_guild"
+            "{guild_id_here}" : "test_server"
         }
     },
 
     "bot_dev": null
 }
 ```
 
@@ -826,22 +829,22 @@
 python run.py
 ```
 
 <br>
 
 ## 🐬 *Install/Set Up* - ``Docker``
 
-These instructions assume you have [Docker](https://www.docker.com/) installed and that you are running on Linux, althought these same steps can be followed on windows too excluding the linux commands.
+These instructions assume you have [Docker](https://www.docker.com/) installed and that you are running on Linux, although these same steps can be followed on Windows too excluding the Linux commands.
 
 1. **Clone the [goldybot-docker](https://github.com/Goldy-Bot/goldybot-docker) repo.**
 ```sh
 git clone https://github.com/Goldy-Bot/goldybot-docker
 ```
 
-2. **Setup enviorment variables.**
+2. **Set up environment variables.**
 ```sh
 cd goldybot-docker
 cp .env.example .env
 nano .env
 ```
 
 Now enter your Discord BOT token over here.
@@ -849,22 +852,22 @@
 DISCORD_TOKEN="DISCORD BOT TOKEN HERE"
 GOLDY_DIRECTORY="./goldy"
 ```
 
 3. **🐬Docker compose!**
 Now you may run docker compose to create your 📦container.
 ```sh
-sudo docker compose up
+docker compose up
 ```
 
-Although you WILL get error an error from goldy bot asking you to configure your ``goldy.json`` file. You may follow the instructions [here](https://github.com/Goldy-Bot/Goldy-Bot-V5#json-configuration) on how to configure that. The ``goldy.json`` file can be found in the goldy directory at root. This goldy directory is an exposed docker folder allowing you to configure and add extensions to goldy bot with ease.
+Although you WILL get an error from goldy bot asking you to configure your ``goldy.json`` file. You may follow the instructions [here](https://github.com/Goldy-Bot/Goldy-Bot-V5#json-configuration) on how to configure that. The ``goldy.json`` file can be found in the goldy directory at root. This goldy directory is an exposed docker folder allowing you to configure and add extensions to goldy bot with ease.
 
-Now run docker compose once again and goldy should be running after the mongodb database has booted.
+Now run docker compose once again and goldy should be running after the MongoDB database has booted.
 ```sh
-sudo docker compose up
+docker compose up
 ```
 
 <br>
 
 <div align="center">
 
   **© Copyright (C) 2023 Goldy (Under the [GPL-3.0 License](LICENSE))**
```

## Comparing `GoldyBot-5.0.dev6.dist-info/RECORD` & `GoldyBot-5.0.dev7.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,82 +1,86 @@
-GoldyBot/__init__.py,sha256=_5TCJAFQBifzYrqSwPy_U9y9kJbiqJ1Lx94QJbYzRdI,1256
+GoldyBot/__init__.py,sha256=njyUiO3N-I76newAQE7fFLyEV9a6wHa6jDbbod_VVZ0,1279
 GoldyBot/config.py,sha256=EW1lxKWKaTzpeW7rjdKWLDl6qVQfbOHcLtMHxlY3zyg,421
 GoldyBot/errors.py,sha256=f_Ljf8DHcOm3T5PyDpejHVOB6225Jajp6NnI-0tqfhE,1673
 GoldyBot/file_templates.py,sha256=ViTNdB-bG7Zr-oDzbOXdY4z-L1hHffaL69d1Ku4Y4Lo,1043
-GoldyBot/info.py,sha256=dmwWfoJ1bzyyBGCPqgIfrIzDzLOZ6Z1wy45x2l-B4pw,404
+GoldyBot/info.py,sha256=MyRaRUy_LHVv9tUynwzRiQP1owvoxPbYMPY1gjFkAA8,463
 GoldyBot/logging.py,sha256=WeF3Kn0e-S-evoOpFyZwHESK_A5_Y3073KqL1tPyFCo,523
 GoldyBot/paths.py,sha256=9Lu-WyjDRbD3oB6yVu5RRK6L6UIcHNiP1lYndN7leFg,530
 GoldyBot/assets/ding.mp3,sha256=6Mkbmpp8ldsZ0Bi_1xNVZKltIIo5L5jPtfrhUwqdBEc,37153
-GoldyBot/assets/goldy.json,sha256=kwnajeZpSc1W47acAvaqRUUKpPajtwveYVS6a98JgMY,397
+GoldyBot/assets/goldy.json,sha256=kFmvLzqwlTPBHQsXrDuccwfofn8Gr46xcVo3DaRt5Vo,391
 GoldyBot/assets/run.py,sha256=dlYQt2USDJsR-xOIo8VWYQCgsA1lmV-mRIRfIqdWU-s,98
 GoldyBot/assets/token.env,sha256=hYmYj4M2oPlAj7ZZFE1PC9ag0Py2moFAoXobVKB_K4g,76
 GoldyBot/cli/__init__.py,sha256=WmWBZzebk-D9VL_KnGUjaMXTGqWenBoTfA1CiZteVrU,50
 GoldyBot/cli/__main__.py,sha256=xyPWowk-HbjOEOybFr23BRVrBP88hx-3be6oiNuguFc,1873
 GoldyBot/cli/_setup.py,sha256=H_u3rQHROAud5kfFMjQFoJxKkN-1I7m73B7l4viHmZo,1419
-GoldyBot/goldy/__init__.py,sha256=sysLmEtI7qkszAwPLtOG-Mt_wllyxDwRuKVUMZ1Q7B8,10935
+GoldyBot/goldy/__init__.py,sha256=T59JrINWmNd2_1xWkiMuNYGSvnxTZwsLPq6Czrhsu4M,10966
 GoldyBot/goldy/goldy_config.py,sha256=TjO5A-r2Jk3H7ue8Hmju4rzbSm1duvhKmQvH3-ru4Hk,2854
-GoldyBot/goldy/permission_system.py,sha256=UbOIJArDBYsrKWnrFRh7mqlRd2Dk87Mv8XPr-N1nh6s,3505
-GoldyBot/goldy/perms.py,sha256=95Kjq4lE188LsnTkR1BsH4Id8NHAr-5jC76qZTFVm7I,193
+GoldyBot/goldy/permission_system.py,sha256=DNaA0xk3b0sjEkqMhfFaKgE0pFPR5o3O9J0gqi1U_QA,3898
+GoldyBot/goldy/perms.py,sha256=_U3oOuNthT3GLZ7t9ET30cG6nrQhRNVawgae1CRtpeQ,160
 GoldyBot/goldy/presence.py,sha256=0HhX7NvT_zMnGyJCs5mqtOkM06MXCeCAhUFnlPPW-Vk,2833
 GoldyBot/goldy/system.py,sha256=cpeAzn7dx2ls4E8VS8qonIxQ9zepRKFa4gil1OdSJqM,1812
 GoldyBot/goldy/token.py,sha256=iAhqROOOYHPxRNHbd2SIhkV2lugs786ZqYq6_ycYYO4,3580
 GoldyBot/goldy/commands/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-GoldyBot/goldy/commands/command.py,sha256=IEXh5y1ytUbYx8XuDgyaf9Xd53FNqEBZx_0bpzWRsSY,7958
-GoldyBot/goldy/commands/decorator.py,sha256=3BwiRDplz7zdJP-OpHvigvHcRXkzxBqZGLCthTfhG-4,2687
-GoldyBot/goldy/commands/group_command.py,sha256=KRwmbI4Cc_hLCdpcZZXGuwbJaq-UOhkzwxjwcRb5Imc,8115
-GoldyBot/goldy/commands/listener.py,sha256=NNwW0KGz1ON8Z68wZ-JkEzbBWhsscsQuC8bjgWWw7xM,4751
-GoldyBot/goldy/commands/loader.py,sha256=2HuaQNAhVe6ab4zivDjEyj9ddPJ4IDBlE-gqbyoPWDw,3387
-GoldyBot/goldy/commands/prefix_command.py,sha256=lhKdN1irkzHI56FmTTEKnXNHVpi-09BhiUWIty2uTpo,5695
-GoldyBot/goldy/commands/slash_command.py,sha256=JDvneT7lsoL_yXNk_8qAAx6RHpne4DgFbhSBT41PKaw,6075
+GoldyBot/goldy/commands/command.py,sha256=_h7GWjBeuaz6B7hYmMo5NeFsDXaEy2ke86pZfs0OaCE,7975
+GoldyBot/goldy/commands/decorator.py,sha256=pNEoIupOG2HalM6Dc-7wSHWiwV3ijY8cH7fqsOntrKw,2722
+GoldyBot/goldy/commands/group_command.py,sha256=ElV10SaGfmaHY12dUHyLKERWuXdDfFfA8Z8G-psBnWs,8234
+GoldyBot/goldy/commands/listener.py,sha256=5QhHbTyjIXRa0RP8YkEP2UgUwWqWl0W5UI6e9mcsIWM,5168
+GoldyBot/goldy/commands/loader.py,sha256=sr73oi6c0X3KW6pLbgNO8YtC0Y6kotLyeQe0nrk9ZoU,5736
+GoldyBot/goldy/commands/prefix_command.py,sha256=MvHwAswaRqFZLbBlDiA7Ki8oE6d1gkI7wF5N2quex8A,5765
+GoldyBot/goldy/commands/slash_command.py,sha256=XprXOgzT_GPKgJnNmPxjHk4tjoGQydW7sMluTh7sRrQ,6181
 GoldyBot/goldy/database/__init__.py,sha256=kXfM4wl3WwU7G1Lgz6mt1DlzAPuu-7ektQ6T-sakQPM,4701
-GoldyBot/goldy/database/databases/__init__.py,sha256=evh5MDTMsTD_UES3uWaFW6blaeh3Oyh8fx-yEDUTLEI,3836
-GoldyBot/goldy/database/wrappers/__init__.py,sha256=aFsPrAkDmGnJIv3KWmmKliR5S1m_OJOM8U5pPhSYN3A,1363
-GoldyBot/goldy/database/wrappers/member.py,sha256=ZFkn2DrtB92voAEy7RTInx8GLZBKG_Haq_x_6y3sLKg,2926
-GoldyBot/goldy/extensions/__init__.py,sha256=HEyzWFtqDJlc9oDFnKdkOnbF2gZJlOJmqKxXM5fRvI8,3714
-GoldyBot/goldy/extensions/extension_loader.py,sha256=u9I3FZJTT6bL6CIP_4ZmVG7lGRWHF9UxNaxlmKtNWs8,7441
-GoldyBot/goldy/guilds/__init__.py,sha256=6BsQuJVq0wgJsr_XHtDVmLMnoZ_9vo4w0q94OfKT34Q,4029
-GoldyBot/goldy/guilds/guild.py,sha256=ASvs9Yy30fDomFc0jocow-VtK-tyRmjD6dFRYsG5YUY,2591
+GoldyBot/goldy/database/databases/__init__.py,sha256=NT1Wbzyvb6Mz3Hih3GTeA1qH_tl6KORZr__Zufsvcc0,4189
+GoldyBot/goldy/database/wrappers/__init__.py,sha256=26SKJBtZovEbAlxXuYWyH61YTMRx3dr_aT3ejvL5rGg,1403
+GoldyBot/goldy/database/wrappers/guild.py,sha256=19iQG2zZRiWire9s0NopLADg5bxbQ9IZf9CDsWSMDOQ,3581
+GoldyBot/goldy/database/wrappers/member.py,sha256=pUk3T4Kn4QKYLNR-dKQmqcY_oxnAsSyIH5eyWiW_Ego,3034
+GoldyBot/goldy/extensions/__init__.py,sha256=2Uee1siab_js5nuA0Fqeh60qWgZgmxD1FeWAksQ6CpA,4063
+GoldyBot/goldy/extensions/extension_loader.py,sha256=oNyTT7skntb021-NjqwH8EBDQTJqwQidQJSEDVDpU_o,10358
+GoldyBot/goldy/extensions/extension_metadata.py,sha256=yfUPpa_YMOqJ6RI_ze3PpmNwlXIFrafobQPQEecC9d0,991
+GoldyBot/goldy/guilds/__init__.py,sha256=0SVRMPOTswxHOB67_mZxr4filcdmU5lWon7aOH3mfGE,2956
+GoldyBot/goldy/guilds/guild.py,sha256=E2S3RNXQTJY9D2hFH2iK_74u4fxqNZSdkRSoZZwWuq0,1958
 GoldyBot/goldy/live_console/__init__.py,sha256=tXs_G00QXInJSCCVEQZTVhSbgtehQfKxIREdu0GIhSo,1016
-GoldyBot/goldy/live_console/app.py,sha256=khPe3dz6PZRxn029sPAP7k6bszdf6hChiLR9JcCNqp4,2177
-GoldyBot/goldy/nextcore_utils/__init__.py,sha256=tLHNn6kGZzgpUxybZMKlLX-IIeEc_n-TWAymR6ZkbxQ,609
-GoldyBot/goldy/nextcore_utils/colours.py,sha256=A0bVFVuS_LwY5gwe6z82zl5GoQVLG2wPfMM90nZwy0E,508
-GoldyBot/goldy/nextcore_utils/front_end_errors.py,sha256=SpRkMPkSqoB6SjuXzGAscXcD-r55hxf4f9iTn0cAfpY,5798
+GoldyBot/goldy/live_console/app.py,sha256=aKWDuXd7jrZH_SwkVqxdvv-r9ctNybGj4K8Tp0txmMw,2176
+GoldyBot/goldy/nextcore_utils/__init__.py,sha256=jhWVRNQjK-k7rSkZWQkBEHkdpLYzW7UweF0iIKx4-TM,948
+GoldyBot/goldy/nextcore_utils/colours.py,sha256=5CtlWlu0oSRcd2rUVqxsR2gesHyQiRUJNRFB5bFzqrE,1164
+GoldyBot/goldy/nextcore_utils/defer.py,sha256=_ZZTVNx7g9gxk_Q4EtZGSQPjsHjvg06PgnjN59n_iwM,1450
+GoldyBot/goldy/nextcore_utils/files.py,sha256=XhlRzEPMd_uGABst6exO91IrrbJP-tDmSafo8ddY1ew,681
+GoldyBot/goldy/nextcore_utils/front_end_errors.py,sha256=hvH8qW-0KwmZnawqUSdmE8SjfYXbwp3LP3ux5QgmZ8U,6763
 GoldyBot/goldy/nextcore_utils/channels/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 GoldyBot/goldy/nextcore_utils/channels/delete_channel.py,sha256=cubcaqMImHscWrKGJfUL_M3nDHlYyJPhrM3WHeYSu20,1222
 GoldyBot/goldy/nextcore_utils/channels/get_channel.py,sha256=cU6H7vPlCoFZKfcGSJNHIWXlwFG1ZEzQ_HI8mbv8GbQ,1158
 GoldyBot/goldy/nextcore_utils/embeds/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-GoldyBot/goldy/nextcore_utils/embeds/embed.py,sha256=Eq27FDO7ZB7XtCBuNsM6R6re7ROhgCl2YrAnIqgYbdc,4255
+GoldyBot/goldy/nextcore_utils/embeds/embed.py,sha256=Zogf5JiL807Tgq4dXLLPYBzSVL6bUWyP2Q-X9duQHc4,5217
 GoldyBot/goldy/nextcore_utils/guilds/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 GoldyBot/goldy/nextcore_utils/guilds/get_channels.py,sha256=WdY1P9BquO45SoEty66WTWUnkEyOOz6Xv9KTnkpm__4,1237
-GoldyBot/goldy/nextcore_utils/guilds/get_guild_data.py,sha256=_biaIefY_AApTUw-DapQL81uf73bRyUWygTnElgEBGQ,1074
+GoldyBot/goldy/nextcore_utils/guilds/get_guild_data.py,sha256=18o5CeKDjSUJioMlj0dA36rbSc3KDRezCJmmC79WYpk,1073
 GoldyBot/goldy/nextcore_utils/messages/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 GoldyBot/goldy/nextcore_utils/messages/delete_msg.py,sha256=4H7gV66oH-7Q-WEmxe9oSm4jbczIA8zz59D6DkAW2Gk,1317
-GoldyBot/goldy/nextcore_utils/messages/send_msg.py,sha256=_ni-YRz_JbfWfF71Yb6Y0WfS3zGm9gXW4NNvSE86k1g,9357
+GoldyBot/goldy/nextcore_utils/messages/send_msg.py,sha256=FWBpStkc2YdvmPMV-mbpQUD7NNedPaNJ8Rz1rOtunYI,10828
 GoldyBot/goldy/nextcore_utils/slash_options/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-GoldyBot/goldy/nextcore_utils/slash_options/auto_complete.py,sha256=2jAx9bGA-J8P0mbDxmV18O-vTOa2KnuKuv3mJCToLUs,2523
-GoldyBot/goldy/nextcore_utils/slash_options/slash_option.py,sha256=XuGSdhqlt3QS6y-9dMQ1mu5Aerx0xIl_XqyFQN-W3P4,4952
-GoldyBot/goldy/objects/__init__.py,sha256=F7kRPFbUIOIQep0jQiGRDuxFoXaQ-sbRPB4oPY9agG8,285
+GoldyBot/goldy/nextcore_utils/slash_options/auto_complete.py,sha256=3FKPBzU1-eK6gOkQUntacAUZLtN6SAwhQbDRQm8wZg0,5378
+GoldyBot/goldy/nextcore_utils/slash_options/slash_option.py,sha256=Hidt7Bm47deFAz8F05HoqRzntZG88m5URyN-0Q90JA0,4913
+GoldyBot/goldy/objects/__init__.py,sha256=pPkl30vZGWLELPUBlioXptPOJ-04PjhXI4ZUP1QSDMI,235
 GoldyBot/goldy/objects/channel.py,sha256=amtPWkXL3S9XHcSvy1oKw9OwYn5kcLKHOnd7o5XvwCI,2303
 GoldyBot/goldy/objects/invokable.py,sha256=3WQ53JIhj8SAksgmvYjf-7TcMt5HsH7KNiGMII1poeM,2293
-GoldyBot/goldy/objects/member.py,sha256=EK_2BMrujO24-WOEFMQxBe3sv1rEZEiJUZ7E9YIfv9k,1811
+GoldyBot/goldy/objects/member.py,sha256=m2GMC_spswm8Q-y0AusffvO8rU5QKmYYfiSZChft54E,1894
 GoldyBot/goldy/objects/message.py,sha256=npTl40xYM8fyeUou5WWRsqYfUTLCZ3wzzCuEwi2wYos,1079
-GoldyBot/goldy/objects/platter/__init__.py,sha256=OKUVu2kRF5amF44-3QzDj1-8__6xjKSlGZzjhTmE17k,2438
-GoldyBot/goldy/objects/platter/golden_platter.py,sha256=sBLi5mnM-g1hueY-FU2fdhyaGdQbPI7H0RNtiOka60Q,1522
-GoldyBot/goldy/objects/platter/silver_platter.py,sha256=wTfDgX2N148RW1bp6qKl_m8RJttSW-I0n2YC6_ZQou0,965
-GoldyBot/goldy/recipes/__init__.py,sha256=QZmyJre2kaPWaqR-JiRHxtQbA25844BmwGWG09THImk,2491
+GoldyBot/goldy/objects/platter/__init__.py,sha256=4q_SN0wXMJJIdiIkDEmWHaAwkzOUbN8KoACxP2ohqk4,841
+GoldyBot/goldy/objects/platter/golden_platter.py,sha256=WkJZljiIg7TANyxu9WDXDsIy3rlNdHBVYkcR3b_Mock,4039
+GoldyBot/goldy/recipes/__init__.py,sha256=9oohtl5ssD6lkayEDppuO6Bsoizlkgq1l_ifiYHzPlA,2488
 GoldyBot/goldy/recipes/buttons/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-GoldyBot/goldy/recipes/buttons/button.py,sha256=SXWDC4Bf6ki0gUuWbrl4o2uzsGeBr4rpXBa-k3VCvXk,3764
-GoldyBot/internal_extensions/extensions.py,sha256=cDdZKC0UpkLlhEIayQtqVT_11INCLc7Br_AkVPauzGo,2809
-GoldyBot/internal_extensions/goldy.py,sha256=3P6Jc9ewp4QYkFwH5b_5-oEdWW6CU7TjFKBcvW4upUo,2645
-GoldyBot/internal_extensions/timestamps.py,sha256=5VjUHQ90W7yZNyaAXF2Sk3_Dut5Wp7pa8astlSu7V_A,8378
-GoldyBot/utils/__init__.py,sha256=einNR8RizMmOKg2wYdmW277Mui6l8aSB2x0UtqGdSL8,181
+GoldyBot/goldy/recipes/buttons/button.py,sha256=2KN-cKM6j85n6sATIGEwYe4zJccoWz6Xo4DSfVXfKjo,3946
+GoldyBot/internal_extensions/goldy.py,sha256=69y37nVfEc9Z01xYMxUicPtrCNZXKwqvcqz-vdL9PpQ,2709
+GoldyBot/internal_extensions/guild_admin.py,sha256=Gxa2stb6X0dWa20eIgzdkIdXqvLX91ZRg3Y-cfhRDn8,6090
+GoldyBot/internal_extensions/timestamps.py,sha256=yHrzdtRtN8wriJH7o6nglZu3_lqvPu5TaZzV3WZvnk8,7887
+GoldyBot/utils/__init__.py,sha256=Fsctcv8dCSzFbDXlcibIlPFgkksXdvOfEWa8t13p0-Q,212
 GoldyBot/utils/_async.py,sha256=0hw_XpdhEFroymdZTXrJBeaYE5PlWFQlfezy9yndpVw,375
+GoldyBot/utils/_dict.py,sha256=ilbsIFPj26oxqBsv4T1yue0T0k2VNd8TiFPExlDW22M,404
 GoldyBot/utils/_lambda.py,sha256=6fR9vam_JqbHZFMlNRLxgUP727_lwNBr-L23V2YhEJI,283
-GoldyBot/utils/cache.py,sha256=CnMB6ZVgQIkPEe1GYuAVEuULPsEKYaejWlGguvfnrmU,1196
+GoldyBot/utils/cache.py,sha256=ipNIvtSQ7I45bkfL6Teg6XPUH6azcjJWtZFPTklCX1Q,1209
 GoldyBot/utils/human_datetime.py,sha256=12E95PB79te1HplmSgfgYJmM4AhCsqdybBvhUfNbuw4,1771
 GoldyBot/utils/strings.py,sha256=Lc3IpV1HC0HpN9_0xG-r4JO2ymaSpbCJTCOhgwkLuYM,251
-GoldyBot-5.0.dev6.dist-info/LICENSE,sha256=BjWrY18cELsFakuc0Cbz7lcDrsy3ZlulKTCWq29AXeg,35123
-GoldyBot-5.0.dev6.dist-info/METADATA,sha256=grbTna1NWW0Ktj0-7jY3GEAslQMv7XjH_cSQJq5zhCE,48606
-GoldyBot-5.0.dev6.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-GoldyBot-5.0.dev6.dist-info/entry_points.txt,sha256=JEDjyL29gt4BvAwieni1LdTOk6isPh1_HX4uIqlnWWY,105
-GoldyBot-5.0.dev6.dist-info/top_level.txt,sha256=arsq264h8V821bmSfzqatd6d2HDXS3ZL6SIYvGtZL5Q,9
-GoldyBot-5.0.dev6.dist-info/RECORD,,
+GoldyBot-5.0.dev7.dist-info/LICENSE,sha256=BjWrY18cELsFakuc0Cbz7lcDrsy3ZlulKTCWq29AXeg,35123
+GoldyBot-5.0.dev7.dist-info/METADATA,sha256=hi5cgUQ3rNY_lNSoacK0GlSOqFRPTYiu3xKy9gr0Iag,49123
+GoldyBot-5.0.dev7.dist-info/WHEEL,sha256=AtBG6SXL3KF_v0NxLf0ehyVOh0cold-JbJYXNGorC6Q,92
+GoldyBot-5.0.dev7.dist-info/entry_points.txt,sha256=JEDjyL29gt4BvAwieni1LdTOk6isPh1_HX4uIqlnWWY,105
+GoldyBot-5.0.dev7.dist-info/top_level.txt,sha256=arsq264h8V821bmSfzqatd6d2HDXS3ZL6SIYvGtZL5Q,9
+GoldyBot-5.0.dev7.dist-info/RECORD,,
```

